# Comparing `tmp/pyaedt-0.6.61.tar.gz` & `tmp/pyaedt-0.6.70.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "pyaedt-0.6.61.tar", last modified: Fri Mar 31 15:55:48 2023, max compression
+gzip compressed data, was "pyaedt-0.6.70.tar", last modified: Fri Apr  7 18:42:41 2023, max compression
```

## Comparing `pyaedt-0.6.61.tar` & `pyaedt-0.6.70.tar`

### file list

```diff
@@ -1,248 +1,248 @@
--rw-r--r--   0        0        0     1111 2023-03-24 16:41:43.754242 pyaedt-0.6.61/LICENSE
--rw-r--r--   0        0        0     9857 2023-03-28 14:38:01.533990 pyaedt-0.6.61/README.rst
--rw-r--r--   0        0        0     2503 2023-03-31 15:28:52.562770 pyaedt-0.6.61/pyaedt/__init__.py
--rw-r--r--   0        0        0    26253 2023-03-24 16:41:45.863775 pyaedt-0.6.61/pyaedt/aedt_logger.py
--rw-r--r--   0        0        0     6965 2023-03-24 16:41:45.863775 pyaedt-0.6.61/pyaedt/application/AEDT_File_Management.py
--rw-r--r--   0        0        0    91247 2023-03-31 15:28:52.562770 pyaedt-0.6.61/pyaedt/application/Analysis.py
--rw-r--r--   0        0        0    41775 2023-03-24 16:41:45.863775 pyaedt-0.6.61/pyaedt/application/Analysis3D.py
--rw-r--r--   0        0        0    17531 2023-03-24 16:41:45.863775 pyaedt-0.6.61/pyaedt/application/Analysis3DLayout.py
--rw-r--r--   0        0        0     3088 2023-03-24 16:41:45.863775 pyaedt-0.6.61/pyaedt/application/AnalysisMaxwellCircuit.py
--rw-r--r--   0        0        0    20320 2023-03-24 16:41:45.863775 pyaedt-0.6.61/pyaedt/application/AnalysisNexxim.py
--rw-r--r--   0        0        0     4374 2023-03-24 16:41:45.863775 pyaedt-0.6.61/pyaedt/application/AnalysisRMxprt.py
--rw-r--r--   0        0        0     4539 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/application/AnalysisTwinBuilder.py
--rw-r--r--   0        0        0   126722 2023-03-30 14:01:28.915292 pyaedt-0.6.61/pyaedt/application/Design.py
--rw-r--r--   0        0        0     6115 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/application/JobManager.py
--rw-r--r--   0        0        0    72919 2023-03-26 21:01:00.338770 pyaedt-0.6.61/pyaedt/application/Variables.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/application/__init__.py
--rw-r--r--   0        0        0    12433 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/application/aedt_objects.py
--rw-r--r--   0        0        0    37014 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/application/design_solutions.py
--rw-r--r--   0        0        0    57605 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/circuit.py
--rw-r--r--   0        0        0    10034 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/common_rpc.py
--rw-r--r--   0        0        0    55548 2023-03-30 18:47:12.530420 pyaedt-0.6.61/pyaedt/desktop.py
--rw-r--r--   0        0        0    23552 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/dlls/PDFReport/AnsysReport.dll
--rw-r--r--   0        0        0     1092 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/dlls/PDFReport/AnsysTemplate.json
--rw-r--r--   0        0        0    23996 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/dlls/PDFReport/Images/Ansys.png
--rw-r--r--   0        0        0   249856 2023-03-24 16:41:45.879401 pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.DocumentObjectModel-gdi.dll
--rw-r--r--   0        0        0   481931 2023-03-24 16:41:45.895031 pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.DocumentObjectModel-gdi.xml
--rw-r--r--   0        0        0   131072 2023-03-24 16:41:45.895031 pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.Rendering-gdi.dll
--rw-r--r--   0        0        0    85860 2023-03-24 16:41:45.895031 pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.Rendering-gdi.xml
--rw-r--r--   0        0        0    86016 2023-03-24 16:41:45.895031 pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.RtfRendering-gdi.dll
--rw-r--r--   0        0        0    51586 2023-03-24 16:41:45.895031 pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.RtfRendering-gdi.xml
--rw-r--r--   0        0        0   700336 2023-03-24 16:41:45.910656 pyaedt-0.6.61/pyaedt/dlls/PDFReport/Newtonsoft.Json.dll
--rw-r--r--   0        0        0   707721 2023-03-24 16:41:45.910656 pyaedt-0.6.61/pyaedt/dlls/PDFReport/Newtonsoft.Json.xml
--rw-r--r--   0        0        0   585728 2023-03-24 16:41:45.926282 pyaedt-0.6.61/pyaedt/dlls/PDFReport/PdfSharp-gdi.dll
--rw-r--r--   0        0        0  1164073 2023-03-24 16:41:45.926282 pyaedt-0.6.61/pyaedt/dlls/PDFReport/PdfSharp-gdi.xml
--rw-r--r--   0        0        0    94208 2023-03-24 16:41:45.926282 pyaedt-0.6.61/pyaedt/dlls/PDFReport/PdfSharp.Charting-gdi.dll
--rw-r--r--   0        0        0   129427 2023-03-24 16:41:45.926282 pyaedt-0.6.61/pyaedt/dlls/PDFReport/PdfSharp.Charting-gdi.xml
--rw-r--r--   0        0        0     9728 2023-03-24 16:41:45.926282 pyaedt-0.6.61/pyaedt/dlls/PDFReport/de/MigraDoc.DocumentObjectModel-gdi.resources.dll
--rw-r--r--   0        0        0     7168 2023-03-24 16:41:45.926282 pyaedt-0.6.61/pyaedt/dlls/PDFReport/de/MigraDoc.Rendering-gdi.resources.dll
--rw-r--r--   0        0        0     7168 2023-03-24 16:41:45.926282 pyaedt-0.6.61/pyaedt/dlls/PDFReport/de/MigraDoc.RtfRendering-gdi.resources.dll
--rw-r--r--   0        0        0     5120 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/dlls/PDFReport/de/PdfSharp-gdi.resources.dll
--rw-r--r--   0        0        0     4608 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/dlls/PDFReport/de/PdfSharp.Charting-gdi.resources.dll
--rw-r--r--   0        0        0    23488 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/downloads.py
--rw-r--r--   0        0        0   114712 2023-03-28 20:31:59.451174 pyaedt-0.6.61/pyaedt/edb.py
--rw-r--r--   0        0        0      381 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/edb_core/__init__.py
--rw-r--r--   0        0        0    84815 2023-03-28 09:14:45.602251 pyaedt-0.6.61/pyaedt/edb_core/components.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/edb_core/edb_data/__init__.py
--rw-r--r--   0        0        0    31804 2023-03-28 09:14:45.602251 pyaedt-0.6.61/pyaedt/edb_core/edb_data/components_data.py
--rw-r--r--   0        0        0      937 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/edb_core/edb_data/design_options.py
--rw-r--r--   0        0        0      324 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/edb_core/edb_data/edb_builder.py
--rw-r--r--   0        0        0     1166 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/edb_core/edb_data/edbvalue.py
--rw-r--r--   0        0        0    65819 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/edb_core/edb_data/hfss_simulation_setup_data.py
--rw-r--r--   0        0        0    60644 2023-03-29 10:35:46.898086 pyaedt-0.6.61/pyaedt/edb_core/edb_data/layer_data.py
--rw-r--r--   0        0        0     4747 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/edb_core/edb_data/nets_data.py
--rw-r--r--   0        0        0    58547 2023-03-28 20:31:59.451174 pyaedt-0.6.61/pyaedt/edb_core/edb_data/padstacks_data.py
--rw-r--r--   0        0        0    32156 2023-03-27 19:28:56.931125 pyaedt-0.6.61/pyaedt/edb_core/edb_data/primitives_data.py
--rw-r--r--   0        0        0    96893 2023-03-30 14:25:32.303650 pyaedt-0.6.61/pyaedt/edb_core/edb_data/simulation_configuration.py
--rw-r--r--   0        0        0    36296 2023-03-24 16:41:45.941910 pyaedt-0.6.61/pyaedt/edb_core/edb_data/siwave_simulation_setup_data.py
--rw-r--r--   0        0        0    30593 2023-03-30 15:03:07.635052 pyaedt-0.6.61/pyaedt/edb_core/edb_data/sources.py
--rw-r--r--   0        0        0     4147 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/edb_data/utilities.py
--rw-r--r--   0        0        0     2425 2023-03-28 07:05:22.837730 pyaedt-0.6.61/pyaedt/edb_core/edb_data/variables.py
--rw-r--r--   0        0        0     2657 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/general.py
--rw-r--r--   0        0        0    65268 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/hfss.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/__init__.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/bom/__init__.py
--rw-r--r--   0        0        0      673 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/bom/bom.py
--rw-r--r--   0        0        0     1283 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/bom/bom_item.py
--rw-r--r--   0        0        0     2213 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/bom/characteristics.py
--rw-r--r--   0        0        0      524 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/bom/refdes.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/__init__.py
--rw-r--r--   0        0        0      768 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/color.py
--rw-r--r--   0        0        0     2118 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/content.py
--rw-r--r--   0        0        0      938 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/dictionary_color.py
--rw-r--r--   0        0        0      921 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/dictionary_fill.py
--rw-r--r--   0        0        0     1029 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/dictionary_line.py
--rw-r--r--   0        0        0      416 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/entry_color.py
--rw-r--r--   0        0        0      548 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/entry_line.py
--rw-r--r--   0        0        0      523 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/fill.py
--rw-r--r--   0        0        0      284 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/layer_ref.py
--rw-r--r--   0        0        0     2844 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/standard_geometries_dictionary.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/__init__.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/__init__.py
--rw-r--r--   0        0        0     1183 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/assembly_drawing.py
--rw-r--r--   0        0        0     1319 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/cad_data.py
--rw-r--r--   0        0        0     1516 2023-03-24 16:41:45.957536 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/component.py
--rw-r--r--   0        0        0      960 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/drill.py
--rw-r--r--   0        0        0     1964 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/feature.py
--rw-r--r--   0        0        0     1158 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/layer.py
--rw-r--r--   0        0        0     7706 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/layer_feature.py
--rw-r--r--   0        0        0      921 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/logical_net.py
--rw-r--r--   0        0        0     1079 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/outline.py
--rw-r--r--   0        0        0     4646 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/package.py
--rw-r--r--   0        0        0     1440 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_def.py
--rw-r--r--   0        0        0      875 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_hole_def.py
--rw-r--r--   0        0        0     2775 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_instance.py
--rw-r--r--   0        0        0      887 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_pad_def.py
--rw-r--r--   0        0        0     4104 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/path.py
--rw-r--r--   0        0        0     2567 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/phy_net.py
--rw-r--r--   0        0        0     1002 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/pin.py
--rw-r--r--   0        0        0     8010 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/polygon.py
--rw-r--r--   0        0        0      663 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/profile.py
--rw-r--r--   0        0        0     1162 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup.py
--rw-r--r--   0        0        0     1626 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup_group.py
--rw-r--r--   0        0        0      838 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup_layer.py
--rw-r--r--   0        0        0    11172 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/step.py
--rw-r--r--   0        0        0     1033 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_header.py
--rw-r--r--   0        0        0      683 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/ecad.py
--rw-r--r--   0        0        0     2008 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/spec.py
--rw-r--r--   0        0        0     1624 2023-03-24 16:41:45.973163 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/history_record.py
--rw-r--r--   0        0        0    21789 2023-03-28 09:14:45.602251 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ipc2581.py
--rw-r--r--   0        0        0      966 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/edb_core/ipc2581/logistic_header.py
--rw-r--r--   0        0        0    47979 2023-03-28 09:14:45.602251 pyaedt-0.6.61/pyaedt/edb_core/layout.py
--rw-r--r--   0        0        0    33244 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/edb_core/materials.py
--rw-r--r--   0        0        0    39982 2023-03-28 14:20:35.311318 pyaedt-0.6.61/pyaedt/edb_core/nets.py
--rw-r--r--   0        0        0    38281 2023-03-30 14:25:32.303650 pyaedt-0.6.61/pyaedt/edb_core/padstack.py
--rw-r--r--   0        0        0    57346 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/edb_core/siwave.py
--rw-r--r--   0        0        0   103703 2023-03-29 10:35:46.898086 pyaedt-0.6.61/pyaedt/edb_core/stackup.py
--rw-r--r--   0        0        0    10592 2023-03-31 13:33:23.741132 pyaedt-0.6.61/pyaedt/emit.py
--rw-r--r--   0        0        0     3555 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/emit_core/Couplings.py
--rw-r--r--   0        0        0     2233 2023-03-31 13:33:23.741132 pyaedt-0.6.61/pyaedt/emit_core/EmitConstants.py
--rw-r--r--   0        0        0      448 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/emit_core/__init__.py
--rw-r--r--   0        0        0        2 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/emit_core/results/__init__.py
--rw-r--r--   0        0        0     5983 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/emit_core/results/results.py
--rw-r--r--   0        0        0    11560 2023-03-31 13:33:23.741132 pyaedt-0.6.61/pyaedt/emit_core/results/revision.py
--rw-r--r--   0        0        0    14317 2023-03-27 11:40:23.480278 pyaedt-0.6.61/pyaedt/generic/DataHandlers.py
--rw-r--r--   0        0        0    11758 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/generic/LoadAEDTFile.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/generic/__init__.py
--rw-r--r--   0        0        0     3021 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/generic/clr_module.py
--rw-r--r--   0        0        0    83375 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/generic/configurations.py
--rw-r--r--   0        0        0    29401 2023-03-27 19:11:18.222018 pyaedt-0.6.61/pyaedt/generic/constants.py
--rw-r--r--   0        0        0    19616 2023-03-24 16:41:45.988798 pyaedt-0.6.61/pyaedt/generic/design_types.py
--rw-r--r--   0        0        0     3416 2023-03-30 12:59:07.949373 pyaedt-0.6.61/pyaedt/generic/filesystem.py
--rw-r--r--   0        0        0    60817 2023-03-29 09:57:36.086495 pyaedt-0.6.61/pyaedt/generic/general_methods.py
--rw-r--r--   0        0        0    25808 2023-03-24 16:41:46.004424 pyaedt-0.6.61/pyaedt/generic/ibis_reader.py
--rw-r--r--   0        0        0     6989 2023-03-24 16:41:46.004424 pyaedt-0.6.61/pyaedt/generic/near_field_import.py
--rw-r--r--   0        0        0    61851 2023-03-30 14:01:28.930918 pyaedt-0.6.61/pyaedt/generic/plot.py
--rw-r--r--   0        0        0    11301 2023-03-24 16:41:46.004424 pyaedt-0.6.61/pyaedt/generic/process.py
--rw-r--r--   0        0        0    19736 2023-03-24 16:41:46.004424 pyaedt-0.6.61/pyaedt/generic/python_optimizers.py
--rw-r--r--   0        0        0     3466 2023-03-24 16:41:46.004424 pyaedt-0.6.61/pyaedt/generic/report_file_parser.py
--rw-r--r--   0        0        0    60355 2023-03-24 16:41:46.004424 pyaedt-0.6.61/pyaedt/generic/toolkit.py
--rw-r--r--   0        0        0    16419 2023-03-24 16:41:46.004424 pyaedt-0.6.61/pyaedt/generic/touchstone_parser.py
--rw-r--r--   0        0        0      438 2023-03-24 16:41:46.004424 pyaedt-0.6.61/pyaedt/generic/wpf_template.xaml
--rw-r--r--   0        0        0   244998 2023-03-28 20:31:59.451174 pyaedt-0.6.61/pyaedt/hfss.py
--rw-r--r--   0        0        0    84494 2023-03-28 08:08:58.339194 pyaedt-0.6.61/pyaedt/hfss3dlayout.py
--rw-r--r--   0        0        0   151079 2023-03-24 16:41:46.004424 pyaedt-0.6.61/pyaedt/icepak.py
--rw-r--r--   0        0        0   113520 2023-03-31 10:20:53.726093 pyaedt-0.6.61/pyaedt/maxwell.py
--rw-r--r--   0        0        0     7816 2023-03-24 16:41:46.004424 pyaedt-0.6.61/pyaedt/maxwellcircuit.py
--rw-r--r--   0        0        0    23989 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/mechanical.py
--rw-r--r--   0        0        0     3629 2023-03-27 19:11:18.222018 pyaedt-0.6.61/pyaedt/misc/Console.py_build
--rw-r--r--   0        0        0     2230 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/Job_Settings.areg
--rw-r--r--   0        0        0     2410 2023-03-27 19:11:18.222018 pyaedt-0.6.61/pyaedt/misc/Jupyter.py_build
--rw-r--r--   0        0        0     3695 2023-03-30 18:47:12.530420 pyaedt-0.6.61/pyaedt/misc/Run_PyAEDT_Script.py_build
--rw-r--r--   0        0        0     2380 2023-03-30 18:47:12.530420 pyaedt-0.6.61/pyaedt/misc/Run_PyAEDT_Toolkit_Script.py_build
--rw-r--r--   0        0        0       53 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/__init__.py
--rw-r--r--   0        0        0     8973 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/aedtlib_personalib_install.py
--rw-r--r--   0        0        0    19870 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/amat.xml
--rw-r--r--   0        0        0     3731 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/console_setup.py
--rw-r--r--   0        0        0       48 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/create_remote_dir.py
--rw-r--r--   0        0        0    15250 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/images/gallery/PyAEDT.png
--rw-r--r--   0        0        0      855 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/images/large/pyansys.png
--rw-r--r--   0        0        0     3507 2023-03-30 18:47:12.530420 pyaedt-0.6.61/pyaedt/misc/install_extra_toolkits.py
--rw-r--r--   0        0        0     1728 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/jupyter_template.ipynb
--rw-r--r--   0        0        0      678 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/misc.py
--rw-r--r--   0        0        0   771467 2023-03-24 16:41:46.020044 pyaedt-0.6.61/pyaedt/misc/ml_data_file_train_100MHz_1GHz.json
--rw-r--r--   0        0        0   502580 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/misc/ml_data_file_train_1GHz_10GHz.json
--rw-r--r--   0        0        0   162026 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/misc/patch_svr_model_100MHz_1GHz.joblib
--rw-r--r--   0        0        0   134414 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/misc/patch_svr_model_1GHz_10GHz.joblib
--rw-r--r--   0        0        0      289 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/misc/pyaedt.runtimeconfig.json
--rw-r--r--   0        0        0      953 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/misc/pyaedt_local_config.acf
--rw-r--r--   0        0        0    16550 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/misc/pyansys-logo-black-cropped.png
--rw-r--r--   0        0        0      868 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/misc/template.acf
--rw-r--r--   0        0        0        0 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/modeler/__init__.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/modeler/advanced_cad/__init__.py
--rw-r--r--   0        0        0    14076 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/modeler/advanced_cad/actors.py
--rw-r--r--   0        0        0    19994 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/modeler/advanced_cad/multiparts.py
--rw-r--r--   0        0        0    18540 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/modeler/advanced_cad/oms.py
--rw-r--r--   0        0        0    16846 2023-03-24 16:41:46.035676 pyaedt-0.6.61/pyaedt/modeler/advanced_cad/parts.py
--rw-r--r--   0        0        0   120906 2023-03-28 09:14:45.617874 pyaedt-0.6.61/pyaedt/modeler/advanced_cad/stackup_3d.py
--rw-r--r--   0        0        0   198679 2023-03-26 21:01:00.338770 pyaedt-0.6.61/pyaedt/modeler/cad/Modeler.py
--rw-r--r--   0        0        0   114349 2023-03-31 15:28:52.562770 pyaedt-0.6.61/pyaedt/modeler/cad/Primitives.py
--rw-r--r--   0        0        0    11332 2023-03-24 16:41:46.051297 pyaedt-0.6.61/pyaedt/modeler/cad/Primitives2D.py
--rw-r--r--   0        0        0   119449 2023-03-31 15:28:52.562770 pyaedt-0.6.61/pyaedt/modeler/cad/Primitives3D.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:46.051297 pyaedt-0.6.61/pyaedt/modeler/cad/__init__.py
--rw-r--r--   0        0        0    29041 2023-03-24 16:41:46.051297 pyaedt-0.6.61/pyaedt/modeler/cad/components_3d.py
--rw-r--r--   0        0        0    49002 2023-03-31 08:50:57.518673 pyaedt-0.6.61/pyaedt/modeler/cad/elements3d.py
--rw-r--r--   0        0        0    59914 2023-03-24 16:41:46.051297 pyaedt-0.6.61/pyaedt/modeler/cad/object3d.py
--rw-r--r--   0        0        0    53213 2023-03-30 15:03:07.635052 pyaedt-0.6.61/pyaedt/modeler/cad/polylines.py
--rw-r--r--   0        0        0    43366 2023-03-31 15:28:52.562770 pyaedt-0.6.61/pyaedt/modeler/circuits/PrimitivesCircuit.py
--rw-r--r--   0        0        0    32231 2023-03-24 16:41:46.051297 pyaedt-0.6.61/pyaedt/modeler/circuits/PrimitivesEmit.py
--rw-r--r--   0        0        0     8157 2023-03-24 16:41:46.051297 pyaedt-0.6.61/pyaedt/modeler/circuits/PrimitivesMaxwellCircuit.py
--rw-r--r--   0        0        0    67061 2023-03-24 16:41:46.051297 pyaedt-0.6.61/pyaedt/modeler/circuits/PrimitivesNexxim.py
--rw-r--r--   0        0        0    15094 2023-03-24 16:41:46.051297 pyaedt-0.6.61/pyaedt/modeler/circuits/PrimitivesTwinBuilder.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:46.051297 pyaedt-0.6.61/pyaedt/modeler/circuits/__init__.py
--rw-r--r--   0        0        0    31901 2023-03-24 16:41:46.051297 pyaedt-0.6.61/pyaedt/modeler/circuits/object3dcircuit.py
--rw-r--r--   0        0        0    67799 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modeler/geometry_operators.py
--rw-r--r--   0        0        0     6902 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modeler/modeler2d.py
--rw-r--r--   0        0        0    48478 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modeler/modeler3d.py
--rw-r--r--   0        0        0    30435 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modeler/modelerpcb.py
--rw-r--r--   0        0        0    49786 2023-03-28 09:14:45.617874 pyaedt-0.6.61/pyaedt/modeler/pcb/Primitives3DLayout.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modeler/pcb/__init__.py
--rw-r--r--   0        0        0    57190 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modeler/pcb/object3dlayout.py
--rw-r--r--   0        0        0    21513 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modeler/schematic.py
--rw-r--r--   0        0        0    30108 2023-03-31 15:28:52.562770 pyaedt-0.6.61/pyaedt/modules/AdvancedPostProcessing.py
--rw-r--r--   0        0        0   113740 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modules/Boundary.py
--rw-r--r--   0        0        0    71549 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modules/CableModeling.py
--rw-r--r--   0        0        0    16319 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modules/CircuitTemplates.py
--rw-r--r--   0        0        0    51910 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modules/DesignXPloration.py
--rw-r--r--   0        0        0    37371 2023-03-31 11:49:22.302421 pyaedt-0.6.61/pyaedt/modules/LayerStackup.py
--rw-r--r--   0        0        0    82846 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modules/Material.py
--rw-r--r--   0        0        0    28306 2023-03-24 16:41:46.066930 pyaedt-0.6.61/pyaedt/modules/MaterialLib.py
--rw-r--r--   0        0        0    53174 2023-03-27 14:39:04.723231 pyaedt-0.6.61/pyaedt/modules/Mesh.py
--rw-r--r--   0        0        0    11919 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/modules/Mesh3DLayout.py
--rw-r--r--   0        0        0    26048 2023-03-31 15:28:52.562770 pyaedt-0.6.61/pyaedt/modules/MeshIcepak.py
--rw-r--r--   0        0        0     4437 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/modules/OptimetricsTemplates.py
--rw-r--r--   0        0        0   181634 2023-03-31 15:28:52.562770 pyaedt-0.6.61/pyaedt/modules/PostProcessor.py
--rw-r--r--   0        0        0    64104 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/modules/SetupTemplates.py
--rw-r--r--   0        0        0   116123 2023-03-28 20:31:59.451174 pyaedt-0.6.61/pyaedt/modules/SolveSetup.py
--rw-r--r--   0        0        0    33225 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/modules/SolveSweeps.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/modules/__init__.py
--rw-r--r--   0        0        0    28652 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/modules/monitor_icepak.py
--rw-r--r--   0        0        0   103276 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/modules/report_templates.py
--rw-r--r--   0        0        0   125679 2023-03-31 15:28:52.562770 pyaedt-0.6.61/pyaedt/modules/solutions.py
--rw-r--r--   0        0        0    92404 2023-03-28 20:31:59.466799 pyaedt-0.6.61/pyaedt/q3d.py
--rw-r--r--   0        0        0    10556 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/rmxprt.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/rpc/__init__.py
--rw-r--r--   0        0        0      415 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/rpc/local_server.py
--rw-r--r--   0        0        0    40721 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/rpc/rpyc_services.py
--rw-r--r--   0        0        0        0 2023-03-24 16:41:46.082556 pyaedt-0.6.61/pyaedt/sbrplus/__init__.py
--rw-r--r--   0        0        0     9425 2023-03-24 16:41:46.098177 pyaedt-0.6.61/pyaedt/sbrplus/hdm_parser.py
--rw-r--r--   0        0        0     2096 2023-03-24 16:41:46.098177 pyaedt-0.6.61/pyaedt/sbrplus/hdm_utils.py
--rw-r--r--   0        0        0     2607 2023-03-24 16:41:46.098177 pyaedt-0.6.61/pyaedt/sbrplus/matlab/HdmObject.m
--rw-r--r--   0        0        0       97 2023-03-24 16:41:46.098177 pyaedt-0.6.61/pyaedt/sbrplus/matlab/README.md
--rw-r--r--   0        0        0      735 2023-03-29 08:48:21.007531 pyaedt-0.6.61/pyaedt/sbrplus/matlab/SbrBounceType.m
--rw-r--r--   0        0        0     2886 2023-03-29 08:48:21.007531 pyaedt-0.6.61/pyaedt/sbrplus/matlab/StopWatch.m
--rw-r--r--   0        0        0     1402 2023-03-29 08:48:21.007531 pyaedt-0.6.61/pyaedt/sbrplus/matlab/add_3dlight.m
--rw-r--r--   0        0        0      340 2023-03-24 16:41:46.098177 pyaedt-0.6.61/pyaedt/sbrplus/matlab/amp2db.m
--rw-r--r--   0        0        0    36837 2023-03-29 08:48:21.007531 pyaedt-0.6.61/pyaedt/sbrplus/matlab/draw_rays1.m
--rw-r--r--   0        0        0     4322 2023-03-29 08:48:21.007531 pyaedt-0.6.61/pyaedt/sbrplus/matlab/draw_wfobj.m
--rw-r--r--   0        0        0    31414 2023-03-29 08:48:21.007531 pyaedt-0.6.61/pyaedt/sbrplus/matlab/filter_rays1.m
--rw-r--r--   0        0        0     1504 2023-03-29 08:48:21.007531 pyaedt-0.6.61/pyaedt/sbrplus/matlab/filtered_tracks.m
--rw-r--r--   0        0        0    20853 2023-03-29 08:48:21.007531 pyaedt-0.6.61/pyaedt/sbrplus/matlab/ld_sbrplushdm.m
--rw-r--r--   0        0        0    14781 2023-03-29 08:48:21.007531 pyaedt-0.6.61/pyaedt/sbrplus/matlab/ld_wfobj.m
--rw-r--r--   0        0        0      318 2023-03-24 16:41:46.098177 pyaedt-0.6.61/pyaedt/sbrplus/matlab/pwr2db.m
--rw-r--r--   0        0        0     2607 2023-03-29 08:48:21.007531 pyaedt-0.6.61/pyaedt/sbrplus/matlab/validate_sfields.m
--rw-r--r--   0        0        0     7601 2023-03-24 16:41:46.098177 pyaedt-0.6.61/pyaedt/sbrplus/plot.py
--rw-r--r--   0        0        0    10373 2023-03-24 16:41:46.098177 pyaedt-0.6.61/pyaedt/siwave.py
--rw-r--r--   0        0        0    10527 2023-03-24 16:41:46.098177 pyaedt-0.6.61/pyaedt/twinbuilder.py
--rw-r--r--   0        0        0     4093 2023-03-31 15:28:52.562770 pyaedt-0.6.61/pyproject.toml
--rw-r--r--   0        0        0    14898 1970-01-01 00:00:00.000000 pyaedt-0.6.61/PKG-INFO
+-rw-r--r--   0        0        0     1111 2023-03-24 16:10:16.742763 pyaedt-0.6.70/LICENSE
+-rw-r--r--   0        0        0     9857 2023-04-07 10:17:20.915272 pyaedt-0.6.70/README.rst
+-rw-r--r--   0        0        0     2503 2023-04-07 18:23:53.677004 pyaedt-0.6.70/pyaedt/__init__.py
+-rw-r--r--   0        0        0    26253 2023-03-24 16:10:18.742581 pyaedt-0.6.70/pyaedt/aedt_logger.py
+-rw-r--r--   0        0        0     6965 2023-03-24 16:10:18.742581 pyaedt-0.6.70/pyaedt/application/AEDT_File_Management.py
+-rw-r--r--   0        0        0    88655 2023-04-07 18:23:53.677004 pyaedt-0.6.70/pyaedt/application/Analysis.py
+-rw-r--r--   0        0        0    41260 2023-04-06 11:56:42.332868 pyaedt-0.6.70/pyaedt/application/Analysis3D.py
+-rw-r--r--   0        0        0    17009 2023-04-06 11:56:42.332868 pyaedt-0.6.70/pyaedt/application/Analysis3DLayout.py
+-rw-r--r--   0        0        0     3088 2023-03-24 16:10:18.742581 pyaedt-0.6.70/pyaedt/application/AnalysisMaxwellCircuit.py
+-rw-r--r--   0        0        0    19795 2023-04-06 11:56:42.332868 pyaedt-0.6.70/pyaedt/application/AnalysisNexxim.py
+-rw-r--r--   0        0        0     4374 2023-03-24 16:10:18.742581 pyaedt-0.6.70/pyaedt/application/AnalysisRMxprt.py
+-rw-r--r--   0        0        0     4539 2023-03-24 16:10:18.742581 pyaedt-0.6.70/pyaedt/application/AnalysisTwinBuilder.py
+-rw-r--r--   0        0        0   126722 2023-03-30 14:12:42.537578 pyaedt-0.6.70/pyaedt/application/Design.py
+-rw-r--r--   0        0        0     6115 2023-03-24 16:10:18.742581 pyaedt-0.6.70/pyaedt/application/JobManager.py
+-rw-r--r--   0        0        0    72583 2023-04-03 12:18:59.459114 pyaedt-0.6.70/pyaedt/application/Variables.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.742581 pyaedt-0.6.70/pyaedt/application/__init__.py
+-rw-r--r--   0        0        0    12433 2023-03-24 16:10:18.742581 pyaedt-0.6.70/pyaedt/application/aedt_objects.py
+-rw-r--r--   0        0        0    37014 2023-03-24 16:10:18.742581 pyaedt-0.6.70/pyaedt/application/design_solutions.py
+-rw-r--r--   0        0        0    57605 2023-03-24 16:10:18.758234 pyaedt-0.6.70/pyaedt/circuit.py
+-rw-r--r--   0        0        0    10034 2023-03-24 16:10:18.758234 pyaedt-0.6.70/pyaedt/common_rpc.py
+-rw-r--r--   0        0        0    56983 2023-04-07 12:39:52.648098 pyaedt-0.6.70/pyaedt/desktop.py
+-rw-r--r--   0        0        0    23552 2023-03-24 16:10:18.758234 pyaedt-0.6.70/pyaedt/dlls/PDFReport/AnsysReport.dll
+-rw-r--r--   0        0        0     1092 2023-03-24 16:10:18.758234 pyaedt-0.6.70/pyaedt/dlls/PDFReport/AnsysTemplate.json
+-rw-r--r--   0        0        0    23996 2023-03-24 16:10:18.758234 pyaedt-0.6.70/pyaedt/dlls/PDFReport/Images/Ansys.png
+-rw-r--r--   0        0        0   249856 2023-03-24 16:10:18.758234 pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.DocumentObjectModel-gdi.dll
+-rw-r--r--   0        0        0   481931 2023-03-24 16:10:18.773842 pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.DocumentObjectModel-gdi.xml
+-rw-r--r--   0        0        0   131072 2023-03-24 16:10:18.773842 pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.Rendering-gdi.dll
+-rw-r--r--   0        0        0    85860 2023-03-24 16:10:18.773842 pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.Rendering-gdi.xml
+-rw-r--r--   0        0        0    86016 2023-03-24 16:10:18.773842 pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.RtfRendering-gdi.dll
+-rw-r--r--   0        0        0    51586 2023-03-24 16:10:18.773842 pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.RtfRendering-gdi.xml
+-rw-r--r--   0        0        0   700336 2023-03-24 16:10:18.773842 pyaedt-0.6.70/pyaedt/dlls/PDFReport/Newtonsoft.Json.dll
+-rw-r--r--   0        0        0   707721 2023-03-24 16:10:18.789780 pyaedt-0.6.70/pyaedt/dlls/PDFReport/Newtonsoft.Json.xml
+-rw-r--r--   0        0        0   585728 2023-03-24 16:10:18.789780 pyaedt-0.6.70/pyaedt/dlls/PDFReport/PdfSharp-gdi.dll
+-rw-r--r--   0        0        0  1164073 2023-03-24 16:10:18.789780 pyaedt-0.6.70/pyaedt/dlls/PDFReport/PdfSharp-gdi.xml
+-rw-r--r--   0        0        0    94208 2023-03-24 16:10:18.805116 pyaedt-0.6.70/pyaedt/dlls/PDFReport/PdfSharp.Charting-gdi.dll
+-rw-r--r--   0        0        0   129427 2023-03-24 16:10:18.805116 pyaedt-0.6.70/pyaedt/dlls/PDFReport/PdfSharp.Charting-gdi.xml
+-rw-r--r--   0        0        0     9728 2023-03-24 16:10:18.805116 pyaedt-0.6.70/pyaedt/dlls/PDFReport/de/MigraDoc.DocumentObjectModel-gdi.resources.dll
+-rw-r--r--   0        0        0     7168 2023-03-24 16:10:18.805116 pyaedt-0.6.70/pyaedt/dlls/PDFReport/de/MigraDoc.Rendering-gdi.resources.dll
+-rw-r--r--   0        0        0     7168 2023-03-24 16:10:18.805116 pyaedt-0.6.70/pyaedt/dlls/PDFReport/de/MigraDoc.RtfRendering-gdi.resources.dll
+-rw-r--r--   0        0        0     5120 2023-03-24 16:10:18.805116 pyaedt-0.6.70/pyaedt/dlls/PDFReport/de/PdfSharp-gdi.resources.dll
+-rw-r--r--   0        0        0     4608 2023-03-24 16:10:18.805116 pyaedt-0.6.70/pyaedt/dlls/PDFReport/de/PdfSharp.Charting-gdi.resources.dll
+-rw-r--r--   0        0        0    23488 2023-03-24 16:43:00.390747 pyaedt-0.6.70/pyaedt/downloads.py
+-rw-r--r--   0        0        0   130774 2023-04-07 14:18:16.247983 pyaedt-0.6.70/pyaedt/edb.py
+-rw-r--r--   0        0        0      333 2023-04-06 16:51:57.478550 pyaedt-0.6.70/pyaedt/edb_core/__init__.py
+-rw-r--r--   0        0        0    88171 2023-04-06 17:43:43.595268 pyaedt-0.6.70/pyaedt/edb_core/components.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.820698 pyaedt-0.6.70/pyaedt/edb_core/edb_data/__init__.py
+-rw-r--r--   0        0        0    32856 2023-04-06 17:43:43.595268 pyaedt-0.6.70/pyaedt/edb_core/edb_data/components_data.py
+-rw-r--r--   0        0        0      937 2023-03-24 16:10:18.820698 pyaedt-0.6.70/pyaedt/edb_core/edb_data/design_options.py
+-rw-r--r--   0        0        0      324 2023-03-24 16:10:18.820698 pyaedt-0.6.70/pyaedt/edb_core/edb_data/edb_builder.py
+-rw-r--r--   0        0        0     1166 2023-03-24 16:10:18.820698 pyaedt-0.6.70/pyaedt/edb_core/edb_data/edbvalue.py
+-rw-r--r--   0        0        0    65819 2023-03-24 16:10:18.820698 pyaedt-0.6.70/pyaedt/edb_core/edb_data/hfss_simulation_setup_data.py
+-rw-r--r--   0        0        0    20305 2023-04-06 16:51:57.478550 pyaedt-0.6.70/pyaedt/edb_core/edb_data/layer_data.py
+-rw-r--r--   0        0        0     4724 2023-04-03 14:45:49.216597 pyaedt-0.6.70/pyaedt/edb_core/edb_data/nets_data.py
+-rw-r--r--   0        0        0    58397 2023-04-03 14:45:49.216597 pyaedt-0.6.70/pyaedt/edb_core/edb_data/padstacks_data.py
+-rw-r--r--   0        0        0    32298 2023-04-06 16:51:57.478550 pyaedt-0.6.70/pyaedt/edb_core/edb_data/primitives_data.py
+-rw-r--r--   0        0        0    96893 2023-03-30 14:49:31.546231 pyaedt-0.6.70/pyaedt/edb_core/edb_data/simulation_configuration.py
+-rw-r--r--   0        0        0    36296 2023-03-24 16:43:00.390747 pyaedt-0.6.70/pyaedt/edb_core/edb_data/siwave_simulation_setup_data.py
+-rw-r--r--   0        0        0    31276 2023-04-06 16:51:57.478550 pyaedt-0.6.70/pyaedt/edb_core/edb_data/sources.py
+-rw-r--r--   0        0        0     4147 2023-03-24 16:10:18.820698 pyaedt-0.6.70/pyaedt/edb_core/edb_data/utilities.py
+-rw-r--r--   0        0        0     2425 2023-03-27 19:28:28.383108 pyaedt-0.6.70/pyaedt/edb_core/edb_data/variables.py
+-rw-r--r--   0        0        0     2657 2023-03-24 16:10:18.820698 pyaedt-0.6.70/pyaedt/edb_core/general.py
+-rw-r--r--   0        0        0    60090 2023-04-03 14:45:49.216597 pyaedt-0.6.70/pyaedt/edb_core/hfss.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/__init__.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/bom/__init__.py
+-rw-r--r--   0        0        0      673 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/bom/bom.py
+-rw-r--r--   0        0        0     1283 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/bom/bom_item.py
+-rw-r--r--   0        0        0     2213 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/bom/characteristics.py
+-rw-r--r--   0        0        0      524 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/bom/refdes.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/__init__.py
+-rw-r--r--   0        0        0      768 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/color.py
+-rw-r--r--   0        0        0     2118 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/content.py
+-rw-r--r--   0        0        0      938 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/dictionary_color.py
+-rw-r--r--   0        0        0      921 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/dictionary_fill.py
+-rw-r--r--   0        0        0     1029 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/dictionary_line.py
+-rw-r--r--   0        0        0      416 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/entry_color.py
+-rw-r--r--   0        0        0      548 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/entry_line.py
+-rw-r--r--   0        0        0      523 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/fill.py
+-rw-r--r--   0        0        0      284 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/layer_ref.py
+-rw-r--r--   0        0        0     2844 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/standard_geometries_dictionary.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/__init__.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/__init__.py
+-rw-r--r--   0        0        0     1183 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/assembly_drawing.py
+-rw-r--r--   0        0        0     1319 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/cad_data.py
+-rw-r--r--   0        0        0     1516 2023-03-24 16:10:18.836323 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/component.py
+-rw-r--r--   0        0        0      960 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/drill.py
+-rw-r--r--   0        0        0     1964 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/feature.py
+-rw-r--r--   0        0        0     1158 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/layer.py
+-rw-r--r--   0        0        0     7706 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/layer_feature.py
+-rw-r--r--   0        0        0      921 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/logical_net.py
+-rw-r--r--   0        0        0     1079 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/outline.py
+-rw-r--r--   0        0        0     4646 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/package.py
+-rw-r--r--   0        0        0     1440 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_def.py
+-rw-r--r--   0        0        0      875 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_hole_def.py
+-rw-r--r--   0        0        0     2775 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_instance.py
+-rw-r--r--   0        0        0      887 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_pad_def.py
+-rw-r--r--   0        0        0     4104 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/path.py
+-rw-r--r--   0        0        0     2567 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/phy_net.py
+-rw-r--r--   0        0        0     1002 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/pin.py
+-rw-r--r--   0        0        0     8010 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/polygon.py
+-rw-r--r--   0        0        0      663 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/profile.py
+-rw-r--r--   0        0        0     1162 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup.py
+-rw-r--r--   0        0        0     1626 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup_group.py
+-rw-r--r--   0        0        0      838 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup_layer.py
+-rw-r--r--   0        0        0    11163 2023-04-03 14:45:49.232236 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/step.py
+-rw-r--r--   0        0        0     1033 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_header.py
+-rw-r--r--   0        0        0      683 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/ecad.py
+-rw-r--r--   0        0        0     2008 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/spec.py
+-rw-r--r--   0        0        0     1624 2023-03-24 16:10:18.851970 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/history_record.py
+-rw-r--r--   0        0        0    21750 2023-04-03 14:45:49.232236 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ipc2581.py
+-rw-r--r--   0        0        0      966 2023-03-24 16:10:18.867622 pyaedt-0.6.70/pyaedt/edb_core/ipc2581/logistic_header.py
+-rw-r--r--   0        0        0    48211 2023-04-03 14:45:49.232236 pyaedt-0.6.70/pyaedt/edb_core/layout.py
+-rw-r--r--   0        0        0    33242 2023-04-07 10:17:20.946469 pyaedt-0.6.70/pyaedt/edb_core/materials.py
+-rw-r--r--   0        0        0    43680 2023-04-06 17:49:40.538145 pyaedt-0.6.70/pyaedt/edb_core/nets.py
+-rw-r--r--   0        0        0    46506 2023-04-06 09:50:14.101200 pyaedt-0.6.70/pyaedt/edb_core/padstack.py
+-rw-r--r--   0        0        0    57133 2023-04-06 16:51:57.478550 pyaedt-0.6.70/pyaedt/edb_core/siwave.py
+-rw-r--r--   0        0        0   101238 2023-04-07 14:18:16.247983 pyaedt-0.6.70/pyaedt/edb_core/stackup.py
+-rw-r--r--   0        0        0    10889 2023-04-01 08:45:04.717291 pyaedt-0.6.70/pyaedt/emit.py
+-rw-r--r--   0        0        0     3555 2023-03-24 16:10:18.867622 pyaedt-0.6.70/pyaedt/emit_core/Couplings.py
+-rw-r--r--   0        0        0     3256 2023-04-01 08:45:04.717291 pyaedt-0.6.70/pyaedt/emit_core/EmitConstants.py
+-rw-r--r--   0        0        0      448 2023-03-24 16:10:18.867622 pyaedt-0.6.70/pyaedt/emit_core/__init__.py
+-rw-r--r--   0        0        0        2 2023-03-24 16:10:18.867622 pyaedt-0.6.70/pyaedt/emit_core/results/__init__.py
+-rw-r--r--   0        0        0     6825 2023-04-06 11:17:50.336000 pyaedt-0.6.70/pyaedt/emit_core/results/results.py
+-rw-r--r--   0        0        0    11615 2023-04-06 11:17:50.351622 pyaedt-0.6.70/pyaedt/emit_core/results/revision.py
+-rw-r--r--   0        0        0    14317 2023-03-27 12:10:05.425190 pyaedt-0.6.70/pyaedt/generic/DataHandlers.py
+-rw-r--r--   0        0        0    11758 2023-03-24 16:10:18.867622 pyaedt-0.6.70/pyaedt/generic/LoadAEDTFile.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.867622 pyaedt-0.6.70/pyaedt/generic/__init__.py
+-rw-r--r--   0        0        0     3021 2023-03-24 16:10:18.883250 pyaedt-0.6.70/pyaedt/generic/clr_module.py
+-rw-r--r--   0        0        0    83375 2023-03-24 16:10:18.883250 pyaedt-0.6.70/pyaedt/generic/configurations.py
+-rw-r--r--   0        0        0    28645 2023-04-07 12:58:03.133395 pyaedt-0.6.70/pyaedt/generic/constants.py
+-rw-r--r--   0        0        0    19616 2023-03-24 16:10:18.883250 pyaedt-0.6.70/pyaedt/generic/design_types.py
+-rw-r--r--   0        0        0     3416 2023-03-30 13:11:17.942263 pyaedt-0.6.70/pyaedt/generic/filesystem.py
+-rw-r--r--   0        0        0    62967 2023-04-07 12:39:52.648098 pyaedt-0.6.70/pyaedt/generic/general_methods.py
+-rw-r--r--   0        0        0    25808 2023-03-24 16:10:18.883250 pyaedt-0.6.70/pyaedt/generic/ibis_reader.py
+-rw-r--r--   0        0        0     6989 2023-03-24 16:10:18.883250 pyaedt-0.6.70/pyaedt/generic/near_field_import.py
+-rw-r--r--   0        0        0    62296 2023-04-07 12:58:03.133395 pyaedt-0.6.70/pyaedt/generic/plot.py
+-rw-r--r--   0        0        0    11301 2023-03-24 16:10:18.883250 pyaedt-0.6.70/pyaedt/generic/process.py
+-rw-r--r--   0        0        0    19736 2023-03-24 16:10:18.883250 pyaedt-0.6.70/pyaedt/generic/python_optimizers.py
+-rw-r--r--   0        0        0     3466 2023-03-24 16:10:18.883250 pyaedt-0.6.70/pyaedt/generic/report_file_parser.py
+-rw-r--r--   0        0        0    60355 2023-03-24 16:10:18.898857 pyaedt-0.6.70/pyaedt/generic/toolkit.py
+-rw-r--r--   0        0        0    17088 2023-04-07 12:58:03.149048 pyaedt-0.6.70/pyaedt/generic/touchstone_parser.py
+-rw-r--r--   0        0        0      438 2023-03-24 16:10:18.898857 pyaedt-0.6.70/pyaedt/generic/wpf_template.xaml
+-rw-r--r--   0        0        0   253030 2023-04-06 12:36:53.912898 pyaedt-0.6.70/pyaedt/hfss.py
+-rw-r--r--   0        0        0    82916 2023-04-06 11:56:42.332868 pyaedt-0.6.70/pyaedt/hfss3dlayout.py
+-rw-r--r--   0        0        0   151079 2023-03-24 16:10:18.898857 pyaedt-0.6.70/pyaedt/icepak.py
+-rw-r--r--   0        0        0   113532 2023-04-06 10:00:10.649919 pyaedt-0.6.70/pyaedt/maxwell.py
+-rw-r--r--   0        0        0     7816 2023-03-24 16:10:18.907751 pyaedt-0.6.70/pyaedt/maxwellcircuit.py
+-rw-r--r--   0        0        0    23989 2023-03-24 16:10:18.907751 pyaedt-0.6.70/pyaedt/mechanical.py
+-rw-r--r--   0        0        0     3642 2023-04-03 09:31:32.851623 pyaedt-0.6.70/pyaedt/misc/Console.py_build
+-rw-r--r--   0        0        0     2230 2023-03-24 16:10:18.907751 pyaedt-0.6.70/pyaedt/misc/Job_Settings.areg
+-rw-r--r--   0        0        0     3035 2023-04-03 09:31:32.851623 pyaedt-0.6.70/pyaedt/misc/Jupyter.py_build
+-rw-r--r--   0        0        0     3695 2023-03-30 19:37:04.658681 pyaedt-0.6.70/pyaedt/misc/Run_PyAEDT_Script.py_build
+-rw-r--r--   0        0        0     2380 2023-03-30 19:37:04.658681 pyaedt-0.6.70/pyaedt/misc/Run_PyAEDT_Toolkit_Script.py_build
+-rw-r--r--   0        0        0       53 2023-03-24 16:10:18.907751 pyaedt-0.6.70/pyaedt/misc/__init__.py
+-rw-r--r--   0        0        0     8973 2023-03-24 16:10:18.907751 pyaedt-0.6.70/pyaedt/misc/aedtlib_personalib_install.py
+-rw-r--r--   0        0        0    19870 2023-03-24 16:10:18.907751 pyaedt-0.6.70/pyaedt/misc/amat.xml
+-rw-r--r--   0        0        0     3731 2023-03-24 16:10:18.914516 pyaedt-0.6.70/pyaedt/misc/console_setup.py
+-rw-r--r--   0        0        0       48 2023-03-24 16:10:18.914516 pyaedt-0.6.70/pyaedt/misc/create_remote_dir.py
+-rw-r--r--   0        0        0    15250 2023-03-24 16:10:18.914516 pyaedt-0.6.70/pyaedt/misc/images/gallery/PyAEDT.png
+-rw-r--r--   0        0        0      855 2023-03-24 16:10:18.914516 pyaedt-0.6.70/pyaedt/misc/images/large/pyansys.png
+-rw-r--r--   0        0        0     3507 2023-03-30 19:37:04.658681 pyaedt-0.6.70/pyaedt/misc/install_extra_toolkits.py
+-rw-r--r--   0        0        0     1728 2023-03-24 16:10:18.914516 pyaedt-0.6.70/pyaedt/misc/jupyter_template.ipynb
+-rw-r--r--   0        0        0      678 2023-03-24 16:10:18.914516 pyaedt-0.6.70/pyaedt/misc/misc.py
+-rw-r--r--   0        0        0   771467 2023-03-24 16:10:18.914516 pyaedt-0.6.70/pyaedt/misc/ml_data_file_train_100MHz_1GHz.json
+-rw-r--r--   0        0        0   502580 2023-03-24 16:10:18.914516 pyaedt-0.6.70/pyaedt/misc/ml_data_file_train_1GHz_10GHz.json
+-rw-r--r--   0        0        0   162026 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/misc/patch_svr_model_100MHz_1GHz.joblib
+-rw-r--r--   0        0        0   134414 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/misc/patch_svr_model_1GHz_10GHz.joblib
+-rw-r--r--   0        0        0      289 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/misc/pyaedt.runtimeconfig.json
+-rw-r--r--   0        0        0      953 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/misc/pyaedt_local_config.acf
+-rw-r--r--   0        0        0    16550 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/misc/pyansys-logo-black-cropped.png
+-rw-r--r--   0        0        0      868 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/misc/template.acf
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/modeler/__init__.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/modeler/advanced_cad/__init__.py
+-rw-r--r--   0        0        0    14076 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/modeler/advanced_cad/actors.py
+-rw-r--r--   0        0        0    19994 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/modeler/advanced_cad/multiparts.py
+-rw-r--r--   0        0        0    18540 2023-03-24 16:10:18.930163 pyaedt-0.6.70/pyaedt/modeler/advanced_cad/oms.py
+-rw-r--r--   0        0        0    16809 2023-04-07 12:58:03.149048 pyaedt-0.6.70/pyaedt/modeler/advanced_cad/parts.py
+-rw-r--r--   0        0        0   120831 2023-04-05 05:51:09.186354 pyaedt-0.6.70/pyaedt/modeler/advanced_cad/stackup_3d.py
+-rw-r--r--   0        0        0   194519 2023-04-06 11:56:42.332868 pyaedt-0.6.70/pyaedt/modeler/cad/Modeler.py
+-rw-r--r--   0        0        0   114949 2023-04-06 10:00:10.649919 pyaedt-0.6.70/pyaedt/modeler/cad/Primitives.py
+-rw-r--r--   0        0        0    11332 2023-03-24 16:10:18.945688 pyaedt-0.6.70/pyaedt/modeler/cad/Primitives2D.py
+-rw-r--r--   0        0        0   119547 2023-04-06 10:00:10.649919 pyaedt-0.6.70/pyaedt/modeler/cad/Primitives3D.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.945688 pyaedt-0.6.70/pyaedt/modeler/cad/__init__.py
+-rw-r--r--   0        0        0    29079 2023-04-06 11:56:42.332868 pyaedt-0.6.70/pyaedt/modeler/cad/components_3d.py
+-rw-r--r--   0        0        0    49002 2023-04-06 10:00:10.649919 pyaedt-0.6.70/pyaedt/modeler/cad/elements3d.py
+-rw-r--r--   0        0        0    59259 2023-04-06 11:56:42.332868 pyaedt-0.6.70/pyaedt/modeler/cad/object3d.py
+-rw-r--r--   0        0        0    53056 2023-04-06 10:00:10.665549 pyaedt-0.6.70/pyaedt/modeler/cad/polylines.py
+-rw-r--r--   0        0        0    42008 2023-04-07 12:45:00.476659 pyaedt-0.6.70/pyaedt/modeler/circuits/PrimitivesCircuit.py
+-rw-r--r--   0        0        0    32231 2023-03-24 16:10:18.945688 pyaedt-0.6.70/pyaedt/modeler/circuits/PrimitivesEmit.py
+-rw-r--r--   0        0        0     8157 2023-03-24 16:10:18.945688 pyaedt-0.6.70/pyaedt/modeler/circuits/PrimitivesMaxwellCircuit.py
+-rw-r--r--   0        0        0    63322 2023-04-06 11:56:42.348489 pyaedt-0.6.70/pyaedt/modeler/circuits/PrimitivesNexxim.py
+-rw-r--r--   0        0        0    15094 2023-03-24 16:10:18.945688 pyaedt-0.6.70/pyaedt/modeler/circuits/PrimitivesTwinBuilder.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.945688 pyaedt-0.6.70/pyaedt/modeler/circuits/__init__.py
+-rw-r--r--   0        0        0    31901 2023-04-06 10:00:10.665549 pyaedt-0.6.70/pyaedt/modeler/circuits/object3dcircuit.py
+-rw-r--r--   0        0        0    67799 2023-03-24 16:10:18.945688 pyaedt-0.6.70/pyaedt/modeler/geometry_operators.py
+-rw-r--r--   0        0        0     6902 2023-03-24 16:10:18.945688 pyaedt-0.6.70/pyaedt/modeler/modeler2d.py
+-rw-r--r--   0        0        0    48446 2023-04-06 11:56:42.348489 pyaedt-0.6.70/pyaedt/modeler/modeler3d.py
+-rw-r--r--   0        0        0    30435 2023-03-24 16:10:18.961334 pyaedt-0.6.70/pyaedt/modeler/modelerpcb.py
+-rw-r--r--   0        0        0    49786 2023-03-28 09:04:51.922409 pyaedt-0.6.70/pyaedt/modeler/pcb/Primitives3DLayout.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.961334 pyaedt-0.6.70/pyaedt/modeler/pcb/__init__.py
+-rw-r--r--   0        0        0    58183 2023-04-06 10:00:10.665549 pyaedt-0.6.70/pyaedt/modeler/pcb/object3dlayout.py
+-rw-r--r--   0        0        0    21513 2023-03-24 16:10:18.961334 pyaedt-0.6.70/pyaedt/modeler/schematic.py
+-rw-r--r--   0        0        0    30108 2023-03-31 15:10:27.403749 pyaedt-0.6.70/pyaedt/modules/AdvancedPostProcessing.py
+-rw-r--r--   0        0        0   113864 2023-04-06 09:22:50.539831 pyaedt-0.6.70/pyaedt/modules/Boundary.py
+-rw-r--r--   0        0        0    71549 2023-03-24 16:10:18.961334 pyaedt-0.6.70/pyaedt/modules/CableModeling.py
+-rw-r--r--   0        0        0    16319 2023-03-24 16:10:18.961334 pyaedt-0.6.70/pyaedt/modules/CircuitTemplates.py
+-rw-r--r--   0        0        0    51910 2023-03-24 16:10:18.961334 pyaedt-0.6.70/pyaedt/modules/DesignXPloration.py
+-rw-r--r--   0        0        0    37371 2023-03-31 10:06:49.073815 pyaedt-0.6.70/pyaedt/modules/LayerStackup.py
+-rw-r--r--   0        0        0    82846 2023-03-24 16:10:18.961334 pyaedt-0.6.70/pyaedt/modules/Material.py
+-rw-r--r--   0        0        0    28306 2023-03-24 16:43:00.406402 pyaedt-0.6.70/pyaedt/modules/MaterialLib.py
+-rw-r--r--   0        0        0    53168 2023-04-07 14:18:16.263614 pyaedt-0.6.70/pyaedt/modules/Mesh.py
+-rw-r--r--   0        0        0    11919 2023-03-24 16:10:18.961334 pyaedt-0.6.70/pyaedt/modules/Mesh3DLayout.py
+-rw-r--r--   0        0        0    26048 2023-03-31 15:10:27.419349 pyaedt-0.6.70/pyaedt/modules/MeshIcepak.py
+-rw-r--r--   0        0        0     4437 2023-03-24 16:10:18.976973 pyaedt-0.6.70/pyaedt/modules/OptimetricsTemplates.py
+-rw-r--r--   0        0        0   172123 2023-04-06 11:56:42.348489 pyaedt-0.6.70/pyaedt/modules/PostProcessor.py
+-rw-r--r--   0        0        0    64104 2023-03-24 16:10:18.976973 pyaedt-0.6.70/pyaedt/modules/SetupTemplates.py
+-rw-r--r--   0        0        0   116130 2023-04-06 10:00:10.665549 pyaedt-0.6.70/pyaedt/modules/SolveSetup.py
+-rw-r--r--   0        0        0    33226 2023-04-07 14:18:16.263614 pyaedt-0.6.70/pyaedt/modules/SolveSweeps.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.976973 pyaedt-0.6.70/pyaedt/modules/__init__.py
+-rw-r--r--   0        0        0    28652 2023-03-24 16:10:18.976973 pyaedt-0.6.70/pyaedt/modules/monitor_icepak.py
+-rw-r--r--   0        0        0   103276 2023-03-24 16:10:18.976973 pyaedt-0.6.70/pyaedt/modules/report_templates.py
+-rw-r--r--   0        0        0   124676 2023-04-07 09:15:24.184408 pyaedt-0.6.70/pyaedt/modules/solutions.py
+-rw-r--r--   0        0        0    92404 2023-03-28 20:31:48.903203 pyaedt-0.6.70/pyaedt/q3d.py
+-rw-r--r--   0        0        0    10556 2023-03-24 16:10:18.976973 pyaedt-0.6.70/pyaedt/rmxprt.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.976973 pyaedt-0.6.70/pyaedt/rpc/__init__.py
+-rw-r--r--   0        0        0      415 2023-03-24 16:10:18.976973 pyaedt-0.6.70/pyaedt/rpc/local_server.py
+-rw-r--r--   0        0        0    40721 2023-03-24 16:10:18.976973 pyaedt-0.6.70/pyaedt/rpc/rpyc_services.py
+-rw-r--r--   0        0        0        0 2023-03-24 16:10:18.976973 pyaedt-0.6.70/pyaedt/sbrplus/__init__.py
+-rw-r--r--   0        0        0     9425 2023-04-03 16:00:03.137655 pyaedt-0.6.70/pyaedt/sbrplus/hdm_parser.py
+-rw-r--r--   0        0        0     2096 2023-03-24 16:10:18.992592 pyaedt-0.6.70/pyaedt/sbrplus/hdm_utils.py
+-rw-r--r--   0        0        0     2607 2023-03-24 16:10:18.992592 pyaedt-0.6.70/pyaedt/sbrplus/matlab/HdmObject.m
+-rw-r--r--   0        0        0       97 2023-03-24 16:10:18.992592 pyaedt-0.6.70/pyaedt/sbrplus/matlab/README.md
+-rw-r--r--   0        0        0      735 2023-03-28 22:11:07.622485 pyaedt-0.6.70/pyaedt/sbrplus/matlab/SbrBounceType.m
+-rw-r--r--   0        0        0     2886 2023-03-28 22:11:07.622485 pyaedt-0.6.70/pyaedt/sbrplus/matlab/StopWatch.m
+-rw-r--r--   0        0        0     1402 2023-03-28 22:11:07.622485 pyaedt-0.6.70/pyaedt/sbrplus/matlab/add_3dlight.m
+-rw-r--r--   0        0        0      340 2023-03-24 16:10:18.992592 pyaedt-0.6.70/pyaedt/sbrplus/matlab/amp2db.m
+-rw-r--r--   0        0        0    36837 2023-03-28 22:11:07.622485 pyaedt-0.6.70/pyaedt/sbrplus/matlab/draw_rays1.m
+-rw-r--r--   0        0        0     4322 2023-03-28 22:11:07.622485 pyaedt-0.6.70/pyaedt/sbrplus/matlab/draw_wfobj.m
+-rw-r--r--   0        0        0    31414 2023-03-28 22:11:07.622485 pyaedt-0.6.70/pyaedt/sbrplus/matlab/filter_rays1.m
+-rw-r--r--   0        0        0     1504 2023-03-28 22:11:07.622485 pyaedt-0.6.70/pyaedt/sbrplus/matlab/filtered_tracks.m
+-rw-r--r--   0        0        0    20853 2023-03-28 22:11:07.622485 pyaedt-0.6.70/pyaedt/sbrplus/matlab/ld_sbrplushdm.m
+-rw-r--r--   0        0        0    14781 2023-03-28 22:11:07.622485 pyaedt-0.6.70/pyaedt/sbrplus/matlab/ld_wfobj.m
+-rw-r--r--   0        0        0      318 2023-03-24 16:10:18.992592 pyaedt-0.6.70/pyaedt/sbrplus/matlab/pwr2db.m
+-rw-r--r--   0        0        0     2607 2023-03-28 22:11:07.622485 pyaedt-0.6.70/pyaedt/sbrplus/matlab/validate_sfields.m
+-rw-r--r--   0        0        0     7601 2023-03-24 16:10:18.992592 pyaedt-0.6.70/pyaedt/sbrplus/plot.py
+-rw-r--r--   0        0        0    10373 2023-03-24 16:10:18.992592 pyaedt-0.6.70/pyaedt/siwave.py
+-rw-r--r--   0        0        0    10527 2023-03-24 16:10:18.992592 pyaedt-0.6.70/pyaedt/twinbuilder.py
+-rw-r--r--   0        0        0     4090 2023-04-06 12:42:41.798409 pyaedt-0.6.70/pyproject.toml
+-rw-r--r--   0        0        0    14895 1970-01-01 00:00:00.000000 pyaedt-0.6.70/PKG-INFO
```

### Comparing `pyaedt-0.6.61/LICENSE` & `pyaedt-0.6.70/LICENSE`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/README.rst` & `pyaedt-0.6.70/README.rst`

 * *Files 0% similar despite different names*

```diff
@@ -179,18 +179,18 @@
 PyAEDT also provides advanced error management. Usage examples follow.
 
 Explicit AEDT declaration and error management
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 .. code:: python
 
-    # Launch AEDT 2022 R2 in non-graphical mode
+    # Launch AEDT 2023 R1 in non-graphical mode
 
     from pyaedt import Desktop, Circuit
-    with Desktop(specified_version="2022.2",
+    with Desktop(specified_version="2023.1",
                  non_graphical=False, new_desktop_session=True,
                  close_on_exit=True, student_version=False):
         circuit = Circuit()
         ...
         # Any error here will be caught by Desktop.
         ...
 
@@ -201,15 +201,15 @@
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 .. code:: python
 
     # Launch the latest installed version of AEDT in graphical mode
 
     from pyaedt import Circuit
-    with Circuit(specified_version="2022.2",
+    with Circuit(specified_version="2023.1",
                  non_graphical=False) as circuit:
         ...
         # Any error here will be caught by Desktop.
         ...
 
     # Desktop is automatically released here.
```

### Comparing `pyaedt-0.6.61/pyaedt/__init__.py` & `pyaedt-0.6.70/pyaedt/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -7,15 +7,15 @@
 os.environ["ANSYSEM_FEATURE_SF6694_NON_GRAPHICAL_COMMAND_EXECUTION_ENABLE"] = "1"
 os.environ["ANSYSEM_FEATURE_SF159726_SCRIPTOBJECT_ENABLE"] = "1"
 os.environ["ANSYSEM_FEATURE_SF222134_CABLE_MODELING_ENHANCEMENTS_ENABLE"] = "1"
 os.environ["ANSYSEM_FEATURE_F395486_RIGID_FLEX_BENDING_ENABLE"] = "1"
 
 pyaedt_path = os.path.dirname(__file__)
 
-__version__ = "0.6.61"
+__version__ = "0.6.70"
 
 version = __version__
 import pyaedt.downloads as downloads
 from pyaedt.generic import constants
 import pyaedt.generic.DataHandlers as data_handler
 import pyaedt.generic.general_methods as general_methods
 from pyaedt.generic.general_methods import _pythonver
```

### Comparing `pyaedt-0.6.61/pyaedt/aedt_logger.py` & `pyaedt-0.6.70/pyaedt/aedt_logger.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/application/AEDT_File_Management.py` & `pyaedt-0.6.70/pyaedt/application/AEDT_File_Management.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/application/Analysis.py` & `pyaedt-0.6.70/pyaedt/application/Analysis.py`

 * *Files 1% similar despite different names*

```diff
@@ -19,20 +19,16 @@
 from pyaedt import is_windows
 from pyaedt import settings
 from pyaedt.application.Design import Design
 from pyaedt.application.JobManager import update_hpc_option
 from pyaedt.application.Variables import Variable
 from pyaedt.application.Variables import decompose_variable_value
 from pyaedt.generic.constants import AXIS
-from pyaedt.generic.constants import CoordinateSystemAxis
-from pyaedt.generic.constants import CoordinateSystemPlane
 from pyaedt.generic.constants import GRAVITY
-from pyaedt.generic.constants import GravityDirection
 from pyaedt.generic.constants import PLANE
-from pyaedt.generic.constants import Plane
 from pyaedt.generic.constants import SETUPS
 from pyaedt.generic.constants import SOLUTIONS
 from pyaedt.generic.constants import VIEW
 from pyaedt.generic.general_methods import filter_tuple
 from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import pyaedt_function_handler
@@ -211,74 +207,14 @@
         :class:`pyaedt.application.Analysis.Analysis.AvailableVariations`
             Available variation object.
 
         """
         return self._available_variations
 
     @property
-    def CoordinateSystemAxis(self):
-        """Coordinate system axis constant.
-
-        .. deprecated:: 0.4.8
-           Use :attr:`AXIS` instead.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.constants.AXIS`
-            Coordinate system axis constants tuple (.X, .Y, .Z).
-
-        """
-        return CoordinateSystemAxis()
-
-    @property
-    def CoordinateSystemPlane(self):
-        """Coordinate system plane constants.
-
-        .. deprecated:: 0.4.8
-           Use :attr:`PLANE` instead.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.constants.PLANE`
-            Coordinate system plane constants tuple (.XY, .YZ, .XZ).
-
-        """
-        return CoordinateSystemPlane()
-
-    @property
-    def View(self):
-        """Planes.
-
-        .. deprecated:: 0.4.8
-           Use :attr:`VIEW` instead.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.constants.PLANE`
-            Coordinate system plane string tuple ("XY", "YZ", "XZ").
-
-        """
-        return Plane()
-
-    @property
-    def GravityDirection(self):
-        """Gravity direction.
-
-        .. deprecated:: 0.4.8
-           Use :attr:`GRAVITY` instead.
-
-        Returns
-        -------
-        tuple
-            Gravity direction tuple (XNeg, YNeg, ZNeg, XPos, YPos, ZPos).
-
-        """
-        return GravityDirection()
-
-    @property
     def active_setup(self):
         """Get or Set the name of the active setup. If not set it will be the first analysis setup.
 
         Returns
         -------
         str
             Name of the active or first analysis setup.
@@ -488,35 +424,14 @@
             list_names = list(self.oboundary.GetExcitations())
             del list_names[1::2]
             return list_names
         except:
             return []
 
     @pyaedt_function_handler()
-    def get_excitations_name(self):
-        """Get all excitation names.
-
-        .. deprecated:: 0.4.27
-           Use :func:`excitations` property instead.
-
-        Returns
-        -------
-        list
-            List of excitation names. Excitations with multiple modes will return one
-            excitation for each mode.
-
-        References
-        ----------
-
-        >>> oModule.GetExcitations
-        """
-        warnings.warn("`get_excitations_name` is deprecated. Use `excitations` property instead.", DeprecationWarning)
-        return self.excitations
-
-    @pyaedt_function_handler()
     def get_traces_for_plot(
         self,
         get_self_terms=True,
         get_mutual_terms=True,
         first_element_filter=None,
         second_element_filter=None,
         category="dB(S",
@@ -1556,24 +1471,14 @@
         warnings.warn("`analyze_from_initial_mesh` is deprecated. Use `analyze` method instead.", DeprecationWarning)
 
         self.oanalysis.RevertSetupToInitial(self._setup)
         self.analyze(self.active_setup)
         return True
 
     @pyaedt_function_handler()
-    def analyse_nominal(self):
-        """Solve the nominal design.
-
-        .. deprecated:: 0.4.0
-           Use :func:`Analysis.analyze` instead.
-        """
-        warnings.warn("`analyse_nominal` is deprecated. Use `analyze` instead.", DeprecationWarning)
-        self.analyze(self.active_setup)
-
-    @pyaedt_function_handler()
     def analyze_nominal(self, num_cores=1, num_tasks=1, num_gpu=0, acf_file=None, use_auto_settings=True):
         """Solve the nominal design.
 
         .. deprecated:: 0.6.52
            Use :func:`analyze` method instead.
 
         Parameters
```

### Comparing `pyaedt-0.6.61/pyaedt/application/Analysis3D.py` & `pyaedt-0.6.70/pyaedt/application/Analysis3D.py`

 * *Files 2% similar despite different names*

```diff
@@ -471,25 +471,14 @@
         if udc_selection:
             self.save_project()
             self._project_dictionary = None
         self.modeler.refresh_all_ids()
         return True
 
     @pyaedt_function_handler()
-    def export3DModel(self, fileName, filePath, fileFormat=".step", object_list=[], removed_objects=[]):
-        """Export the 3D model.
-
-        .. deprecated:: 0.5.0
-           Use :func:`pyaedt.application.Analysis3D.modeler.export_3d_model` instead.
-
-        """
-        warnings.warn("`export3DModel` is deprecated. Use `export_3d_model` instead.", DeprecationWarning)
-        return self.export_3d_model(fileName, filePath, fileFormat, object_list, removed_objects)
-
-    @pyaedt_function_handler()
     def export_3d_model(
         self, file_name="", file_path="", file_format=".step", object_list=None, removed_objects=None, **kwargs
     ):
         """Export the 3D model.
 
         Parameters
         ----------
```

### Comparing `pyaedt-0.6.61/pyaedt/application/Analysis3DLayout.py` & `pyaedt-0.6.70/pyaedt/application/Analysis3DLayout.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,8 @@
 import os
-import warnings
 
 from pyaedt.application.Analysis import Analysis
 from pyaedt.generic.general_methods import is_ironpython
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.modules.SetupTemplates import SetupKeys
 from pyaedt.modules.SolveSetup import Setup3DLayout
 
@@ -138,34 +137,14 @@
         ----------
 
         >>> oModule.GetExcitations
         """
         return list(self.oboundary.GetAllPortsList())
 
     @property
-    def get_excitations_name(self):
-        """Excitation names.
-
-        .. deprecated:: 0.4.27
-           Use :func:`excitations` property instead.
-
-        Returns
-        -------
-        list
-            list of all excitation
-
-        References
-        ----------
-
-        >>> oModule.GetAllPortsList
-        """
-        warnings.warn("`get_excitations_name` is deprecated. Use `excitations` property instead.", DeprecationWarning)
-        return self.excitations
-
-    @property
     def get_all_sparameter_list(self, excitation_names=[]):
         """List of all S parameters for a list of excitations.
 
         Parameters
         ----------
         excitation_names : list, optional
             List of excitations. The default is ``[]``, in which case
```

### Comparing `pyaedt-0.6.61/pyaedt/application/AnalysisMaxwellCircuit.py` & `pyaedt-0.6.70/pyaedt/application/AnalysisMaxwellCircuit.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/application/AnalysisNexxim.py` & `pyaedt-0.6.70/pyaedt/application/AnalysisNexxim.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,9 +1,7 @@
-import warnings
-
 from pyaedt.application.Analysis import Analysis
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.modeler.circuits.object3dcircuit import CircuitComponent
 from pyaedt.modules.Boundary import CurrentSinSource
 from pyaedt.modules.Boundary import Excitations
 from pyaedt.modules.Boundary import PowerIQSource
 from pyaedt.modules.Boundary import PowerSinSource
@@ -313,34 +311,14 @@
                     else:
                         for new_port in self.excitation_names:
                             if new_port not in props.keys():
                                 props[new_port] = Excitations(self, new_port)
         return props
 
     @property
-    def get_excitations_name(self):
-        """Excitation names.
-
-        .. deprecated:: 0.4.27
-           Use :func:`excitations` property instead.
-
-        Returns
-        -------
-        type
-            BoundarySetup Module object
-
-        References
-        ----------
-
-        >>> oEditor.GetAllPorts
-        """
-        warnings.warn("`get_excitations_name` is deprecated. Use `excitations` property instead.", DeprecationWarning)
-        return self.excitations
-
-    @property
     def get_all_sparameter_list(self, excitation_names=[]):
         """List of all S parameters for a list of excitations.
 
         Parameters
         ----------
         excitation_names : list, optional
             List of excitations. The default value is ``[]``, in which case
```

### Comparing `pyaedt-0.6.61/pyaedt/application/AnalysisRMxprt.py` & `pyaedt-0.6.70/pyaedt/application/AnalysisRMxprt.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/application/AnalysisTwinBuilder.py` & `pyaedt-0.6.70/pyaedt/application/AnalysisTwinBuilder.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/application/Design.py` & `pyaedt-0.6.70/pyaedt/application/Design.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/application/JobManager.py` & `pyaedt-0.6.70/pyaedt/application/JobManager.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/application/Variables.py` & `pyaedt-0.6.70/pyaedt/application/Variables.py`

 * *Files 0% similar despite different names*

```diff
@@ -411,18 +411,17 @@
     def decompose(self, variable_value):
         """Decompose a variable string to a floating with its unit.
 
         Parameters
         ----------
         variable_value : str
 
-
         Returns
         -------
-        tuples
+        tuple
             The float value of the variable and the units exposed as a string.
 
         Examples
         --------
         >>> hfss = Hfss()
         >>> print(hfss.variable_manager.decompose("5mm"))
         >>> (5.0, 'mm')
@@ -1535,20 +1534,19 @@
         modeler and see ``10.0mm`` returned as the string value.
 
         """
         return ("{}{}").format(self.numeric_value, self._units)
 
     @pyaedt_function_handler()
     def decompose(self):
-        """Decompose variable value to a floating with its unit.
-
+        """Decompose a variable value to a floating with its unit.
 
         Returns
         -------
-        tuples
+        tuple
             The float value of the variable and the units exposed as a string.
 
         Examples
         --------
         >>> hfss = Hfss()
         >>> hfss["v1"] = "3N"
         >>> print(hfss.variable_manager["v1"].decompose("v1"))
@@ -1671,34 +1669,34 @@
 
     __rmul__ = __mul__
 
     @pyaedt_function_handler()
     def __add__(self, other):
         """Add the variable to another variable to return a new object.
 
-                Parameters
-                ---------
-                other : Variable
-                    Object to be multiplied.
-
-                Returns
-                -------
-                type
-                    Variable.
+        Parameters
+        ---------
+        other : class:`pyaedt.application.Variables.Variable`
+            Object to be multiplied.
 
-                Examples
-                --------
-                >>> from pyaedt.application.Variables import Variable
+        Returns
+        -------
+        type
+            Variable.
 
-        import pyaedt.generic.constants        >>> v1 = Variable("3mA")
-                >>> v2 = Variable("10A")
-                >>> result = v1 + v2
-                >>> assert result.numeric_value == 10.003
-                >>> assert result.units == "A"
-                >>> assert result.unit_system == "Current"
+        Examples
+        --------
+        >>> from pyaedt.application.Variables import Variable
+        >>> import pyaedt.generic.constants
+        >>> v1 = Variable("3mA")
+        >>> v2 = Variable("10A")
+        >>> result = v1 + v2
+        >>> assert result.numeric_value == 10.003
+        >>> assert result.units == "A"
+        >>> assert result.unit_system == "Current"
 
         """
         assert isinstance(other, Variable), "You can only add a variable with another variable."
         assert (
             self.unit_system == other.unit_system
         ), "Only ``Variable`` objects with the same unit system can be added."
         result_value = self.value + other.value
@@ -1712,34 +1710,35 @@
 
         return result_variable
 
     @pyaedt_function_handler()
     def __sub__(self, other):
         """Subtract another variable from the variable to return a new object.
 
-                Parameters
-                ---------
-                other : Variable
-                    Object to be subtracted.
+        Parameters
+        ---------
+        other : class:`pyaedt.application.Variables.Variable`
+            Object to be subtracted.
 
-                Returns
-                -------
-                type
-                    Variable.
+        Returns
+        -------
+        type
+            Variable.
 
-                Examples
-                --------
+        Examples
+        --------
 
-        import pyaedt.generic.constants        >>> from pyaedt.application.Variables import Variable
-                >>> v3 = Variable("3mA")
-                >>> v4 = Variable("10A")
-                >>> result_2 = v3 - v4
-                >>> assert result_2.numeric_value == -9.997
-                >>> assert result_2.units == "A"
-                >>> assert result_2.unit_system == "Current"
+        >>> import pyaedt.generic.constants
+        >>> from pyaedt.application.Variables import Variable
+        >>> v3 = Variable("3mA")
+        >>> v4 = Variable("10A")
+        >>> result_2 = v3 - v4
+        >>> assert result_2.numeric_value == -9.997
+        >>> assert result_2.units == "A"
+        >>> assert result_2.unit_system == "Current"
 
         """
         assert isinstance(other, Variable), "You can only subtract a variable from another variable."
         assert (
             self.unit_system == other.unit_system
         ), "Only ``Variable`` objects with the same unit system can be subtracted."
         result_value = self.value - other.value
@@ -1754,37 +1753,37 @@
         return result_variable
 
     # Python 3.x version
     @pyaedt_function_handler()
     def __truediv__(self, other):
         """Divide the variable by a number or another variable to return a new object.
 
-                Parameters
-                ---------
-                other : numbers.Number or variable
-                    Object by which to divide.
-
-                Returns
-                -------
-                type
-                    Variable.
+        Parameters
+        ---------
+        other : numbers.Number or variable
+            Object by which to divide.
 
-                Examples
-                --------
-                Divide a variable with units ``"W"`` by a variable with units ``"V"`` and automatically
-                resolve the new units to ``"A"``.
+        Returns
+        -------
+        type
+            Variable.
 
-                >>> from pyaedt.application.Variables import Variable
+        Examples
+        --------
+        Divide a variable with units ``"W"`` by a variable with units ``"V"`` and automatically
+        resolve the new units to ``"A"``.
 
-        import pyaedt.generic.constants        >>> v1 = Variable("10W")
-                >>> v2 = Variable("40V")
-                >>> result = v1 / v2
-                >>> assert result_1.numeric_value == 0.25
-                >>> assert result_1.units == "A"
-                >>> assert result_1.unit_system == "Current"
+        >>> from pyaedt.application.Variables import Variable
+        >>> import pyaedt.generic.constants
+        >>> v1 = Variable("10W")
+        >>> v2 = Variable("40V")
+        >>> result = v1 / v2
+        >>> assert result_1.numeric_value == 0.25
+        >>> assert result_1.units == "A"
+        >>> assert result_1.unit_system == "Current"
 
         """
         assert is_number(other) or isinstance(other, Variable), "Divisor must be a scalar quantity or a variable."
         if is_number(other):
             result_value = self.numeric_value / other
             result_units = self.units
         else:
@@ -1798,35 +1797,36 @@
     def __div__(self, other):
         return self.__truediv__(other)
 
     @pyaedt_function_handler()
     def __rtruediv__(self, other):
         """Divide another object by this object.
 
-                Parameters
-                ---------
-                other : numbers.Number or variable
-                    Object to divide by.
+        Parameters
+        ---------
+        other : numbers.Number or variable
+            Object to divide by.
 
-                Returns
-                -------
-                type
-                    Variable.
+        Returns
+        -------
+        type
+            Variable.
 
-                Examples
-                --------
-                Divide a number by a variable with units ``"s"`` and automatically determine that
-                the result is in ``"Hz"``.
+        Examples
+        --------
+        Divide a number by a variable with units ``"s"`` and automatically determine that
+        the result is in ``"Hz"``.
 
-        import pyaedt.generic.constants        >>> from pyaedt.application.Variables import Variable
-                >>> v = Variable("1s")
-                >>> result = 3.0 / v
-                >>> assert result.numeric_value == 3.0
-                >>> assert result.units == "Hz"
-                >>> assert result.unit_system == "Freq"
+        >>> import pyaedt.generic.constants
+        >>> from pyaedt.application.Variables import Variable
+        >>> v = Variable("1s")
+        >>> result = 3.0 / v
+        >>> assert result.numeric_value == 3.0
+        >>> assert result.units == "Hz"
+        >>> assert result.unit_system == "Freq"
 
         """
         if is_number(other):
             result_value = other / self.numeric_value
             result_units = _resolve_unit_system("None", self.unit_system, "divide")
 
         else:
@@ -1843,15 +1843,16 @@
 
 class DataSet(object):
     """Manages datasets.
 
     Parameters
     ----------
     app :
-    name :
+    name : str
+        Name of the app.
     x : list
         List of X-axis values for the dataset.
     y : list
         List of Y-axis values for the dataset.
     z : list, optional
         List of Z-axis values for a 3D dataset only. The default is ``None``.
     v : list, optional
@@ -1943,15 +1944,17 @@
     @pyaedt_function_handler()
     def add_point(self, x, y, z=None, v=None):
         """Add a point to the dataset.
 
         Parameters
         ----------
         x : float
+            X coordinate of the point.
         y : float
+            Y coordinate of the point.
         z : float, optional
             The default is ``None``.
         v : float, optional
             The default is ``None``.
 
         Returns
         -------
```

### Comparing `pyaedt-0.6.61/pyaedt/application/aedt_objects.py` & `pyaedt-0.6.70/pyaedt/application/aedt_objects.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/application/design_solutions.py` & `pyaedt-0.6.70/pyaedt/application/design_solutions.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/circuit.py` & `pyaedt-0.6.70/pyaedt/circuit.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/common_rpc.py` & `pyaedt-0.6.70/pyaedt/common_rpc.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/desktop.py` & `pyaedt-0.6.70/pyaedt/desktop.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,14 +14,15 @@
 import logging
 import os
 import pkgutil
 import re
 import socket
 import sys
 import tempfile
+import threading
 import time
 import traceback
 import warnings
 
 from pyaedt import is_ironpython
 from pyaedt import is_linux
 from pyaedt import is_windows
@@ -57,14 +58,46 @@
 elif is_windows and "pythonnet" in modules:  # pragma: no cover
     _com = "pythonnet_v3"
 else:
     _com = "gprc_v3"
     settings.use_grpc_api = True
 
 
+@pyaedt_function_handler()
+def launch_aedt(full_path, non_graphical, port, first_run=True):
+    """Launch AEDT in gRPC mode."""
+
+    def launch_desktop_on_port():
+        command = [full_path, "-grpcsrv", str(port)]
+        if non_graphical:
+            command.append("-ng")
+        my_env = os.environ.copy()
+        for env, val in settings.aedt_environment_variables.items():
+            my_env[env] = val
+        if is_linux:  # pragma: no cover
+            subprocess.Popen(command, env=my_env, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
+        else:
+            subprocess.Popen(" ".join(command), env=my_env, stdout=subprocess.DEVNULL, stderr=subprocess.PIPE)
+
+    _aedt_process_thread = threading.Thread(target=launch_desktop_on_port)
+    _aedt_process_thread.daemon = True
+    _aedt_process_thread.start()
+    timeout = settings.desktop_launch_timeout
+    k = 0
+    while not _check_grpc_port(port):
+        if k > timeout:  # pragma: no cover
+            if first_run:
+                port = _find_free_port()
+                return launch_aedt(full_path, non_graphical, port, first_run=False)
+            return False, port
+        time.sleep(1)
+        k += 1
+    return True, port
+
+
 def launch_aedt_in_lsf(non_graphical, port):  # pragma: no cover
     """Launch AEDT in LSF in GRPC mode."""
     if settings.lsf_queue:
         command = [
             "bsub",
             "-n",
             str(settings.lsf_num_cores),
@@ -859,14 +892,15 @@
                             settings.use_grpc_api = False
                             self.logger.info("No AEDT gRPC found. Found active COM Sessions.")
                             return self._init_cpython(
                                 non_graphical, new_aedt_session, version, student_version, version_key
                             )
                     self.port = _find_free_port()
                     self.logger.info("New AEDT session is starting on gRPC port %s", self.port)
+                    new_aedt_session = True
         elif new_aedt_session and not _check_grpc_port(self.port, self.machine):
             self.logger.info("New AEDT session is starting on gRPC port %s", self.port)
         elif new_aedt_session:
             self.logger.warning("New Session of AEDT cannot be started on specified port because occupied.")
             self.port = _find_free_port()
             self.logger.info("New AEDT session is starting on gRPC port %s", self.port)
         elif _check_grpc_port(self.port, self.machine):
@@ -878,14 +912,24 @@
         if new_aedt_session and settings.use_lsf_scheduler and is_linux:  # pragma: no cover
             out, self.machine = launch_aedt_in_lsf(non_graphical, self.port)
             if out:
                 ScriptEnv._doInitialize(version, None, False, non_graphical, self.machine, self.port)
             else:
                 self.logger.error("Failed to start LSF job on machine: %s.", self.machine)
                 return
+        elif new_aedt_session:
+            installer = os.path.join(base_path, "ansysedt")
+            if not is_linux:
+                installer = os.path.join(base_path, "ansysedt.exe")
+            out, self.port = launch_aedt(installer, non_graphical, self.port)
+            if out:
+                ScriptEnv._doInitialize(version, None, False, non_graphical, self.machine, self.port)
+            else:
+                self.logger.error("Failed to start AEDT on port %s.", self.port)
+                return
         else:
             ScriptEnv._doInitialize(version, None, new_aedt_session, non_graphical, self.machine, self.port)
 
         if "oAnsoftApplication" in dir(self._main):
             self._main.isoutsideDesktop = True
             self._main.oDesktop = self._main.oAnsoftApplication.GetAppDesktop()
             _proc = self._main.oDesktop.GetProcessID()
@@ -1263,29 +1307,14 @@
         >>> desktop.release_desktop(close_projects=False, close_on_exit=False) # doctest: +SKIP
 
         """
         result = release_desktop(close_projects, close_on_exit)
         self.odesktop = None
         return result
 
-    def force_close_desktop(self):
-        """Forcibly close all projects and shut down AEDT.
-
-        .. deprecated:: 0.4.0
-           Use :func:`desktop.close_desktop` instead.
-
-        """
-
-        warnings.warn(
-            "`force_close_desktop` is deprecated. Use `close_desktop` instead.",
-            DeprecationWarning,
-        )
-
-        force_close_desktop()
-
     def close_desktop(self):
         """Close all projects and shut down AEDT.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
```

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/AnsysReport.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/AnsysReport.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/AnsysTemplate.json` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/AnsysTemplate.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/Images/Ansys.png` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/Images/Ansys.png`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.DocumentObjectModel-gdi.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.DocumentObjectModel-gdi.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.DocumentObjectModel-gdi.xml` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.DocumentObjectModel-gdi.xml`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.Rendering-gdi.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.Rendering-gdi.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.Rendering-gdi.xml` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.Rendering-gdi.xml`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.RtfRendering-gdi.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.RtfRendering-gdi.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/MigraDoc.RtfRendering-gdi.xml` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/MigraDoc.RtfRendering-gdi.xml`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/Newtonsoft.Json.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/Newtonsoft.Json.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/Newtonsoft.Json.xml` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/Newtonsoft.Json.xml`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/PdfSharp-gdi.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/PdfSharp-gdi.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/PdfSharp-gdi.xml` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/PdfSharp-gdi.xml`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/PdfSharp.Charting-gdi.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/PdfSharp.Charting-gdi.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/PdfSharp.Charting-gdi.xml` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/PdfSharp.Charting-gdi.xml`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/de/MigraDoc.DocumentObjectModel-gdi.resources.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/de/MigraDoc.DocumentObjectModel-gdi.resources.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/de/MigraDoc.Rendering-gdi.resources.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/de/MigraDoc.Rendering-gdi.resources.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/de/MigraDoc.RtfRendering-gdi.resources.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/de/MigraDoc.RtfRendering-gdi.resources.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/de/PdfSharp-gdi.resources.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/de/PdfSharp-gdi.resources.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/dlls/PDFReport/de/PdfSharp.Charting-gdi.resources.dll` & `pyaedt-0.6.70/pyaedt/dlls/PDFReport/de/PdfSharp.Charting-gdi.resources.dll`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/downloads.py` & `pyaedt-0.6.70/pyaedt/downloads.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb.py` & `pyaedt-0.6.70/pyaedt/modules/solutions.py`

 * *Files 14% similar despite different names*

```diff
@@ -1,2868 +1,3411 @@
-"""This module contains the ``Edb`` class.
-
-This module is implicitily loaded in HFSS 3D Layout when launched.
-
-"""
-import gc
+from collections import OrderedDict
+import itertools
+import math
 import os
-import re
-import shutil
 import sys
 import time
-import traceback
-import warnings
 
-from pyaedt import __version__
-from pyaedt import pyaedt_logger
+from pyaedt import get_pyaedt_app
+from pyaedt import is_ironpython
+from pyaedt import pyaedt_function_handler
 from pyaedt import settings
-from pyaedt.edb_core import Components
-from pyaedt.edb_core import EdbHfss
-from pyaedt.edb_core import EdbLayout
-from pyaedt.edb_core import EdbNets
-from pyaedt.edb_core import EdbSiwave
-from pyaedt.edb_core import EdbStackup
-from pyaedt.edb_core.edb_data.design_options import EdbDesignOptions
-from pyaedt.edb_core.edb_data.edb_builder import EdbBuilder
-from pyaedt.edb_core.edb_data.edbvalue import EdbValue
-from pyaedt.edb_core.edb_data.hfss_simulation_setup_data import HfssSimulationSetup
-from pyaedt.edb_core.edb_data.padstacks_data import EDBPadstackInstance
-from pyaedt.edb_core.edb_data.simulation_configuration import SimulationConfiguration
-from pyaedt.edb_core.edb_data.siwave_simulation_setup_data import SiwaveDCSimulationSetup
-from pyaedt.edb_core.edb_data.siwave_simulation_setup_data import SiwaveSYZSimulationSetup
-from pyaedt.edb_core.edb_data.sources import ExcitationDifferential
-from pyaedt.edb_core.edb_data.sources import ExcitationPorts
-from pyaedt.edb_core.edb_data.sources import ExcitationProbes
-from pyaedt.edb_core.edb_data.sources import ExcitationSources
-from pyaedt.edb_core.edb_data.sources import SourceType
-from pyaedt.edb_core.edb_data.variables import Variable
-from pyaedt.edb_core.general import convert_py_list_to_net_list
-from pyaedt.edb_core.ipc2581.ipc2581 import Ipc2581
-from pyaedt.edb_core.materials import Materials
-from pyaedt.edb_core.padstack import EdbPadstacks
-from pyaedt.edb_core.stackup import Stackup
-from pyaedt.generic.clr_module import Convert
-from pyaedt.generic.clr_module import List
-from pyaedt.generic.clr_module import _clr
-from pyaedt.generic.clr_module import edb_initialized
-from pyaedt.generic.constants import SolverType
-from pyaedt.generic.general_methods import env_path
-from pyaedt.generic.general_methods import env_path_student
-from pyaedt.generic.general_methods import env_value
-from pyaedt.generic.general_methods import generate_unique_name
-from pyaedt.generic.general_methods import inside_desktop
-from pyaedt.generic.general_methods import is_ironpython
-from pyaedt.generic.general_methods import is_linux
-from pyaedt.generic.general_methods import is_windows
-from pyaedt.generic.general_methods import pyaedt_function_handler
-from pyaedt.generic.process import SiwaveSolve
-from pyaedt.misc.misc import list_installed_ansysem
-
-if is_linux and is_ironpython:
-    import subprocessdotnet as subprocess
-else:
-    import subprocess
-
-
-class Edb(object):
-    """Provides the EDB application interface.
-
-    This module inherits all objects that belong to EDB.
-
-    Parameters
-    ----------
-    edbpath : str, optional
-        Full path to the ``aedb`` folder. The variable can also contain
-        the path to a layout to import. Allowed formats are BRD,
-        XML (IPC2581), GDS, and DXF. The default is ``None``.
-        For GDS import, the Ansys control file (also XML) should have the same
-        name as the GDS file. Only the file extension differs.
-    cellname : str, optional
-        Name of the cell to select. The default is ``None``.
-    isreadonly : bool, optional
-        Whether to open EBD in read-only mode when it is
-        owned by HFSS 3D Layout. The default is ``False``.
-    edbversion : str, optional
-        Version of EDB to use. The default is ``"2021.2"``.
-    isaedtowned : bool, optional
-        Whether to launch EDB from HFSS 3D Layout. The
-        default is ``False``.
-    oproject : optional
-        Reference to the AEDT project object.
-    student_version : bool, optional
-        Whether to open the AEDT student version. The default is ``False.``
-
-    Examples
-    --------
-    Create an ``Edb`` object and a new EDB cell.
-
-    >>> from pyaedt import Edb
-    >>> app = Edb()
-
-    Add a new variable named "s1" to the ``Edb`` instance.
-    >>> app['s1'] = "0.25 mm"
-    >>> app['s1'].tofloat
-    >>> 0.00025
-    >>> app['s1'].tostring
-    >>> "0.25mm"
-
-    Create an ``Edb`` object and open the specified project.
-
-    >>> app = Edb("myfile.aedb")
-
-    Create an ``Edb`` object from GDS and control files.
-    The XML control file resides in the same directory as the GDS file: (myfile.xml).
-
-    >>> app = Edb("/path/to/file/myfile.gds")
-
-    """
-
-    def __init__(
-        self,
-        edbpath=None,
-        cellname=None,
-        isreadonly=False,
-        edbversion=None,
-        isaedtowned=False,
-        oproject=None,
-        student_version=False,
-        use_ppe=False,
-    ):
-        self._clean_variables()
-        if inside_desktop:
-            self.standalone = False
-        else:
-            self.standalone = True
-        if edb_initialized:
-            self.oproject = oproject
-            self._main = sys.modules["__main__"]
-            self._global_logger = pyaedt_logger
-            self._logger = pyaedt_logger
-            self.student_version = student_version
-            self.logger.info("Logger is initialized in EDB.")
-            self.logger.info("pyaedt v%s", __version__)
-            self.logger.info("Python version %s", sys.version)
-            if not edbversion:
-                try:
-                    edbversion = "20{}.{}".format(list_installed_ansysem()[0][-3:-1], list_installed_ansysem()[0][-1:])
-                    self._logger.info("Edb version " + edbversion)
-                except IndexError:
-                    raise Exception("No ANSYSEM_ROOTxxx is found.")
-            self.edbversion = edbversion
-            self.isaedtowned = isaedtowned
-            self._init_dlls()
-            self._db = None
-            # self._edb.Database.SetRunAsStandAlone(not isaedtowned)
-            self.isreadonly = isreadonly
-            self.cellname = cellname
-            if not edbpath:
-                if is_windows:
-                    edbpath = os.getenv("USERPROFILE")
-                    if not edbpath:
-                        edbpath = os.path.expanduser("~")
-                    edbpath = os.path.join(edbpath, "Documents", generate_unique_name("layout") + ".aedb")
-                else:
-                    edbpath = os.getenv("HOME")
-                    if not edbpath:
-                        edbpath = os.path.expanduser("~")
-                    edbpath = os.path.join(edbpath, generate_unique_name("layout") + ".aedb")
-                self.logger.info("No EDB is provided. Creating a new EDB {}.".format(edbpath))
-            self.edbpath = edbpath
-            self.log_name = None
-            if edbpath:
-                self.log_name = os.path.join(
-                    os.path.dirname(edbpath), "pyaedt_" + os.path.splitext(os.path.split(edbpath)[-1])[0] + ".log"
-                )
+from pyaedt.generic.constants import AEDT_UNITS
+from pyaedt.generic.constants import db10
+from pyaedt.generic.constants import db20
+from pyaedt.generic.constants import unit_converter
+from pyaedt.generic.general_methods import check_and_download_folder
+from pyaedt.generic.general_methods import open_file
+from pyaedt.generic.general_methods import write_csv
+from pyaedt.generic.plot import get_structured_mesh
+from pyaedt.generic.plot import is_notebook
+from pyaedt.generic.plot import plot_2d_chart
+from pyaedt.generic.plot import plot_3d_chart
+from pyaedt.generic.plot import plot_contour
+from pyaedt.generic.plot import plot_polar_chart
+from pyaedt.modeler.cad.elements3d import FacePrimitive
+
+np = None
+pd = None
+pv = None
+if not is_ironpython:
+    try:
+        import numpy as np
+    except ImportError:
+        np = None
+    try:
+        import pandas as pd
+    except ImportError:
+        pd = None
+    try:
+        import pyvista as pv
+    except ImportError:
+        pv = None
+
+
+class SolutionData(object):
+    """Contains information from the :func:`GetSolutionDataPerVariation` method."""
+
+    def __init__(self, aedtdata):
+        self._original_data = aedtdata
+        self.number_of_variations = len(aedtdata)
+        self._enable_pandas_output = True if settings.enable_pandas_output and pd else False
+        self._expressions = None
+        self._intrinsics = None
+        self._nominal_variation = None
+        self._nominal_variation = self._original_data[0]
+        self.active_expression = self.expressions[0]
+        self._sweeps_names = []
+        self.update_sweeps()
+        self.variations = self._get_variations()
+        self.active_intrinsic = OrderedDict({})
+        for k, v in self.intrinsics.items():
+            self.active_intrinsic[k] = v[0]
+        if len(self.intrinsics) > 0:
+            self._primary_sweep = list(self.intrinsics.keys())[0]
+        else:
+            self._primary_sweep = self._sweeps_names[0]
+        self.active_variation = self.variations[0]
+        self.units_sweeps = {}
+        for intrinsic in self.intrinsics:
+            try:
+                self.units_sweeps[intrinsic] = self.nominal_variation.GetSweepUnits(intrinsic)
+            except:
+                self.units_sweeps[intrinsic] = None
+        self.init_solutions_data()
+        self._ifft = None
 
-            if isaedtowned and (inside_desktop or settings.remote_api):
-                self.open_edb_inside_aedt()
-            elif edbpath[-3:] in ["brd", "gds", "xml", "dxf", "tgz"]:
-                self.edbpath = edbpath[:-4] + ".aedb"
-                working_dir = os.path.dirname(edbpath)
-                self.import_layout_pcb(edbpath, working_dir, use_ppe=use_ppe)
-                if settings.enable_local_log_file and self.log_name:
-                    self._logger = self._global_logger.add_file_logger(self.log_name, "Edb")
-                self.logger.info("EDB %s was created correctly from %s file.", self.edbpath, edbpath[-2:])
-            elif edbpath.endswith("edb.def"):
-                self.edbpath = os.path.dirname(edbpath)
-                if settings.enable_local_log_file and self.log_name:
-                    self._logger = self._global_logger.add_file_logger(self.log_name, "Edb")
-                self.open_edb()
-            elif not os.path.exists(os.path.join(self.edbpath, "edb.def")):
-                self.create_edb()
-                if settings.enable_local_log_file and self.log_name:
-                    self._logger = self._global_logger.add_file_logger(self.log_name, "Edb")
-                self.logger.info("EDB %s was created correctly.", self.edbpath)
-            elif ".aedb" in edbpath:
-                self.edbpath = edbpath
-                if settings.enable_local_log_file and self.log_name:
-                    self._logger = self._global_logger.add_file_logger(self.log_name, "Edb")
-                self.open_edb()
-            if self.builder:
-                self.logger.info("EDB was initialized.")
-            else:
-                self.logger.info("Failed to initialize DLLs.")
-        else:
-            warnings.warn("Failed to initialize DLLs.")
+    @property
+    def enable_pandas_output(self):
+        """Set/Get a flag to use Pandas to export dict and lists. This applies to Solution data output.
+        If ``True`` the property or method will return a pandas object in CPython environment.
+        Default is ``False``.
 
-    def __enter__(self):
-        return self
+        Returns
+        -------
+        bool
+        """
+        return True if self._enable_pandas_output and pd else False
 
-    def __exit__(self, ex_type, ex_value, ex_traceback):
-        if ex_type:
-            self.edb_exception(ex_value, ex_traceback)
+    @enable_pandas_output.setter
+    def enable_pandas_output(self, val):
+        if val != self._enable_pandas_output and pd:
+            self._enable_pandas_output = val
+            self.init_solutions_data()
 
     @pyaedt_function_handler()
-    def __getitem__(self, variable_name):
-        """Get or Set a variable to the Edb project. The variable can be project using ``$`` prefix or
-        it can be a design variable, in which case the ``$`` is omitted.
+    def set_active_variation(self, var_id=0):
+        """Set the active variations to one of available variations in self.variations.
 
         Parameters
         ----------
-        variable_name : str
+        var_id : int
+            Index of Variations to assign.
 
         Returns
         -------
-        :class:`pyaedt.edb_core.edb_data.variables.Variable`
-
+        bool
         """
-        if self.variable_exists(variable_name)[0]:
-            return self.variables[variable_name]
-        return
+        if var_id < len(self.variations):
+            self.active_variation = self.variations[var_id]
+            self.nominal_variation = var_id
+            self._expressions = None
+            self._intrinsics = None
+            return True
+        return False
 
     @pyaedt_function_handler()
-    def __setitem__(self, variable_name, variable_value):
-        if self.variable_exists(variable_name)[0]:
-            self.change_design_variable_value(variable_name, variable_value)
-        else:
-            self.add_design_variable(variable_name, variable_value)
-
-    def _clean_variables(self):
-        """Initialize internal variables and perform garbage collection."""
-
-        self._components = None
-        self._core_primitives = None
-        self._stackup = None
-        self._padstack = None
-        self._siwave = None
-        self._hfss = None
-        self._nets = None
-        self._db = None
-        self._edb = None
-        self.builder = None
-        self.edbutils = None
-        self.simSetup = None
-        self.simsetupdata = None
-        self._setups = {}
-        self._layout_instance = None
-        self._variables = None
-        # time.sleep(2)
-        # gc.collect()
-
-    @pyaedt_function_handler()
-    def _init_objects(self):
-        time.sleep(1)
-        self._components = Components(self)
-        self._stackup = EdbStackup(self)
-        self._padstack = EdbPadstacks(self)
-        self._siwave = EdbSiwave(self)
-        self._hfss = EdbHfss(self)
-        self._nets = EdbNets(self)
-        self._core_primitives = EdbLayout(self)
-        self._stackup2 = Stackup(self)
-        self._materials = Materials(self)
+    def _get_variations(self):
+        variations_lists = []
+        for data in self._original_data:
+            variations = OrderedDict({})
+            for v in data.GetDesignVariableNames():
+                variations[v] = data.GetDesignVariableValue(v)
+            variations_lists.append(variations)
+        return variations_lists
 
-        self.logger.info("Objects Initialized")
+    @pyaedt_function_handler()
+    def variation_values(self, variation_name):
+        """Get the list of the specific variation available values.
 
-    @property
-    def logger(self):
-        """Logger for EDB.
+        Parameters
+        ----------
+        variation_name : str
+            Name of variation to return.
 
         Returns
         -------
-        :class:`pyaedt.aedt_logger.AedtLogger`
+        list
         """
-        return self._logger
+        if variation_name in self.intrinsics:
+            return self.intrinsics[variation_name]
+        else:
+            vars_vals = []
+            for el in self.variations:
+                if variation_name in el and el[variation_name] not in vars_vals:
+                    vars_vals.append(el[variation_name])
+            return vars_vals
 
     @property
-    def cell_names(self):
-        """Cell name container.
-        Returns
-        -------
-        list of str, cell names.
-        """
-        names = []
-        for cell in list(self._db.TopCircuitCells):
-            names.append(cell.GetName())
-        return names
+    def intrinsics(self):
+        """Get intrinsics dictionary on active variation."""
+        if not self._intrinsics:
+            self._intrinsics = OrderedDict({})
+            intrinsics = [i for i in self._sweeps_names if i not in self.nominal_variation.GetDesignVariableNames()]
+            for el in intrinsics:
+                values = list(self.nominal_variation.GetSweepValues(el, False))
+                self._intrinsics[el] = [i for i in values]
+                self._intrinsics[el] = list(OrderedDict.fromkeys(self._intrinsics[el]))
+        return self._intrinsics
 
-    @pyaedt_function_handler()
-    def _init_dlls(self):
-        """Initialize DLLs."""
-        if is_linux:
-            if env_value(self.edbversion) in os.environ or settings.edb_dll_path:
-                if settings.edb_dll_path:
-                    self.base_path = settings.edb_dll_path
-                else:
-                    self.base_path = env_path(self.edbversion)
-                sys.path.append(self.base_path)
-            else:
-                main = sys.modules["__main__"]
-                if "oDesktop" in dir(main):
-                    self.base_path = main.oDesktop.GetExeDir()
-                    sys.path.append(main.oDesktop.GetExeDir())
-                    os.environ[env_value(self.edbversion)] = self.base_path
-                else:
-                    edb_path = os.getenv("PYAEDT_SERVER_AEDT_PATH")
-                    if edb_path:
-                        self.base_path = edb_path
-                        sys.path.append(edb_path)
-                        os.environ[env_value(self.edbversion)] = self.base_path
-            if is_ironpython:
-                _clr.AddReferenceToFile("Ansys.Ansoft.Edb.dll")
-                _clr.AddReferenceToFile("Ansys.Ansoft.EdbBuilderUtils.dll")
-                _clr.AddReferenceToFileAndPath(os.path.join(self.base_path, "Ansys.Ansoft.SimSetupData.dll"))
-            else:
-                _clr.AddReference("Ansys.Ansoft.Edb")
-                _clr.AddReference("Ansys.Ansoft.EdbBuilderUtils")
-                _clr.AddReference("Ansys.Ansoft.SimSetupData")
-        else:
-            if settings.edb_dll_path:
-                self.base_path = settings.edb_dll_path
-            elif self.student_version:
-                self.base_path = env_path_student(self.edbversion)
-            else:
-                self.base_path = env_path(self.edbversion)
-            sys.path.append(self.base_path)
-            _clr.AddReference("Ansys.Ansoft.Edb")
-            _clr.AddReference("Ansys.Ansoft.EdbBuilderUtils")
-            _clr.AddReference("Ansys.Ansoft.SimSetupData")
-        os.environ["ECAD_TRANSLATORS_INSTALL_DIR"] = self.base_path
-        oaDirectory = os.path.join(self.base_path, "common", "oa")
-        os.environ["ANSYS_OADIR"] = oaDirectory
-        os.environ["PATH"] = "{};{}".format(os.environ["PATH"], self.base_path)
-        edb = __import__("Ansys.Ansoft.Edb")
-        self.edb = edb.Ansoft.Edb
-        edbbuilder = __import__("Ansys.Ansoft.EdbBuilderUtils")
-        self.edbutils = edbbuilder.Ansoft.EdbBuilderUtils
-        self.simSetup = __import__("Ansys.Ansoft.SimSetupData")
-        self.simsetupdata = self.simSetup.Ansoft.SimSetupData.Data
+    @property
+    def nominal_variation(self):
+        """Nominal variation."""
+        return self._nominal_variation
+
+    @nominal_variation.setter
+    def nominal_variation(self, val):
+        if 0 <= val <= self.number_of_variations:
+            self._nominal_variation = self._original_data[val]
+        else:
+            print(str(val) + " not in Variations")
 
     @property
-    def design_variables(self):
-        """Get all edb design variables.
+    def primary_sweep(self):
+        """Primary sweep.
 
-        Returns
-        -------
-        Dict[str, :class:`pyaedt.edb_core.edb_data.variables.Variable`]
+        Parameters
+        ----------
+        ps : float
+            Perimeter of the source.
         """
-        d_var = dict()
-        for i in self.active_cell.GetVariableServer().GetAllVariableNames():
-            d_var[i] = Variable(self, i)
-        return d_var
+        return self._primary_sweep
+
+    @primary_sweep.setter
+    def primary_sweep(self, ps):
+        if ps in self._sweeps_names:
+            self._primary_sweep = ps
 
     @property
-    def project_variables(self):
-        """Get all project variables.
+    def expressions(self):
+        """Expressions."""
+        if not self._expressions:
+            mydata = [i for i in self._nominal_variation.GetDataExpressions()]
+            self._expressions = list(dict.fromkeys(mydata))
+        return self._expressions
+
+    @pyaedt_function_handler()
+    def update_sweeps(self):
+        """Update sweeps.
 
         Returns
         -------
-        Dict[str, :class:`pyaedt.edb_core.edb_data.variables.Variable`]
+        dict
+            Updated sweeps.
+        """
+
+        names = list(self.nominal_variation.GetSweepNames())
+        for data in self._original_data:
+            for v in data.GetDesignVariableNames():
+                if v not in self._sweeps_names:
+                    self._sweeps_names.append(v)
+        self._sweeps_names.extend((reversed(names)))
 
+    @staticmethod
+    @pyaedt_function_handler()
+    def _quantity(unit):
         """
-        p_var = dict()
-        for i in self.db.GetVariableServer().GetAllVariableNames():
-            p_var[i] = Variable(self, i)
-        return p_var
 
-    @property
-    def variables(self):
-        """Get all Edb variables.
+        Parameters
+        ----------
+        unit :
+
 
         Returns
         -------
-        Dict[str, :class:`pyaedt.edb_core.edb_data.variables.Variable`]
 
         """
-        all_vars = dict()
-        for i, j in self.project_variables.items():
-            all_vars[i] = j
-        for i, j in self.design_variables.items():
-            all_vars[i] = j
-        return all_vars
+        for el in AEDT_UNITS:
+            keys_units = [i.lower() for i in list(AEDT_UNITS[el].keys())]
+            if unit.lower() in keys_units:
+                return el
+        return None
 
-    @property
-    def excitations(self):
-        """Get all layout excitations."""
-        terms = [term for term in list(self._active_layout.Terminals) if int(term.GetBoundaryType()) == 0]
-        terms = [i for i in terms if not i.IsReferenceTerminal()]
-        temp = {}
-        for ter in terms:
-            if "BundleTerminal" in ter.GetType().ToString():
-                temp[ter.GetName()] = ExcitationDifferential(self, ter)
+    @pyaedt_function_handler()
+    def init_solutions_data(self):
+        "Initialize the database and store info in variables."
+        self._solutions_real = self._init_solution_data_real()
+        self._solutions_imag = self._init_solution_data_imag()
+        self._solutions_mag = self._init_solution_data_mag()
+        self._solutions_phase = self._init_solution_data_phase()
+
+    @pyaedt_function_handler()
+    def _init_solution_data_mag(self):
+        _solutions_mag = {}
+        self.units_data = {}
+
+        for expr in self.expressions:
+            _solutions_mag[expr] = {}
+            self.units_data[expr] = self.nominal_variation.GetDataUnits(expr)
+            if self.enable_pandas_output:
+                _solutions_mag[expr] = np.sqrt(
+                    self._solutions_real[expr]
+                    .mul(self._solutions_real[expr])
+                    .add(self._solutions_imag[expr].mul(self._solutions_imag[expr]))
+                )
             else:
-                temp[ter.GetName()] = ExcitationPorts(self, ter)
-        return temp
+                for i in self._solutions_real[expr]:
+                    _solutions_mag[expr][i] = abs(complex(self._solutions_real[expr][i], self._solutions_imag[expr][i]))
+        if self.enable_pandas_output:
+            return pd.DataFrame.from_dict(_solutions_mag)
+        else:
+            return _solutions_mag
+
+    @pyaedt_function_handler()
+    def _init_solution_data_real(self):
+        """ """
+        sols_data = {}
+
+        for expression in self.expressions:
+            solution_Data = {}
+
+            for data, comb in zip(self._original_data, self.variations):
+                solution = list(data.GetRealDataValues(expression, False))
+                values = []
+                for el in list(self.intrinsics.keys()):
+                    values.append(list(OrderedDict.fromkeys(data.GetSweepValues(el, False))))
+
+                i = 0
+                c = [comb[v] for v in list(comb.keys())]
+                for t in itertools.product(*values):
+                    solution_Data[tuple(c + list(t))] = solution[i]
+                    i += 1
+            sols_data[expression] = solution_Data
+        if self.enable_pandas_output:
+            return pd.DataFrame.from_dict(sols_data)
+        else:
+            return sols_data
+
+    @pyaedt_function_handler()
+    def _init_solution_data_imag(self):
+        """ """
+        sols_data = {}
+
+        for expression in self.expressions:
+            solution_Data = {}
+            for data, comb in zip(self._original_data, self.variations):
+                if data.IsDataComplex(expression):
+                    solution = list(data.GetImagDataValues(expression, False))
+                else:
+                    l = len(list(data.GetRealDataValues(expression, False)))
+                    solution = [0] * l
+                values = []
+                for el in list(self.intrinsics.keys()):
+                    values.append(list(OrderedDict.fromkeys(data.GetSweepValues(el, False))))
+                i = 0
+                c = [comb[v] for v in list(comb.keys())]
+                for t in itertools.product(*values):
+                    solution_Data[tuple(c + list(t))] = solution[i]
+                    i += 1
+            sols_data[expression] = solution_Data
+        if self.enable_pandas_output:
+            return pd.DataFrame.from_dict(sols_data)
+        else:
+            return sols_data
+
+    @pyaedt_function_handler()
+    def _init_solution_data_phase(self):
+        data_phase = {}
+        for expr in self.expressions:
+            data_phase[expr] = {}
+            if self.enable_pandas_output:
+                data_phase[expr] = np.arctan2(self._solutions_imag[expr], self._solutions_real[expr])
+            else:
+                for i in self._solutions_real[expr]:
+                    data_phase[expr][i] = math.atan2(self._solutions_imag[expr][i], self._solutions_real[expr][i])
+        if self.enable_pandas_output:
+            return pd.DataFrame.from_dict(data_phase)
+        else:
+            return data_phase
 
     @property
-    def excitations_nets(self):
-        """Get all excitations net names."""
-        return list(set([i.GetNet().GetName() for i in list(self._active_layout.Terminals)]))
+    def full_matrix_real_imag(self):
+        """Get the full available solution data in Real and Imaginary parts.
 
-    @property
-    def sources(self):
-        """Get all layout sources."""
-        terms = [term for term in list(self._active_layout.Terminals) if int(term.GetBoundaryType()) in [3, 4, 7]]
-        return {ter.GetName(): ExcitationSources(self, ter) for ter in terms}
+        Returns
+        -------
+        tuple of dicts
+            (Real Dict, Imag Dict)
+        """
+        return self._solutions_real, self._solutions_imag
 
     @property
-    def probes(self):
-        """Get all layout sources."""
-        terms = [term for term in list(self._active_layout.Terminals) if int(term.GetBoundaryType()) in [8]]
-        return {ter.GetName(): ExcitationProbes(self, ter) for ter in terms}
-
-    @pyaedt_function_handler()
-    def open_edb(self, init_dlls=False):
-        """Open EDB.
-
-        Parameters
-        ----------
-        init_dlls : bool, optional
-            Whether to initialize DLLs. The default is ``False``.
+    def full_matrix_mag_phase(self):
+        """Get the full available solution data magnitude and phase in radians.
 
         Returns
         -------
-
+        tuple of dicts
+            (Mag Dict, Phase Dict).
         """
-        if init_dlls:
-            self._init_dlls()
-        self.logger.info("EDB Path %s", self.edbpath)
-        self.logger.info("EDB Version %s", self.edbversion)
-        self.edb.Database.SetRunAsStandAlone(self.standalone)
-        self.logger.info("EDB Standalone %s", self.standalone)
-        try:
-            db = self.edb.Database.Open(self.edbpath, self.isreadonly)
-        except Exception as e:
-            db = None
-            self.logger.error("Builder is not Initialized.")
-        if not db:
-            self.logger.warning("Error Opening db")
-            self._db = None
-            self._active_cell = None
-            self.builder = None
-            return None
-        self._db = db
-        self.logger.info("Database Opened")
-
-        self._active_cell = None
-        if self.cellname:
-            for cell in list(self._db.TopCircuitCells):
-                if cell.GetName() == self.cellname:
-                    self._active_cell = cell
-        # if self._active_cell is still None, set it to default cell
-        if self._active_cell is None:
-            self._active_cell = list(self._db.TopCircuitCells)[0]
-        self.logger.info("Cell %s Opened", self._active_cell.GetName())
-        if self._db and self._active_cell:
-            self.builder = EdbBuilder(self.edbutils, self._db, self._active_cell)
-            self._init_objects()
-            self.logger.info("Builder was initialized.")
-        else:
-            self.builder = None
-            self.logger.error("Builder was not initialized.")
-
-        return self.builder
-
-    @pyaedt_function_handler()
-    def open_edb_inside_aedt(self, init_dlls=False):
-        """Open EDB inside of AEDT.
+        return self._solutions_mag, self._solutions_phase
+
+    @staticmethod
+    @pyaedt_function_handler()
+    def to_degrees(input_list):
+        """Convert an input list from radians to degrees.
 
         Parameters
         ----------
-        init_dlls : bool, optional
-            Whether to initialize DLLs. The default is ``False``.
+        input_list : list
+            List of inputs in radians.
 
         Returns
         -------
+        list
+            List of inputs in degrees.
 
         """
-        if init_dlls:
-            self._init_dlls()
-        self.logger.info("Opening EDB from HDL")
-        self.edb.Database.SetRunAsStandAlone(False)
-        if self.oproject.GetEDBHandle():
-            hdl = Convert.ToUInt64(self.oproject.GetEDBHandle())
-            db = self.edb.Database.Attach(hdl)
-            if not db:
-                self.logger.warning("Error getting the database.")
-                self._db = None
-                self._active_cell = None
-                self.builder = None
-                return None
-            self._db = db
-            self._active_cell = self.edb.Cell.Cell.FindByName(
-                self.db, self.edb.Cell.CellType.CircuitCell, self.cellname
-            )
-            if self._active_cell is None:
-                self._active_cell = list(self._db.TopCircuitCells)[0]
-            if self._db and self._active_cell:
-                if not os.path.exists(self.edbpath):
-                    os.makedirs(self.edbpath)
-                time.sleep(3)
-                self.builder = EdbBuilder(self.edbutils, self._db, self._active_cell)
-                self._init_objects()
-                return self.builder
-            else:
-                self.builder = None
-                return None
-        else:
-            self._db = None
-            self._active_cell = None
-            self.builder = None
-            return None
-
-    @pyaedt_function_handler()
-    def create_edb(self, init_dlls=False):
-        """Create EDB.
-
-        Parameters
-        ----------
-        init_dlls : bool, optional
-            Whether to initialize DLLs. The default is ``False``.
-
-        """
-        if init_dlls:
-            self._init_dlls()
-        self.edb.Database.SetRunAsStandAlone(self.standalone)
-        db = self.edb.Database.Create(self.edbpath)
-        if not db:
-            self.logger.warning("Error creating the database.")
-            self._db = None
-            self._active_cell = None
-            self.builder = None
-            return None
-        self._db = db
-        if not self.cellname:
-            self.cellname = generate_unique_name("Cell")
-        self._active_cell = self.edb.Cell.Cell.Create(self._db, self.edb.Cell.CellType.CircuitCell, self.cellname)
-        if self._db and self._active_cell:
-            self.builder = EdbBuilder(self.edbutils, self._db, self._active_cell)
-            self._init_objects()
-            return self.builder
-        self.builder = None
-        return None
+        if isinstance(input_list, (tuple, list)):
+            return [i * 360 / (2 * math.pi) for i in input_list]
+        else:
+            return input_list * 360 / (2 * math.pi)
 
+    @staticmethod
     @pyaedt_function_handler()
-    def import_layout_pcb(
-        self, input_file, working_dir, init_dlls=False, anstranslator_full_path="", use_ppe=False, control_file=None
-    ):
-        """Import a board file and generate an ``edb.def`` file in the working directory.
-
-        This function supports all AEDT formats, including DXF, GDS, SML (IPC2581), BRD, and TGZ.
+    def to_radians(input_list):
+        """Convert an input list from degrees to radians.
 
         Parameters
         ----------
-        input_file : str
-            Full path to the board file.
-        working_dir : str
-            Directory in which to create the ``aedb`` folder. The name given to the AEDB file
-            is the same as the name of the board file.
-        init_dlls : bool
-            Whether to initialize DLLs. The default is ``False``.
-        anstranslator_full_path : str, optional
-            Full path to the Ansys translator. The default is ``""``.
-        use_ppe : bool
-            Whether to use the PPE License. The default is ``False``.
-        control_file : str, optional
-            Path to the XML file. The default is ``None``, in which case an attempt is made to find
-            the XML file in the same directory as the board file. To succeed, the XML file and board file
-            must have the same name. Only the extension differs.
+        input_list : list
+            List of inputs in degrees.
 
         Returns
         -------
-        str
-            Full path to the AEDB file.
+        type
+            List of inputs in radians.
+
         """
-        self._components = None
-        self._core_primitives = None
-        self._stackup = None
-        self._padstack = None
-        self._siwave = None
-        self._hfss = None
-        self._nets = None
-        self._db = None
-        if init_dlls:
-            self._init_dlls()
-        aedb_name = os.path.splitext(os.path.basename(input_file))[0] + ".aedb"
-        if anstranslator_full_path and os.path.exists(anstranslator_full_path):
-            command = anstranslator_full_path
-        else:
-            command = os.path.join(self.base_path, "anstranslator")
-            if is_windows:
-                command += ".exe"
-
-        if not working_dir:
-            working_dir = os.path.dirname(input_file)
-        cmd_translator = [
-            command,
-            input_file,
-            os.path.join(working_dir, aedb_name),
-            "-l={}".format(os.path.join(working_dir, "Translator.log")),
-        ]
-        if not use_ppe:
-            cmd_translator.append("-ppe=false")
-        if control_file and input_file[-3:] not in ["brd"]:
-            if is_linux:
-                cmd_translator.append("-c={}".format(control_file))
-            else:
-                cmd_translator.append('-c="{}"'.format(control_file))
-        p = subprocess.Popen(cmd_translator)
-        p.wait()
-        if not os.path.exists(os.path.join(working_dir, aedb_name)):
-            self.logger.error("Translator failed to translate.")
-            return False
-        self.edbpath = os.path.join(working_dir, aedb_name)
-        self.open_edb()
+        if isinstance(input_list, (tuple, list)):
+            return [i * 2 * math.pi / 360 for i in input_list]
+        else:
+            return input_list * 2 * math.pi / 360
 
     @pyaedt_function_handler()
-    def export_to_ipc2581(self, ipc_path=None, units="MILLIMETER"):
-        """Create an XML IPC2581 file from the active EDB.
+    def _variation_tuple(self):
+        temp = []
+        for it in self._sweeps_names:
+            try:
+                temp.append(self.active_variation[it])
+            except KeyError:
+                temp.append(self.active_intrinsic[it])
+        return temp
 
-        .. note::
-           The method works only in CPython because of some limitations on Ironpython in XML parsing and
-           because it's time-consuming.
-           This method is still being tested and may need further debugging.
-           Any feedback is welcome. Backdrills and custom pads are not supported yet.
+    @pyaedt_function_handler()
+    def data_magnitude(self, expression=None, convert_to_SI=False):
+        """Retrieve the data magnitude of an expression.
 
         Parameters
         ----------
-        ipc_path : str, optional
-            Path to the XML IPC2581 file. The default is ``None``, in which case
-            an attempt is made to find the XML IPC2581 file in the same directory
-            as the active EDB. To succeed, the XML IPC2581 file and the active
-            EDT must have the same name. Only the extension differs.
-        units : str, optional
-            Units of the XML IPC2581 file. Options are ``"millimeter"``,
-            ``"inch"``, and ``"micron"``. The default is ``"millimeter"``.
+        expression : str, optional
+            Name of the expression. The default is ``None``, in which case the
+            active expression is used.
+        convert_to_SI : bool, optional
+            Whether to convert the data to the SI unit system.
+            The default is ``False``.
 
         Returns
         -------
-        bool
-            ``True`` if successful, ``False`` if failed.
+        list
+            List of data.
+
         """
-        if is_ironpython:  # pragma no cover
-            self.logger.error("This method is not supported in Ironpython")
+        if not expression:
+            expression = self.active_expression
+        elif expression not in self.expressions:
             return False
-        if units.lower() not in ["millimeter", "inch", "micron"]:  # pragma no cover
-            self.logger.warning("The wrong unit is entered. Setting to the default, millimeter.")
-            units = "millimeter"
-
-        if not ipc_path:
-            ipc_path = self.edbpath[:-4] + "xml"
-        self.logger.info("Export IPC 2581 is starting. This operation can take a while.")
-        start = time.time()
-        ipc = Ipc2581(self, units)
-        ipc.load_ipc_model()
-        ipc.file_path = ipc_path
-        result = ipc.write_xml()
-
-        if result:  # pragma no cover
-            self.logger.info_timer("Export IPC 2581 completed.", start)
-            self.logger.info("File saved as %s", ipc_path)
-            return ipc_path
-        self.logger.info("Error exporting IPC 2581.")
-        return False
+        temp = self._variation_tuple()
+        solution_Data = self._solutions_mag[expression]
+        sol = []
+        position = list(self._sweeps_names).index(self.primary_sweep)
+        sw = self.variation_values(self.primary_sweep)
+        for el in sw:
+            temp[position] = el
+            try:
+                sol.append(solution_Data[tuple(temp)])
+            except KeyError:
+                sol.append(None)
+        if convert_to_SI and self._quantity(self.units_data[expression]):
+            sol = self._convert_list_to_SI(
+                sol, self._quantity(self.units_data[expression]), self.units_data[expression]
+            )
+        if self.enable_pandas_output:
+            return pd.Series(sol)
+        return sol
 
-    def edb_exception(self, ex_value, tb_data):
-        """Write the trace stack to AEDT when a Python error occurs.
+    @staticmethod
+    @pyaedt_function_handler()
+    def _convert_list_to_SI(datalist, dataunits, units):
+        """Convert a data list to the SI unit system.
 
         Parameters
         ----------
-        ex_value :
+        datalist : list
+           List of data to convert.
+        dataunits :
 
-        tb_data :
+        units :
 
 
         Returns
         -------
+        list
+           List of the data converted to the SI unit system.
 
         """
-        tb_trace = traceback.format_tb(tb_data)
-        tblist = tb_trace[0].split("\n")
-        self.logger.error(str(ex_value))
-        for el in tblist:
-            self.logger.error(el)
-
-    @property
-    def db(self):
-        """Database object."""
-        return self._db
+        sol = datalist
+        if dataunits in AEDT_UNITS and units in AEDT_UNITS[dataunits]:
+            sol = [i * AEDT_UNITS[dataunits][units] for i in datalist]
+        return sol
 
-    @property
-    def active_cell(self):
-        """Active cell."""
-        return self._active_cell
+    @pyaedt_function_handler()
+    def data_db10(self, expression=None, convert_to_SI=False):
+        """Retrieve the data in the database for an expression and convert in db10.
 
-    @property
-    def core_components(self):
-        """Edb Components methods and properties.
+        Parameters
+        ----------
+        expression : str, optional
+            Name of the expression. The default is ``None``,
+            in which case the active expression is used.
+        convert_to_SI : bool, optional
+            Whether to convert the data to the SI unit system.
+            The default is ``False``.
 
         Returns
         -------
-        Instance of :class:`pyaedt.edb_core.Components.Components`
+        list
+            List of the data in the database for the expression.
 
-        Examples
-        --------
-        >>> edbapp = pyaedt.Edb("myproject.aedb")
-        >>> comp = self.edbapp.core_components.get_component_by_name("J1")
         """
-        if not self._components and self.builder:
-            self._components = Components(self)
-        return self._components
+        if not expression:
+            expression = self.active_expression
+        if self.enable_pandas_output:
+            return 10 * np.log10(self.data_magnitude(expression, convert_to_SI))
+        return [db10(i) for i in self.data_magnitude(expression, convert_to_SI)]
 
-    @property
-    def core_stackup(self):
-        """Core stackup.
-
-        .. deprecated:: 0.6.5
-            There is no need to use the ``core_stackup`` property anymore.
-            You can instantiate a new ``stackup`` class directly from the ``Edb`` class.
-        """
-        mess = "`core_stackup` is deprecated.\n"
-        mess += " Use `app.stackup` directly to instantiate new stackup methods."
-        warnings.warn(mess, DeprecationWarning)
-        if not self._stackup and self.builder:
-            self._stackup = EdbStackup(self)
-        return self._stackup
+    @pyaedt_function_handler()
+    def data_db20(self, expression=None, convert_to_SI=False):
+        """Retrieve the data in the database for an expression and convert in db20.
 
-    @property
-    def design_options(self):
-        """Edb Design Settings and Options.
+        Parameters
+        ----------
+        expression : str, optional
+            Name of the expression. The default is ``None``,
+            in which case the active expression is used.
+        convert_to_SI : bool, optional
+            Whether to convert the data to the SI unit system.
+            The default is ``False``.
 
         Returns
         -------
-        Instance of :class:`pyaedt.edb_core.edb_data.design_options.EdbDesignOptions`
+        list
+            List of the data in the database for the expression.
+
         """
-        return EdbDesignOptions(self.active_cell)
+        if not expression:
+            expression = self.active_expression
+        if self.enable_pandas_output:
+            return 20 * np.log10(self.data_magnitude(expression, convert_to_SI))
+        return [db20(i) for i in self.data_magnitude(expression, convert_to_SI)]
 
-    @property
-    def stackup(self):
-        """Stackup manager.
+    @pyaedt_function_handler()
+    def data_phase(self, expression=None, radians=True):
+        """Retrieve the phase part of the data for an expression.
+
+        Parameters
+        ----------
+        expression : str, None
+            Name of the expression. The default is ``None``,
+            in which case the active expression is used.
+        radians : bool, optional
+            Whether to convert the data into radians or degree.
+            The default is ``True`` for radians.
 
         Returns
         -------
-        Instance of :class: 'pyaedt.edb_core.Stackup`
+        list
+            Phase data for the expression.
 
-        Examples
-        --------
-        >>> edbapp = pyaedt.Edb("myproject.aedb")
-        >>> edbapp.stackup.layers["TOP"].thickness = 4e-5
-        >>> edbapp.stackup.layers["TOP"].thickness == 4e-05
-        >>> edbapp.stackup.add_layer("Diel", "GND", layer_type="dielectric", thickness="0.1mm", material="FR4_epoxy")
         """
-        if not self._stackup2 and self.builder:
-            self._stackup2 = Stackup(self)
-        return self._stackup2
+        if not expression:
+            expression = self.active_expression
+        coefficient = 1
+        if not radians:
+            coefficient = 180 / math.pi
+        if self.enable_pandas_output:
+            return coefficient * np.arctan2(self.data_imag(expression), self.data_real(expression))
+        return [coefficient * math.atan2(k, i) for i, k in zip(self.data_real(expression), self.data_imag(expression))]
 
     @property
-    def materials(self):
-        """Material Database.
+    def primary_sweep_values(self):
+        """Retrieve the primary sweep for a given data and primary variable.
 
         Returns
         -------
-        Instance of :class: `pyaedt.edb_core.Materials`
+        list
+            List of the primary sweep valid points for the expression.
 
-        Examples
-        --------
-        >>> edbapp = pyaedt.Edb("myproject.aedb")
-        >>> edbapp.materials["FR4_epoxy"].conductivity = 1
-        >>> edbapp.materials.add_debye_material("My_Debye2", 5, 3, 0.02, 0.05, 1e5, 1e9)
-        >>> edbapp.materials.add_djordjevicsarkar_material("MyDjord2", 3.3, 0.02, 3.3)
         """
-
-        if not self._materials and self.builder:
-            self._materials = Materials(self)
-        return self._materials
+        if self.enable_pandas_output:
+            return pd.Series(self.variation_values(self.primary_sweep))
+        return self.variation_values(self.primary_sweep)
 
     @property
-    def core_padstack(self):
-        """Core padstack.
-
+    def primary_sweep_variations(self):
+        """Retrieve the variations lists for a given primary variable.
 
         Returns
         -------
-        Instance of :class: `pyaedt.edb_core.padstack.EdbPadstack`
+        list
+            List of the primary sweep valid points for the expression.
 
-        Examples
-        --------
-        >>> edbapp = pyaedt.Edb("myproject.aedb")
-        >>> p = edbapp.core_padstack.create_padstack(padstackname="myVia_bullet", antipad_shape="Bullet")
-        >>> edbapp.core_padstack.get_pad_parameters(
-        >>> ... p, "TOP", self.edbapp.core_padstack.pad_type.RegularPad
-        >>> ... )
         """
+        expression = self.active_expression
+        temp = self._variation_tuple()
 
-        if not self._padstack and self.builder:
-            self._padstack = EdbPadstacks(self)
-        return self._padstack
+        solution_Data = list(self._solutions_real[expression].keys())
+        sol = []
+        position = list(self._sweeps_names).index(self.primary_sweep)
+
+        for el in self.primary_sweep_values:
+            temp[position] = el
+            if tuple(temp) in solution_Data:
+                sol_dict = OrderedDict({})
+                i = 0
+                for sn in self._sweeps_names:
+                    sol_dict[sn] = temp[i]
+                    i += 1
+                sol.append(sol_dict)
+            else:
+                sol.append(None)
+        if self.enable_pandas_output:
+            return pd.Series(sol)
+        return sol
 
-    @property
-    def core_siwave(self):
-        """Core SIWave methods and properties.
+    @pyaedt_function_handler()
+    def data_real(self, expression=None, convert_to_SI=False):
+        """Retrieve the real part of the data for an expression.
+
+        Parameters
+        ----------
+        expression : str, None
+            Name of the expression. The default is ``None``,
+            in which case the active expression is used.
+        convert_to_SI : bool, optional
+            Whether to convert the data to the SI unit system.
+            The default is ``False``.
 
         Returns
         -------
-        Instance of :class: `pyaedt.edb_core.siwave.EdbSiwave`
+        list
+            List of the real data for the expression.
 
-        Examples
-        --------
-        >>> edbapp = pyaedt.Edb("myproject.aedb")
-        >>> p2 = edbapp.core_siwave.create_circuit_port_on_net("U2A5", "V3P3_S0", "U2A5", "GND", 50, "test")
         """
+        if not expression:
+            expression = self.active_expression
+        temp = self._variation_tuple()
 
-        if not self._siwave and self.builder:
-            self._siwave = EdbSiwave(self)
-        return self._siwave
+        solution_Data = self._solutions_real[expression]
+        sol = []
+        position = list(self._sweeps_names).index(self.primary_sweep)
 
-    @property
-    def core_hfss(self):
-        """Core HFSS methods and properties.
-
-        Returns
-        -------
-        Instance of :class:`pyaedt.edb_core.hfss.EdbHfss`
+        for el in self.primary_sweep_values:
+            temp[position] = el
+            try:
+                sol.append(solution_Data[tuple(temp)])
+            except KeyError:
+                sol.append(None)
+
+        if convert_to_SI and self._quantity(self.units_data[expression]):
+            sol = self._convert_list_to_SI(
+                sol, self._quantity(self.units_data[expression]), self.units_data[expression]
+            )
+        if self.enable_pandas_output:
+            return pd.Series(sol)
+        return sol
 
-        Examples
-        --------
-        >>> edbapp = pyaedt.Edb("myproject.aedb")
-        >>> edbapp.core_hfss.configure_hfss_analysis_setup(sim_config)
-        """
-        if not self._hfss and self.builder:
-            self._hfss = EdbHfss(self)
-        return self._hfss
+    @pyaedt_function_handler()
+    def data_imag(self, expression=None, convert_to_SI=False):
+        """Retrieve the imaginary part of the data for an expression.
 
-    @property
-    def core_nets(self):
-        """Core nets.
+        Parameters
+        ----------
+        expression : str, optional
+            Name of the expression. The default is ``None``,
+            in which case the active expression is used.
+        convert_to_SI : bool, optional
+            Whether to convert the data to the SI unit system.
+            The default is ``False``.
 
         Returns
         -------
-        :class:`pyaedt.edb_core.nets.EdbNets`
+        list
+            List of the imaginary data for the expression.
 
-        Examples
-        --------
-        >>> edbapp = pyaedt.Edb("myproject.aedb")
-        >>> edbapp.core_nets.find_or_create_net("GND")
-        >>> edbapp.core_nets.find_and_fix_disjoint_nets("GND", keep_only_main_net=True)
         """
+        if not expression:
+            expression = self.active_expression
+        temp = self._variation_tuple()
+
+        solution_Data = self._solutions_imag[expression]
+        sol = []
+        position = list(self._sweeps_names).index(self.primary_sweep)
+        for el in self.primary_sweep_values:
+            temp[position] = el
+            try:
+                sol.append(solution_Data[tuple(temp)])
+            except KeyError:
+                sol.append(None)
+        if convert_to_SI and self._quantity(self.units_data[expression]):
+            sol = self._convert_list_to_SI(
+                sol, self._quantity(self.units_data[expression]), self.units_data[expression]
+            )
+        if self.enable_pandas_output:
+            return pd.Series(sol)
+        return sol
 
-        if not self._nets and self.builder:
-            self._nets = EdbNets(self)
-        return self._nets
+    @pyaedt_function_handler()
+    def is_real_only(self, expression=None):
+        """Check if the expression has only real values or not.
 
-    @property
-    def core_primitives(self):
-        """Core primitives.
+        Parameters
+        ----------
+        expression : str, optional
+            Name of the expression. The default is ``None``,
+            in which case the active expression is used.
 
         Returns
         -------
-        Instance of :class: `pyaedt.edb_core.layout.EdbLayout`
-
-        Examples
-        --------
-        >>> edbapp = pyaedt.Edb("myproject.aedb")
-        >>> top_prims = edbapp.core_primitives.primitives_by_layer["TOP"]
+        bool
+            ``True`` if the Solution Data for specific expression contains only real values.
         """
-        if not self._core_primitives and self.builder:
-            self._core_primitives = EdbLayout(self)
-        return self._core_primitives
+        if not expression:
+            expression = self.active_expression
+        if self.enable_pandas_output:
+            return True if self._solutions_imag[expression].abs().sum() > 0.0 else False
+        for v in list(self._solutions_imag[expression].values()):
+            if float(v) != 0.0:
+                return False
+        return True
 
-    @property
-    def active_layout(self):
-        """Active layout.
+    @pyaedt_function_handler()
+    def export_data_to_csv(self, output, delimiter=";"):
+        """Save to output csv file the Solution Data.
+
+        Parameters
+        ----------
+        output : str,
+            Full path to csv file.
+        delimiter : str,
+            CSV Delimiter. Default is ``";"``.
 
         Returns
         -------
-        Instance of :class: `pyaedt.`
+        bool
         """
-        self._active_layout = None
-        if self._active_cell:
-            self._active_layout = self.active_cell.GetLayout()
-        return self._active_layout
+        header = [el for el in self._sweeps_names]
+        for el in self.expressions:
+            if not self.is_real_only(el):
+                header.append(el + " (Real)")
+                header.append(el + " (Imag)")
+            else:
+                header.append(el)
 
-    @property
-    def layout_instance(self):
-        """Edb Layout Instance."""
-        if not self._layout_instance:
-            self._layout_instance = self.active_layout.GetLayoutInstance()
-        return self._layout_instance
+        list_full = [header]
+        for e, v in self._solutions_real[self.active_expression].items():
+            list_full.append(list(e))
+        for el in self.expressions:
+            i = 1
+            for e, v in self._solutions_real[el].items():
+                list_full[i].extend([v])
+                i += 1
+            i = 1
+            if not self.is_real_only(el):
+                for e, v in self._solutions_imag[el].items():
+                    list_full[i].extend([v])
+                    i += 1
 
-    @property
-    def pins(self):
-        """EDBPadstackInstance of Component.
+        return write_csv(output, list_full, delimiter=delimiter)
 
-        Returns
-        -------
-        dic[str, :class:`pyaedt.edb_core.edb_data.definitions.EDBPadstackInstance`]
-            Dictionary of EDBPadstackInstance Components.
+    @pyaedt_function_handler()
+    def plot(
+        self,
+        curves=None,
+        math_formula=None,
+        size=(2000, 1000),
+        show_legend=True,
+        xlabel="",
+        ylabel="",
+        title="",
+        snapshot_path=None,
+        is_polar=False,
+    ):
+        """Create a matplotlib plot based on a list of data.
 
+        Parameters
+        ----------
+        curves : list
+            Curves to be plotted. If None, the first curve will be plotted.
+        math_formula : str , optional
+            Mathematical formula to apply to the plot curve.
+            Valid values are `"re"`, `"im"`, `"db20"`, `"db10"`, `"abs"`, `"mag"`, `"phasedeg"`, `"phaserad"`.
+            `None` value will plot only real value of the data stored in solution data.
+        size : tuple, optional
+            Image size in pixel (width, height).
+        show_legend : bool
+            Either to show legend or not. Flag will be ignored if number of curves to plot is greater than 15.
+        xlabel : str
+            Plot X label.
+        ylabel : str
+            Plot Y label.
+        title : str
+            Plot Title label.
+        snapshot_path : str
+            Full path to image file if a snapshot is needed.
+        is_polar : bool, optional
+            Set to `True` if this is a polar plot.
+
+        Returns
+        -------
+        :class:`matplotlib.plt`
+            Matplotlib fig object.
+        """
+        if is_ironpython:
+            return False  # pragma: no cover
+        if not curves:
+            curves = [self.active_expression]
+        if isinstance(curves, str):
+            curves = [curves]
+        data_plot = []
+        sweep_name = self.primary_sweep
+        if is_polar:
+            sw = self.to_radians(self.primary_sweep_values)
+        else:
+            sw = self.primary_sweep_values
+        for curve in curves:
+            if not math_formula:
+                data_plot.append([sw, self.data_real(curve), curve])
+            elif math_formula == "re":
+                data_plot.append([sw, self.data_real(curve), "{}({})".format(math_formula, curve)])
+            elif math_formula == "im":
+                data_plot.append([sw, self.data_imag(curve), "{}({})".format(math_formula, curve)])
+            elif math_formula == "db20":
+                data_plot.append([sw, self.data_db20(curve), "{}({})".format(math_formula, curve)])
+            elif math_formula == "db10":
+                data_plot.append([sw, self.data_db10(curve), "{}({})".format(math_formula, curve)])
+            elif math_formula == "mag":
+                data_plot.append([sw, self.data_magnitude(curve), "{}({})".format(math_formula, curve)])
+            elif math_formula == "phasedeg":
+                data_plot.append([sw, self.data_phase(curve, False), "{}({})".format(math_formula, curve)])
+            elif math_formula == "phaserad":
+                data_plot.append([sw, self.data_phase(curve, True), "{}({})".format(math_formula, curve)])
+        if not xlabel:
+            xlabel = sweep_name
+        if not ylabel:
+            ylabel = math_formula
+        if not title:
+            title = "Simulation Results Plot"
+        if len(data_plot) > 15:
+            show_legend = False
+        if is_polar:
+            return plot_polar_chart(data_plot, size, show_legend, xlabel, ylabel, title, snapshot_path)
+        else:
+            return plot_2d_chart(data_plot, size, show_legend, xlabel, ylabel, title, snapshot_path)
 
-        Examples
-        --------
-        >>> edbapp = pyaedt.Edb("myproject.aedb")
-        >>> pin_net_name = edbapp.pins[424968329].netname
-        """
-        pins = {}
-        if self.core_components:
-            for el in self.core_components.components:
-                comp = self.edb.Cell.Hierarchy.Component.FindByName(self.active_layout, el)
-                temp = [
-                    p
-                    for p in comp.LayoutObjs
-                    if p.GetObjType() == self.edb.Cell.LayoutObjType.PadstackInstance and p.IsLayoutPin()
-                ]
-                for p in temp:
-                    pins[p.GetId()] = EDBPadstackInstance(p, self)
-        return pins
+    @pyaedt_function_handler()
+    def plot_3d(
+        self,
+        curve=None,
+        x_axis="Theta",
+        y_axis="Phi",
+        xlabel="",
+        ylabel="",
+        title="",
+        math_formula=None,
+        size=(2000, 1000),
+        snapshot_path=None,
+    ):
+        """Create a matplotlib 3d plot based on a list of data.
 
-    class Boundaries:
-        """Boundaries Enumerator.
+        Parameters
+        ----------
+        curve : str
+            Curve to be plotted. If None, the first curve will be plotted.
+        x_axis : str, optional
+            X Axis sweep. Default is `"Theta"`.
+        y_axis : str, optional
+            Y Axis sweep. Default is `"Phi"`.
+        math_formula : str , optional
+            Mathematical formula to apply to the plot curve.
+            Valid values are `"re"`, `"im"`, `"db20"`, `"db10"`, `"abs"`, `"mag"`, `"phasedeg"`, `"phaserad"`.
+        size : tuple, optional
+            Image size in pixel (width, height).
+        snapshot_path : str
+            Full path to image file if a snapshot is needed.
+        is_polar : bool, optional
+            Set to `True` if this is a polar plot.
+
+        Returns
+        -------
+        :class:`matplotlib.plt`
+            Matplotlib fig object.
+        """
+        if is_ironpython:
+            return False  # pragma: no cover
+        if not curve:
+            curve = self.active_expression
+
+        if not math_formula:
+            math_formula = "mag"
+        theta = self.variation_values(x_axis)
+        y_axis_val = self.variation_values(y_axis)
+
+        phi = []
+        r = []
+        for el in y_axis_val:
+            self.active_variation[y_axis] = el
+            phi.append(el * math.pi / 180)
+
+            if math_formula == "re":
+                r.append(self.data_real(curve))
+            elif math_formula == "im":
+                r.append(self.data_imag(curve))
+            elif math_formula == "db20":
+                r.append(self.data_db20(curve))
+            elif math_formula == "db10":
+                r.append(self.data_db10(curve))
+            elif math_formula == "mag":
+                r.append(self.data_magnitude(curve))
+            elif math_formula == "phasedeg":
+                r.append(self.data_phase(curve, False))
+            elif math_formula == "phaserad":
+                r.append(self.data_phase(curve, True))
+        active_sweep = self.active_intrinsic[self.primary_sweep]
+        position = self.variation_values(self.primary_sweep).index(active_sweep)
+        if len(self.variation_values(self.primary_sweep)) > 1:
+            new_r = []
+            for el in r:
+                new_r.append([el[position]])
+            r = new_r
+        data_plot = [theta, phi, r]
+        if not xlabel:
+            xlabel = x_axis
+        if not ylabel:
+            ylabel = y_axis
+        if not title:
+            title = "Simulation Results Plot"
+        return plot_3d_chart(data_plot, size, xlabel, ylabel, title, snapshot_path)
+
+    @pyaedt_function_handler()
+    def ifft(self, curve_header="NearE", u_axis="_u", v_axis="_v", window=False):
+        """Create IFFT of given complex data.
+
+        Parameters
+        ----------
+        curve_header : curve header. Solution data must contain 3 curves with X, Y and Z components of curve header.
+        u_axis : str, optional
+            U Axis name. Default is Hfss name "_u"
+        v_axis : str, optional
+            V Axis name. Default is Hfss name "_v"
+        window : bool, optional
+            Either if Hanning windowing has to be applied.
 
         Returns
         -------
-        int
+        List
+            IFFT Matrix.
         """
+        if is_ironpython:
+            return False
+        u = self.variation_values(u_axis)
+        v = self.variation_values(v_axis)
+
+        freq = self.variation_values("Freq")
+        if self.enable_pandas_output:
+            E_realx = np.reshape(self._solutions_real[curve_header + "X"].copy().values, (len(freq), len(v), len(u)))
+            E_imagx = np.reshape(self._solutions_imag[curve_header + "X"].copy().values, (len(freq), len(v), len(u)))
+            E_realy = np.reshape(self._solutions_real[curve_header + "Y"].copy().values, (len(freq), len(v), len(u)))
+            E_imagy = np.reshape(self._solutions_imag[curve_header + "Y"].copy().values, (len(freq), len(v), len(u)))
+            E_realz = np.reshape(self._solutions_real[curve_header + "Z"].copy().values, (len(freq), len(v), len(u)))
+            E_imagz = np.reshape(self._solutions_imag[curve_header + "Z"].copy().values, (len(freq), len(v), len(u)))
+        else:
+            vals_real_Ex = [j for j in self._solutions_real[curve_header + "X"].values()]
+            vals_imag_Ex = [j for j in self._solutions_imag[curve_header + "X"].values()]
+            vals_real_Ey = [j for j in self._solutions_real[curve_header + "Y"].values()]
+            vals_imag_Ey = [j for j in self._solutions_imag[curve_header + "Y"].values()]
+            vals_real_Ez = [j for j in self._solutions_real[curve_header + "Z"].values()]
+            vals_imag_Ez = [j for j in self._solutions_imag[curve_header + "Z"].values()]
+
+            E_realx = np.reshape(vals_real_Ex, (len(freq), len(v), len(u)))
+            E_imagx = np.reshape(vals_imag_Ex, (len(freq), len(v), len(u)))
+            E_realy = np.reshape(vals_real_Ey, (len(freq), len(v), len(u)))
+            E_imagy = np.reshape(vals_imag_Ey, (len(freq), len(v), len(u)))
+            E_realz = np.reshape(vals_real_Ez, (len(freq), len(v), len(u)))
+            E_imagz = np.reshape(vals_imag_Ez, (len(freq), len(v), len(u)))
+
+        Temp_E_compx = E_realx + 1j * E_imagx  # Here is the complex FD data matrix, ready for transforming
+        Temp_E_compy = E_realy + 1j * E_imagy
+        Temp_E_compz = E_realz + 1j * E_imagz
+
+        E_compx = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
+        E_compy = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
+        E_compz = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
+        if window:
+            timewin = np.hanning(len(freq))
+
+            for row in range(0, len(v)):
+                for col in range(0, len(u)):
+                    E_compx[:, row, col] = np.multiply(Temp_E_compx[:, row, col], timewin)
+                    E_compy[:, row, col] = np.multiply(Temp_E_compy[:, row, col], timewin)
+                    E_compz[:, row, col] = np.multiply(Temp_E_compz[:, row, col], timewin)
+        else:
+            E_compx = Temp_E_compx
+            E_compy = Temp_E_compy
+            E_compz = Temp_E_compz
+
+        E_time_x = np.fft.ifft(np.fft.fftshift(E_compx, 0), len(freq), 0, None)
+        E_time_y = np.fft.ifft(np.fft.fftshift(E_compy, 0), len(freq), 0, None)
+        E_time_z = np.fft.ifft(np.fft.fftshift(E_compz, 0), len(freq), 0, None)
+        E_time = np.zeros((np.size(freq), np.size(v), np.size(u)))
+        for i in range(0, len(freq)):
+            E_time[i, :, :] = np.abs(
+                np.sqrt(np.square(E_time_x[i, :, :]) + np.square(E_time_y[i, :, :]) + np.square(E_time_z[i, :, :]))
+            )
+        self._ifft = E_time
 
-        (Port, Pec, RLC, CurrentSource, VoltageSource, NexximGround, NexximPort, DcTerminal, VoltageProbe) = range(0, 9)
+        return self._ifft
 
     @pyaedt_function_handler()
-    def edb_value(self, val):
-        """Convert a value to an EDB value. Value can be a string, float or integer. Mainly used in internal calls.
+    def ifft_to_file(
+        self,
+        u_axis="_u",
+        v_axis="_v",
+        coord_system_center=None,
+        db_val=False,
+        num_frames=None,
+        csv_dir=None,
+        name_str="res_",
+    ):
+        """Save IFFT Matrix to a list of csv files (one per time step).
 
         Parameters
         ----------
-        val : str, float, int
-
+        u_axis : str, optional
+            U Axis name. Default is Hfss name "_u"
+        v_axis : str, optional
+            V Axis name. Default is Hfss name "_v"
+        coord_system_center : list, optional
+            List of UV GlobalCS Center.
+        db_val : bool, optional
+            Either if data has to be exported in db or not.
+        num_frames : int, optional
+            Number of frames to export.
+        csv_dir : str
+            Output path
+        name_str : str, optional
+            csv file header.
 
         Returns
         -------
-        Instance of `Edb.Utility.Value`
-
+        str
+            Path to file containing the list of csv files.
         """
-        if isinstance(val, (int, float)):
-            return self.edb.Utility.Value(val)
-        m1 = re.findall(r"(?<=[/+-/*//^/(/[])([a-z_A-Z/$]\w*)", str(val).replace(" ", ""))
-        m2 = re.findall(r"^([a-z_A-Z/$]\w*)", str(val).replace(" ", ""))
-        val_decomposed = list(set(m1).union(m2))
-        if not val_decomposed:
-            return self.edb.Utility.Value(val)
-        var_server_db = self.db.GetVariableServer()
-        var_names = var_server_db.GetAllVariableNames()
-        var_server_cell = self.active_cell.GetVariableServer()
-        var_names_cell = var_server_cell.GetAllVariableNames()
-        if set(val_decomposed).intersection(var_names_cell):
-            return self.edb.Utility.Value(val, var_server_cell)
-        if set(val_decomposed).intersection(var_names):
-            return self.edb.Utility.Value(val, var_server_db)
-        return self.edb.Utility.Value(val)
+        if not coord_system_center:
+            coord_system_center = [0, 0, 0]
+        t_matrix = self._ifft
+        x_c_list = self.variation_values(u_axis)
+        y_c_list = self.variation_values(v_axis)
+
+        adj_x = coord_system_center[0]
+        adj_y = coord_system_center[1]
+        adj_z = coord_system_center[2]
+        if num_frames:
+            frames = num_frames
+        else:
+            frames = t_matrix.shape[0]
+        csv_list = []
+        if os.path.exists(csv_dir):
+            files = [os.path.join(csv_dir, f) for f in os.listdir(csv_dir) if name_str in f and ".csv" in f]
+            for file in files:
+                os.remove(file)
+        else:
+            os.mkdir(csv_dir)
+
+        for frame in range(frames):
+            output = os.path.join(csv_dir, name_str + str(frame) + ".csv")
+            list_full = [["x", "y", "z", "val"]]
+            for i, y in enumerate(y_c_list):
+                for j, x in enumerate(x_c_list):
+                    y_coord = y + adj_y
+                    x_coord = x + adj_x
+                    z_coord = adj_z
+                    if db_val:
+                        val = 10.0 * np.log10(np.abs(t_matrix[frame, i, j]))
+                    else:
+                        val = t_matrix[frame, i, j]
+                    row_lst = [x_coord, y_coord, z_coord, val]
+                    list_full.append(row_lst)
+            write_csv(output, list_full, delimiter=",")
+            csv_list.append(output)
+
+        txt_file_name = csv_dir + "fft_list.txt"
+        textfile = open_file(txt_file_name, "w")
+
+        for element in csv_list:
+            textfile.write(element + "\n")
+        textfile.close()
+        return txt_file_name
 
-    @pyaedt_function_handler()
-    def _is_file_existing_and_released(self, filename):
-        if os.path.exists(filename):
-            try:
-                os.rename(filename, filename + "_")
-                os.rename(filename + "_", filename)
-                return True
-            except OSError as e:
-                return False
-        else:
-            return False
-
-    @pyaedt_function_handler()
-    def _is_file_existing(self, filename):
-        if os.path.exists(filename):
-            return True
-        else:
-            return False
 
-    @pyaedt_function_handler()
-    def _wait_for_file_release(self, timeout=30, file_to_release=None):
-        if not file_to_release:
-            file_to_release = os.path.join(self.edbpath)
-        tstart = time.time()
-        while True:
-            if self._is_file_existing_and_released(file_to_release):
-                return True
-            elif time.time() - tstart > timeout:
-                return False
-            else:
-                time.sleep(0.250)
+class FfdSolutionData(object):
+    """Contains Hfss Far Field Solution Data (ffd)."""
 
-    @pyaedt_function_handler()
-    def _wait_for_file_exists(self, timeout=30, file_to_release=None, wait_count=4):
-        if not file_to_release:
-            file_to_release = os.path.join(self.edbpath)
-        tstart = time.time()
-        times = 0
-        while True:
-            if self._is_file_existing(file_to_release):
-                # print 'File is released'
-                times += 1
-                if times == wait_count:
-                    return True
-            elif time.time() - tstart > timeout:
-                # print 'Timeout reached'
-                return False
-            else:
-                times = 0
-                time.sleep(0.250)
+    def __init__(
+        self,
+        app,
+        sphere_name,
+        setup_name,
+        frequencies,
+        variations=None,
+        overwrite=True,
+        taper="flat",
+        sbr_3d_comp_name=None,
+    ):
+        self._app = app
+        self.levels = 64
+        self._native_indexes = []
+        self._port_indexes = {}
+        self.all_max = 1
+        self.sphere_name = sphere_name
+        self.setup_name = setup_name
+        self.sbr_comp = sbr_3d_comp_name
+        if not isinstance(frequencies, list):
+            self.frequencies = [frequencies]
+        else:
+            self.frequencies = frequencies
+        self._frequency = self.frequencies[0]
+        self.variations = variations
+        self.overwrite = overwrite
+        self._all_solutions = self._export_all_ffd()
+        self.ffd_dict = self._all_solutions[0]
+        self.lattice_vectors = self.get_lattice_vectors()
+        self.taper = taper
+        self.data_dict = {}
+        self._init_ffd()
+        self._phase_offset = [0] * len(self.all_port_names)
+
+    @pyaedt_function_handler()
+    def _init_ffd(self):
+        all_ports = list(self.ffd_dict.keys())
+        valid_ffd = True
+
+        if os.path.exists(self.ffd_dict[all_ports[0]]):
+            with open(self.ffd_dict[all_ports[0]], "r") as reader:
+                theta = [int(i) for i in reader.readline().split()]
+                phi = [int(i) for i in reader.readline().split()]
+            reader.close()
+            for port in self.ffd_dict.keys():
+                if ":" in port:
+                    port = port.split(":")[0]
+                temp_dict = {}
+                theta_range = np.linspace(*theta)
+                phi_range = np.linspace(*phi)
+                if os.path.exists(self.ffd_dict[port]):
+                    eep_txt = np.loadtxt(self.ffd_dict[port], skiprows=4)
+                    Etheta = np.vectorize(complex)(eep_txt[:, 0], eep_txt[:, 1])
+                    Ephi = np.vectorize(complex)(eep_txt[:, 2], eep_txt[:, 3])
+                    # eep=np.column_stack((etheta, ephi))
+                    temp_dict["Theta"] = theta_range
+                    temp_dict["Phi"] = phi_range
+                    temp_dict["rETheta"] = Etheta
+                    temp_dict["rEPhi"] = Ephi
+                    self.data_dict[port] = temp_dict
+                else:
+                    valid_ffd = False
+            if valid_ffd:
+                # differential area of sphere, based on observation angle
+                self.d_theta = np.abs(theta_range[1] - theta_range[0])
+                self.d_phi = np.abs(phi_range[1] - phi_range[0])
+                self.diff_area = np.radians(self.d_theta) * np.radians(self.d_phi) * np.sin(np.radians(theta_range))
+                self.num_samples = len(temp_dict["rETheta"])
+                self.all_port_names = list(self.data_dict.keys())
+                if self._native_indexes:
+                    i = 0
+                    for p in self.all_port_names:
+                        self._port_indexes[p] = self._native_indexes[i]
+                        i += 1
+                else:
+                    for p in self.all_port_names:
+                        self._port_indexes[p] = self.get_array_index(p)
+                self.solution_type = "DrivenModal"
+                self.unique_beams = None
+                self.renormalize = False
+                self.renormalize_dB = True
+                self.renorm_value = 1
+        else:
+            valid_ffd = False
+            self._app.logger.info("ERROR: Far Field Files are Missing")
+        self.valid_ffd = valid_ffd
+        self.Ax = float(self.lattice_vectors[0])
+        self.Ay = float(self.lattice_vectors[1])
+        self.Bx = float(self.lattice_vectors[3])
+        self.By = float(self.lattice_vectors[4])
+        self._phase_offset = [0] * len(self.all_port_names)
+        self._mag_offset = [1] * len(self.all_port_names)
+        self.beamform()
 
-    @pyaedt_function_handler()
-    def close_edb(self):
-        """Close EDB and cleanup variables.
+    @property
+    def frequency(self):
+        """Get/set the Active Frequency.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
+        float
         """
-        self._db.Close()
-        if self.log_name and settings.enable_local_log_file:
-            self._global_logger.remove_file_logger(os.path.splitext(os.path.split(self.log_name)[-1])[0])
-            self._logger = self._global_logger
-        time.sleep(2)
-        start_time = time.time()
-        self._wait_for_file_release()
-        elapsed_time = time.time() - start_time
-        self.logger.info("EDB file release time: {0:.2f}ms".format(elapsed_time * 1000.0))
-        self._clean_variables()
-        timeout = 4
-        time.sleep(2)
-        while gc.collect() != 0 and timeout > 0:
-            time.sleep(1)
-            timeout -= 1
-        return True
+        return self._frequency
 
-    @pyaedt_function_handler()
-    def save_edb(self):
-        """Save the EDB file.
+    @frequency.setter
+    def frequency(self, val):
+        if val in self.frequencies:
+            self._frequency = val
+            self.ffd_dict = self._all_solutions[self.frequencies.index(val)]
+            self._init_ffd()
+
+    @property
+    def phase_offset(self):
+        """Additional phase offset in degrees on each port. Useful when element has more than one port.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
+        list
         """
-        self._db.Save()
-        return True
+        return self._phase_offset
 
-    @pyaedt_function_handler()
-    def save_edb_as(self, fname):
-        """Save the EDB file as another file.
+    @phase_offset.setter
+    def phase_offset(self, phases):
+        if len(phases) != len(self.all_port_names):
+            self._app.logger.error("Number of phases must be equal to number of ports")
+        else:
+            phases_to_rad = []
+            for phase in phases:
+                phases_to_rad.append(math.radians(phase))
+            self._phase_offset = phases_to_rad
+            self.beamform()
 
-        Parameters
-        ----------
-        fname : str
-            Name of the new file to save to.
+    @property
+    def mag_offset(self):
+        """Additional magnitude on each port. Useful when element has more than one port.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
+        list
         """
-        self._db.SaveAs(fname)
-        self.edbpath = self._db.GetDirectory()
-        if self.log_name:
-            self._global_logger.remove_file_logger(os.path.splitext(os.path.split(self.log_name)[-1])[0])
-            self._logger = self._global_logger
+        return self._mag_offset
 
-        self.log_name = os.path.join(
-            os.path.dirname(fname), "pyaedt_" + os.path.splitext(os.path.split(fname)[-1])[0] + ".log"
-        )
-        if settings.enable_local_log_file:
-            self._logger = self._global_logger.add_file_logger(self.log_name, "Edb")
-        return True
+    @mag_offset.setter
+    def mag_offset(self, mags):
+        if len(mags) != len(self.all_port_names):
+            self._app.logger.error("Number of magnitude must be equal to number of ports")
+        else:
+            self._mag_offset = mags
+            self.beamform()
 
     @pyaedt_function_handler()
-    def execute(self, func):
-        """Execute a function.
+    def get_array_index(self, port_name):
+        """Get index of a given port.
 
         Parameters
         ----------
-        func : str
-            Function to execute.
-
+        port_name : str
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
+        list of int
         """
-        return self.edb.Utility.Command.Execute(func)
+        if self._port_indexes and port_name in self._port_indexes:
+            return self._port_indexes[port_name]
+        try:
+            str1 = port_name.split("[", 1)[1].split("]", 1)[0]
+            index_str = [int(i) for i in str1.split(",")]
+        except:
+            return [1, 1]
+        return index_str
 
     @pyaedt_function_handler()
-    def import_cadence_file(self, inputBrd, WorkDir=None, anstranslator_full_path="", use_ppe=False):
-        """Import a board file and generate an ``edb.def`` file in the working directory.
-
-        Parameters
-        ----------
-        inputBrd : str
-            Full path to the board file.
-        WorkDir : str, optional
-            Directory in which to create the ``aedb`` folder. The default value is ``None``,
-            in which case the AEDB file is given the same name as the board file. Only
-            the extension differs.
-        anstranslator_full_path : str, optional
-            Full path to the Ansys translator.
-        use_ppe : bool, optional
-            Whether to use the PPE License. The default is ``False``.
+    def array_min_max_values(self):
+        """Array bounding box.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
+        list of float
         """
-        if self.import_layout_pcb(
-            inputBrd, working_dir=WorkDir, anstranslator_full_path=anstranslator_full_path, use_ppe=use_ppe
-        ):
-            return True
-        else:
-            return False
+        row_min = 1
+        row_max = 1
+        col_min = 1
+        col_max = 1
+        rows = []
+        cols = []
+        for portstring in self.all_port_names:
+            index_str = self.get_array_index(portstring)
+            rows.append(index_str[1])
+            cols.append(index_str[0])
 
-    @pyaedt_function_handler()
-    def import_gds_file(self, inputGDS, WorkDir=None, anstranslator_full_path="", use_ppe=False, control_file=None):
-        """Import a GDS file and generate an ``edb.def`` file in the working directory.
+        row_min = np.min(rows)
+        row_max = np.max(rows)
+        col_min = np.min(cols)
+        col_max = np.max(cols)
+        return [col_min, col_max, row_min, row_max]
 
-        Parameters
-        ----------
-        inputGDS : str
-            Full path to the GDS file.
-        WorkDir : str, optional
-            Directory in which to create the ``aedb`` folder. The default value is ``None``,
-            in which case the AEDB file is given the same name as the GDS file. Only the extension
-            differs.
-        anstranslator_full_path : str, optional
-            Full path to the Ansys translator.
-        use_ppe : bool, optional
-            Whether to use the PPE License. The default is ``False``.
-        control_file : str, optional
-            Path to the XML file. The default is ``None``, in which case an attempt is made to find
-            the XML file in the same directory as the GDS file. To succeed, the XML file and GDS file must
-            have the same name. Only the extension differs.
+    @pyaedt_function_handler()
+    def array_center_and_edge(self):
+        """Find the center and edge of our array, assumes all ports in far field
+        mapping file are active ports.
 
         Returns
         -------
         bool
-            ``True`` when successful, ``False`` when failed.
-
         """
-        if self.import_layout_pcb(
-            inputGDS,
-            working_dir=WorkDir,
-            anstranslator_full_path=anstranslator_full_path,
-            use_ppe=use_ppe,
-            control_file=control_file,
-        ):
-            return True
-        else:
-            return False
-
-    @pyaedt_function_handler()
-    def _create_extent(
-        self,
-        net_signals,
-        extent_type,
-        expansion_size,
-        use_round_corner,
-        use_pyaedt_extent=False,
-    ):
-        if extent_type in ["Conforming", self.edb.Geometry.ExtentType.Conforming, 1]:
-            if use_pyaedt_extent:
-                _poly = self._create_conformal(net_signals, expansion_size, 1e-12, use_round_corner, expansion_size)
-            else:
-                _poly = self.active_layout.GetExpandedExtentFromNets(
-                    net_signals, self.edb.Geometry.ExtentType.Conforming, expansion_size, False, use_round_corner, 1
-                )
-        elif extent_type in ["Bounding", self.edb.Geometry.ExtentType.BoundingBox, 0]:
-            _poly = self.active_layout.GetExpandedExtentFromNets(
-                net_signals, self.edb.Geometry.ExtentType.BoundingBox, expansion_size, False, use_round_corner, 1
-            )
-        else:
-            if use_pyaedt_extent:
-                _poly = self._create_convex_hull(net_signals, expansion_size, 1e-12, use_round_corner, expansion_size)
-            else:
-                _poly = self.active_layout.GetExpandedExtentFromNets(
-                    net_signals, self.edb.Geometry.ExtentType.Conforming, expansion_size, False, use_round_corner, 1
-                )
-                _poly_list = convert_py_list_to_net_list([_poly])
-                _poly = self.edb.Geometry.PolygonData.GetConvexHullOfPolygons(_poly_list)
-        return _poly
-
-    @pyaedt_function_handler()
-    def _create_conformal(self, net_signals, expansion_size, tolerance, round_corner, round_extension):
-        names = []
-        _polys = []
-        for net in net_signals:
-            names.append(net.GetName())
-        for prim in self.core_primitives.primitives:
-            if prim.net_name in names:
-                obj_data = prim.primitive_object.GetPolygonData().Expand(
-                    expansion_size, tolerance, round_corner, round_extension
-                )
-                if obj_data:
-                    _polys.extend(list(obj_data))
-        _poly = self.edb.Geometry.PolygonData.Unite(convert_py_list_to_net_list(_polys))[0]
-        return _poly
-
-    @pyaedt_function_handler()
-    def _create_convex_hull(self, net_signals, expansion_size, tolerance, round_corner, round_extension):
-        names = []
-        _polys = []
-        for net in net_signals:
-            names.append(net.GetName())
-        for prim in self.core_primitives.primitives:
-            if prim.net_name in names:
-                _polys.append(prim.primitive_object.GetPolygonData())
-        _poly = self.edb.Geometry.PolygonData.GetConvexHullOfPolygons(convert_py_list_to_net_list(_polys))
-        _poly = _poly.Expand(expansion_size, tolerance, round_corner, round_extension)[0]
-        return _poly
+        AMax = 0
+        BMax = 0
+        RMax = 0
+        XMax = 0
+        YMax = 0
+        CenterA = 0
+        CenterB = 0
+        CenterX = 0
+        CenterY = 0
+
+        # collecting all active cells inside the specified region
+        activeCells = []
+
+        for i in range(0, len(self.all_port_names)):
+            index_str = self.get_array_index(self.all_port_names[i])
+            row = index_str[1]
+            col = index_str[0]
+            a = row
+            b = col
+
+            activeCells.append((a, b))  # because ffd is assuming all ffd files are active
+        if len(activeCells) == 0:
+            return
+
+        [a_min, a_max, b_min, b_max] = self.array_min_max_values()
+
+        CenterA = (a_min + a_max) / 2
+        CenterB = (b_min + b_max) / 2
+        CenterX = (CenterA + 0.5) * self.Ax + (CenterB + 0.5) * self.Bx
+        CenterY = (CenterA + 0.5) * self.Ay + (CenterB + 0.5) * self.By
+
+        self.CenterA = CenterA
+        self.CenterB = CenterB
+        self.CenterX = CenterX
+        self.CenterY = CenterY
+        # find the distance from the edge to the center
+        AMax = a_max - a_min
+        BMax = b_max - b_min
+
+        self.AMax = AMax
+        self.BMax = BMax
+        for a, b in activeCells:
+            x = (a + 0.5) * self.Ax + (b + 0.5) * self.Bx
+            y = (a + 0.5) * self.Ay + (b + 0.5) * self.By
+            x_dis = abs(x - CenterX)
+            y_dis = abs(y - CenterY)
+            distance = math.sqrt(x_dis**2 + y_dis**2)
+            XMax = max(XMax, x_dis)
+            YMax = max(YMax, y_dis)
+            RMax = max(RMax, distance)
+
+        self.RMax = RMax
+        self.XMax = XMax
+        self.YMax = YMax
+        self.RMax *= 2
+        self.XMax *= 2
+        self.YMax *= 2
+        return True
 
     @pyaedt_function_handler()
-    def cutout(
-        self,
-        signal_list=None,
-        reference_list=["GND"],
-        extent_type="ConvexHull",
-        expansion_size=0.002,
-        use_round_corner=False,
-        output_aedb_path=None,
-        open_cutout_at_end=True,
-        use_legacy_cutout=False,
-        number_of_threads=4,
-        use_pyaedt_extent_computing=True,
-        extent_defeature=0,
-        remove_single_pin_components=False,
-        custom_extent=None,
-        custom_extent_units="mm",
-        include_partial_instances=False,
-        keep_voids=True,
-    ):
-        """Create a cutout using an approach entirely based on pyaedt.
-        This new method replaces all legacy cutout methods in pyaedt.
-        It does in sequence:
-        - delete all nets not in list,
-        - create a extent of the nets,
-        - check and delete all vias not in the extent,
-        - check and delete all the primitives not in extent,
-        - check and intersect all the primitives that intersect the extent.
+    def element_location(self, a, b):
+        """Element location in the array.
 
         Parameters
         ----------
-         signal_list : list
-            List of signal strings.
-        reference_list : list, optional
-            List of references to add. The default is ``["GND"]``.
-        extent_type : str, optional
-            Type of the extension. Options are ``"Conforming"``, ``"ConvexHull"``, and
-            ``"Bounding"``. The default is ``"Conforming"``.
-        expansion_size : float, str, optional
-            Expansion size ratio in meters. The default is ``0.002``.
-        use_round_corner : bool, optional
-            Whether to use round corners. The default is ``False``.
-        output_aedb_path : str, optional
-            Full path and name for the new AEDB file. If None, then current aedb will be cutout.
-        open_cutout_at_end : bool, optional
-            Whether to open the cutout at the end. The default is ``True``.
-        use_legacy_cutout : bool, optional
-            Whether to use new PyAEDT cutout method or EDB API method.
-            New method is faster than native API method since it benefits of multithread.
-        number_of_threads : int, optional
-            Number of thread to use. Default is 4. Valid only if `use_legacy_cutout` is set to `False`.
-        use_pyaedt_extent_computing : bool, optional
-            Whether to use pyaedt extent computing (experimental) or EDB API.
-        extent_defeature : float, optional
-            Defeature the cutout before applying it to produce simpler geometry for mesh (Experimental).
-            It applies only to Conforming bounding box. Default value is ``0`` which disable it.
-         remove_single_pin_components : bool, optional
-            Remove all Single Pin RLC after the cutout is completed. Default is `False`.
-        custom_extent : list
-            Points list defining the cutout shape. This setting will override `extent_type` field.
-        custom_extent_units : str
-            Units of the point list. The default is ``"mm"``. Valid only if `custom_extend` is provided.
-        include_partial_instances : bool, optional
-            Whether to include padstack instances that have bounding boxes intersecting with point list polygons.
-            This operation may slow down the cutout export.Valid only if `custom_extend` is provided.
-        keep_voids : bool
-            Boolean used for keep or not the voids intersecting the polygon used for clipping the layout.
-            Default value is ``True``, ``False`` will remove the voids.Valid only if `custom_extend` is provided.
+        a : int
+        b : int
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
-        Examples
-        --------
-        >>> edb = Edb(r'C:\\test.aedb', edbversion="2022.2")
-        >>> edb.logger.info_timer("Edb Opening")
-        >>> edb.logger.reset_timer()
-        >>> start = time.time()
-        >>> signal_list = []
-        >>> for net in edb.core_nets.nets.keys():
-        >>>      if "3V3" in net:
-        >>>           signal_list.append(net)
-        >>> power_list = ["PGND"]
-        >>> edb.cutout(signal_list=signal_list, reference_list=power_list, extent_type="Conforming")
-        >>> end_time = str((time.time() - start)/60)
-        >>> edb.logger.info("Total pyaedt cutout time in min %s", end_time)
-        >>> edb.core_nets.plot(signal_list, None, color_by_net=True)
-        >>> edb.core_nets.plot(power_list, None, color_by_net=True)
-        >>> edb.save_edb()
-        >>> edb.close_edb()
-
-
+        list of float
         """
-        if signal_list is None:
-            signal_list = []
-        if isinstance(reference_list, str):
-            reference_list = [reference_list]
-        if use_legacy_cutout and custom_extent:
-            return self._create_cutout_on_point_list(
-                custom_extent,
-                units=custom_extent_units,
-                output_aedb_path=output_aedb_path,
-                open_cutout_at_end=open_cutout_at_end,
-                nets_to_include=signal_list,
-                include_partial_instances=include_partial_instances,
-                keep_voids=keep_voids,
-            )
-        elif use_legacy_cutout:
-            return self._create_cutout_legacy(
-                signal_list=signal_list,
-                reference_list=reference_list,
-                extent_type=extent_type,
-                expansion_size=expansion_size,
-                use_round_corner=use_round_corner,
-                output_aedb_path=output_aedb_path,
-                open_cutout_at_end=open_cutout_at_end,
-                use_pyaedt_extent_computing=use_pyaedt_extent_computing,
-            )
-        else:
-            legacy_path = self.edbpath
-            result = self._create_cutout_multithread(
-                signal_list=signal_list,
-                reference_list=reference_list,
-                extent_type=extent_type,
-                expansion_size=expansion_size,
-                use_round_corner=use_round_corner,
-                number_of_threads=number_of_threads,
-                custom_extent=custom_extent,
-                output_aedb_path=output_aedb_path,
-                remove_single_pin_components=remove_single_pin_components,
-                use_pyaedt_extent_computing=use_pyaedt_extent_computing,
-                extent_defeature=extent_defeature,
-            )
-            if result and not open_cutout_at_end:
-                self.save_edb()
-                self.close_edb()
-                self.open_edb(legacy_path)
-            return result
-
-    @pyaedt_function_handler()
-    def _create_cutout_legacy(
-        self,
-        signal_list=[],
-        reference_list=["GND"],
-        extent_type="Conforming",
-        expansion_size=0.002,
-        use_round_corner=False,
-        output_aedb_path=None,
-        open_cutout_at_end=True,
-        use_pyaedt_extent_computing=False,
-        remove_single_pin_components=False,
-    ):
-        expansion_size = self.edb_value(expansion_size).ToDouble()
+        a = int(a)
+        b = int(b)
 
-        # validate nets in layout
-        net_signals = convert_py_list_to_net_list(
-            [net for net in list(self.active_layout.Nets) if net.GetName() in signal_list]
-        )
-        # validate references in layout
-        _netsClip = convert_py_list_to_net_list(
-            [net for net in list(self.active_layout.Nets) if net.GetName() in reference_list]
-        )
-
-        _poly = self._create_extent(
-            net_signals,
-            extent_type,
-            expansion_size,
-            use_round_corner,
-            use_pyaedt_extent_computing,
-        )
+        x = (a + 0.5) * self.Ax + (b + 0.5) * self.Bx
+        y = (a + 0.5) * self.Ay + (b + 0.5) * self.By
+        x_dis = x - self.CenterX
+        y_dis = y - self.CenterY
 
-        # Create new cutout cell/design
-        included_nets_list = signal_list + reference_list
-        included_nets = convert_py_list_to_net_list(
-            [net for net in list(self.active_layout.Nets) if net.GetName() in included_nets_list]
-        )
-        _cutout = self.active_cell.CutOut(included_nets, _netsClip, _poly, True)
-        # Analysis setups do not come over with the clipped design copy,
-        # so add the analysis setups from the original here.
-        id = 1
-        for _setup in self.active_cell.SimulationSetups:
-            # Empty string '' if coming from setup copy and don't set explicitly.
-            _setup_name = _setup.GetName()
-            if "GetSimSetupInfo" in dir(_setup):
-                # setup is an Ansys.Ansoft.Edb.Utility.HFSSSimulationSetup object
-                _hfssSimSetupInfo = _setup.GetSimSetupInfo()
-                _hfssSimSetupInfo.Name = "HFSS Setup " + str(id)  # Set name of analysis setup
-                # Write the simulation setup info into the cell/design setup
-                _setup.SetSimSetupInfo(_hfssSimSetupInfo)
-                _cutout.AddSimulationSetup(_setup)  # Add simulation setup to the cutout design
-                id += 1
-            else:
-                _cutout.AddSimulationSetup(_setup)  # Add simulation setup to the cutout design
-
-        _dbCells = [_cutout]
-
-        if output_aedb_path:
-            db2 = self.edb.Database.Create(output_aedb_path)
-            _success = db2.Save()
-            _dbCells = convert_py_list_to_net_list(_dbCells)
-            db2.CopyCells(_dbCells)  # Copies cutout cell/design to db2 project
-            if len(list(db2.CircuitCells)) > 0:
-                for net in list(list(db2.CircuitCells)[0].GetLayout().Nets):
-                    if not net.GetName() in included_nets_list:
-                        net.Delete()
-                _success = db2.Save()
-            for c in list(self.db.TopCircuitCells):
-                if c.GetName() == _cutout.GetName():
-                    c.Delete()
-            if open_cutout_at_end:  # pragma: no cover
-                self._db = db2
-                self.edbpath = output_aedb_path
-                self._active_cell = list(self._db.TopCircuitCells)[0]
-                self.builder = EdbBuilder(self.edbutils, self._db, self._active_cell)
-                self.edbpath = self._db.GetDirectory()
-                self._init_objects()
-                if remove_single_pin_components:
-                    self.core_components.delete_single_pin_rlc()
-                    self.logger.info_timer("Single Pins components deleted")
-                    self.core_components.refresh_components()
-            else:
-                if remove_single_pin_components:
-                    try:
-                        layout = list(db2.CircuitCells)[0].GetLayout()
-                        _cmps = [
-                            l
-                            for l in layout.Groups
-                            if l.ToString() == "Ansys.Ansoft.Edb.Cell.Hierarchy.Component" and l.GetNumberOfPins() < 2
-                        ]
-                        for _cmp in _cmps:
-                            _cmp.Delete()
-                    except:
-                        self._logger.error("Failed to remove single pin components.")
-                db2.Close()
-                source = os.path.join(output_aedb_path, "edb.def.tmp")
-                target = os.path.join(output_aedb_path, "edb.def")
-                self._wait_for_file_release(file_to_release=output_aedb_path)
-                if os.path.exists(source) and not os.path.exists(target):
-                    try:
-                        shutil.copy(source, target)
-                    except:
-                        pass
-        elif open_cutout_at_end:
-            self._active_cell = _cutout
-            self._init_objects()
-            if remove_single_pin_components:
-                self.core_components.delete_single_pin_rlc()
-                self.logger.info_timer("Single Pins components deleted")
-                self.core_components.refresh_components()
-        return True
+        return np.array([x_dis, y_dis, 0])
 
     @pyaedt_function_handler()
-    def create_cutout(
-        self,
-        signal_list=[],
-        reference_list=["GND"],
-        extent_type="Conforming",
-        expansion_size=0.002,
-        use_round_corner=False,
-        output_aedb_path=None,
-        open_cutout_at_end=True,
-        use_pyaedt_extent_computing=False,
-    ):
-        """Create a cutout using an approach entirely based on pyaedt.
-        It does in sequence:
-        - delete all nets not in list,
-        - create an extent of the nets,
-        - check and delete all vias not in the extent,
-        - check and delete all the primitives not in extent,
-        - check and intersect all the primitives that intersect the extent.
-
-        .. deprecated:: 0.6.58
-           Use new method :func:`cutout` instead.
+    def assign_weight(self, a, b, taper="flat", port_cont=0):
+        """Assign weight to array.
 
         Parameters
         ----------
-        signal_list : list
-            List of signal strings.
-        reference_list : list, optional
-            List of references to add. The default is ``["GND"]``.
-        extent_type : str, optional
-            Type of the extension. Options are ``"Conforming"``, ``"ConvexHull"``, and
-            ``"Bounding"``. The default is ``"Conforming"``.
-        expansion_size : float, str, optional
-            Expansion size ratio in meters. The default is ``0.002``.
-        use_round_corner : bool, optional
-            Whether to use round corners. The default is ``False``.
-        output_aedb_path : str, optional
-            Full path and name for the new AEDB file.
-        open_cutout_at_end : bool, optional
-            Whether to open the cutout at the end. The default
-            is ``True``.
-        use_pyaedt_extent_computing : bool, optional
-            Whether to use pyaedt extent computing (experimental).
+        a : int
+            Inndex of array, column.
+        b : int
+            Inndex of array, row.
+        taper : string, optional
+            This is the type of taper we want to apply. The default is 'flat'.
+            It can be ``"cosine"``, ``"triangular"``, ``"hamming"`` or ``"flat"``.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
+        float
+            Weight to applied to specific index of array.
         """
-        warnings.warn("Use new method `cutout` instead.", DeprecationWarning)
-        return self._create_cutout_legacy(
-            signal_list=signal_list,
-            reference_list=reference_list,
-            extent_type=extent_type,
-            expansion_size=expansion_size,
-            use_round_corner=use_round_corner,
-            output_aedb_path=output_aedb_path,
-            open_cutout_at_end=open_cutout_at_end,
-            use_pyaedt_extent_computing=use_pyaedt_extent_computing,
-        )
-
-    @pyaedt_function_handler()
-    def _create_cutout_multithread(
-        self,
-        signal_list=[],
-        reference_list=["GND"],
-        extent_type="Conforming",
-        expansion_size=0.002,
-        use_round_corner=False,
-        number_of_threads=4,
-        custom_extent=None,
-        output_aedb_path=None,
-        remove_single_pin_components=False,
-        use_pyaedt_extent_computing=False,
-        extent_defeature=0,
-    ):
-        if is_ironpython:  # pragma: no cover
-            self.logger.error("Method working only in Cpython")
-            return False
-        from concurrent.futures import ThreadPoolExecutor
-
-        if output_aedb_path:
-            self.save_edb_as(output_aedb_path)
-        self.logger.info("Cutout Multithread started.")
-        expansion_size = self.edb_value(expansion_size).ToDouble()
-
-        timer_start = self.logger.reset_timer()
-        if custom_extent:
-            reference_list = reference_list + signal_list
-            all_list = reference_list
-        else:
-            all_list = signal_list + reference_list
-        for i in self.core_nets.nets.values():
-            if i.name not in all_list:
-                i.net_object.Delete()
-        reference_pinsts = []
-        reference_prims = []
-        for i in self.core_padstack.instances.values():
-            net_name = i.net_name
-            if net_name not in all_list:
-                i.delete()
-            elif net_name in reference_list:
-                reference_pinsts.append(i)
-        for i in self.core_primitives.primitives:
-            net_name = i.net_name
-            if net_name not in all_list:
-                i.delete()
-            elif net_name in reference_list and not i.is_void:
-                reference_prims.append(i)
-        self.logger.info_timer("Net clean up")
-        self.logger.reset_timer()
-
-        if custom_extent and isinstance(custom_extent, list):
-            plane = self.core_primitives.Shape("polygon", points=custom_extent)
-            _poly = self.core_primitives.shape_to_polygon_data(plane)
-        elif custom_extent:
-            _poly = custom_extent
-        else:
-            net_signals = convert_py_list_to_net_list(
-                [net for net in list(self.active_layout.Nets) if net.GetName() in signal_list]
-            )
-            _poly = self._create_extent(
-                net_signals, extent_type, expansion_size, use_round_corner, use_pyaedt_extent_computing
-            )
-            if extent_type in ["Conforming", self.edb.Geometry.ExtentType.Conforming, 1] and extent_defeature > 0:
-                _poly = _poly.Defeature(extent_defeature)
-
-        if not _poly or _poly.IsNull():
-            self._logger.error("Failed to create Extent.")
-            return False
-        self.logger.info_timer("Expanded Net Polygon Creation")
-        self.logger.reset_timer()
-        _poly_list = convert_py_list_to_net_list([_poly])
-        prims_to_delete = []
-        poly_to_create = []
-        pins_to_delete = []
-
-        def get_polygon_data(prim):
-            return prim.primitive_object.GetPolygonData()
-
-        def intersect(poly1, poly2):
-            return list(poly1.Intersect(poly2))
-
-        def subtract(poly, voids):
-            return poly.Subtract(convert_py_list_to_net_list(poly), convert_py_list_to_net_list(voids))
-
-        def clean_prim(prim_1):  # pragma: no cover
-            pdata = get_polygon_data(prim_1)
-            int_data = _poly.GetIntersectionType(pdata)
-            if int_data == 0:
-                prims_to_delete.append(prim_1)
-            elif int_data != 2:
-                list_poly = intersect(_poly, pdata)
-                if list_poly:
-                    net = prim_1.net_name
-                    voids = prim_1.voids
-                    for p in list_poly:
-                        if p.IsNull():
-                            continue
-                        list_void = []
-                        void_to_subtract = []
-                        if voids:
-                            for void in voids:
-                                void_pdata = get_polygon_data(void)
-                                int_data2 = p.GetIntersectionType(void_pdata)
-                                if int_data2 > 2 or int_data2 == 1:
-                                    void_to_subtract.append(void_pdata)
-                                elif int_data2 == 2:
-                                    list_void.append(void_pdata)
-                            if void_to_subtract:
-                                polys_cleans = subtract(p, void_to_subtract)
-                                for polys_clean in polys_cleans:
-                                    if not polys_clean.IsNull():
-                                        void_to_append = [
-                                            v for v in list_void if polys_clean.GetIntersectionType(v) == 2
-                                        ]
-                                        poly_to_create.append([polys_clean, prim_1.layer_name, net, void_to_append])
-                            else:
-                                poly_to_create.append([p, prim_1.layer_name, net, list_void])
-                        else:
-                            poly_to_create.append([p, prim_1.layer_name, net, list_void])
 
-                prims_to_delete.append(prim_1)
+        a = int(a)
+        b = int(b)
+        if taper.lower() == "flat":  # Flat
+            return self.mag_offset[port_cont]
 
-        def pins_clean(pinst):
-            if not pinst.in_polygon(_poly, simple_check=True):
-                pins_to_delete.append(pinst)
+        cosinePow = 1
+        edgeTaper_dB = -200
 
-        with ThreadPoolExecutor(number_of_threads) as pool:
-            pool.map(lambda item: pins_clean(item), reference_pinsts)
+        edgeTaper = 10 ** ((float(edgeTaper_dB)) / 20)
 
-        for pin in pins_to_delete:
-            pin.delete()
+        threshold = 1e-10
+        length_in_direction1 = 0
+        max_length_in_dir1 = 0
+        length_in_direction2 = 0
+        max_length_in_dir2 = 0
+        w1 = w2 = None
 
-        self.logger.info_timer("Padstack Instances removal completed")
-        self.logger.reset_timer()
-
-        with ThreadPoolExecutor(number_of_threads) as pool:
-            pool.map(lambda item: clean_prim(item), reference_prims)
-
-        for el in poly_to_create:
-            self.core_primitives.create_polygon(el[0], el[1], net_name=el[2], voids=el[3])
-
-        for prim in prims_to_delete:
-            prim.delete()
-        self.logger.info_timer("Primitives cleanup completed")
-        self.logger.reset_timer()
-
-        i = 0
-        for comp, val in self.core_components.components.items():
-            if val.numpins == 0:
-                val.edbcomponent.Delete()
-                i += 1
-        self.logger.info("Deleted {} additional components".format(i))
-        if remove_single_pin_components:
-            self.core_components.delete_single_pin_rlc()
-            self.logger.info_timer("Single Pins components deleted")
+        # find the distance between current cell and array center in terms of index
+        length_in_direction1 = a - self.CenterA
+        length_in_direction2 = b - self.CenterB
+        max_length_in_dir1 = self.AMax
+        max_length_in_dir2 = self.BMax
 
-        self.core_components.refresh_components()
+        if taper.lower() == "cosine":  # Cosine
+            if max_length_in_dir1 < threshold:
+                w1 = 1
+            else:
+                w1 = (1 - edgeTaper) * (
+                    math.cos(math.pi * length_in_direction1 / max_length_in_dir1)
+                ) ** cosinePow + edgeTaper
+            if max_length_in_dir2 < threshold:
+                w2 = 1
+            else:
+                w2 = (1 - edgeTaper) * (
+                    math.cos(math.pi * length_in_direction2 / max_length_in_dir2)
+                ) ** cosinePow + edgeTaper
+        elif taper.lower() == "triangular":  # Triangular
+            if max_length_in_dir1 < threshold:
+                w1 = 1
+            else:
+                w1 = (1 - edgeTaper) * (1 - (math.fabs(length_in_direction1) / (max_length_in_dir1 / 2))) + edgeTaper
+            if max_length_in_dir2 < threshold:
+                w2 = 1
+            else:
+                w2 = (1 - edgeTaper) * (1 - (math.fabs(length_in_direction2) / (max_length_in_dir2 / 2))) + edgeTaper
+        elif taper.lower() == "hamming":  # Hamming Window
+            if max_length_in_dir1 < threshold:
+                w1 = 1
+            else:
+                w1 = 0.54 - 0.46 * math.cos(2 * math.pi * (length_in_direction1 / max_length_in_dir1 - 0.5))
+            if max_length_in_dir2 < threshold:
+                w2 = 1
+            else:
+                w2 = 0.54 - 0.46 * math.cos(2 * math.pi * (length_in_direction2 / max_length_in_dir2 - 0.5))
+        else:
+            return 0
 
-        self.logger.info_timer("Cutout completed.", timer_start)
-        self.logger.reset_timer()
-        return True
+        return w1 * w2 * self.mag_offset[port_cont]
 
     @pyaedt_function_handler()
-    def create_cutout_multithread(
-        self,
-        signal_list=[],
-        reference_list=["GND"],
-        extent_type="Conforming",
-        expansion_size=0.002,
-        use_round_corner=False,
-        number_of_threads=4,
-        custom_extent=None,
-        output_aedb_path=None,
-        remove_single_pin_components=False,
-        use_pyaedt_extent_computing=False,
-        extent_defeature=0,
-    ):
-        """Create a cutout using an approach entirely based on pyaedt.
-        It does in sequence:
-        - delete all nets not in list,
-        - create a extent of the nets,
-        - check and delete all vias not in the extent,
-        - check and delete all the primitives not in extent,
-        - check and intersect all the primitives that intersect the extent.
-
-
-        .. deprecated:: 0.6.58
-           Use new method :func:`cutout` instead.
+    def beamform(self, phi_scan=0, theta_scan=0):
+        """Compute the far field pattern calculated for a specific phi/scan angle requested.
+        This is calculated based on the lattice vector spacing and the embedded element
+        patterns of a ca-ddm or fa-ddm array in HFSS.
+        Calculates phase shifts between array elements in A and B directions,
+        PhaseShiftA and PhaseShiftB, given Wave Vector (k), lattice vectors
+        (Ax, Ay, Bx, By), Scan angles (theta, phi) using formula below
+        Phase Shift A = - (Ax*k*sin(theta)*cos(phi) + Ay*k*sin(theta)*sin(phi))
+        Phase Shift B = - (Bx*k*sin(theta)*cos(phi) + By*k*sin(theta)*sin(phi)).
 
         Parameters
         ----------
-        signal_list : list
-            List of signal strings.
-        reference_list : list, optional
-            List of references to add. The default is ``["GND"]``.
-        extent_type : str, optional
-            Type of the extension. Options are ``"Conforming"``, ``"ConvexHull"``, and
-            ``"Bounding"``. The default is ``"Conforming"``.
-        expansion_size : float, str, optional
-            Expansion size ratio in meters. The default is ``0.002``.
-        use_round_corner : bool, optional
-            Whether to use round corners. The default is ``False``.
-        number_of_threads : int, optional
-            Number of thread to use. Default is 4
-        custom_extent : list, optional
-            Custom extent to use for the cutout. It has to be a list of points [[x1,y1],[x2,y2]....] or
-            Edb PolygonData object. In this case, both signal_list and reference_list will be cut.
-        output_aedb_path : str, optional
-            Full path and name for the new AEDB file. If None, then current aedb will be cutout.
-        remove_single_pin_components : bool, optional
-            Remove all Single Pin RLC after the cutout is completed. Default is `False`.
-        use_pyaedt_extent_computing : bool, optional
-            Whether to use pyaedt extent computing (experimental).
-        extent_defeature : float, optional
-            Defeature the cutout before applying it to produce simpler geometry for mesh (Experimental).
-            It applies only to Conforming bounding box. Default value is ``0`` which disable it.
+        phi_scan : int, float
+            Spherical cs for desired scan angle of beam.
+        theta_scan: : int, float
+            Spherical cs for desired scan angle of beam.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
+        dict
+            Updated quantities dictionary.
+        """
+        num_ports = len(self.all_port_names)
+        self.array_center_and_edge()
+
+        c = 299792458
+        k = (2 * math.pi * self.frequency) / c
+
+        theta_scan = math.radians(theta_scan)
+        phi_scan = math.radians(phi_scan)
 
-        Examples
-        --------
-        >>> edb = Edb(r'C:\\test.aedb', edbversion="2022.2")
-        >>> edb.logger.info_timer("Edb Opening")
-        >>> edb.logger.reset_timer()
-        >>> start = time.time()
-        >>> signal_list = []
-        >>> for net in edb.core_nets.nets.keys():
-        >>>      if "3V3" in net:
-        >>>           signal_list.append(net)
-        >>> power_list = ["PGND"]
-        >>> edb.create_cutout_multithread(signal_list=signal_list, reference_list=power_list, extent_type="Conforming")
-        >>> end_time = str((time.time() - start)/60)
-        >>> edb.logger.info("Total pyaedt cutout time in min %s", end_time)
-        >>> edb.core_nets.plot(signal_list, None, color_by_net=True)
-        >>> edb.core_nets.plot(power_list, None, color_by_net=True)
-        >>> edb.save_edb()
-        >>> edb.close_edb()
-
-        """
-        warnings.warn("Use new method `cutout` instead.", DeprecationWarning)
-        return self._create_cutout_multithread(
-            signal_list=signal_list,
-            reference_list=reference_list,
-            extent_type=extent_type,
-            expansion_size=expansion_size,
-            use_round_corner=use_round_corner,
-            number_of_threads=number_of_threads,
-            custom_extent=custom_extent,
-            output_aedb_path=output_aedb_path,
-            remove_single_pin_components=remove_single_pin_components,
-            use_pyaedt_extent_computing=use_pyaedt_extent_computing,
-            extent_defeature=extent_defeature,
+        phase_shift_A_rad = -1 * (
+            (self.Ax * k * math.sin(theta_scan) * math.cos(phi_scan))
+            + (self.Ay * k * math.sin(theta_scan) * math.sin(phi_scan))
+        )
+        phase_shift_B_rad = -1 * (
+            (self.Bx * k * math.sin(theta_scan) * math.cos(phi_scan))
+            + (self.By * k * math.sin(theta_scan) * math.sin(phi_scan))
         )
 
-    @pyaedt_function_handler()
-    def get_conformal_polygon_from_netlist(self, netlist=None):
-        """Return an EDB conformal polygon based on a netlist.
+        w_dict = {}
+        w_dict_ang = {}
+        w_dict_mag = {}
+        array_positions = {}
+        port_cont = 0
+        for port_name in self.all_port_names:
+            index_str = self.get_array_index(port_name)
+            a = index_str[0] - 1
+            b = index_str[1] - 1
+            w_mag = np.round(np.abs(self.assign_weight(a, b, taper=self.taper, port_cont=port_cont)), 3)
+            w_ang = self.phase_offset[port_cont] + (a * phase_shift_A_rad + b * phase_shift_B_rad)
+            w_dict[port_name] = np.sqrt(w_mag) * np.exp(1j * w_ang)
+            w_dict_ang[port_name] = w_ang
+            w_dict_mag[port_name] = w_mag
+            array_positions[port_name] = self.element_location(a, b)
+            port_cont += 1
+
+        length_of_ff_data = len(self.data_dict[self.all_port_names[0]]["rETheta"])
+
+        rEtheta_fields = np.zeros((num_ports, length_of_ff_data), dtype=complex)
+        rEphi_fields = np.zeros((num_ports, length_of_ff_data), dtype=complex)
+        w = np.zeros((1, num_ports), dtype=complex)
+        # create port mapping
+        for n, port in enumerate(self.all_port_names):
+            re_theta = self.data_dict[port]["rETheta"]  # this is re_theta index of loaded data
+            re_phi = self.data_dict[port]["rEPhi"]  # this is re_ohi index of loaded data
+
+            w[0][n] = w_dict[port]  # build 1xNumPorts array of weights
+
+            rEtheta_fields[n] = re_theta
+            rEphi_fields[n] = re_phi
+
+            theta_range = self.data_dict[port]["Theta"]
+            phi_range = self.data_dict[port]["Phi"]
+            Ntheta = len(theta_range)
+            Nphi = len(phi_range)
+
+        rEtheta_fields_sum = np.dot(w, rEtheta_fields)
+        rEtheta_fields_sum = np.reshape(rEtheta_fields_sum, (Ntheta, Nphi))
+
+        rEphi_fields_sum = np.dot(w, rEphi_fields)
+        rEphi_fields_sum = np.reshape(rEphi_fields_sum, (Ntheta, Nphi))
+
+        self.all_qtys = {}
+        self.all_qtys["rEPhi"] = rEphi_fields_sum
+        self.all_qtys["rETheta"] = rEtheta_fields_sum
+        self.all_qtys["rETotal"] = np.sqrt(
+            np.power(np.abs(rEphi_fields_sum), 2) + np.power(np.abs(rEtheta_fields_sum), 2)
+        )
+        self.all_qtys["Theta"] = theta_range
+        self.all_qtys["Phi"] = phi_range
+        self.all_qtys["nPhi"] = Nphi
+        self.all_qtys["nTheta"] = Ntheta
+        pin = np.sum(np.power(np.abs(w), 2))
+        self.all_qtys["Pincident"] = pin
+        self._app.logger.info("Incident Power: %s", pin)
+        real_gain = 2 * np.pi * np.abs(np.power(self.all_qtys["rETotal"], 2)) / pin / 377
+        self.all_qtys["RealizedGain"] = real_gain
+        self.all_qtys["RealizedGain_dB"] = 10 * np.log10(real_gain)
+        self.max_gain = np.max(10 * np.log10(real_gain))
+        self.min_gain = np.min(10 * np.log10(real_gain))
+        self._app.logger.info("Peak Realized Gain: %s dB", self.max_gain)
+        self.all_qtys["Element_Location"] = array_positions
+
+        return self.all_qtys
+
+    @pyaedt_function_handler()
+    def beamform_2beams(self, phi_scan1=0, theta_scan1=0, phi_scan2=0, theta_scan2=0):
+        """Compute the far field pattern calculated for a specific phi/scan angle requested.
+        This is calculated based on the lattice vector spacing and the embedded element
+        patterns of a ca-ddm or fa-ddm array in HFSS.
 
         Parameters
         ----------
-
-        netlist : List of net names.
-            list[str]
+        phi_scan1 : int, float
+            Spherical cs for desired scan angle of beam.
+        theta_scan1: : int, float
+            Spherical cs for desired scan angle of beam.
+        phi_scan2 : int, float
+            Spherical cs for desired scan angle of second beam.
+        theta_scan2 : int, float
+            Spherical cs for desired scan angle of second beam.
 
         Returns
         -------
-        :class:`Edb.Cell.Primitive.Polygon`
-            Edb polygon object.
-
-        """
-        temp_edb_path = self.edbpath[:-5] + "_temp_aedb.aedb"
-        shutil.copytree(self.edbpath, temp_edb_path)
-        temp_edb = Edb(temp_edb_path)
-        for via in list(temp_edb.core_padstack.instances.values()):
-            via.pin.Delete()
-        if netlist:
-            nets = convert_py_list_to_net_list(
-                [net for net in list(self.active_layout.Nets) if net.GetName() in netlist]
-            )
-            _poly = temp_edb.active_layout.GetExpandedExtentFromNets(
-                nets, self.edb.Geometry.ExtentType.Conforming, 0.0, True, True, 1
-            )
-        else:
-            nets = convert_py_list_to_net_list(
-                [net for net in list(temp_edb.active_layout.Nets) if "gnd" in net.GetName().lower()]
-            )
-            _poly = temp_edb.active_layout.GetExpandedExtentFromNets(
-                nets, self.edb.Geometry.ExtentType.Conforming, 0.0, True, True, 1
-            )
-            temp_edb.close_edb()
-        if _poly:
-            return _poly
-        else:
-            return False
+        dict
+            Updated quantities dictionary.
+        """
+        num_ports = len(self.all_port_names)
+        self.array_center_and_edge()
+
+        c = 299792458
+        k = (2 * math.pi * self.frequency) / c
+
+        # ---------------------- METHOD : CalculatePhaseShifts -------------------
+        # Calculates phase shifts between array elements in A and B directions,
+        # PhaseShiftA and PhaseShiftB, given Wave Vector (k), lattice vectors
+        # (Ax, Ay, Bx, By), Scan angles (theta, phi) using formula below
+        # Phase Shift A = - (Ax*k*sin(theta)*cos(phi) + Ay*k*sin(theta)*sin(phi))
+        # Phase Shift B = - (Bx*k*sin(theta)*cos(phi) + By*k*sin(theta)*sin(phi))
+        # ------------------------------------------------------------------------
+
+        theta_scan1 = math.radians(theta_scan1)
+        phi_scan1 = math.radians(phi_scan1)
+
+        theta_scan2 = math.radians(theta_scan2)
+        phi_scan2 = math.radians(phi_scan2)
+
+        phase_shift_A_rad1 = -1 * (
+            (self.Ax * k * math.sin(theta_scan1) * math.cos(phi_scan1))
+            + (self.Ay * k * math.sin(theta_scan1) * math.sin(phi_scan1))
+        )
+        phase_shift_B_rad1 = -1 * (
+            (self.Bx * k * math.sin(theta_scan1) * math.cos(phi_scan1))
+            + (self.By * k * math.sin(theta_scan1) * math.sin(phi_scan1))
+        )
 
-    @pyaedt_function_handler()
-    def number_with_units(self, value, units=None):
-        """Convert a number to a string with units. If value is a string, it's returned as is.
+        phase_shift_A_rad2 = -1 * (
+            (self.Ax * k * math.sin(theta_scan2) * math.cos(phi_scan2))
+            + (self.Ay * k * math.sin(theta_scan2) * math.sin(phi_scan2))
+        )
+        phase_shift_B_rad2 = -1 * (
+            (self.Bx * k * math.sin(theta_scan2) * math.cos(phi_scan2))
+            + (self.By * k * math.sin(theta_scan2) * math.sin(phi_scan2))
+        )
 
-        Parameters
-        ----------
-        value : float, int, str
-            Input number or string.
-        units : optional
-            Units for formatting. The default is ``None``, which uses ``"meter"``.
+        w_dict = {}
+        w_dict_ang = {}
+        w_dict_mag = {}
+        array_positions = {}
+        port_count = 0
+        for port_name in self.all_port_names:
+            index_str = self.get_array_index(port_name)
+            a = index_str[0]
+            b = index_str[1]
+            w_mag1 = np.round(np.abs(self.assign_weight(a, b, taper=self.taper, port_cont=port_count)), 3)
+            w_ang1 = a * phase_shift_A_rad1 + b * phase_shift_B_rad1
+
+            w_mag2 = np.round(np.abs(self.assign_weight(a, b, taper=self.taper, port_cont=port_count)), 3)
+            w_ang2 = a * phase_shift_A_rad2 + b * phase_shift_B_rad2
+
+            w_dict[port_name] = np.sqrt(w_mag1) * np.exp(1j * w_ang1) + np.sqrt(w_mag2) * np.exp(1j * w_ang2)
+            w_dict_ang[port_name] = np.angle(w_dict[port_name])
+            w_dict_mag[port_name] = np.abs(w_dict[port_name])
+
+            array_positions[port_name] = self.element_location(a, b)
+            port_count += 1
+
+        length_of_ff_data = len(self.data_dict[self.all_port_names[0]]["rETheta"])
+        rEtheta_fields = np.zeros((num_ports, length_of_ff_data), dtype=complex)
+        rEphi_fields = np.zeros((num_ports, length_of_ff_data), dtype=complex)
+        w = np.zeros((1, num_ports), dtype=complex)
+        # create port mapping
+        for n, port in enumerate(self.all_port_names):
+            re_theta = self.data_dict[port]["rETheta"]  # this is re_theta index of loaded data
+            re_phi = self.data_dict[port]["rEPhi"]  # this is re_ohi index of loaded data
+
+            w[0][n] = w_dict[port]  # build 1xNumPorts array of weights
+
+            rEtheta_fields[n] = re_theta
+            rEphi_fields[n] = re_phi
+
+            theta_range = self.data_dict[port]["Theta"]
+            phi_range = self.data_dict[port]["Phi"]
+            Ntheta = len(theta_range)
+            Nphi = len(phi_range)
+
+        rEtheta_fields_sum = np.dot(w, rEtheta_fields)
+        rEtheta_fields_sum = np.reshape(rEtheta_fields_sum, (Ntheta, Nphi))
+
+        rEphi_fields_sum = np.dot(w, rEphi_fields)
+        rEphi_fields_sum = np.reshape(rEphi_fields_sum, (Ntheta, Nphi))
+
+        self.all_qtys = {}
+        self.all_qtys["rEPhi"] = rEphi_fields_sum
+        self.all_qtys["rETheta"] = rEtheta_fields_sum
+        self.all_qtys["rETotal"] = np.sqrt(
+            np.power(np.abs(rEphi_fields_sum), 2) + np.power(np.abs(rEtheta_fields_sum), 2)
+        )
+        self.all_qtys["Theta"] = theta_range
+        self.all_qtys["Phi"] = phi_range
+        self.all_qtys["nPhi"] = Nphi
+        self.all_qtys["nTheta"] = Ntheta
+        pin = np.sum(np.power(np.abs(w), 2))
+        self.all_qtys["Pincident"] = pin
+        self._app.logger.info("Incident Power: %s", pin)
+        real_gain = 2 * np.pi * np.abs(np.power(self.all_qtys["rETotal"], 2)) / pin / 377
+        self.all_qtys["RealizedGain"] = real_gain
+        self.all_qtys["RealizedGain_dB"] = 10 * np.log10(real_gain)
+        self.max_gain = np.max(10 * np.log10(real_gain))
+        self.min_gain = np.min(10 * np.log10(real_gain))
+        self._app.logger.info("Peak Realized Gain: %s dB", self.max_gain)
+        self.all_qtys["Element_Location"] = array_positions
+
+        return self.all_qtys
+
+    @pyaedt_function_handler()
+    def _get_far_field_mesh(self, qty_str="RealizedGain", convert_to_db=True):
+        if convert_to_db:
+            ff_data = 10 * np.log10(self.all_qtys[qty_str])
+
+        else:
+            ff_data = self.all_qtys[qty_str]
+        theta = np.deg2rad(np.array(self.all_qtys["Theta"]))
+        phi = np.deg2rad(np.array(self.all_qtys["Phi"]))
+        self.mesh = get_structured_mesh(theta=theta, phi=phi, ff_data=ff_data)
+
+    @pyaedt_function_handler()
+    def get_lattice_vectors(self):
+        """Compute Lattice vectors for Antenna Arrays or return default array in case of simple antenna analysis.
 
         Returns
         -------
-        str
-           String concatenating the value and unit.
-
-        """
-        if units is None:
-            units = "meter"
-        if isinstance(value, str):
-            return value
+        list of float
+        """
+        if self.sbr_comp and self.sbr_comp in self._app.modeler.user_defined_components:
+            component_props = "NativeComponentDefinitionProvider"
+            comp_obj = self._app.modeler.user_defined_components[self.sbr_comp]
+            if "Project" in list(comp_obj.native_properties.keys()):
+                # Project opened
+                project = comp_obj.native_properties["Project"]
+                proj_name = os.path.splitext(os.path.split(project)[-1])[0]
+                close = False
+                if proj_name not in self._app.project_list:
+                    close = True
+                    self._app.odesktop.OpenProject(project)
+                comp = get_pyaedt_app(proj_name, comp_obj.native_properties["Design"])
+                comp_units = comp.modeler.model_units
+                lattice_vectors = comp.omodelsetup.GetLatticeVectors()
+                source_names = [i[5:-1] for i in comp.post.available_report_quantities(quantities_category="VSWR")]
+                for port in source_names:
+                    try:
+                        str1 = port.split("[", 1)[1].split("]", 1)[0]
+                        self._native_indexes.append([int(i) for i in str1.split(",")])
+                    except:
+                        self._native_indexes.append([1, 1])
+                if close:
+                    comp.close_project()
+            else:
+                # Project not opened
+                project = comp_obj.native_properties[component_props]["Project"]
+                proj_name = os.path.splitext(os.path.split(project)[-1])[0]
+                close = False
+                if proj_name not in self._app.project_list:
+                    close = True
+                    self._app.odesktop.OpenProject(project)
+                comp = get_pyaedt_app(proj_name, comp_obj.native_properties[component_props]["Design"])
+                lattice_vectors = comp.omodelsetup.GetLatticeVectors()
+                comp_units = comp.modeler.model_units
+                source_names = [i[5:-1] for i in comp.post.available_report_quantities(quantities_category="VSWR")]
+                for port in source_names:
+                    try:
+                        str1 = port.split("[", 1)[1].split("]", 1)[0]
+                        self._native_indexes.append([int(i) for i in str1.split(",")])
+                    except:
+                        self._native_indexes.append([1, 1])
+                if close:
+                    comp.close_project(save_project=False)
+
+            lattice_vectors = [
+                str(x)
+                for x in unit_converter(
+                    values=[float(i) for i in lattice_vectors],
+                    unit_system="Length",
+                    input_units=comp_units,
+                    output_units=self._app.modeler.model_units,
+                )
+            ]
         else:
-            return "{0}{1}".format(value, units)
+            try:
+                lattice_vectors = self._app.omodelsetup.GetLatticeVectors()
+                lattice_vectors = [
+                    float(vec) * AEDT_UNITS["Length"][self._app.modeler.model_units] for vec in lattice_vectors
+                ]
+            except:
+                lattice_vectors = [0, 0, 0, 0, 1, 0]
+        return lattice_vectors
+
+    @pyaedt_function_handler()
+    def _export_all_ffd(self):
+        exported_name_base = "eep"
+        exported_name_map = exported_name_base + ".txt"
+        sol_setup_name_str = self.setup_name.replace(":", "_").replace(" ", "")
+        path_dict = []
+        for frequency in self.frequencies:
+            full_setup_str = "{}-{}-{}".format(sol_setup_name_str, self.sphere_name, frequency)
+            export_path = "{}/{}/eep/".format(self._app.working_directory, full_setup_str)
+            if settings.remote_rpc_session:
+                settings.remote_rpc_session.filemanager.makedirs(export_path)
+                file_exists = settings.remote_rpc_session.filemanager.pathexists(
+                    export_path + exported_name_base + ".txt"
+                )
+            elif not os.path.exists(export_path):
+                os.makedirs(export_path)
+                file_exists = os.path.exists(export_path + exported_name_base + ".txt")
+            else:
+                file_exists = os.path.exists(export_path + exported_name_base + ".txt")
+            path_dict.append({})
+            time_before = time.time()
+            if self.overwrite or not file_exists:
+                self._app.logger.info("Exporting Embedded Element Patterns...")
+                var = []
+                if self.variations:
+                    for k, v in self.variations.items():
+                        var.append("{}='{}'".format(k, v))
+                variation = " ".join(var)
+                try:
+                    self._app.oradfield.ExportElementPatternToFile(
+                        [
+                            "ExportFileName:=",
+                            export_path + exported_name_base + ".ffd",
+                            "SetupName:=",
+                            self.sphere_name,
+                            "IntrinsicVariationKey:=",
+                            "Freq='" + str(frequency) + "'",
+                            "DesignVariationKey:=",
+                            variation,
+                            "SolutionName:=",
+                            self.setup_name,
+                        ]
+                    )
+                except:
+                    self._app.logger.error("Failed to export one Element Pattern.")
+                    self._app.logger.error(export_path + exported_name_base + ".ffd")
 
-    @pyaedt_function_handler()
-    def arg_with_dim(self, Value, sUnits):
-        """Convert a number to a string with units. If value is a string, it's returned as is.
+            else:
+                self._app.logger.info("Using Existing Embedded Element Patterns")
+            local_path = "{}/{}/eep/".format(settings.remote_rpc_session_temp_folder, full_setup_str)
+            export_path = check_and_download_folder(local_path, export_path)
+            if os.path.exists(export_path + "/" + exported_name_map):
+                with open(export_path + "/" + exported_name_map, "r") as reader:
+                    lines = [line.split(None) for line in reader]
+                lines = lines[1:]  # remove header
+                for pattern in lines:
+                    if len(pattern) >= 2:
+                        port = pattern[0]
+                        if ":" in port:
+                            port = port.split(":")[0]
+                        path_dict[-1][port] = export_path + "/" + pattern[1] + ".ffd"
+        elapsed_time = time.time() - time_before
+        self._app.logger.info("Exporting Embedded Element Patterns...Done: %s seconds", elapsed_time)
+        return path_dict
 
-        .. deprecated:: 0.6.56
-           Use :func:`number_with_units` property instead.
+    @pyaedt_function_handler()
+    def plot_farfield_contour(
+        self,
+        qty_str="RealizedGain",
+        phi_scan=0,
+        theta_scan=0,
+        title="RectangularPlot",
+        convert_to_db=True,
+        export_image_path=None,
+    ):
+        """Create a Contour plot of specified quantity.
 
         Parameters
         ----------
-        Value : float, int, str
-            Input  number or string.
-        sUnits : optional
-            Units for formatting. The default is ``None``, which uses ``"meter"``.
+        qty_str : str, optional
+            Quantity to plot. Default `"RealizedGain"`.
+        phi_scan : float, int, optional
+            Phi Scan Angle in degree. Default `0`.
+        theta_scan : float, int, optional
+            Theta Scan Angle in degree. Default `0`.
+        title : str, optional
+            Plot title. Default `"RectangularPlot"`.
+        convert_to_db : bool, optional
+            Either if the quantity has to be converted in db or not. Default is `True`.
+        export_image_path : str, optional
+            Full path to image file. Default is None to not export.
 
         Returns
         -------
-        str
-           String concatenating the value and unit.
-
-        """
-        warnings.warn("Use :func:`number_with_units` instead.", DeprecationWarning)
-        return self.number_with_units(Value, sUnits)
+        :class:`matplotlib.plt`
+            Matplotlib fig object.
+        """
+        data = self.beamform(phi_scan, theta_scan)
+        if qty_str == "":
+            qty_to_plot = data
+            qty_str = "Data"
+        else:
+            qty_to_plot = data[qty_str]
+        qty_to_plot = np.reshape(qty_to_plot, (data["nTheta"], data["nPhi"]))
+        th, ph = np.meshgrid(data["Theta"], data["Phi"])
+
+        if convert_to_db:
+            factor = 20
+            if "Gain" in qty_str:
+                factor = 10
+            qty_to_plot = factor * np.log10(np.abs(qty_to_plot))
+
+        return plot_contour(
+            x=th,
+            y=ph,
+            qty_to_plot=qty_to_plot,
+            xlabel="Theta (degree)",
+            ylabel="Phi (degree)",
+            title=title,
+            levels=self.levels,
+            snapshot_path=export_image_path,
+        )
 
     @pyaedt_function_handler()
-    def _create_cutout_on_point_list(
+    def plot_2d_cut(
         self,
-        point_list,
-        units="mm",
-        output_aedb_path=None,
-        open_cutout_at_end=True,
-        nets_to_include=None,
-        include_partial_instances=False,
-        keep_voids=True,
+        qty_str="RealizedGain",
+        primary_sweep="phi",
+        secondary_sweep_value=0,
+        phi_scan=0,
+        theta_scan=0,
+        title="Far Field Cut",
+        convert_to_db=True,
+        export_image_path=None,
     ):
-        if point_list[0] != point_list[-1]:
-            point_list.append(point_list[0])
-        point_list = [[self.number_with_units(i[0], units), self.number_with_units(i[1], units)] for i in point_list]
-        plane = self.core_primitives.Shape("polygon", points=point_list)
-        polygonData = self.core_primitives.shape_to_polygon_data(plane)
-        _ref_nets = []
-        if nets_to_include:
-            self.logger.info("Creating cutout on {} nets.".format(len(nets_to_include)))
-        else:
-            self.logger.info("Creating cutout on all nets.")  # pragma: no cover
-
-        # Check Padstack Instances overlapping the cutout
-        pinstance_to_add = []
-        if include_partial_instances:
-            if nets_to_include:
-                pinst = [i for i in list(self.core_padstack.instances.values()) if i.net_name in nets_to_include]
-            else:
-                pinst = [i for i in list(self.core_padstack.instances.values())]
-            for p in pinst:
-                if p.in_polygon(polygonData):
-                    pinstance_to_add.append(p)
-        # validate references in layout
-        for _ref in self.core_nets.nets:
-            if nets_to_include:
-                if _ref in nets_to_include:
-                    _ref_nets.append(self.core_nets.nets[_ref].net_object)
-            else:
-                _ref_nets.append(self.core_nets.nets[_ref].net_object)  # pragma: no cover
-        if keep_voids:
-            voids = [p for p in self.core_primitives.circles if p.is_void]
-            voids2 = [p for p in self.core_primitives.polygons if p.is_void]
-            voids.extend(voids2)
-        else:
-            voids = []
-        voids_to_add = []
-        for circle in voids:
-            if polygonData.GetIntersectionType(circle.primitive_object.GetPolygonData()) >= 3:
-                voids_to_add.append(circle)
-
-        _netsClip = convert_py_list_to_net_list(_ref_nets)
-        net_signals = List[type(_ref_nets[0])]()  # pragma: no cover
-        # Create new cutout cell/design
-        _cutout = self.active_cell.CutOut(net_signals, _netsClip, polygonData)
-        layout = _cutout.GetLayout()
-        cutout_obj_coll = list(layout.PadstackInstances)
-        ids = []
-        for lobj in cutout_obj_coll:
-            ids.append(lobj.GetId())
-
-        if include_partial_instances:
-            p_missing = [i for i in pinstance_to_add if i.id not in ids]
-            self.logger.info("Added {} padstack instances after cutout".format(len(p_missing)))
-            for p in p_missing:
-                position = self.edb.Geometry.PointData(self.edb_value(p.position[0]), self.edb_value(p.position[1]))
-                net = self.core_nets.find_or_create_net(p.net_name)
-                rotation = self.edb_value(p.rotation)
-                sign_layers = list(self.stackup.signal_layers.keys())
-                if not p.start_layer:  # pragma: no cover
-                    fromlayer = self.stackup.signal_layers[sign_layers[0]]._edb_layer
-                else:
-                    fromlayer = self.stackup.signal_layers[p.start_layer]._edb_layer
+        """Create a 2D plot of specified quantity in matplotlib.
 
-                if not p.stop_layer:  # pragma: no cover
-                    tolayer = self.stackup.signal_layers[sign_layers[-1]]._edb_layer
-                else:
-                    tolayer = self.stackup.signal_layers[p.stop_layer]._edb_layer
-                padstack = None
-                for pad in list(self.core_padstack.definitions.keys()):
-                    if pad == p.padstack_definition:
-                        padstack = self.core_padstack.definitions[pad].edb_padstack
-                        padstack_instance = self.edb.Cell.Primitive.PadstackInstance.Create(
-                            _cutout.GetLayout(),
-                            net,
-                            p.name,
-                            padstack,
-                            position,
-                            rotation,
-                            fromlayer,
-                            tolayer,
-                            None,
-                            None,
-                        )
-                        padstack_instance.SetIsLayoutPin(p.is_pin)
-                        break
-
-        for void_circle in voids_to_add:
-            if void_circle.type == "Circle":
-                if is_ironpython:  # pragma: no cover
-                    res, center_x, center_y, radius = void_circle.primitive_object.GetParameters()
+        Parameters
+        ----------
+        qty_str : str, optional
+            Quantity to plot. Default `"RealizedGain"`.
+        primary_sweep : str, optional.
+            X Axis variable. Default is `"phi"`. Option is  `"theta"`.
+        secondary_sweep_value : float, list, string, optional
+            List of cuts on secondary sweep to plot. Options are `"all"`, single value float or list of float.
+        phi_scan : float, int, optional
+            Phi Scan Angle in degree. Default `0`.
+        theta_scan : float, int, optional
+            Theta Scan Angle in degree. Default `0`.
+        title : str, optional
+            Plot title. Default `"RectangularPlot"`.
+        convert_to_db : bool, optional
+            Either if the quantity has to be converted in db or not. Default is `True`.
+        export_image_path : str, optional
+            Full path to image file. Default is None to not export.
+
+
+        Returns
+        -------
+        :class:`matplotlib.plt`
+            Matplotlib fig object.
+        """
+        data = self.beamform(phi_scan, theta_scan)
+
+        data_to_plot = data[qty_str]
+        curves = []
+        if primary_sweep == "phi":
+            x_key = "Phi"
+            y_key = "Theta"
+        else:
+            y_key = "Phi"
+            x_key = "Theta"
+        x = data[x_key]
+        xlabel = x_key
+        if x_key == "Phi":
+            temp = data_to_plot
+        else:
+            temp = data_to_plot.T
+        if secondary_sweep_value == "all":
+            for el in data[y_key]:
+                idx = self._find_nearest(data[y_key], el)
+                y = temp[idx]
+                if convert_to_db:
+                    if "Gain" in qty_str or "Dir" in qty_str:
+                        y = 10 * np.log10(y)
+                    else:
+                        y = 20 * np.log10(y)
+                curves.append([x, y, "{}={}".format(y_key, el)])
+        elif isinstance(secondary_sweep_value, list):
+            list_inserted = []
+            for el in secondary_sweep_value:
+                theta_idx = self._find_nearest(data[y_key], el)
+                if theta_idx not in list_inserted:
+                    y = temp[theta_idx]
+                    if convert_to_db:
+                        if "Gain" in qty_str or "Dir" in qty_str:
+                            y = 10 * np.log10(y)
+                        else:
+                            y = 20 * np.log10(y)
+                    curves.append([x, y, "{}={}".format(y_key, el)])
+                    list_inserted.append(theta_idx)
+        else:
+            theta_idx = self._find_nearest(data[y_key], secondary_sweep_value)
+            y = temp[theta_idx]
+            if convert_to_db:
+                if "Gain" in qty_str or "Dir" in qty_str:
+                    y = 10 * np.log10(y)
                 else:
-                    res, center_x, center_y, radius = void_circle.primitive_object.GetParameters(0.0, 0.0, 0.0)
-                cloned_circle = self.edb.Cell.Primitive.Circle.Create(
-                    layout,
-                    void_circle.layer_name,
-                    void_circle.net,
-                    self.edb_value(center_x),
-                    self.edb_value(center_y),
-                    self.edb_value(radius),
-                )
-                cloned_circle.SetIsNegative(True)
-            elif void_circle.type == "Polygon":
-                cloned_polygon = self.edb.Cell.Primitive.Polygon.Create(
-                    layout, void_circle.layer_name, void_circle.net, void_circle.primitive_object.GetPolygonData()
-                )
-                cloned_polygon.SetIsNegative(True)
-        layers = [i for i in list(self.stackup.signal_layers.keys())]
-        for layer in layers:
-            layer_primitves = self.core_primitives.get_primitives(layer_name=layer)
-            if len(layer_primitves) == 0:
-                self.core_primitives.create_polygon(plane, layer, net_name="DUMMY")
-        self.logger.info("Cutout %s created correctly", _cutout.GetName())
-        id = 1
-        for _setup in self.active_cell.SimulationSetups:
-            # Empty string '' if coming from setup copy and don't set explicitly.
-            _setup_name = _setup.GetName()
-            if "GetSimSetupInfo" in dir(_setup):
-                # setup is an Ansys.Ansoft.Edb.Utility.HFSSSimulationSetup object
-                _hfssSimSetupInfo = _setup.GetSimSetupInfo()
-                _hfssSimSetupInfo.Name = "HFSS Setup " + str(id)  # Set name of analysis setup
-                # Write the simulation setup info into the cell/design setup
-                _setup.SetSimSetupInfo(_hfssSimSetupInfo)
-                _cutout.AddSimulationSetup(_setup)  # Add simulation setup to the cutout design
-                id += 1
-            else:
-                _cutout.AddSimulationSetup(_setup)  # Add simulation setup to the cutout design
-
-        _dbCells = [_cutout]
-        if output_aedb_path:
-            db2 = self.edb.Database.Create(output_aedb_path)
-            if not db2.Save():
-                self.logger.error("Failed to create new Edb. Check if the path already exists and remove it.")
-                return False
-            _dbCells = convert_py_list_to_net_list(_dbCells)
-            cell_copied = db2.CopyCells(_dbCells)  # Copies cutout cell/design to db2 project
-            cell = list(cell_copied)[0]
-            cell.SetName(os.path.basename(output_aedb_path[:-5]))
-            db2.Save()
-            for c in list(self.db.TopCircuitCells):
-                if c.GetName() == _cutout.GetName():
-                    c.Delete()
-            if open_cutout_at_end:  # pragma: no cover
-                _success = db2.Save()
-                self._db = db2
-                self.edbpath = output_aedb_path
-                self._active_cell = cell
-                self.builder = EdbBuilder(self.edbutils, self._db, self._active_cell)
-                self.edbpath = self._db.GetDirectory()
-                self._init_objects()
-            else:
-                db2.Close()
-                source = os.path.join(output_aedb_path, "edb.def.tmp")
-                target = os.path.join(output_aedb_path, "edb.def")
-                self._wait_for_file_release(file_to_release=output_aedb_path)
-                if os.path.exists(source) and not os.path.exists(target):
-                    try:
-                        shutil.copy(source, target)
-                        self.logger.warning("aedb def file manually created.")
-                    except:
-                        pass
-        return True
+                    y = 20 * np.log10(y)
+            curves.append([x, y, "{}={}".format(y_key, data[y_key][theta_idx])])
+        show_legend = True
+        if len(curves) > 15:
+            show_legend = False
+        return plot_2d_chart(
+            curves, xlabel=xlabel, ylabel=qty_str, title=title, snapshot_path=export_image_path, show_legend=show_legend
+        )
 
     @pyaedt_function_handler()
-    def create_cutout_on_point_list(
+    def polar_plot_3d(
         self,
-        point_list,
-        units="mm",
-        output_aedb_path=None,
-        open_cutout_at_end=True,
-        nets_to_include=None,
-        include_partial_instances=False,
-        keep_voids=True,
+        qty_str="RealizedGain",
+        phi_scan=0,
+        theta_scan=0,
+        title="3D Plot",
+        convert_to_db=True,
+        export_image_path=None,
     ):
-        """Create a cutout on a specified shape and save it to a new AEDB file.
-
-        .. deprecated:: 0.6.58
-           Use new method :func:`cutout` instead.
+        """Create a 3d plot of specified quantity.
 
         Parameters
         ----------
-        point_list : list
-            Points list defining the cutout shape.
-        units : str
-            Units of the point list. The default is ``"mm"``.
-        output_aedb_path : str, optional
-            Full path and name for the new AEDB file.
-            The aedb folder shall not exist otherwise the method will return ``False``.
-        open_cutout_at_end : bool, optional
-            Whether to open the cutout at the end. The default is ``True``.
-        nets_to_include : list, optional
-            List of nets to include in the cutout. The default is ``None``, in
-            which case all nets are included.
-        include_partial_instances : bool, optional
-            Whether to include padstack instances that have bounding boxes intersecting with point list polygons.
-            This operation may slow down the cutout export.
-        keep_voids : bool
-            Boolean used for keep or not the voids intersecting the polygon used for clipping the layout.
-            Default value is ``True``, ``False`` will remove the voids.
+        qty_str : str, optional
+            Quantity to plot. Default `"RealizedGain"`.
+        phi_scan : float, int, optional
+            Phi Scan Angle in degree. Default `0`.
+        theta_scan : float, int, optional
+            Theta Scan Angle in degree. Default `0`.
+        title : str, optional
+            Plot title. Default `"3D Plot"`.
+        convert_to_db : bool, optional
+            Either if the quantity has to be converted in db or not. Default is `True`.
+        export_image_path : str, optional
+            Full path to image file. Default is None to not export.
+
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
 
         """
-        warnings.warn("Use new method `cutout` instead.", DeprecationWarning)
-        return self._create_cutout_multithread(
-            point_list=point_list,
-            units=units,
-            output_aedb_path=output_aedb_path,
-            open_cutout_at_end=open_cutout_at_end,
-            nets_to_include=nets_to_include,
-            include_partial_instances=include_partial_instances,
-            keep_voids=keep_voids,
-        )
+        data = self.beamform(phi_scan, theta_scan)
+
+        if convert_to_db:
+            ff_data = 10 * np.log10(data[qty_str])
+            # renormalize to 0 and 1
+            ff_max_dB = np.max(ff_data)
+            ff_min_dB = np.min(ff_data)
+            ff_data_renorm = (ff_data - ff_min_dB) / (ff_max_dB - ff_min_dB)
+        else:
+            ff_data = data[qty_str]
+            # renormalize to 0 and 1
+            ff_max = np.max(ff_data)
+            ff_min = np.min(ff_data)
+            ff_data_renorm = (ff_data - ff_max) / (ff_max - ff_min)
+
+        theta = np.deg2rad(np.array(data["Theta"]))
+        phi = np.deg2rad(np.array(data["Phi"]))
+        phi_grid, theta_grid = np.meshgrid(phi, theta)
+        r = np.reshape(ff_data_renorm, (len(data["Theta"]), len(data["Phi"])))
+
+        x = r * np.sin(theta_grid) * np.cos(phi_grid)
+        y = r * np.sin(theta_grid) * np.sin(phi_grid)
+        z = r * np.cos(theta_grid)
+        plot_3d_chart([x, y, z], xlabel="Theta", ylabel="Phi", title=title, snapshot_path=export_image_path)
+
+    @pyaedt_function_handler()
+    def _get_geometry(self, is_antenna_array=True):
+        data = self.beamform(0, 0)
+        time_before = time.time()
+        self._app.logger.info("Exporting Geometry...")
+
+        # obj is being exported as model units, scaling factor needed for display
+        sf = AEDT_UNITS["Length"][self._app.modeler.model_units]
+
+        bounding_box = self._app.modeler.obounding_box
+        xmax = float(bounding_box[3]) - float(bounding_box[0])
+        ymax = float(bounding_box[4]) - float(bounding_box[1])
+        zmax = float(bounding_box[5]) - float(bounding_box[2])
+
+        geo_path = "{}\\geo\\".format(self._app.working_directory)
+        if not os.path.exists(geo_path):
+            os.makedirs(geo_path)
+
+        model_pv = self._app.post.get_model_plotter_geometries(plot_air_objects=False)
+
+        obj_meshes = []
+        center = []
+        if is_antenna_array:
+            i = 0
+            for obj in model_pv.objects:
+                for each in data["Element_Location"]:
+                    mesh = obj._cached_polydata
+                    translated_mesh = mesh.copy()
+                    offset_xyz = data["Element_Location"][each] / sf
+                    if np.abs(2 * offset_xyz[0]) > xmax:  # assume array is centere, factor of 2
+                        xmax = offset_xyz[0] * 2
+                    if np.abs(2 * offset_xyz[1]) > ymax:  # assume array is centere, factor of 2
+                        ymax = offset_xyz[1] * 2
+                    translated_mesh.position = offset_xyz
+                    translated_mesh.translate(offset_xyz, inplace=True)
+                    color_cad = [i / 255 for i in obj.color]
+
+                    if len(obj_meshes) > i:
+                        obj_meshes[i][0] += translated_mesh
+                    else:
+                        obj_meshes.append([translated_mesh, color_cad, obj.opacity])
+                i += 1
+                if not center:
+                    center = obj_meshes[-1][0].center
+                else:
+                    center = [i + j for i, j in zip(obj_meshes[-1][0].center, center)]
+        center = [-k / i for k in center]
+        self.all_max = np.max(np.array([xmax, ymax, zmax]))
+        elapsed_time = time.time() - time_before
+        self._app.logger.info("Exporting Geometry...Done: %s seconds", elapsed_time)
+        for mesh in obj_meshes:
+            mesh[0].translate(center, inplace=True)
+        return obj_meshes
 
     @pyaedt_function_handler()
-    def write_export3d_option_config_file(self, path_to_output, config_dictionaries=None):
-        """Write the options for a 3D export to a configuration file.
-
-        Parameters
-        ----------
-        path_to_output : str
-            Full path to the configuration file to save 3D export options to.
-
-        config_dictionaries : dict, optional
-            Configuration dictionaries. The default is ``None``.
-
-        """
-        option_config = {
-            "UNITE_NETS": 1,
-            "ASSIGN_SOLDER_BALLS_AS_SOURCES": 0,
-            "Q3D_MERGE_SOURCES": 0,
-            "Q3D_MERGE_SINKS": 0,
-            "CREATE_PORTS_FOR_PWR_GND_NETS": 0,
-            "PORTS_FOR_PWR_GND_NETS": 0,
-            "GENERATE_TERMINALS": 0,
-            "SOLVE_CAPACITANCE": 0,
-            "SOLVE_DC_RESISTANCE": 0,
-            "SOLVE_DC_INDUCTANCE_RESISTANCE": 1,
-            "SOLVE_AC_INDUCTANCE_RESISTANCE": 0,
-            "CreateSources": 0,
-            "CreateSinks": 0,
-            "LAUNCH_Q3D": 0,
-            "LAUNCH_HFSS": 0,
-        }
-        if config_dictionaries:
-            for el, val in config_dictionaries.items():
-                option_config[el] = val
-        with open(os.path.join(path_to_output, "options.config"), "w") as f:
-            for el, val in option_config.items():
-                f.write(el + " " + str(val) + "\n")
-        return os.path.join(path_to_output, "options.config")
-
-    @pyaedt_function_handler()
-    def export_hfss(self, path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False):
-        """Export EDB to HFSS.
+    def polar_plot_3d_pyvista(
+        self,
+        qty_str="RealizedGain",
+        convert_to_db=True,
+        position=None,
+        rotation=None,
+        export_image_path=None,
+        show=True,
+        show_as_standalone=False,
+    ):
+        """Create a 3d Polar Plot of Geometry with Radiation Pattern in Pyvista.
 
         Parameters
         ----------
-        path_to_output : str
-            Full path and name for saving the AEDT file.
-        net_list : list, optional
-            List of nets to export if only certain ones are to be exported.
-            The default is ``None``, in which case all nets are eported.
-        num_cores : int, optional
-            Number of cores to use for the export. The default is ``None``.
-        aedt_file_name : str, optional
-            Name of the AEDT output file without the ``.aedt`` extension. The default is ``None``,
-            in which case the default name is used.
-        hidden : bool, optional
-            Open Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.
-
-        Returns
-        -------
-        str
-            Full path to the AEDT file.
-
-        Examples
-        --------
+        qty_str : str, optional
+            Quantity to plot. Default `"RealizedGain"`.
+        convert_to_db : bool, optional
+            Either if the quantity has to be converted in db or not. Default is `True`.
+        export_image_path : str, optional
+            Full path to image file. Default is None to not export.
+        position : list, optional
+            It can be a list of numpy list of origin of plot. Default is [0,0,0].
+        rotation : list, optional
+            It can be a list of numpy list of origin of plot.
+            Default is [[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]].
+        show : bool, optional
+            Either if the plot has to be shown or not. Default is `True`.
+        show_as_standalone : bool, optional
+            Either if the plot has to be shown as standalone or not. Default is `True`.
+
+        Returns
+        -------
+        bool or :class:`Pyvista.Plotter`
+            Return :class:`Pyvista.Plotter` in case show and export_image_path is `False`.
+            In other cases return ``True`` when successful.
+
+        """
+        if not position:
+            position = np.zeros(3)
+        elif isinstance(position, (list, tuple)):
+            position = np.array(position)
+        if not rotation:
+            rotation = np.eye(3)
+        elif isinstance(rotation, (list, tuple)):
+            rotation = np.array(rotation)
+        self.beamform(phi_scan=0, theta_scan=0)
+        plot_min = -40
+        self._get_far_field_mesh(qty_str=qty_str, convert_to_db=convert_to_db)
+
+        # plot everything together
+        rotation_euler = self._rotation_to_euler_angles(rotation) * 180 / np.pi
+
+        if not export_image_path and not show:
+            off_screen = False
+        else:
+            off_screen = not show
+
+        if show_as_standalone:
+            p = pv.Plotter(notebook=False, off_screen=off_screen)
+        else:
+            p = pv.Plotter(notebook=is_notebook(), off_screen=off_screen)
+
+        uf = UpdateBeamForm(self)
+
+        p.add_slider_widget(
+            uf.update_phi,
+            rng=[0, 360],
+            value=0,
+            title="Phi",
+            pointa=(0.55, 0.1),
+            pointb=(0.74, 0.1),
+            style="modern",
+            event_type="always",
+            title_height=0.02,
+        )
+        p.add_slider_widget(
+            uf.update_theta,
+            rng=[-180, 180],
+            value=0,
+            title="Theta",
+            pointa=(0.77, 0.1),
+            pointb=(0.98, 0.1),
+            style="modern",
+            event_type="always",
+            title_height=0.02,
+        )
 
-        >>> from pyaedt import Edb
+        # sargs = dict(height=0.4, vertical=True, position_x=0.05, position_y=0.5)
+        sargs = dict(
+            title_font_size=12,
+            label_font_size=10,
+            shadow=True,
+            n_labels=7,
+            italic=True,
+            fmt="%.1f",
+            font_family="arial",
+            vertical=True,
+            position_x=0.05,
+            position_y=0.65,
+            height=0.3,
+            width=0.06,
+            outline=True,
+        )
+        # ff_mesh_inst = p.add_mesh(uf.output,smooth_shading=True,cmap="jet",scalar_bar_args=sargs,opacity=0.5)
+        # not sure why, but smooth_shading causes this to not update
 
-        >>> edb = Edb(edbpath=r"C:\temp\myproject.aedb", edbversion="2021.2")
+        ff_mesh_inst = p.add_mesh(uf.output, cmap="jet", clim=[plot_min, self.max_gain], scalar_bar_args=sargs)
+        cad_mesh = self._get_geometry()
+        if cad_mesh:
+
+            def toggle_vis_ff(flag):
+                ff_mesh_inst.SetVisibility(flag)
+
+            def toggle_vis_cad(flag):
+                for i in cad:
+                    i.SetVisibility(flag)
+
+            def scale(value=1):
+                ff_mesh_inst.SetScale(value, value, value)
+                ff_mesh_inst.SetPosition(position)
+                ff_mesh_inst.SetOrientation(rotation_euler)
+                # p.add_mesh(ff_mesh, smooth_shading=True,cmap="jet")
+                return
+
+            p.add_checkbox_button_widget(toggle_vis_ff, value=True, size=30)
+            p.add_text("Show Far Fields", position=(70, 25), color="white", font_size=10)
+            slider_max = int(np.ceil(self.all_max / 2 / self.max_gain))
+            if slider_max > 0:
+                slider_min = 0
+                value = slider_max / 3
+            else:
+                slider_min = slider_max
+                slider_max = 0
+                value = slider_min / 3
+
+            p.add_slider_widget(
+                scale,
+                [slider_min, slider_max],
+                title="Scale Plot",
+                value=value,
+                pointa=(0.7, 0.93),
+                pointb=(0.99, 0.93),
+                style="modern",
+                title_height=0.02,
+            )
 
-        >>> options_config = {'UNITE_NETS' : 1, 'LAUNCH_Q3D' : 0}
-        >>> edb.write_export3d_option_config_file(r"C:\temp", options_config)
-        >>> edb.export_hfss(r"C:\temp")
-        "C:\\temp\\hfss_siwave.aedt"
+            cad = []
+            for cm in cad_mesh:
+                cad.append(p.add_mesh(cm[0], color=cm[1], show_scalar_bar=False, opacity=cm[2]))
+            p.add_checkbox_button_widget(toggle_vis_cad, value=True, position=(10, 70), size=30)
+            p.add_text("Show Geometry", position=(70, 75), color="white", font_size=10)
 
-        """
-        siwave_s = SiwaveSolve(self.edbpath, aedt_installer_path=self.base_path)
-        return siwave_s.export_3d_cad("HFSS", path_to_output, net_list, num_cores, aedt_file_name, hidden=hidden)
+        if export_image_path:
+            p.show(screenshot=export_image_path)
+            return True
+        elif show:  # pragma: no cover
+            p.show()
+            return True
+        return p
 
     @pyaedt_function_handler()
-    def export_q3d(self, path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False):
-        """Export EDB to Q3D.
+    def polar_plot_3d_pyvista_2beams(
+        self,
+        qty_str="RealizedGain",
+        convert_to_db=True,
+        position=None,
+        rotation=None,
+        export_image_path=None,
+        show=True,
+    ):  # pragma: no cover
+        """Create a 3d Polar Plot with 2 beams of Geometry with Radiation Pattern in Pyvista.
 
         Parameters
         ----------
-        path_to_output : str
-            Full path and name for saving the AEDT file.
-        net_list : list, optional
-            List of nets to export only if certain ones are to be exported.
-            The default is ``None``, in which case all nets are eported.
-        num_cores : int, optional
-            Number of cores to use for the export. The default is ``None``.
-        aedt_file_name : str, optional
-            Name of the AEDT output file without the ``.aedt`` extension. The default is ``None``,
-            in which case the default name is used.
-        hidden : bool, optional
-            Open Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.
+        qty_str : str, optional
+            Quantity to plot. Default `"RealizedGain"`.
+        convert_to_db : bool, optional
+            Either if the quantity has to be converted in db or not. Default is `True`.
+        export_image_path : str, optional
+            Full path to image file. Default is None to not export.
+        position : list, optional
+            It can be a list of numpy list of origin of plot. Default is [0,0,0].
+        rotation : list, optional
+            It can be a list of numpy list of origin of plot.
+            Default is [[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]].
+        show : bool, optional
+            Either if the plot has to be shown or not. Default is `True`.
 
         Returns
         -------
-        str
-            Full path to the AEDT file.
-
-        Examples
-        --------
-
-        >>> from pyaedt import Edb
-
-        >>> edb = Edb(edbpath=r"C:\temp\myproject.aedb", edbversion="2021.2")
+        bool or :class:`Pyvista.Plotter`
+            Return :class:`Pyvista.Plotter` in case show and export_image_path is `False`.
+            In other cases return ``True`` when successful.
+        """
+        if not position:
+            position = np.zeros(3)
+        elif isinstance(position, (list, tuple)):
+            position = np.array(position)
+        if not rotation:
+            rotation = np.eye(3)
+        elif isinstance(rotation, (list, tuple)):
+            rotation = np.array(rotation)
+        self.beamform_2beams(phi_scan1=0, theta_scan1=0, phi_scan2=0, theta_scan2=0)
+        self._get_far_field_mesh(qty_str=qty_str, convert_to_db=convert_to_db)
+
+        uf = Update2BeamForms(self, max_value=self.max_gain)
+        rotation_euler = self._rotation_to_euler_angles(rotation) * 180 / np.pi
+
+        if not export_image_path and not show:
+            off_screen = False
+        else:
+            off_screen = not show
+
+        p = pv.Plotter(notebook=is_notebook(), off_screen=off_screen, window_size=[1024, 768])
+
+        p.add_slider_widget(
+            uf.update_phi1,
+            rng=[0, 360],
+            value=0,
+            title="Phi1",
+            pointa=(0.35, 0.1),
+            pointb=(0.64, 0.1),
+            style="modern",
+            event_type="always",
+        )
+        p.add_slider_widget(
+            uf.update_theta1,
+            rng=[-180, 180],
+            value=0,
+            title="Theta1",
+            pointa=(0.67, 0.1),
+            pointb=(0.98, 0.1),
+            style="modern",
+            event_type="always",
+        )
 
-        >>> options_config = {'UNITE_NETS' : 1, 'LAUNCH_Q3D' : 0}
-        >>> edb.write_export3d_option_config_file(r"C:\temp", options_config)
-        >>> edb.export_q3d(r"C:\temp")
-        "C:\\temp\\q3d_siwave.aedt"
+        p.add_slider_widget(
+            uf.update_phi2,
+            rng=[0, 360],
+            value=0,
+            title="Phi2",
+            pointa=(0.35, 0.25),
+            pointb=(0.64, 0.25),
+            style="modern",
+            event_type="always",
+        )
+        p.add_slider_widget(
+            uf.update_theta2,
+            rng=[-180, 180],
+            value=0,
+            title="Theta2",
+            pointa=(0.67, 0.25),
+            pointb=(0.98, 0.25),
+            style="modern",
+            event_type="always",
+        )
+        sargs = dict(height=0.4, vertical=True, position_x=0.05, position_y=0.5)
+        # ff_mesh_inst = p.add_mesh(uf.output,smooth_shading=True,cmap="jet",scalar_bar_args=sargs,opacity=0.5)
+        # not sure why, but smooth_shading causes this to not update
+        plot_min = self.min_gain
+        ff_mesh_inst = p.add_mesh(uf.output, cmap="jet", clim=[plot_min, self.max_gain], scalar_bar_args=sargs)
+        cad_mesh = self._get_geometry()
+        if cad_mesh:
+
+            def toggle_vis_ff(flag):
+                ff_mesh_inst.SetVisibility(flag)
+
+            def toggle_vis_cad(flag):
+                for i in cad:
+                    i.SetVisibility(flag)
+
+            def scale(value=1):
+                ff_mesh_inst.SetScale(value, value, value)
+                ff_mesh_inst.SetPosition(position)
+                ff_mesh_inst.SetOrientation(rotation_euler)
+                # p.add_mesh(ff_mesh, smooth_shading=True,cmap="jet")
+                return
+
+            p.add_checkbox_button_widget(toggle_vis_ff, value=True)
+            p.add_text("Show Far Fields", position=(70, 25), color="black", font_size=12)
+            slider_max = int(np.ceil(self.all_max / 2 / self.max_gain))
+            if slider_max > 0:
+                slider_min = 0
+                value = slider_max / 3
+            else:
+                slider_min = slider_max
+                slider_max = 0
+                value = slider_min / 3
+            p.add_slider_widget(scale, [0, slider_max], title="Scale Plot", value=value)
 
-        """
+            if "MaterialIds" in cad_mesh.array_names:
+                color_display_type = cad_mesh["MaterialIds"]
+            else:
+                color_display_type = None
+            cad = []
+            for cm in cad_mesh:
+                cad.append(p.add_mesh(cm[0], color=cm[1], show_scalar_bar=False, opacity=cm[2]))
+            size = int(p.window_size[1] / 40)
+            p.add_checkbox_button_widget(toggle_vis_cad, size=size, value=True, position=(10, 70))
+            p.add_text("Show Geometry", position=(70, 75), color="black", font_size=12)
 
-        siwave_s = SiwaveSolve(self.edbpath, aedt_installer_path=self.base_path)
-        return siwave_s.export_3d_cad(
-            "Q3D", path_to_output, net_list, num_cores=num_cores, aedt_file_name=aedt_file_name, hidden=hidden
-        )
+        if export_image_path:
+            p.show(screenshot=export_image_path)
+            return True
+        elif show:
+            p.show()
+            return True
+        return p
 
+    @staticmethod
     @pyaedt_function_handler()
-    def export_maxwell(self, path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False):
-        """Export EDB to Maxwell 3D.
+    def _find_nearest(array, value):
+        idx = np.searchsorted(array, value, side="left")
+        if idx > 0 and (idx == len(array) or math.fabs(value - array[idx - 1]) < math.fabs(value - array[idx])):
+            return idx - 1
+        else:
+            return idx
+
+    @staticmethod
+    @pyaedt_function_handler()
+    def _rotation_to_euler_angles(R):
+        sy = math.sqrt(R[0, 0] * R[0, 0] + R[1, 0] * R[1, 0])
+        singular = sy < 1e-6
+        if not singular:
+            x = math.atan2(R[2, 1], R[2, 2])
+            y = math.atan2(-R[2, 0], sy)
+            z = math.atan2(R[1, 0], R[0, 0])
+        else:
+            x = math.atan2(-R[1, 2], R[1, 1])
+            y = math.atan2(-R[2, 0], sy)
+            z = 0
+        return np.array([x, y, z])
+
+
+class UpdateBeamForm:
+    def __init__(self, ff):
+        self.output = ff.mesh
+        self._phi = 0
+        self._theta = 0
+        # default parameters
+        self.ff = ff
+        self.qty_str = "RealizedGain"
+        self.convert_to_db = True
+
+    def _update_both(self):
+        self.ff.beamform(phi_scan=self._phi, theta_scan=self._theta)
+        # perc_of_maxgain= self.ff.max_gain/self.max_value
 
-        Parameters
-        ----------
-        path_to_output : str
-            Full path and name for saving the AEDT file.
-        net_list : list, optional
-            List of nets to export only if certain ones are to be
-            exported. The default is ``None``, in which case all nets are exported.
-        num_cores : int, optional
-            Number of cores to use for the export. The default is ``None.``
-        aedt_file_name : str, optional
-            Name of the AEDT output file without the ``.aedt`` extension. The default is ``None``,
-            in which case the default name is used.
-        hidden : bool, optional
-            Open Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.
+        self.ff._get_far_field_mesh(self.qty_str, self.convert_to_db)
 
-        Returns
-        -------
-        str
-            Full path to the AEDT file.
+        self.output.overwrite(self.ff.mesh)
+        return
 
-        Examples
-        --------
+    def update_phi(self, phi):
+        """Updates the Pyvista Plot with new phi value."""
+        self._phi = phi
+        self._update_both()
+
+    def update_theta(self, theta):
+        """Updates the Pyvista Plot with new theta value."""
+        self._theta = theta
+        self._update_both()
+
+
+class Update2BeamForms:
+    def __init__(self, ff, max_value=1):
+        self.max_value = max_value
+        self.output = ff.mesh
+        self._phi1 = 0
+        self._theta1 = 0
+        self._phi2 = 0
+        self._theta2 = 0
+        # default parameters
+        self.ff = ff
+        self.qty_str = "RealizedGain"
+        self.convert_to_db = True
+
+    def _update_both(self):
+        self.ff.beamform_2beams(
+            phi_scan1=self._phi1, theta_scan1=self._theta1, phi_scan2=self._phi2, theta_scan2=self._theta2
+        )
+        self.ff._get_far_field_mesh(self.qty_str, self.convert_to_db)
+        current_max = np.max(self.ff.mesh["FarFieldData"])
+        delta = self.max_value - current_max
+        self.ff.mesh["FarFieldData"] = self.ff.mesh["FarFieldData"] - delta
+        self.output.overwrite(self.ff.mesh)
+        return
 
-        >>> from pyaedt import Edb
+    def update_phi1(self, phi1):
+        """Updates the Pyvista Plot with new phi1 value."""
+        self._phi1 = phi1
+        self._update_both()
+
+    def update_theta1(self, theta1):
+        """Updates the Pyvista Plot with new theta1 value."""
+        self._theta1 = theta1
+        self._update_both()
+
+    def update_phi2(self, phi2):
+        """Updates the Pyvista Plot with new phi2 value."""
+        self._phi2 = phi2
+        self._update_both()
+
+    def update_theta2(self, theta2):
+        """Updates the Pyvista Plot with new theta2 value."""
+        self._theta2 = theta2
+        self._update_both()
 
-        >>> edb = Edb(edbpath=r"C:\temp\myproject.aedb", edbversion="2021.2")
 
-        >>> options_config = {'UNITE_NETS' : 1, 'LAUNCH_Q3D' : 0}
-        >>> edb.write_export3d_option_config_file(r"C:\temp", options_config)
-        >>> edb.export_maxwell(r"C:\temp")
-        "C:\\temp\\maxwell_siwave.aedt"
+class FieldPlot:
+    """Creates and edits field plots.
 
-        """
-        siwave_s = SiwaveSolve(self.edbpath, aedt_installer_path=self.base_path)
-        return siwave_s.export_3d_cad(
-            "Maxwell",
-            path_to_output,
-            net_list,
-            num_cores=num_cores,
-            aedt_file_name=aedt_file_name,
-            hidden=hidden,
-        )
+    Parameters
+    ----------
+    postprocessor : :class:`pyaedt.modules.PostProcessor.PostProcessor`
 
-    @pyaedt_function_handler()
-    def solve_siwave(self):
-        """Close EDB and solve it with Siwave.
+    objlist : list
+        List of objects.
+    solutionName : str
+        Name of the solution.
+    quantityName : str
+        Name of the plot or the name of the object.
+    intrinsincList : dict, optional
+        Name of the intrinsic dictionary. The default is ``{}``.
 
-        Returns
-        -------
-        str
-            Siwave project path.
-        """
-        process = SiwaveSolve(self.edbpath, aedt_version=self.edbversion)
-        try:
-            self._db.Close()
-        except:
-            pass
-        process.solve()
-        return self.edbpath[:-5] + ".siw"
+    """
 
-    @pyaedt_function_handler()
-    def export_siwave_dc_results(
+    def __init__(
         self,
-        siwave_project,
-        solution_name,
-        output_folder=None,
-        html_report=True,
-        vias=True,
-        voltage_probes=True,
-        current_sources=True,
-        voltage_sources=True,
-        power_tree=True,
-        loop_res=True,
+        postprocessor,
+        objlist=[],
+        surfacelist=[],
+        linelist=[],
+        cutplanelist=[],
+        solutionName="",
+        quantityName="",
+        intrinsincList={},
+        seedingFaces=[],
     ):
-        """Close EDB and solve it with Siwave.
+        self._postprocessor = postprocessor
+        self.oField = postprocessor.ofieldsreporter
+        self.volume_indexes = objlist
+        self.surfaces_indexes = surfacelist
+        self.line_indexes = linelist
+        self.cutplane_indexes = cutplanelist
+        self.seeding_faces = seedingFaces
+        self.solutionName = solutionName
+        self.quantityName = quantityName
+        self.intrinsincList = intrinsincList
+        self.name = "Field_Plot"
+        self.plotFolder = "Field_Plot"
+        self.Filled = False
+        self.IsoVal = "Fringe"
+        self.SmoothShade = True
+        self.AddGrid = False
+        self.MapTransparency = True
+        self.Refinement = 0
+        self.Transparency = 0
+        self.SmoothingLevel = 0
+        self.ArrowUniform = True
+        self.ArrowSpacing = 0
+        self.MinArrowSpacing = 0
+        self.MaxArrowSpacing = 0
+        self.GridColor = [255, 255, 255]
+        self.PlotIsoSurface = True
+        self.PointSize = 1
+        self.CloudSpacing = 0.5
+        self.CloudMinSpacing = -1
+        self.CloudMaxSpacing = -1
+        self.LineWidth = 4
+        self.LineStyle = "Cylinder"
+        self.IsoValType = "Tone"
+        self.NumofPoints = 100
+        self.TraceStepLength = "0.001mm"
+        self.UseAdaptiveStep = True
+        self.SeedingSamplingOption = True
+        self.SeedingPointsNumber = 15
+        self.FractionOfMaximum = 0.8
+
+    @property
+    def plotGeomInfo(self):
+        """Plot geometry information."""
+        idx = 0
+        if self.volume_indexes:
+            idx += 1
+        if self.surfaces_indexes:
+            idx += 1
+        if self.cutplane_indexes:
+            idx += 1
+        if self.line_indexes:
+            idx += 1
+        info = [idx]
+        if self.volume_indexes:
+            info.append("Volume")
+            info.append("ObjList")
+            info.append(len(self.volume_indexes))
+            for index in self.volume_indexes:
+                info.append(str(index))
+        if self.surfaces_indexes:
+            model_faces = []
+            nonmodel_faces = []
+            models = self._postprocessor.modeler.model_objects
+            for index in self.surfaces_indexes:
+                try:
+                    if isinstance(index, FacePrimitive):
+                        index = index.id
+                    oname = self._postprocessor.modeler.oeditor.GetObjectNameByFaceID(index)
+                    if oname in models:
+                        model_faces.append(str(index))
+                    else:
+                        nonmodel_faces.append(str(index))
+                except:
+                    pass
+            info.append("Surface")
+            if model_faces:
+                info.append("FacesList")
+                info.append(len(model_faces))
+                for index in model_faces:
+                    info.append(index)
+            if nonmodel_faces:
+                info.append("NonModelFaceList")
+                info.append(len(nonmodel_faces))
+                for index in nonmodel_faces:
+                    info.append(index)
+        if self.cutplane_indexes:
+            info.append("Surface")
+            info.append("CutPlane")
+            info.append(len(self.cutplane_indexes))
+            for index in self.cutplane_indexes:
+                info.append(str(index))
+        if self.line_indexes:
+            info.append("Line")
+            info.append(len(self.line_indexes))
+            for index in self.line_indexes:
+                info.append(str(index))
+        return info
+
+    @property
+    def intrinsicVar(self):
+        """Intrinsic variable.
 
-        Parameters
-        ----------
-        siwave_project : str
-            Siwave full project name.
-        solution_name : str
-            Siwave DC Analysis name.
-        output_folder : str, optional
-            Ouptu folder where files will be downloaded.
-        html_report : bool, optional
-            Either if generate or not html report. Default is `True`.
-        vias : bool, optional
-            Either if generate or not vias report. Default is `True`.
-        voltage_probes : bool, optional
-            Either if generate or not voltage probe report. Default is `True`.
-        current_sources : bool, optional
-            Either if generate or not current source report. Default is `True`.
-        voltage_sources : bool, optional
-            Either if generate or not voltage source report. Default is `True`.
-        power_tree : bool, optional
-            Either if generate or not power tree image. Default is `True`.
-        loop_res : bool, optional
-            Either if generate or not loop resistance report. Default is `True`.
         Returns
         -------
-        list
-            list of files generated.
-        """
-        process = SiwaveSolve(self.edbpath, aedt_version=self.edbversion)
-        try:
-            self._db.Close()
-        except:
-            pass
-        return process.export_dc_report(
-            siwave_project,
-            solution_name,
-            output_folder,
-            html_report,
-            vias,
-            voltage_probes,
-            current_sources,
-            voltage_sources,
-            power_tree,
-            loop_res,
-            hidden=True,
-        )
+        list or dict
+            List or dictionary of the variables for the field plot.
+        """
+        var = ""
+        if type(self.intrinsincList) is list:
+            l = 0
+            while l < len(self.intrinsincList):
+                val = self.intrinsincList[l + 1]
+                if ":=" in self.intrinsincList[l] and isinstance(self.intrinsincList[l + 1], list):
+                    val = self.intrinsincList[l + 1][0]
+                ll = self.intrinsincList[l].split(":=")
+                var += ll[0] + "='" + str(val) + "' "
+                l += 2
+        else:
+            for a in self.intrinsincList:
+                var += a + "='" + str(self.intrinsincList[a]) + "' "
+        return var
 
-    @pyaedt_function_handler()
-    def variable_exists(self, variable_name):
-        """Check if a variable exists or not.
+    @property
+    def plotsettings(self):
+        """Plot settings.
 
         Returns
         -------
-        tuple of bool and VaribleServer
-            It returns a booleand to check if the variable exists and the variable
-            server that should contain the variable.
+        list
+            List of plot settings.
         """
-        if "$" in variable_name:
-            if variable_name.index("$") == 0:
-                var_server = self.db.GetVariableServer()
+        if self.surfaces_indexes or self.cutplane_indexes:
+            arg = [
+                "NAME:PlotOnSurfaceSettings",
+                "Filled:=",
+                self.Filled,
+                "IsoValType:=",
+                self.IsoVal,
+                "SmoothShade:=",
+                self.SmoothShade,
+                "AddGrid:=",
+                self.AddGrid,
+                "MapTransparency:=",
+                self.MapTransparency,
+                "Refinement:=",
+                self.Refinement,
+                "Transparency:=",
+                self.Transparency,
+                "SmoothingLevel:=",
+                self.SmoothingLevel,
+                [
+                    "NAME:Arrow3DSpacingSettings",
+                    "ArrowUniform:=",
+                    self.ArrowUniform,
+                    "ArrowSpacing:=",
+                    self.ArrowSpacing,
+                    "MinArrowSpacing:=",
+                    self.MinArrowSpacing,
+                    "MaxArrowSpacing:=",
+                    self.MaxArrowSpacing,
+                ],
+                "GridColor:=",
+                self.GridColor,
+            ]
+        elif self.line_indexes:
+            arg = [
+                "NAME:PlotOnLineSettings",
+                ["NAME:LineSettingsID", "Width:=", self.LineWidth, "Style:=", self.LineStyle],
+                "IsoValType:=",
+                self.IsoValType,
+                "ArrowUniform:=",
+                self.ArrowUniform,
+                "NumofArrow:=",
+                self.NumofPoints,
+                "Refinement:=",
+                self.Refinement,
+            ]
+        else:
+            arg = [
+                "NAME:PlotOnVolumeSettings",
+                "PlotIsoSurface:=",
+                self.PlotIsoSurface,
+                "PointSize:=",
+                self.PointSize,
+                "Refinement:=",
+                self.Refinement,
+                "CloudSpacing:=",
+                self.CloudSpacing,
+                "CloudMinSpacing:=",
+                self.CloudMinSpacing,
+                "CloudMaxSpacing:=",
+                self.CloudMaxSpacing,
+                [
+                    "NAME:Arrow3DSpacingSettings",
+                    "ArrowUniform:=",
+                    self.ArrowUniform,
+                    "ArrowSpacing:=",
+                    self.ArrowSpacing,
+                    "MinArrowSpacing:=",
+                    self.MinArrowSpacing,
+                    "MaxArrowSpacing:=",
+                    self.MaxArrowSpacing,
+                ],
+            ]
+        return arg
 
-            else:
-                var_server = self.active_cell.GetVariableServer()
-
-        else:
-            var_server = self.active_cell.GetVariableServer()
-
-        variables = var_server.GetAllVariableNames()
-        if variable_name in list(variables):
-            return True, var_server
-        return False, var_server
-
-    @pyaedt_function_handler()
-    def get_variable(self, variable_name):
-        """Return Variable Value if variable exists.
-
-        Parameters
-        ----------
-        variable_name
+    @property
+    def surfacePlotInstruction(self):
+        """Surface plot settings.
 
         Returns
         -------
-        :class:`pyaedt.edb_core.edb_data.edbvalue.EdbValue`
+        list
+            List of surface plot settings.
+
         """
-        var_server = self.variable_exists(variable_name)
-        if var_server[0]:
-            tuple_value = var_server[1].GetVariableValue(variable_name)
-            return EdbValue(tuple_value[1])
-        self.logger.info("Variable %s doesn't exists.", variable_name)
-        return None
+        return [
+            "NAME:" + self.name,
+            "SolutionName:=",
+            self.solutionName,
+            "QuantityName:=",
+            self.quantityName,
+            "PlotFolder:=",
+            self.plotFolder,
+            "UserSpecifyName:=",
+            1,
+            "UserSpecifyFolder:=",
+            1,
+            "StreamlinePlot:=",
+            False,
+            "AdjacentSidePlot:=",
+            False,
+            "FullModelPlot:=",
+            False,
+            "IntrinsicVar:=",
+            self.intrinsicVar,
+            "PlotGeomInfo:=",
+            self.plotGeomInfo,
+            "FilterBoxes:=",
+            [0],
+            self.plotsettings,
+            "EnableGaussianSmoothing:=",
+            False,
+        ]
 
-    @pyaedt_function_handler()
-    def add_project_variable(self, variable_name, variable_value):
-        """Add a variable to edb database (project). The variable will have the prefix `$`.
+    @property
+    def surfacePlotInstructionLineTraces(self):
+        """Surface plot settings for field line traces.
 
         ..note::
-            User can use also the setitem to create or assign a variable. See example below.
-
-        Parameters
-        ----------
-        variable_name : str
-            Name of the variable. Name can be provided without ``$`` prefix.
-        variable_value : str, float
-            Value of the variable with units.
+            ``Specify seeding points on selections`` is by default set to ''by sampling''.
 
         Returns
         -------
-        tuple
-            Tuple containing the ``AddVariable`` result and variable server.
-
-        Examples
-        --------
-
-        >>> from pyaedt import Edb
-        >>> edb_app = Edb()
-        >>> boolean_1, ant_length = edb_app.add_project_variable("my_local_variable", "1cm")
-        >>> print(edb_app["$my_local_variable"])    #using getitem
-        >>> edb_app["$my_local_variable"] = "1cm"   #using setitem
+        list
+            List of plot settings for line traces.
 
         """
-        if not variable_name.startswith("$"):
-            variable_name = "${}".format(variable_name)
-        return self.add_design_variable(variable_name=variable_name, variable_value=variable_value)
-
-    @pyaedt_function_handler()
-    def add_design_variable(self, variable_name, variable_value, is_parameter=False):
-        """Add a variable to edb. The variable can be a design one or a project variable (using ``$`` prefix).
-
-        ..note::
-            User can use also the setitem to create or assign a variable. See example below.
+        return [
+            "NAME:" + self.name,
+            "SolutionName:=",
+            self.solutionName,
+            "UserSpecifyName:=",
+            0,
+            "UserSpecifyFolder:=",
+            0,
+            "QuantityName:=",
+            "QuantityName_FieldLineTrace",
+            "PlotFolder:=",
+            self.plotFolder,
+            "IntrinsicVar:=",
+            self.intrinsicVar,
+            "Trace Step Length:=",
+            self.TraceStepLength,
+            "Use Adaptive Step:=",
+            self.UseAdaptiveStep,
+            "Seeding Faces:=",
+            self.seeding_faces,
+            "Seeding Markers:=",
+            [0],
+            "Surface Tracing Objects:=",
+            self.surfaces_indexes,
+            "Volume Tracing Objects:=",
+            self.volume_indexes,
+            "Seeding Sampling Option:=",
+            self.SeedingSamplingOption,
+            "Seeding Points Number:=",
+            self.SeedingPointsNumber,
+            "Fractional of Maximal:=",
+            self.FractionOfMaximum,
+            "Discrete Seeds Option:=",
+            "Marker Point",
+            [
+                "NAME:InceptionEvaluationSettings",
+                "Gas Type:=",
+                0,
+                "Gas Pressure:=",
+                1,
+                "Use Inception:=",
+                True,
+                "Potential U0:=",
+                0,
+                "Potential K:=",
+                0,
+                "Potential A:=",
+                1,
+            ],
+            self.field_line_trace_plot_settings,
+        ]
 
-        Parameters
-        ----------
-        variable_name : str
-            Name of the variable. To added the variable as a project variable, the name
-            must begin with ``$``.
-        variable_value : str, float
-            Value of the variable with units.
-        is_parameter : bool, optional
-            Whether to add the variable as a local variable. The default is ``False``.
-            When ``True``, the variable is added as a parameter default.
+    @property
+    def field_plot_settings(self):
+        """Field Plot Settings.
 
         Returns
         -------
-        tuple
-            Tuple containing the ``AddVariable`` result and variable server.
-
-        Examples
-        --------
-
-        >>> from pyaedt import Edb
-        >>> edb_app = Edb()
-        >>> boolean_1, ant_length = edb_app.add_design_variable("my_local_variable", "1cm")
-        >>> print(edb_app["my_local_variable"])    #using getitem
-        >>> edb_app["my_local_variable"] = "1cm"   #using setitem
-        >>> boolean_2, para_length = edb_app.change_design_variable_value("my_parameter", "1m", is_parameter=True
-        >>> boolean_3, project_length = edb_app.change_design_variable_value("$my_project_variable", "1m")
-
-
+        list
+            Field Plot Settings.
         """
-        var_server = self.variable_exists(variable_name)
-        if not var_server[0]:
-            var_server[1].AddVariable(variable_name, self.edb_value(variable_value), is_parameter)
-            return True, var_server[1]
-        self.logger.error("Variable %s already exists.", variable_name)
-        return False, var_server[1]
-
-    @pyaedt_function_handler()
-    def change_design_variable_value(self, variable_name, variable_value):
-        """Change a variable value.
-        ..note::
-            User can use also the getitem to read the variable value. See example below.
+        return [
+            "NAME:FieldsPlotItemSettings",
+            [
+                "NAME:PlotOnSurfaceSettings",
+                "Filled:=",
+                self.Filled,
+                "IsoValType:=",
+                self.IsoVal,
+                "AddGrid:=",
+                self.AddGrid,
+                "MapTransparency:=",
+                self.MapTransparency,
+                "Refinement:=",
+                self.Refinement,
+                "Transparency:=",
+                self.Transparency,
+                "SmoothingLevel:=",
+                self.SmoothingLevel,
+                "ShadingType:=",
+                self.SmoothShade,
+                [
+                    "NAME:Arrow3DSpacingSettings",
+                    "ArrowUniform:=",
+                    self.ArrowUniform,
+                    "ArrowSpacing:=",
+                    self.ArrowSpacing,
+                    "MinArrowSpacing:=",
+                    self.MinArrowSpacing,
+                    "MaxArrowSpacing:=",
+                    self.MaxArrowSpacing,
+                ],
+                "GridColor:=",
+                self.GridColor,
+            ],
+        ]
 
-        Parameters
-        ----------
-        variable_name : str
-            Name of the variable.
-        variable_value : str, float
-            Value of the variable with units.
+    @property
+    def field_line_trace_plot_settings(self):
+        """Settings for the field line traces in the plot.
 
         Returns
         -------
-        tuple
-            Tuple containing the ``SetVariableValue`` result and variable server.
-
-        Examples
-        --------
-
-        >>> from pyaedt import Edb
-        >>> edb_app = Edb()
-        >>> boolean, ant_length = edb_app.add_design_variable("ant_length", "1cm")
-        >>> boolean, ant_length = edb_app.change_design_variable_value("ant_length", "1m")
-        >>> print(edb_app["ant_length"])    #using getitem
+        list
+            List of settings for the field line traces in the plot.
         """
-        var_server = self.variable_exists(variable_name)
-        if var_server[0]:
-            var_server[1].SetVariableValue(variable_name, self.edb_value(variable_value))
-            return True, var_server[1]
-        self.logger.error("Variable %s does not exists.", variable_name)
-        return False, var_server[1]
+        return [
+            "NAME:FieldLineTracePlotSettings",
+            ["NAME:LineSettingsID", "Width:=", self.LineWidth, "Style:=", self.LineStyle],
+            "IsoValType:=",
+            self.IsoValType,
+        ]
 
     @pyaedt_function_handler()
-    def get_bounding_box(self):
-        """Get the layout bounding box.
+    def create(self):
+        """Create a field plot.
 
         Returns
         -------
-        list of list of double
-            Bounding box as a [lower-left X, lower-left Y], [upper-right X, upper-right Y]) pair in meters.
+        bool
+            ``True`` when successful, ``False`` when failed.
+
         """
-        bbox = self.edbutils.HfssUtilities.GetBBox(self.active_layout)
-        return [[bbox.Item1.X.ToDouble(), bbox.Item1.Y.ToDouble()], [bbox.Item2.X.ToDouble(), bbox.Item2.Y.ToDouble()]]
+        try:
+            if self.seeding_faces:
+                self.oField.CreateFieldPlot(self.surfacePlotInstructionLineTraces, "FieldLineTrace")
+            else:
+                self.oField.CreateFieldPlot(self.surfacePlotInstruction, "Field")
+            return True
+        except:
+            return False
 
     @pyaedt_function_handler()
-    def build_simulation_project(self, simulation_setup):
-        """Build a ready-to-solve simulation project.
+    def update(self):
+        """Update the field plot.
 
-        Parameters
-        ----------
-        simulation_setup : edb_data.SimulationConfiguratiom object.
-            SimulationConfiguration object that can be instantiated or directly loaded with a
-            configuration file.
+        .. note::
+           This method works on any plot created inside PyAEDT.
+           For Plot already existing in AEDT Design it may produce incorrect results.
 
         Returns
         -------
         bool
-            ``True`` when successful, False when ``Failed``.
-
-        Examples
-        --------
-
-        >>> from pyaedt import Edb
-        >>> from pyaedt.edb_core.edb_data.simulation_configuration import SimulationConfiguration
-        >>> config_file = path_configuration_file
-        >>> source_file = path_to_edb_folder
-        >>> edb = Edb(source_file)
-        >>> sim_setup = SimulationConfiguration(config_file)
-        >>> edb.build_simulation_project(sim_setup)
-        >>> edb.save_edb()
-        >>> edb.close_edb()
-        """
-        self.logger.info("Building simulation project.")
-        legacy_name = self.edbpath
-        if simulation_setup.output_aedb:
-            self.save_edb_as(simulation_setup.output_aedb)
+            ``True`` when successful, ``False`` when failed.
+        """
         try:
-            if simulation_setup.signal_layer_etching_instances:
-                for layer in simulation_setup.signal_layer_etching_instances:
-                    if layer in self.stackup.layers:
-                        idx = simulation_setup.signal_layer_etching_instances.index(layer)
-                        if len(simulation_setup.etching_factor_instances) > idx:
-                            self.stackup[layer].etch_factor = float(simulation_setup.etching_factor_instances[idx])
-
-            self.core_nets.classify_nets(simulation_setup.power_nets, simulation_setup.signal_nets)
-            if simulation_setup.do_cutout_subdesign:
-                self.logger.info("Cutting out using method: {0}".format(simulation_setup.cutout_subdesign_type))
-                if simulation_setup.use_default_cutout:
-                    old_cell_name = self.active_cell.GetName()
-                    if self.cutout(
-                        signal_list=simulation_setup.signal_nets,
-                        reference_list=simulation_setup.power_nets,
-                        expansion_size=simulation_setup.cutout_subdesign_expansion,
-                        use_round_corner=simulation_setup.cutout_subdesign_round_corner,
-                        extent_type=simulation_setup.cutout_subdesign_type,
-                        use_legacy_cutout=True,
-                        use_pyaedt_extent_computing=False,
-                    ):
-                        self.logger.info("Cutout processed.")
-                        old_cell = self.active_cell.FindByName(
-                            self._db, self.edb.Cell.CellType.CircuitCell, old_cell_name
-                        )
-                        if old_cell:
-                            old_cell.Delete()
-                    else:  # pragma: no cover
-                        self.logger.error("Cutout failed.")
-                else:
-                    self.logger.info("Cutting out using method: {0}".format(simulation_setup.cutout_subdesign_type))
-                    self.cutout(
-                        signal_list=simulation_setup.signal_nets,
-                        reference_list=simulation_setup.power_nets,
-                        expansion_size=simulation_setup.cutout_subdesign_expansion,
-                        use_round_corner=simulation_setup.cutout_subdesign_round_corner,
-                        extent_type=simulation_setup.cutout_subdesign_type,
-                        use_pyaedt_extent_computing=True,
-                        remove_single_pin_components=True,
-                    )
-                    self.logger.info("Cutout processed.")
-            self.logger.info("Deleting existing ports.")
-            map(lambda port: port.Delete(), list(self.active_layout.Terminals))
-            map(lambda pg: pg.Delete(), list(self.active_layout.PinGroups))
-            if simulation_setup.solver_type == SolverType.Hfss3dLayout:
-                self.logger.info("Creating HFSS ports for signal nets.")
-                for cmp in simulation_setup.components:
-                    self.core_components.create_port_on_component(
-                        cmp,
-                        net_list=simulation_setup.signal_nets,
-                        do_pingroup=False,
-                        reference_net=simulation_setup.power_nets,
-                        port_type=SourceType.CoaxPort,
-                    )
-                if not self.core_hfss.set_coax_port_attributes(simulation_setup):  # pragma: no cover
-                    self.logger.error("Failed to configure coaxial port attributes.")
-                self.logger.info("Number of ports: {}".format(self.core_hfss.get_ports_number()))
-                self.logger.info("Configure HFSS extents.")
-                if simulation_setup.trim_reference_size:  # pragma: no cover
-                    self.logger.info(
-                        "Trimming the reference plane for coaxial ports: {0}".format(
-                            bool(simulation_setup.trim_reference_size)
-                        )
-                    )
-                    self.core_hfss.trim_component_reference_size(simulation_setup)  # pragma: no cover
-                self.core_hfss.configure_hfss_extents(simulation_setup)
-                if not self.core_hfss.configure_hfss_analysis_setup(simulation_setup):
-                    self.logger.error("Failed to configure HFSS simulation setup.")
-            if simulation_setup.solver_type == SolverType.SiwaveSYZ:
-                for cmp in simulation_setup.components:
-                    self.core_components.create_port_on_component(
-                        cmp,
-                        net_list=simulation_setup.signal_nets,
-                        do_pingroup=simulation_setup.do_pingroup,
-                        reference_net=simulation_setup.power_nets,
-                        port_type=SourceType.CircPort,
-                    )
-                self.logger.info("Configuring analysis setup.")
-                if not self.core_siwave.configure_siw_analysis_setup(simulation_setup):  # pragma: no cover
-                    self.logger.error("Failed to configure Siwave simulation setup.")
-
-            if simulation_setup.solver_type == SolverType.SiwaveDC:
-                self.core_components.create_source_on_component(simulation_setup.sources)
-                if not self.core_siwave.configure_siw_analysis_setup(simulation_setup):  # pragma: no cover
-                    self.logger.error("Failed to configure Siwave simulation setup.")
-            self.core_padstack.check_and_fix_via_plating()
-            self.save_edb()
-            if not simulation_setup.open_edb_after_build and simulation_setup.output_aedb:
-                self.close_edb()
-                self.edbpath = legacy_name
-                self.open_edb(True)
+            if self.seeding_faces:
+                if self.seeding_faces[0] != len(self.seeding_faces) - 1:
+                    for face in self.seeding_faces[1:]:
+                        if not isinstance(face, int):
+                            self._postprocessor.logger.error("Provide valid object id for seeding faces.")
+                            return False
+                        else:
+                            if face not in list(self._postprocessor._app.modeler.objects.keys()):
+                                self._postprocessor.logger.error("Invalid object id.")
+                                self.seeding_faces.remove(face)
+                                return False
+                    self.seeding_faces[0] = len(self.seeding_faces) - 1
+                if self.volume_indexes[0] != len(self.volume_indexes) - 1:
+                    for obj in self.volume_indexes[1:]:
+                        if not isinstance(obj, int):
+                            self._postprocessor.logger.error("Provide valid object id for in-volume object.")
+                            return False
+                        else:
+                            if obj not in list(self._postprocessor._app.modeler.objects.keys()):
+                                self._postprocessor.logger.error("Invalid object id.")
+                                self.volume_indexes.remove(obj)
+                                return False
+                    self.volume_indexes[0] = len(self.volume_indexes) - 1
+                if self.surfaces_indexes[0] != len(self.surfaces_indexes) - 1:
+                    for obj in self.surfaces_indexes[1:]:
+                        if not isinstance(obj, int):
+                            self._postprocessor.logger.error("Provide valid object id for surface object.")
+                            return False
+                        else:
+                            if obj not in list(self._postprocessor._app.modeler.objects.keys()):
+                                self._postprocessor.logger.error("Invalid object id.")
+                                self.surfaces_indexes.remove(obj)
+                                return False
+                    self.surfaces_indexes[0] = len(self.surfaces_indexes) - 1
+                self.oField.ModifyFieldPlot(self.name, self.surfacePlotInstructionLineTraces)
+            else:
+                self.oField.ModifyFieldPlot(self.name, self.surfacePlotInstruction)
             return True
-        except:  # pragma: no cover
+        except:
             return False
 
     @pyaedt_function_handler()
-    def get_statistics(self, compute_area=False):
-        """Get the EDBStatistics object.
+    def update_field_plot_settings(self):
+        """Modify the field plot settings.
+
+        .. note::
+            This method is not available for field plot line traces.
 
         Returns
         -------
-        EDBStatistics object from the loaded layout.
+        bool
+            ``True`` when successful, ``False`` when failed.
         """
-        return self.core_primitives.get_layout_statistics(evaluate_area=compute_area, net_list=None)
+        self.oField.SetFieldPlotSettings(self.name, ["NAME:FieldsPlotItemSettings", self.plotsettings])
+        return True
 
     @pyaedt_function_handler()
-    def are_port_reference_terminals_connected(self, common_reference=None):
-        """Check if all terminal references in design are connected.
-        If the reference nets are different, there is no hope for the terminal references to be connected.
-        After we have identified a common reference net we need to loop the terminals again to get
-        the correct reference terminals that uses that net.
+    def delete(self):
+        """Delete the field plot."""
+        self.oField.DeleteFieldPlot([self.name])
+        self._postprocessor.field_plots.pop(self.name, None)
+
+    @pyaedt_function_handler()
+    def change_plot_scale(self, minimum_value, maximum_value, is_log=False, is_db=False):
+        """Change Field Plot Scale.
 
         Parameters
         ----------
-        common_reference : str, optional
-            Common Reference name. If ``None`` it will be searched in ports terminal.
-            If a string is passed then all excitations must have such reference assigned.
+        minimum_value : str, float
+            Minimum value of the scale.
+        maximum_value : str, float
+            Maximum value of the scale.
+        is_log : bool, optional
+            Set to ``True`` if Log Scale is setup.
+        is_db : bool, optional
+            Set to ``True`` if dB Scale is setup.
 
         Returns
         -------
         bool
-            Either if the ports are connected to reference_name or not.
-
-        Examples
-        --------
-        >>>edb = Edb()
-        >>> edb.core_hfss.create_edge_port_vertical(prim_1_id, ["-66mm", "-4mm"], "port_ver")
-        >>> edb.core_hfss.create_edge_port_horizontal(
-        >>> ... prim_1_id, ["-60mm", "-4mm"], prim_2_id, ["-59mm", "-4mm"], "port_hori", 30, "Lower"
-        >>> ... )
-        >>> edb.core_hfss.create_wave_port(traces[0].id, trace_paths[0][0], "wave_port")
-        >>> edb.cutout(["Net1"])
-        >>> assert edb.are_port_reference_terminals_connected()
-        """
-        self.logger.reset_timer()
-        if not common_reference:
-            common_reference = list(
-                set([i.reference_net_name for i in self.excitations.values() if i.reference_net_name])
-            )
-            if len(common_reference) > 1:
-                self.logger.error("More than 1 reference found.")
-            common_reference = common_reference[0]
-        setList = [
-            set(i.reference_object.get_connected_object_id_set())
-            for i in self.excitations.values()
-            if i.reference_net_name == common_reference
-        ]
+            ``True`` if successful.
 
-        # Get the set intersections for all the ID sets.
-        iDintersection = set.intersection(*setList)
-        self.logger.info_timer(
-            "Terminal reference primitive IDs total intersections = {}\n\n".format(len(iDintersection))
-        )
+        References
+        ----------
 
-        # If the intersections are non-zero, the terminal references are connected.
-        return True if len(iDintersection) > 0 else False
+        >>> oModule.SetPlotFolderSettings
+        """
+        args = ["NAME:FieldsPlotSettings", "Real Time mode:=", True]
+        args += [
+            [
+                "NAME:ColorMaPSettings",
+                "ColorMapType:=",
+                "Spectrum",
+                "SpectrumType:=",
+                "Rainbow",
+                "UniformColor:=",
+                [127, 255, 255],
+                "RampColor:=",
+                [255, 127, 127],
+            ]
+        ]
+        args += [
+            [
+                "NAME:Scale3DSettings",
+                "minvalue:=",
+                minimum_value,
+                "maxvalue:=",
+                maximum_value,
+                "log:=",
+                not is_log,
+                "dB:=",
+                is_db,
+                "ScaleType:=",
+                1,
+            ]
+        ]
+        self.oField.SetPlotFolderSettings(self.plotFolder, args)
+        return True
 
     @pyaedt_function_handler()
-    def new_simulation_configuration(self, filename=None):
-        """New SimulationConfiguration Object.
+    def export_image(self, full_path=None, width=1920, height=1080, orientation="isometric", display_wireframe=True):
+        """Export the active plot to an image file.
 
-        Parameters
-        ----------
-        filename : str, optional
-            Input config file.
+        .. note::
+           There are some limitations on HFSS 3D Layout plots.
+
+        full_path : str, optional
+            Path for saving the image file. PNG and GIF formats are supported.
+            The default is ``None`` which export file in working_directory.
+        width : int, optional
+            Plot Width.
+        height : int, optional
+            Plot height.
+        orientation : str, optional
+            View of the exported plot. Options are ``isometric``,
+            ``top``, ``bottom``, ``right``, ``left``, ``front``,
+            ``back``, and any custom orientation.
+        display_wireframe : bool, optional
+            Set to ``True`` if the objects has to be put in wireframe mode.
 
         Returns
         -------
-        :class:`pyaedt.edb_core.edb_data.simulation_configuration.SimulationConfiguration`
-        """
-        return SimulationConfiguration(filename, self)
+        str
+            Full path to exported file if successful.
 
-    @property
-    def setups(self):
-        """Get the dictionary of all EDB HFSS and SIwave setups.
+        References
+        ----------
 
-        Returns
-        -------
-        Dict[str, :class:`pyaedt.edb_core.edb_data.hfss_simulation_setup_data.HfssSimulationSetup`] or
-        Dict[str, :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveDCSimulationSetup`] or
-        Dict[str, :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup`]
+        >>> oModule.ExportPlotImageToFile
+        >>> oModule.ExportModelImageToFile
+        >>> oModule.ExportPlotImageWithViewToFile
+        """
+        self.oField.UpdateQuantityFieldsPlots(self.plotFolder)
+        if not full_path:
+            full_path = os.path.join(self._postprocessor._app.working_directory, self.name + ".png")
+        status = self._postprocessor.export_field_jpg(
+            full_path,
+            self.name,
+            self.plotFolder,
+            orientation=orientation,
+            width=width,
+            height=height,
+            display_wireframe=display_wireframe,
+        )
+        if status:
+            return full_path
+        else:
+            return False
 
-        """
-        for i in list(self.active_cell.SimulationSetups):
-            if i.GetName() not in self._setups:
-                if i.GetType() == self.edb.Utility.SimulationSetupType.kHFSS:
-                    self._setups[i.GetName()] = HfssSimulationSetup(self, i.GetName(), i)
-                elif i.GetType() == self.edb.Utility.SimulationSetupType.kSIWave:
-                    self._setups[i.GetName()] = SiwaveSYZSimulationSetup(self, i.GetName(), i)
-                elif i.GetType() == self.edb.Utility.SimulationSetupType.kSIWaveDCIR:
-                    self._setups[i.GetName()] = SiwaveDCSimulationSetup(self, i.GetName(), i)
-        return self._setups
+    @pyaedt_function_handler()
+    def export_image_from_aedtplt(
+        self, export_path=None, view="isometric", plot_mesh=False, scale_min=None, scale_max=None
+    ):
+        """Save an image of the active plot using PyVista.
 
-    @property
-    def hfss_setups(self):
-        """Active HFSS setup in EDB.
+        .. note::
+            This method only works if the CPython with PyVista module is installed.
+
+        Parameters
+        ----------
+        export_path : str, optional
+            Path where image will be saved.
+            The default is ``None`` which export file in working_directory.
+        view : str, optional
+           View to export. Options are ``"isometric"``, ``"xy"``, ``"xz"``, ``"yz"``.
+        plot_mesh : bool, optional
+            Plot mesh.
+        scale_min : float, optional
+            Scale output min.
+        scale_max : float, optional
+            Scale output max.
 
         Returns
         -------
-        Dict[str, :class:`pyaedt.edb_core.edb_data.hfss_simulation_setup_data.HfssSimulationSetup`]
+        str
+            Full path to exported file if successful.
 
-        """
-        return {name: i for name, i in self.setups.items() if i.setup_type == "kHFSS"}
+        References
+        ----------
 
-    @property
-    def siwave_dc_setups(self):
-        """Active Siwave DC IR Setups.
+        >>> oModule.UpdateAllFieldsPlots
+        >>> oModule.UpdateQuantityFieldsPlots
+        >>> oModule.ExportFieldPlot
+        """
+        if not export_path:
+            export_path = self._postprocessor._app.working_directory
+        if sys.version_info.major > 2:
+            return self._postprocessor.plot_field_from_fieldplot(
+                self.name,
+                project_path=export_path,
+                meshplot=plot_mesh,
+                imageformat="jpg",
+                view=view,
+                plot_label=self.quantityName,
+                show=False,
+                scale_min=scale_min,
+                scale_max=scale_max,
+            )
+        else:
+            self._postprocessor.logger.info("This method works only on CPython with PyVista")
+            return False
 
-        Returns
-        -------
-        Dict[str, :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveDCSimulationSetup`]
-        """
-        return {name: i for name, i in self.setups.items() if i.setup_type == "kSIWaveDCIR"}
 
-    @property
-    def siwave_ac_setups(self):
-        """Active Siwave SYZ setups.
+class VRTFieldPlot:
+    """Creates and edits VRT field plots for SBR+ and Creeping Waves.
 
-        Returns
-        -------
-        Dict[str, :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup`]
-        """
-        return {name: i for name, i in self.setups.items() if i.setup_type == "kSIWave"}
+    Parameters
+    ----------
+    postprocessor : :class:`pyaedt.modules.PostProcessor.PostProcessor`
 
-    def create_hfss_setup(self, name=None):
-        """Create a setup from a template.
+    objlist : list
+        List of objects.
+    solutionName : str
+        Name of the solution.
+    quantity_name : str
+        Name of the plot or the name of the object.
+    intrinsincList : dict, optional
+        Name of the intrinsic dictionary. The default is ``{}``.
 
-        Parameters
-        ----------
-        name : str, optional
-            Setup name.
+    """
+
+    def __init__(
+        self,
+        postprocessor,
+        is_creeping_wave=False,
+        quantity_name="QuantityName_SBR",
+        max_frequency="1GHz",
+        ray_density=2,
+        bounces=5,
+        intrinsincList={},
+    ):
+        self.is_creeping_wave = is_creeping_wave
+        self._postprocessor = postprocessor
+        self._ofield = postprocessor.ofieldsreporter
+        self.quantity_name = quantity_name
+        self.intrinsics = intrinsincList
+        self.name = "Field_Plot"
+        self.plot_folder = "Field_Plot"
+        self.max_frequency = max_frequency
+        self.ray_density = ray_density
+        self.number_of_bounces = bounces
+        self.multi_bounce_ray_density_control = False
+        self.mbrd_max_subdivision = 2
+        self.shoot_utd_rays = False
+        self.shoot_type = "All Rays"
+        self.start_index = 0
+        self.stop_index = 1
+        self.step_index = 1
+        self.is_plane_wave = True
+        self.incident_theta = "0deg"
+        self.incident_phi = "0deg"
+        self.vertical_polarization = False
+        self.custom_location = [0, 0, 0]
+        self.ray_box = None
+        self.ray_elevation = "0deg"
+        self.ray_azimuth = "0deg"
+        self.custom_coordinatesystem = 1
+        self.ray_cutoff = 40
+        self.sample_density = 10
+        self.irregular_surface_tolerance = 50
+
+    @property
+    def intrinsicVar(self):
+        """Intrinsic variable.
+
+        Returns
+        -------
+        list or dict
+            List or dictionary of the variables for the field plot.
+        """
+        var = ""
+        if isinstance(self.intrinsics, list):
+            l = 0
+            while l < len(self.intrinsics):
+                val = self.intrinsics[l + 1]
+                if ":=" in self.intrinsics[l] and isinstance(self.intrinsics[l + 1], list):
+                    val = self.intrinsics[l + 1][0]
+                ll = self.intrinsics[l].split(":=")
+                var += ll[0] + "='" + str(val) + "' "
+                l += 2
+        else:
+            for a in self.intrinsics:
+                var += a + "='" + str(self.intrinsics[a]) + "' "
+        return var
+
+    @pyaedt_function_handler()
+    def _create_args(self):
+        args = [
+            "NAME:" + self.name,
+            "UserSpecifyName:=",
+            0,
+            "UserSpecifyFolder:=",
+            0,
+            "QuantityName:=",
+            self.quantity_name,
+            "PlotFolder:=",
+            "Visual Ray Trace SBR",
+            "IntrinsicVar:=",
+            self.intrinsicVar,
+            "MaxFrequency:=",
+            self.max_frequency,
+            "RayDensity:=",
+            self.ray_density,
+            "NumberBounces:=",
+            self.number_of_bounces,
+            "Multi-Bounce Ray Density Control:=",
+            self.multi_bounce_ray_density_control,
+            "MBRD Max sub divisions:=",
+            self.mbrd_max_subdivision,
+            "Shoot UTD Rays:=",
+            self.shoot_utd_rays,
+            "ShootFilterType:=",
+            self.shoot_type,
+        ]
+        if self.shoot_type == "Rays by index":
+            args.extend(
+                [
+                    "start index:=",
+                    self.start_index,
+                    "stop index:=",
+                    self.stop_index,
+                    "index step:=",
+                    self.step_index,
+                ]
+            )
+        elif self.shoot_type == "Rays in box":
+            box_id = None
+            if isinstance(self.ray_box, int):
+                box_id = self.ray_box
+            elif isinstance(self.ray_box, str):
+                box_id = self._postprocessor._primitives._object_names_to_ids[self.ray_box]
+            else:
+                box_id = self.ray_box.id
+            args.extend("FilterBoxID:=", box_id)
+        elif self.shoot_type == "Single ray":
+            args.extend("Ray elevation:=", self.ray_elevation, "Ray azimuth:=", self.ray_azimuth)
+        args.append("LaunchFrom:=")
+        if self.is_plane_wave:
+            args.append("Launch from Plane-Wave")
+            args.append("Incident direction theta:=")
+            args.append(self.incident_theta)
+            args.append("Incident direction phi:=")
+            args.append(self.incident_phi)
+            args.append("Vertical Incident Polarization:=")
+            args.append(self.vertical_polarization)
+        else:
+            args.append("Launch from Custom")
+            args.append("LaunchFromPointID:=")
+            args.append(-1)
+            args.append("CustomLocationCoordSystem:=")
+            args.append(self.custom_coordinatesystem)
+            args.append("CustomLocation:=")
+            args.append(self.custom_location)
+        return args
+
+    @pyaedt_function_handler()
+    def _create_args_creeping(self):
+        args = [
+            "NAME:" + self.name,
+            "UserSpecifyName:=",
+            0,
+            "UserSpecifyFolder:=",
+            0,
+            "QuantityName:=",
+            self.quantity_name,
+            "PlotFolder:=",
+            "Visual Ray Trace CW",
+            "IntrinsicVar:=",
+            "",
+            "MaxFrequency:=",
+            self.max_frequency,
+            "SampleDensity:=",
+            self.sample_density,
+            "RayCutOff:=",
+            self.ray_cutoff,
+            "Irregular Surface Tolerance:=",
+            self.irregular_surface_tolerance,
+            "LaunchFrom:=",
+        ]
+        if self.is_plane_wave:
+            args.append("Launch from Plane-Wave")
+            args.append("Incident direction theta:=")
+            args.append(self.incident_theta)
+            args.append("Incident direction phi:=")
+            args.append(self.incident_phi)
+            args.append("Vertical Incident Polarization:=")
+            args.append(self.vertical_polarization)
+        else:
+            args.append("Launch from Custom")
+            args.append("LaunchFromPointID:=")
+            args.append(-1)
+            args.append("CustomLocationCoordSystem:=")
+            args.append(self.custom_coordinatesystem)
+            args.append("CustomLocation:=")
+            args.append(self.custom_location)
+        args.append("SBRRayDensity:=")
+        args.append(self.ray_density)
+        return args
+
+    @pyaedt_function_handler()
+    def create(self):
+        """Create a field plot.
 
         Returns
         -------
-        :class:`pyaedt.edb_core.edb_data.hfss_simulation_setup_data.HfssSimulationSetup`
+        bool
+            ``True`` when successful, ``False`` when failed.
 
-        Examples
-        --------
-        >>> setup1 = edbapp.create_hfss_setup("setup1")
-        >>> setup1.hfss_port_settings.max_delta_z0 = 0.5
         """
-        if name in self.setups:
+        try:
+            if self.is_creeping_wave:
+                self._ofield.CreateFieldPlot(self._create_args_creeping(), "CreepingWave_VRT")
+            else:
+                self._ofield.CreateFieldPlot(self._create_args(), "VRT")
+            return True
+        except:
             return False
-        setup = HfssSimulationSetup(self, name)
-        self._setups[name] = setup
-        return setup
 
     @pyaedt_function_handler()
-    def create_siwave_syz_setup(self, name=None):
-        """Create a setup from a template.
+    def update(self):
+        """Update the field plot.
 
-        Parameters
-        ----------
-        name : str, optional
-            Setup name.
 
         Returns
         -------
-        :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup`
-
-        Examples
-        --------
-        >>> setup1 = edbapp.create_siwave_syz_setup("setup1")
-        >>> setup1.add_frequency_sweep(frequency_sweep=[
-        ...                           ["linear count", "0", "1kHz", 1],
-        ...                           ["log scale", "1kHz", "0.1GHz", 10],
-        ...                           ["linear scale", "0.1GHz", "10GHz", "0.1GHz"],
-        ...                           ])
+        bool
+            ``True`` when successful, ``False`` when failed.
         """
-        if not name:
-            name = generate_unique_name("Siwave_SYZ")
-        if name in self.setups:
+        try:
+            if self.is_creeping_wave:
+                self._ofield.ModifyFieldPlot(self.name, self._create_args_creeping())
+
+            else:
+                self._ofield.ModifyFieldPlot(self.name, self._create_args())
+            return True
+        except:
             return False
-        setup = SiwaveSYZSimulationSetup(self, name)
-        self._setups[name] = setup
-        return setup
 
     @pyaedt_function_handler()
-    def create_siwave_dc_setup(self, name=None):
-        """Create a setup from a template.
+    def delete(self):
+        """Delete the field plot."""
+        self._ofield.DeleteFieldPlot([self.name])
+        return True
+
+    @pyaedt_function_handler()
+    def export(self, path_to_hdm_file=None):
+        """Export the Visual Ray Tracing to ``hdm`` file.
 
         Parameters
         ----------
-        name : str, optional
-            Setup name.
+        path_to_hdm_file : str, optional
+            Full path to output file. If ``None``, the file will be exported in working directory.
 
         Returns
         -------
-        :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup`
-
-        Examples
-        --------
-        >>> setup1 = edbapp.create_siwave_dc_setup("setup1")
-        >>> setup1.mesh_bondwires = True
-
+        str
+            Path to the file.
         """
-        if not name:
-            name = generate_unique_name("Siwave_DC")
-        if name in self.setups:
-            return False
-        setup = SiwaveDCSimulationSetup(self, name)
-        self._setups[name] = setup
-        return setup
+        if not path_to_hdm_file:
+            path_to_hdm_file = os.path.join(self._postprocessor._app.working_directory, self.name + ".hdm")
+        self._ofield.ExportFieldPlot(self.name, False, path_to_hdm_file)
+        return path_to_hdm_file
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/components.py` & `pyaedt-0.6.70/pyaedt/edb_core/components.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 """This module contains the `Components` class.
 
 """
 import codecs
 import json
 import math
 import re
+import warnings
 
 from pyaedt import _retry_ntimes
 from pyaedt.edb_core.edb_data.components_data import EDBComponent
 from pyaedt.edb_core.edb_data.components_data import EDBComponentDef
 from pyaedt.edb_core.edb_data.padstacks_data import EDBPadstackInstance
 from pyaedt.edb_core.edb_data.sources import Source
 from pyaedt.edb_core.edb_data.sources import SourceType
@@ -45,27 +46,47 @@
         RValue = RValue.replace("m", "e-3")
         RValue = RValue.replace("M", "e6")
     RValue = float(RValue)
     return RValue
 
 
 class Components(object):
-    """Manages EDB components and related method accessible from `Edb.core_components` property.
+    """Manages EDB components and related method accessible from `Edb.components` property.
 
     Parameters
     ----------
     edb_class : :class:`pyaedt.edb.Edb`
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edbapp = Edb("myaedbfolder")
-    >>> edbapp.core_components
+    >>> edbapp.components
     """
 
+    @pyaedt_function_handler()
+    def __getitem__(self, name):
+        """Get  a component or component definition from the Edb project.
+
+        Parameters
+        ----------
+        name : str
+
+        Returns
+        -------
+        :class:`pyaedt.edb_core.edb_data.components_data.EDBComponent`
+
+        """
+        if name in self.instances:
+            return self.instances[name]
+        elif name in self.definitions:
+            return self.definitions[name]
+        self._pedb.logger.error("Component or definition not found.")
+        return
+
     def __init__(self, p_edb):
         self._pedb = p_edb
         self._cmp = {}
         self._res = {}
         self._cap = {}
         self._ind = {}
         self._ios = {}
@@ -119,25 +140,48 @@
     def _db(self):
         return self._pedb.db
 
     @property
     def components(self):
         """Component setup information.
 
+        .. deprecated:: 0.6.62
+           Use new property :func:`instances` instead.
+
         Returns
         -------
         dict[str, :class:`pyaedt.edb_core.edb_data.components_data.EDBComponent`]
             Default dictionary for the EDB component.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.components
+        >>> edbapp.components.components
+
+        """
+        warnings.warn("Use new property :func:`instances` instead.", DeprecationWarning)
+        return self.instances
+
+    @property
+    def instances(self):
+        """All Cell components objects.
+
+        Returns
+        -------
+        Dict[str, :class:`pyaedt.edb_core.edb_data.components_data.EDBComponent`]
+            Default dictionary for the EDB component.
+
+        Examples
+        --------
+
+        >>> from pyaedt import Edb
+        >>> edbapp = Edb("myaedbfolder")
+        >>> edbapp.components.components
 
         """
         if not self._cmp:
             self.refresh_components()
         return self._cmp
 
     @property
@@ -259,15 +303,15 @@
             Dictionary of resistors.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.resistors
+        >>> edbapp.components.resistors
         """
         self._res = {}
         for el, val in self.components.items():
             if val.type == "Resistor":
                 self._res[el] = val
         return self._res
 
@@ -281,15 +325,15 @@
             Dictionary of capacitors.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.capacitors
+        >>> edbapp.components.capacitors
         """
         self._cap = {}
         for el, val in self.components.items():
             if val.type == "Capacitor":
                 self._cap[el] = val
         return self._cap
 
@@ -303,15 +347,15 @@
             Dictionary of inductors.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.inductors
+        >>> edbapp.components.inductors
 
         """
         self._ind = {}
         for el, val in self.components.items():
             if val.type == "Inductor":
                 self._ind[el] = val
         return self._ind
@@ -326,15 +370,15 @@
             Dictionary of integrated circuits.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.ICs
+        >>> edbapp.components.ICs
 
         """
         self._ics = {}
         for el, val in self.components.items():
             if val.type == "IC":
                 self._ics[el] = val
         return self._ics
@@ -349,15 +393,15 @@
             Dictionary of circuit inputs and outputs.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.IOs
+        >>> edbapp.components.IOs
 
         """
         self._ios = {}
         for el, val in self.components.items():
             if val.type == "IO":
                 self._ios[el] = val
         return self._ios
@@ -372,15 +416,15 @@
             Dictionary of other core components.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.others
+        >>> edbapp.components.others
 
         """
         self._others = {}
         for el, val in self.components.items():
             if val.type == "Other":
                 self._others[el] = val
         return self._others
@@ -395,15 +439,15 @@
             Dictionary of components by part name.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.components_by_partname
+        >>> edbapp.components.components_by_partname
 
         """
         self._comps_by_part = {}
         for el, val in self.components.items():
             if val.partname in self._comps_by_part.keys():
                 self._comps_by_part[val.partname].append(val)
             else:
@@ -517,17 +561,17 @@
         -------
         tuple
             Tuple of Vector offset, rotation and solder height.
 
         Examples
         --------
         >>> edb1 = Edb(edbpath=targetfile1,  edbversion="2021.2")
-        >>> hosting_cmp = edb1.core_components.get_component_by_name("U100")
-        >>> mounted_cmp = edb2.core_components.get_component_by_name("BGA")
-        >>> vector, rotation, solder_ball_height = edb1.core_components.get_component_placement_vector(
+        >>> hosting_cmp = edb1.components.get_component_by_name("U100")
+        >>> mounted_cmp = edb2.components.get_component_by_name("BGA")
+        >>> vector, rotation, solder_ball_height = edb1.components.get_component_placement_vector(
         ...                                             mounted_component=mounted_cmp,
         ...                                             hosting_component=hosting_cmp,
         ...                                             mounted_component_pin1="A12",
         ...                                             mounted_component_pin2="A14",
         ...                                             hosting_component_pin1="A12",
         ...                                             hosting_component_pin2="A14")
         """
@@ -672,17 +716,18 @@
                 negative_pin_group_term.SetSourceAmplitude(self._get_edb_value(source.amplitude))
                 positive_pin_group_term.SetSourcePhase(self._get_edb_value(source.phase))
                 negative_pin_group_term.SetSourcePhase(self._get_edb_value(source.phase))
                 positive_pin_group_term.SetImpedance(self._get_edb_value(source.impedance))
                 negative_pin_group_term.SetImpedance(self._get_edb_value(source.impedance))
                 positive_pin_group_term.SetReferenceTerminal(negative_pin_group_term)
             elif source.source_type == SourceType.Rlc:  # pragma: no cover
-                self.create_rlc_component(
+                self.create(
                     pins=[positive_pins[0], negative_pins[0]],
                     component_name=source.name,
+                    is_rlc=True,
                     r_value=source.r_value,
                     l_value=source.l_value,
                     c_value=source.c_value,
                 )
         return True
 
     @pyaedt_function_handler()
@@ -723,20 +768,20 @@
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
         >>> net_list = ["M_DQ<1>", "M_DQ<2>", "M_DQ<3>", "M_DQ<4>", "M_DQ<5>"]
-        >>> edbapp.core_components.create_port_on_component(cmp="U2A5", net_list=net_list,
+        >>> edbapp.components.create_port_on_component(cmp="U2A5", net_list=net_list,
         >>> port_type=SourceType.CoaxPort, do_pingroup=False, refnet="GND")
 
         """
         if isinstance(component, str):
-            component = self.components[component].edbcomponent
+            component = self.instances[component].edbcomponent
         if not isinstance(net_list, list):
             net_list = [net_list]
         for net in net_list:
             if not isinstance(net, str):
                 try:
                     net_name = net.GetName()
                     if net_name != "":
@@ -896,39 +941,38 @@
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
         >>> from pyaedt import Edb
         >>> edb_file = r'C:\my_edb_file.aedb'
         >>> edb = Edb(edb_file)
-        >>> for cmp in list(edb.core_components.components.keys()):
-        >>>     edb.core_components.deactivate_rlc_component(component=cmp, create_circuit_port=False)
+        >>> for cmp in list(edb.components.components.keys()):
+        >>>     edb.components.deactivate_rlc_component(component=cmp, create_circuit_port=False)
         >>> edb.save_edb()
         >>> edb.close_edb()
         """
         if not component:
             return False
         if isinstance(component, str):
-            component = self.components[component]
+            component = self.instances[component]
             if not component:
                 self._logger.error("component %s not found.", component)
                 return False
         component_type = component.edbcomponent.GetComponentType()
         if (
             component_type == self._edb.Definition.ComponentType.Other
             or component_type == self._edb.Definition.ComponentType.IC
             or component_type == self._edb.Definition.ComponentType.IO
         ):
             self._logger.info("Component %s passed to deactivate is not an RLC.", component.refdes)
             return False
+        component.is_enabled = False
         if create_circuit_port:
-            self.add_port_on_rlc_component(component.refdes)
-            return True
-        else:
-            return self.set_component_rlc(component.refdes)
+            return self.add_port_on_rlc_component(component.refdes)
+        return True
 
     @pyaedt_function_handler()
     def add_port_on_rlc_component(self, component=None):
         """Deactivate RLC component and replace it with a circuit port.
         The circuit port supports only 2-pin components.
 
         Parameters
@@ -938,15 +982,15 @@
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
         """
         if isinstance(component, str):  # pragma: no cover
-            component = self.components[component]
+            component = self.instances[component]
         if not isinstance(component, EDBComponent):  # pragma: no cover
             return False
         self.set_component_rlc(component.refdes)
         pins = self.get_pin_from_component(component.refdes)
         if len(pins) == 2:  # pragma: no cover
             pos_pin_loc = self.get_pin_position(pins[0])
             pt = self._pedb.edb.Geometry.PointData(
@@ -1050,24 +1094,28 @@
                     self._logger.error("Failed to create component definition pin {}-{}".format(name, pin.GetName()))
                     return None
         else:
             self._logger.warning("Found existing component definition for footprint {}".format(name))
         return componentDefinition
 
     @pyaedt_function_handler()
-    def create_rlc_component(self, pins, component_name="", r_value=1.0, c_value=1e-9, l_value=1e-9, is_parallel=False):
+    def create_rlc_component(
+        self, pins, component_name="", r_value=1.0, c_value=1e-9, l_value=1e-9, is_parallel=False
+    ):  # pragma: no cover
         """Create physical Rlc component.
 
         Parameters
         ----------
-        pins : list[Edb.Primitive.PadstackInstance]
+        pins : list
              List of EDB pins, length must be 2, since only 2 pins component are currently supported.
+             It can be an `pyaedt.edb_core.edb_data.padstacks_data.EDBPadstackInstance` object or
+             an Edb Padstack Instance object.
 
         component_name : str
-            Component name.
+            Component definition name.
 
         r_value : float
             Resistor value.
 
         c_value : float
             Capacitance value.
 
@@ -1079,94 +1127,72 @@
 
         Returns
         -------
         Component
             Created EDB component.
 
         """
-        if not len(pins) == 2:  # pragma no cover
-            self._logger.error("2 Pins must be provided to create an rlc component.")
-            return False
-        comp_def = self._getComponentDefinition(component_name, pins)
-        if not comp_def:  # pragma no cover
-            self._logger.error("Failed to create component definition")
-            return False
-        new_cmp = self._edb.Cell.Hierarchy.Component.Create(self._active_layout, component_name, comp_def.GetName())
-        hosting_component_location = pins[0].GetComponent().GetTransform()
-        for pin in pins:
-            new_cmp.AddMember(pin)
-        new_cmp_layer_name = pins[0].GetPadstackDef().GetData().GetLayerNames()[0]
-        new_cmp_placement_layer = self._edb.Cell.Layer.FindByName(
-            self._active_layout.GetLayerCollection(), new_cmp_layer_name
+        warnings.warn("`create_rlc_component` is deprecated. Use `create` method instead.", DeprecationWarning)
+        return self.create(
+            pins=pins,
+            component_name=component_name,
+            is_rlc=True,
+            r_value=r_value,
+            l_value=l_value,
+            c_value=c_value,
+            is_parallel=is_parallel,
         )
-        new_cmp.SetPlacementLayer(new_cmp_placement_layer)
-        rlc = self._edb.Utility.Rlc()
-        rlc.IsParallel = is_parallel
-        if r_value:  # pragma no cover
-            rlc.REnabled = True
-            rlc.R = self._get_edb_value(r_value)
-        else:  # pragma no cover
-            rlc.REnabled = False
-        if l_value:  # pragma no cover
-            rlc.LEnabled = True
-            rlc.L = self._get_edb_value(l_value)
-        else:  # pragma no cover
-            rlc.LEnabled = False
-        if c_value:  # pragma no cover
-            rlc.CEnabled = True
-            rlc.C = self._get_edb_value(c_value)
-        else:  # pragma no cover
-            rlc.CEnabled = False
-        if rlc.REnabled and not rlc.CEnabled and not rlc.CEnabled:  # pragma no cover
-            new_cmp.SetComponentType(self._edb.Definition.ComponentType.Resistor)
-        elif rlc.CEnabled and not rlc.REnabled and not rlc.LEnabled:  # pragma no cover
-            new_cmp.SetComponentType(self._edb.Definition.ComponentType.Capacitor)
-        elif rlc.LEnabled and not rlc.REnabled and not rlc.CEnabled:  # pragma no cover
-            new_cmp.SetComponentType(self._edb.Definition.ComponentType.Inductor)
-        else:  # pragma no cover
-            new_cmp.SetComponentType(self._edb.Definition.ComponentType.Resistor)
-
-        pin_pair = self._edb.Utility.PinPair(pins[0].GetName(), pins[1].GetName())  # pragma no cover
-        rlc_model = self._edb.Cell.Hierarchy.PinPairModel()
-        rlc_model.SetPinPairRlc(pin_pair, rlc)
-        edb_rlc_component_property = self._edb.Cell.Hierarchy.RLCComponentProperty()
-        if not edb_rlc_component_property.SetModel(rlc_model) or not new_cmp.SetComponentProperty(
-            edb_rlc_component_property
-        ):
-            return False  # pragma no cover
-        new_cmp.SetTransform(hosting_component_location)
-        return new_cmp
 
     @pyaedt_function_handler()
-    def create_component_from_pins(self, pins, component_name, placement_layer=None, component_part_name=None):
+    def create(
+        self,
+        pins,
+        component_name,
+        placement_layer=None,
+        component_part_name=None,
+        is_rlc=False,
+        r_value=1.0,
+        c_value=1e-9,
+        l_value=1e-9,
+        is_parallel=False,
+    ):
         """Create a component from pins.
 
         Parameters
         ----------
         pins : list
             List of EDB core pins.
         component_name : str
             Name of the reference designator for the component.
         placement_layer : str, optional
             Name of the layer used for placing the component.
         component_part_name : str, optional
             Part name of the component.
-
+        is_rlc : bool, optional
+            Whether if the new component will be an RLC or not.
+        r_value : float
+            Resistor value.
+        c_value : float
+            Capacitance value.
+        l_value : float
+            Inductor value.
+        is_parallel : bool
+            Using parallel model when ``True``, series when ``False``.
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> pins = edbapp.core_components.get_pin_from_component("A1")
-        >>> edbapp.core_components.create_component_from_pins(pins, "A1New")
+        >>> pins = edbapp.components.get_pin_from_component("A1")
+        >>> edbapp.components.create(pins, "A1New")
 
         """
         if component_part_name:
             compdef = self._getComponentDefinition(component_part_name, pins)
         else:
             compdef = self._getComponentDefinition(component_name, pins)
         if not compdef:
@@ -1183,20 +1209,97 @@
             new_cmp_layer_name = pins[0].GetPadstackDef().GetData().GetLayerNames()[0]
         else:
             new_cmp_layer_name = placement_layer
         new_cmp_placement_layer = self._edb.Cell.Layer.FindByName(
             self._active_layout.GetLayerCollection(), new_cmp_layer_name
         )
         new_cmp.SetPlacementLayer(new_cmp_placement_layer)
-        # cmp_transform = System.Activator.CreateInstance(self._edb.Utility.)
-        # new_cmp.SetTransform(cmp_transform)
+        hosting_component_location = pins[0].GetComponent().GetTransform()
+
+        if is_rlc:
+            rlc = self._edb.Utility.Rlc()
+            rlc.IsParallel = is_parallel
+            if r_value:
+                rlc.REnabled = True
+                rlc.R = self._get_edb_value(r_value)
+            else:
+                rlc.REnabled = False
+            if l_value:
+                rlc.LEnabled = True
+                rlc.L = self._get_edb_value(l_value)
+            else:
+                rlc.LEnabled = False
+            if c_value:
+                rlc.CEnabled = True
+                rlc.C = self._get_edb_value(c_value)
+            else:
+                rlc.CEnabled = False
+            if rlc.REnabled and not rlc.CEnabled and not rlc.CEnabled:
+                new_cmp.SetComponentType(self._edb.Definition.ComponentType.Resistor)
+            elif rlc.CEnabled and not rlc.REnabled and not rlc.LEnabled:
+                new_cmp.SetComponentType(self._edb.Definition.ComponentType.Capacitor)
+            elif rlc.LEnabled and not rlc.REnabled and not rlc.CEnabled:
+                new_cmp.SetComponentType(self._edb.Definition.ComponentType.Inductor)
+            else:
+                new_cmp.SetComponentType(self._edb.Definition.ComponentType.Resistor)
+
+            pin_pair = self._edb.Utility.PinPair(pins[0].GetName(), pins[1].GetName())
+            rlc_model = self._edb.Cell.Hierarchy.PinPairModel()
+            rlc_model.SetPinPairRlc(pin_pair, rlc)
+            edb_rlc_component_property = self._edb.Cell.Hierarchy.RLCComponentProperty()
+            if not edb_rlc_component_property.SetModel(rlc_model) or not new_cmp.SetComponentProperty(
+                edb_rlc_component_property
+            ):
+                return False  # pragma no cover
+        new_cmp.SetTransform(hosting_component_location)
         self._cmp[new_cmp.GetName()] = EDBComponent(self, new_cmp)
         return new_cmp
-        # except:
-        #    return (False, None)
+
+    @pyaedt_function_handler()
+    def create_component_from_pins(
+        self, pins, component_name, placement_layer=None, component_part_name=None
+    ):  # pragma: no cover
+        """Create a component from pins.
+
+        .. deprecated:: 0.6.62
+           Use :func:`create` method instead.
+
+        Parameters
+        ----------
+        pins : list
+            List of EDB core pins.
+        component_name : str
+            Name of the reference designator for the component.
+        placement_layer : str, optional
+            Name of the layer used for placing the component.
+        component_part_name : str, optional
+            Part name of the component. It's created a new definition if doesn't exists.
+
+        Returns
+        -------
+        bool
+            ``True`` when successful, ``False`` when failed.
+
+        Examples
+        --------
+
+        >>> from pyaedt import Edb
+        >>> edbapp = Edb("myaedbfolder")
+        >>> pins = edbapp.components.get_pin_from_component("A1")
+        >>> edbapp.components.create(pins, "A1New")
+
+        """
+        warnings.warn("`create_component_from_pins` is deprecated. Use `create` method instead.", DeprecationWarning)
+        return self.create(
+            pins=pins,
+            component_name=component_name,
+            placement_layer=placement_layer,
+            component_part_name=component_part_name,
+            is_rlc=False,
+        )
 
     @pyaedt_function_handler()
     def set_component_model(self, componentname, model_type="Spice", modelpath=None, modelname=None):
         """Assign a Spice or Touchstone model to a component.
 
         Parameters
         ----------
@@ -1216,15 +1319,15 @@
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.set_component_model("A1", model_type="Spice",
+        >>> edbapp.components.set_component_model("A1", model_type="Spice",
         ...                                            modelpath="pathtospfile",
         ...                                            modelname="spicemodelname")
 
         """
         if not modelname:
             modelname = get_filename_without_extension(modelpath)
         edbComponent = self.get_component_by_name(componentname)
@@ -1300,15 +1403,15 @@
         tuple
             The tuple is structured as: (bool, pingroup).
 
         Examples
         --------
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.create_pingroup_from_pins(gndpinlist, "MyGNDPingroup")
+        >>> edbapp.components.create_pingroup_from_pins(gndpinlist, "MyGNDPingroup")
 
         """
         if len(pins) < 1:
             self._logger.error("No pins specified for pin group %s", group_name)
             return (False, None)
         if group_name is None:
             group_name = self._edb.Cell.Hierarchy.PinGroup.GetUniqueName(self._active_layout)
@@ -1336,32 +1439,35 @@
 
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> list_of_deleted_rlcs = edbapp.core_components.delete_single_pin_rlc()
+        >>> list_of_deleted_rlcs = edbapp.components.delete_single_pin_rlc()
         >>> print(list_of_deleted_rlcs)
 
         """
         deleted_comps = []
         for comp, val in self.components.items():
             if val.numpins < 2 and val.type in ["Resistor", "Capacitor", "Inductor"]:
                 val.edbcomponent.Delete()
                 deleted_comps.append(comp)
         self.refresh_components()
         self._pedb._logger.info("Deleted {} components".format(len(deleted_comps)))
 
         return deleted_comps
 
     @pyaedt_function_handler()
-    def delete_component(self, component_name):
+    def delete_component(self, component_name):  # pragma: no cover
         """Delete a component.
 
+        .. deprecated:: 0.6.62
+           Use :func:`delete` method instead.
+
         Parameters
         ----------
         component_name : str
             Name of the component.
 
         Returns
         -------
@@ -1369,15 +1475,40 @@
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.delete_component("A1")
+        >>> edbapp.components.delete("A1")
+
+        """
+        warnings.warn("`delete_component` is deprecated. Use `delete` property instead.", DeprecationWarning)
+        return self.delete(component_name=component_name)
+
+    @pyaedt_function_handler()
+    def delete(self, component_name):
+        """Delete a component.
+
+        Parameters
+        ----------
+        component_name : str
+            Name of the component.
+
+        Returns
+        -------
+        bool
+            ``True`` when successful, ``False`` when failed.
+
+        Examples
+        --------
+
+        >>> from pyaedt import Edb
+        >>> edbapp = Edb("myaedbfolder")
+        >>> edbapp.components.delete("A1")
 
         """
         edb_cmp = self.get_component_by_name(component_name)
         if edb_cmp is not None:
             edb_cmp.Delete()
             if edb_cmp in list(self.components.keys()):
                 del self.components[edb_cmp]
@@ -1399,15 +1530,15 @@
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.disable_rlc_component("A1")
+        >>> edbapp.components.disable_rlc_component("A1")
 
         """
         edb_cmp = self.get_component_by_name(component_name)
         if edb_cmp is not None:
             rlc_property = edb_cmp.GetComponentProperty().Clone()
             pin_pair_model = rlc_property.GetModel().Clone()
             pprlc = pin_pair_model.GetPinPairRlc(list(pin_pair_model.PinPairs)[0])
@@ -1454,15 +1585,15 @@
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.set_solder_ball("A1")
+        >>> edbapp.components.set_solder_ball("A1")
 
         """
         if not isinstance(component, self._edb.Cell.Hierarchy.Component):
             edb_cmp = self.get_component_by_name(component)
             cmp = self.components[component]
         else:
             edb_cmp = component
@@ -1542,19 +1673,23 @@
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.set_component_rlc(
+        >>> edbapp.components.set_component_rlc(
         ...     "R1", res_value=50, ind_value=1e-9, cap_value=1e-12, isparallel=False
         ... )
 
         """
+        if res_value is None and ind_value is None and cap_value is None:
+            self.instances[componentname].is_enabled = False
+            self._logger.info("No parameters passed, component %s  is disabled.", componentname)
+            return True
         edb_component = self.get_component_by_name(componentname)
         edb_rlc_component_property = self._edb.Cell.Hierarchy.RLCComponentProperty()
         component_pins = self.get_pin_from_component(componentname)
         pin_number = len(component_pins)
         if pin_number == 2:
             from_pin = component_pins[0]
             to_pin = component_pins[1]
@@ -1586,15 +1721,15 @@
         else:
             self._logger.warning(
                 "Component %s has not been assigned because either it is not present in the layout "
                 "or it contains a number of pins not equal to 2",
                 componentname,
             )
             return False
-        self._logger.warning("RLC properties for Component %s has been assigned.", componentname)
+        self._logger.info("RLC properties for Component %s has been assigned.", componentname)
         return True
 
     @pyaedt_function_handler()
     def update_rlc_from_bom(
         self,
         bom_file,
         delimiter=";",
@@ -1721,15 +1856,15 @@
                         p_layer = comp.placement_layer
                         refdes_temp = comp.refdes + "_temp"
                         comp.refdes = refdes_temp
 
                         unmount_comp_list.remove(refdes)
                         comp.edbcomponent.Ungroup(True)
 
-                        self.create_component_from_pins(pinlist, refdes, p_layer, part_name)
+                        self.create(pinlist, refdes, p_layer, part_name)
                         self.refresh_components()
                         comp = self.components[refdes]
 
                 comp_type = l[comp_type_col]
                 if comp_type.capitalize() in ["Resistor", "Capacitor", "Inductor", "Other"]:
                     comp.type = comp_type.capitalize()
                 else:
@@ -1805,15 +1940,15 @@
             List of pins when the component is found or ``[]`` otherwise.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_components.get_pin_from_component("R1", refdes)
+        >>> edbapp.components.get_pin_from_component("R1", refdes)
 
         """
         if not isinstance(component, self._edb.Cell.Hierarchy.Component):
             component = self._edb.Cell.Hierarchy.Component.FindByName(self._active_layout, component)
         if netName:
             if not isinstance(netName, list):
                 netName = [netName]
@@ -1862,15 +1997,15 @@
             Name of the pin in AEDT.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_components.get_aedt_pin_name(pin)
+        >>> edbapp.components.get_aedt_pin_name(pin)
 
         """
         if isinstance(pin, EDBPadstackInstance):
             pin = pin._edb_padstackinstance
         if is_ironpython:
             name = _clr.Reference[String]()
             pin.GetProductProperty(self._edb.ProductId.Designer, 11, name)
@@ -1895,15 +2030,15 @@
             Pin position as a list of float values in the form ``[x, y]``.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_components.get_pin_position(pin)
+        >>> edbapp.components.get_pin_position(pin)
 
         """
         res, pt_pos, rot_pos = pin.GetPositionAndRotation()
 
         if pin.GetComponent().IsNull():
             transformed_pt_pos = pt_pos
         else:
@@ -1931,15 +2066,15 @@
             List of pins belong to the net.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_components.get_pins_name_from_net(pin_list, net_name)
+        >>> edbapp.components.get_pins_name_from_net(pin_list, net_name)
 
         """
         pinlist = []
         for pin in pin_list:
             if pin.GetNet().GetName() == net_name:
                 pinlist.append(pin.GetName())
         return pinlist
@@ -1959,15 +2094,15 @@
             List of nets with one or more pins.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_components.get_nets_from_pin_list(pinlist)
+        >>> edbapp.components.get_nets_from_pin_list(pinlist)
 
         """
         netlist = []
         for pin in PinList:
             netlist.append(pin.GetNet().GetName())
         return list(set(netlist))
 
@@ -1986,15 +2121,15 @@
             Dictionary of the net connection information for the reference designator.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_components.get_component_net_connection_info(refdes)
+        >>> edbapp.components.get_component_net_connection_info(refdes)
 
         """
         component_pins = self.get_pin_from_component(refdes)
         data = {"refdes": [], "pin_name": [], "net_name": []}
         for pin_obj in component_pins:
             pin_name = pin_obj.GetName()
             net_name = pin_obj.GetNet().GetName()
@@ -2014,15 +2149,15 @@
             and net names.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_components.get_rats()
+        >>> edbapp.components.get_rats()
 
         """
         df_list = []
         for refdes in self.components.keys():
             df = self.get_component_net_connection_info(refdes)
             df_list.append(df)
         return df_list
@@ -2041,15 +2176,15 @@
             List of through resistors.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_components.get_through_resistor_list()
+        >>> edbapp.components.get_through_resistor_list()
 
         """
         through_comp_list = []
         for refdes, comp_obj in self.resistors.items():
             numpins = comp_obj.numpins
 
             if numpins == 2:
@@ -2080,15 +2215,15 @@
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder")
-        >>> edbapp.core_components.short_component_pins("J4A2", ["G4", "9", "3"])
+        >>> edbapp.components.short_component_pins("J4A2", ["G4", "9", "3"])
 
         """
         component = self.components[component_name]
         pins = component.pins
         pins_list = []
 
         component.center
@@ -2102,23 +2237,21 @@
         center = component.center
         c = [center[0], center[1], 0]
         delta_pins = []
         w = width
         for pin in pins_list:
             placement_layer = pin.placement_layer
             positions_to_short.append(pin.position)
-            if placement_layer in self._pedb.core_padstack.definitions[pin.pin.GetPadstackDef().GetName()].pad_by_layer:
-                pad = self._pedb.core_padstack.definitions[pin.pin.GetPadstackDef().GetName()].pad_by_layer[
-                    placement_layer
-                ]
+            if placement_layer in self._pedb.padstacks.definitions[pin.pin.GetPadstackDef().GetName()].pad_by_layer:
+                pad = self._pedb.padstacks.definitions[pin.pin.GetPadstackDef().GetName()].pad_by_layer[placement_layer]
             else:
-                layer = list(
-                    self._pedb.core_padstack.definitions[pin.pin.GetPadstackDef().GetName()].pad_by_layer.keys()
-                )[0]
-                pad = self._pedb.core_padstack.definitions[pin.pin.GetPadstackDef().GetName()].pad_by_layer[layer]
+                layer = list(self._pedb.padstacks.definitions[pin.pin.GetPadstackDef().GetName()].pad_by_layer.keys())[
+                    0
+                ]
+                pad = self._pedb.padstacks.definitions[pin.pin.GetPadstackDef().GetName()].pad_by_layer[layer]
             pars = pad.parameters_values
             geom = pad.geometry_type
             if geom < 6 and pars:
                 delta_pins.append(max(pars) + min(pars) / 2)
                 w = min(min(pars), w)
             elif pars:
                 delta_pins.append(1.5 * pars[0])
@@ -2193,15 +2326,15 @@
 
             trace_points.append(p0[l0_min][:2])
             trace_points.append(c[:2])
             trace_points.append(p1[l1_min][:2])
 
             trace_points.append(positions_to_short[i + 1])
 
-            self._pedb.core_primitives.create_trace(
+            self._pedb.modeler.create_trace(
                 trace_points,
                 layer_name=placement_layer,
                 net_name="short",
                 width=w,
                 start_cap_style="Flat",
                 end_cap_style="Flat",
             )
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/components_data.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/components_data.py`

 * *Files 1% similar despite different names*

```diff
@@ -79,25 +79,25 @@
             for l in self._pcomponents._edb.Cell.Hierarchy.Component.FindByComponentDef(
                 self._pcomponents._pedb.active_layout, self.part_name
             )
         ]
         return {comp.refdes: comp for comp in comp_list}
 
     @pyaedt_function_handler
-    def assign_rlc_model(self, res, ind, cap, is_parallel=False):
+    def assign_rlc_model(self, res=None, ind=None, cap=None, is_parallel=False):
         """Assign RLC to all components under this part name.
 
         Parameters
         ----------
         res : int, float
-            Resistance.
+            Resistance. Default is ``None``.
         ind : int, float
-            Inductance.
+            Inductance. Default is ``None``.
         cap : int, float
-            Capacitance.
+            Capacitance. Default is ``None``.
         is_parallel : bool, optional
             Whether it is parallel or series RLC component.
         """
         for comp in list(self.components.values()):
             res, ind, cap = res, ind, cap
             comp.assign_rlc_model(res, ind, cap, is_parallel)
         return True
@@ -309,14 +309,31 @@
         edb_model = self._edb_model
         return [
             self._PinPair(self, self.edbcomponent, edb_comp_prop, edb_model, pin_pair)
             for pin_pair in list(edb_model.PinPairs)
         ]
 
     @property
+    def is_enabled(self):
+        """Get or Set the component to active mode.
+
+        Returns
+        -------
+        bool
+            ``True`` if component is active, ``False`` if is disabled..
+        """
+        return self.component_property.IsEnabled()
+
+    @is_enabled.setter
+    def is_enabled(self, value):
+        cmp_prop = self.component_property.Clone()
+        cmp_prop.SetEnabled(value)
+        self.edbcomponent.SetComponentProperty(cmp_prop)
+
+    @property
     def spice_model(self):
         """Get assigned Spice model properties."""
         if not self.model_type == "SPICEModel":
             return None
         else:
             return self._SpiceModel(self._edb_model)
 
@@ -891,35 +908,45 @@
         model = self._edb.Cell.Hierarchy.SParameterModel()
         model.SetComponentModelName(name)
         if reference_net:
             model.SetReferenceNet(reference_net)
         return self._set_model(model)
 
     @pyaedt_function_handler
-    def assign_rlc_model(self, res, ind, cap, is_parallel=False):
+    def assign_rlc_model(self, res=None, ind=None, cap=None, is_parallel=False):
         """Assign RLC to this component.
 
         Parameters
         ----------
         res : int, float
-            Resistance.
+            Resistance. Default is ``None``.
         ind : int, float
-            Inductance.
+            Inductance. Default is ``None``.
         cap : int, float
-            Capacitance.
+            Capacitance. Default is ``None``.
         is_parallel : bool, optional
             Whether it is a parallel or series RLC component. The default is ``False``.
         """
+        if res is None and ind is None and cap is None:
+            self._pedb.logger.error("At least one value has to be provided.")
+            return False
+        r_enabled = True if res else False
+        l_enabled = True if ind else False
+        c_enabled = True if cap else False
+        res = 0 if res is None else res
+        ind = 0 if ind is None else ind
+        cap = 0 if cap is None else cap
         res, ind, cap = self._get_edb_value(res), self._get_edb_value(ind), self._get_edb_value(cap)
         model = self._edb.Cell.Hierarchy.PinPairModel()
 
         pin_names = list(self.pins.keys())
         for idx, i in enumerate(np.arange(len(pin_names) // 2)):
             pin_pair = self._edb.Utility.PinPair(pin_names[idx], pin_names[idx + 1])
-            rlc = self._edb.Utility.Rlc(res, True, ind, True, cap, True, is_parallel)
+
+            rlc = self._edb.Utility.Rlc(res, r_enabled, ind, l_enabled, cap, c_enabled, is_parallel)
             model.SetPinPairRlc(pin_pair, rlc)
         return self._set_model(model)
 
     @pyaedt_function_handler
     def create_clearance_on_component(self, extra_soldermask_clearance=1e-4):
         """Create a Clearance on Soldermask layer by drawing a rectangle.
 
@@ -943,20 +970,20 @@
         if comp_layer in [layer_names[0] + layer_names[-1]]:
             return False
         elif layer_index < len(layer_names) / 2:
             soldermask_layer = layer_names[layer_index - 1]
         else:
             soldermask_layer = layer_names[layer_index + 1]
 
-        if not self._pedb.core_primitives.get_primitives(layer_name=soldermask_layer):
-            all_nets = list(self._pedb.core_nets.nets.values())
+        if not self._pedb.modeler.get_primitives(layer_name=soldermask_layer):
+            all_nets = list(self._pedb.nets.nets.values())
             poly = self._pedb._create_conformal(all_nets, 0, 1e-12, False, 0)
-            self._pedb.core_primitives.create_polygon(poly, soldermask_layer, [], "")
+            self._pedb.modeler.create_polygon(poly, soldermask_layer, [], "")
 
-        void = self._pedb.core_primitives.create_rectangle(
+        void = self._pedb.modeler.create_rectangle(
             soldermask_layer,
             "{}_opening".format(self.refdes),
             lower_left_point=opening[:2],
             upper_right_point=opening[2:],
         )
         void.is_negative = True
         return True
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/design_options.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/design_options.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/edbvalue.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/edbvalue.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/hfss_simulation_setup_data.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/hfss_simulation_setup_data.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/layer_data.py` & `pyaedt-0.6.70/pyaedt/modeler/cad/object3d.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,1753 +1,1894 @@
-from __future__ import absolute_import
+# -*- coding: utf-8 -*-
+"""
+This module contains these classes: `Components3DLayout`,`CircuitComponent',
+`EdgePrimitive`, `EdgeTypePrimitive`, `FacePrimitive`, `Geometries3DLayout`,
+`Nets3DLayout`, `Objec3DLayout`, `Object3d`, `Padstack`, `PDSHole`, `PDSLayer`,
+`Pins3DLayout', and `VertexPrimitive`.
 
-from collections import OrderedDict
+This module provides methods and data structures for managing all properties of
+objects (points, lines, sheeets, and solids) within the AEDT 3D Modeler.
+
+"""
+from __future__ import absolute_import  # noreorder
+
+import os
 import re
-import time
 
-from pyaedt import pyaedt_function_handler
-from pyaedt.generic.clr_module import List
+from pyaedt.generic.constants import AEDT_UNITS
+from pyaedt.generic.general_methods import _retry_ntimes
+from pyaedt.generic.general_methods import _to_boolean
+from pyaedt.generic.general_methods import _uname
+from pyaedt.generic.general_methods import clamp
+from pyaedt.generic.general_methods import is_ironpython
+from pyaedt.generic.general_methods import open_file
+from pyaedt.generic.general_methods import pyaedt_function_handler
+from pyaedt.generic.general_methods import rgb_color_codes
+from pyaedt.generic.general_methods import settings
+from pyaedt.modeler.cad.elements3d import BinaryTreeNode
+from pyaedt.modeler.cad.elements3d import EdgePrimitive
+from pyaedt.modeler.cad.elements3d import FacePrimitive
+from pyaedt.modeler.cad.elements3d import VertexPrimitive
 
 
-class EDBLayer(object):
-    """Manages EDB functionalities for a layer.
+class Object3d(object):
+    """Manages object attributes for the AEDT 3D Modeler.
 
-    .. deprecated:: 0.6.5
-        There is no need to use core_stackup anymore. You can instantiate new class stackup directly from edb class.
+    Parameters
+    ----------
+    primitives : :class:`pyaedt.modeler.Primitives3D.Primitives3D`
+        Inherited parent object.
+    name : str
 
     Examples
     --------
-    >>> from pyaedt import Edb
-    >>> edb = Edb(myedb, edbversion="2021.2")
-    >>> edb_layer = edb.core_stackup.stackup_layers.layers["TOP"]
+    Basic usage demonstrated with an HFSS design:
+
+    >>> from pyaedt import Hfss
+    >>> aedtapp = Hfss()
+    >>> prim = aedtapp.modeler
+
+    Create a part, such as box, to return an :class:`pyaedt.modeler.Object3d.Object3d`.
+
+    >>> id = prim.create_box([0, 0, 0], [10, 10, 5], "Mybox", "Copper")
+    >>> part = prim[id]
     """
 
-    def __init__(self, edblayer, app):
-        self._layer = edblayer
-        self._name = None
-        self._layer_type = None
-        self._thickness = None
-        self._etch_factor = None
-        self._material_name = None
-        self._filling_material_name = None
-        self._negative_layer = False
-        self._lower_elevation = None
-        self._upper_elevation = None
-        self._top_bottom_association = None
+    def __init__(self, primitives, name=None):
+        """
+        Parameters
+        ----------
+        primitives : :class:`pyaedt.modeler.Primitives3D.Primitives3D`
+            Inherited parent object.
+        name : str
+        """
         self._id = None
-        self._edb = app._edb
-        self._active_layout = app._active_layout
-        self._pedblayers = app
-        self._roughness_enabled = False
-        self._roughness_model_top = None
-        self._roughness_model_bottom = None
-        self._roughness_model_side = None
-        self.init_vals()
+        if name:
+            self._m_name = name
+        else:
+            self._m_name = _uname()
+        self._primitives = primitives
+        self.flags = ""
+        self._part_coordinate_system = "Global"
+        self._material_name = None
+        self._transparency = None
+        self._solve_inside = None
+        self._is_updated = False
+        self._all_props = None
+        self._surface_material = None
+        self._color = None
+        self._wireframe = None
+        self._part_coordinate_system = None
+        self._model = None
+        self._m_groupName = None
+        self._object_type = None
+        self._mass = 0.0
+        self._volume = 0.0
 
-    @property
-    def _cloned_layer(self):
-        return self._layer.Clone()
+    @pyaedt_function_handler()
+    def _bounding_box_unmodel(self):
+        """Bounding box of a part, unmodel/undo method.
 
-    @property
-    def _builder(self):
-        return self._pedblayers._builder
+        This is done by setting all other objects as unmodel and getting the model bounding box.
+        Then an undo operation restore the design.
 
-    @property
-    def _logger(self):
-        """Logger."""
-        return self._pedblayers._logger
+        Returns
+        -------
+        list of [list of float]
+            List of six ``[x, y, z]`` positions of the bounding box containing
+            Xmin, Ymin, Zmin, Xmax, Ymax, and Zmax values.
+
+        """
+        objs_to_unmodel = [
+            val.name for i, val in self._primitives.objects.items() if val.model and val.name != self.name
+        ]
+        if objs_to_unmodel:
+            vArg1 = ["NAME:Model", "Value:=", False]
+            self._primitives._change_geometry_property(vArg1, objs_to_unmodel)
+        modeled = True
+        if not self.model:
+            vArg1 = ["NAME:Model", "Value:=", True]
+            self._primitives._change_geometry_property(vArg1, self.name)
+            modeled = False
+        bounding = self._primitives.get_model_bounding_box()
+        if objs_to_unmodel:
+            self._odesign.Undo()
+        if not modeled:
+            self._odesign.Undo()
+        if not settings.non_graphical:
+            self._primitives._app.odesktop.ClearMessages(
+                self._primitives._app.project_name, self._primitives._app.design_name, 1
+            )
+        return bounding
+
+    @pyaedt_function_handler()
+    def _bounding_box_sat(self):
+        """Bounding box of a part.
+
+        This is done by exporting a part as a SAT file and reading the bounding box information from the SAT file.
+        A list of six 3D position vectors is returned.
+
+        Returns
+        -------
+        list of [list of float]
+            List of six ``[x, y, z]`` positions of the bounding box containing
+            Xmin, Ymin, Zmin, Xmax, Ymax, and Zmax values.
+
+        References
+        ----------
+
+        >>> oEditor.GetModelBoundingBox
+
+        """
+        tmp_path = self._primitives._app.working_directory
+        filename = os.path.join(tmp_path, self.name + ".sat")
+
+        self._primitives._app.export_3d_model(self.name, tmp_path, ".sat", [self.name])
+
+        if not os.path.isfile(filename):
+            raise Exception("Cannot export the ACIS SAT file for object {}".format(self.name))
+
+        with open_file(filename, "r") as fh:
+            temp = fh.read().splitlines()
+        all_lines = [s for s in temp if s.startswith("body ")]
+
+        bb = []
+        if len(all_lines) == 1:
+            line = all_lines[0]
+            pattern = r".+ (.+) (.+) (.+) (.+) (.+) (.+) #$"
+            m = re.search(pattern, line)
+            if m:
+                try:
+                    for i in range(1, 7):
+                        bb.append(float(m.group(i)))
+                except:
+                    return False
+            else:
+                return False
+        else:
+            return False
 
-    def _get_edb_value(self, value):
-        """Get Edb Value."""
-        return self._pedblayers._get_edb_value(value)
+        try:
+            os.remove(filename)
+        except:
+            self.logger.warning("ERROR: Cannot remove temp file.")
+        return bb
 
     @property
-    def name(self):
-        """Layer name.
+    def bounding_box(self):
+        """Bounding box of a part.
+
+        A list of six 3D position vectors is returned.
 
         Returns
         -------
-        str
-            Name of the layer.
+        list of [list of float]
+            List of six ``[x, y, z]`` positions of the bounding box containing
+            Xmin, Ymin, Zmin, Xmax, Ymax, and Zmax values.
+
+        References
+        ----------
+
+        >>> oEditor.GetModelBoundingBox
+
         """
-        if not self._name:
-            self._name = self._layer.GetName()
-        return self._name
+        if self.object_type == "Unclassified":
+            return [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
+        if not settings.disable_bounding_box_sat:
+            bounding = self._bounding_box_sat()
+            if bounding:
+                return bounding
+            else:
+                return self._bounding_box_unmodel()
+        else:
+            return self._bounding_box_unmodel()
 
     @property
-    def id(self):
-        """Layer ID.
+    def bounding_dimension(self):
+        """Retrieve the dimension array of the bounding box.
 
         Returns
         -------
-        int
-            ID of the layer.
+        list
+            List of three float values representing the bounding box dimensions
+            in the form ``[dim_x, dim_y, dim_z]``.
+
+        References
+        ----------
+
+        >>> oEditor.GetModelBoundingBox
         """
-        if not self._id:
-            self._id = self._layer.GetLayerId()
-        return self._id
+        oBoundingBox = self.bounding_box
+        dimensions = []
+        dimensions.append(abs(float(oBoundingBox[0]) - float(oBoundingBox[3])))
+        dimensions.append(abs(float(oBoundingBox[1]) - float(oBoundingBox[4])))
+        dimensions.append(abs(float(oBoundingBox[2]) - float(oBoundingBox[5])))
+        return dimensions
 
     @property
-    def layer_type(self):
-        """Layer type.
+    def _odesign(self):
+        """Design."""
+        return self._primitives._modeler._app._odesign
+
+    @pyaedt_function_handler()
+    def plot(self, show=True):
+        """Plot model with PyVista.
+
+        Parameters
+        ----------
+        show : bool, optional
+            Show the plot after generation.  The default value is ``True``.
 
         Returns
         -------
-        int
-            Type of the layer.
+        :class:`pyaedt.generic.plot.ModelPlotter`
+            Model Object.
+
+        Notes
+        -----
+        Works from AEDT 2021.2 in CPython only. PyVista has to be installed.
         """
-        if not self._layer_type:
-            self._layer_type = self._layer.GetLayerType()
-        return self._pedblayers._layer_types_to_int(self._layer_type)
+        if not is_ironpython and self._primitives._app._aedt_version >= "2021.2":
+            return self._primitives._app.post.plot_model_obj(
+                objects=[self.name],
+                plot_as_separate_objects=True,
+                plot_air_objects=True,
+                show=show,
+            )
 
-    @layer_type.setter
-    def layer_type(self, value):
-        if type(value) is not type(self._layer_type):
-            self._layer_type = self._pedblayers._int_to_layer_types(value)
-            self.update_layers()
-        else:
-            self._layer_type = value
-            self.update_layers()
+    @pyaedt_function_handler()
+    def export_image(self, file_path=None):
+        """Export the current object to a specified file path.
 
-    @property
-    def material_name(self):
-        """Retrieve or update the material name.
+
+        .. note::
+           Works from AEDT 2021.2 in CPython only. PyVista has to be installed.
+
+        Parameters
+        ----------
+        file_path : str, optional
+            File name with full path. If `None` the exported image will be a ``png`` file that
+            will be saved in ``working_directory``.
+            To access the ``working_directory`` the use ``app.working_directory`` property.
 
         Returns
         -------
         str
-            Name of the material.
+            File path.
         """
-        try:
-            self._material_name = self._cloned_layer.GetMaterial()
-        except:
-            pass
-        return self._material_name
-
-    @material_name.setter
-    def material_name(self, value):
-        self._material_name = value
-        self.update_layers()
+        if not is_ironpython and self._primitives._app._aedt_version >= "2021.2":
+            if not file_path:
+                file_path = os.path.join(self._primitives._app.working_directory, self.name + ".png")
+            model_obj = self._primitives._app.post.plot_model_obj(
+                objects=[self.name],
+                show=False,
+                export_path=file_path,
+                plot_as_separate_objects=True,
+                clean_files=True,
+            )
+            if model_obj:
+                return model_obj.image_file
+        return False
 
     @property
-    def thickness_value(self):
-        """Thickness value.
+    def touching_objects(self):
+        """Get the objects that touch one of the vertex, edge midpoint or face of the object."""
+        if self.object_type == "Unclassified":
+            return []
+        list_names = []
+        for vertex in self.vertices:
+            body_names = self._primitives.get_bodynames_from_position(vertex.position)
+            a = [i for i in body_names if i != self.name and i not in list_names]
+            if a:
+                list_names.extend(a)
+        for edge in self.edges:
+            body_names = self._primitives.get_bodynames_from_position(edge.midpoint)
+            a = [i for i in body_names if i != self.name and i not in list_names]
+            if a:
+                list_names.extend(a)
+        for face in self.faces:
+            body_names = self._primitives.get_bodynames_from_position(face.center)
+            a = [i for i in body_names if i != self.name and i not in list_names]
+            if a:
+                list_names.extend(a)
+        return list_names
+
+    @pyaedt_function_handler()
+    def get_touching_faces(self, object_name):
+        """Get the objects that touch one of the face center of each face of the object.
 
+        Parameters
+        ----------
+        object_name : str, :class:`Object3d`
+            Object to check.
         Returns
         -------
-        float
-            Thickness value.
-        """
-        try:
-            self._thickness = self._cloned_layer.GetThicknessValue().ToDouble()
-        except:
-            pass
-        return self._thickness
+        list
+            list of objects and faces touching."""
 
-    @thickness_value.setter
-    def thickness_value(self, value):
-        self._thickness = value
-        self.update_layers()
+        _names = []
+        if isinstance(object_name, Object3d):
+            object_name = object_name.name
+        for face in self.faces:
+            body_names = self._primitives.get_bodynames_from_position(face.center)
+            if object_name in body_names:
+                _names.append(face)
+        return _names
 
     @property
-    def filling_material_name(self):
-        """Filling material.
+    def faces(self):
+        """Information for each face in the given part.
 
         Returns
         -------
-        str
-            Name of the filling material if it exists.
-        """
-        if (
-            self._layer_type == self._edb.Cell.LayerType.SignalLayer
-            or self._layer_type == self._edb.Cell.LayerType.ConductingLayer
-        ):
-            try:
-                self._filling_material_name = self._cloned_layer.GetFillMaterial()
-            except:
-                pass
-            return self._filling_material_name
-        return ""
+        list of :class:`pyaedt.modeler.elements3d.FacePrimitive`
+
+        References
+        ----------
+
+        >>> oEditor.GetFaceIDs
 
-    @filling_material_name.setter
-    def filling_material_name(self, value):
-        if (
-            self._layer_type == self._edb.Cell.LayerType.SignalLayer
-            or self._layer_type == self._edb.Cell.LayerType.ConductingLayer
-        ):
-            self._filling_material_name = value
-            self.update_layers()
+        """
+        if self.object_type == "Unclassified":
+            return []
+        faces = []
+        for face in list(self._oeditor.GetFaceIDs(self.name)):
+            face = int(face)
+            faces.append(FacePrimitive(self, face))
+        return faces
 
     @property
-    def negative_layer(self):
-        """Negative layer.
+    def faces_on_bounding_box(self):
+        """Return only the face ids of the faces touching the bounding box.
 
         Returns
         -------
-        bool
-            ``True`` when negative, ``False`` otherwise..
+        List of :class:`pyaedt.modeler.Object3d.FacePrimitive`
         """
-        if (
-            self._layer_type == self._edb.Cell.LayerType.SignalLayer
-            or self._layer_type == self._edb.Cell.LayerType.ConductingLayer
-        ):
-            try:
-                self._negative_layer = self._layer.GetNegative()
-            except:
-                pass
-        return self._negative_layer
-
-    @negative_layer.setter
-    def negative_layer(self, value):
-        if (
-            self._layer_type == self._edb.Cell.LayerType.SignalLayer
-            or self._layer_type == self._edb.Cell.LayerType.ConductingLayer
-        ):
-            self._negative_layer = value
-            self.update_layers()
+        f_list = []
+        for face in self.faces:
+            if face.is_on_bounding():
+                f_list.append(face)
+        return f_list
 
     @property
-    def roughness_enabled(self):
-        """Roughness enabled.
+    def face_closest_to_bounding_box(self):
+        """Return only the face ids of the face closest to the bounding box.
 
         Returns
         -------
-        bool
-            ``True`` if the layer has roughness, ``False`` otherwise.
+        :class:`pyaedt.modeler.elements3d.FacePrimitive`
         """
-        if (
-            self._layer_type == self._edb.Cell.LayerType.SignalLayer
-            or self._layer_type == self._edb.Cell.LayerType.ConductingLayer
-        ):
-            try:
-                self._roughness_enabled = self._layer.IsRoughnessEnabled()
-            except:
-                pass
-        return self._roughness_enabled
+        b = [float(i) for i in list(self._oeditor.GetModelBoundingBox())]
+        f_id = None
+        f_val = None
+        for face in self.faces:
+            c = face.center
+            p_dist = min(
+                [
+                    abs(c[0] - b[0]),
+                    abs(c[1] - b[1]),
+                    abs(c[2] - b[2]),
+                    abs(c[0] - b[3]),
+                    abs(c[1] - b[4]),
+                    abs(c[2] - b[5]),
+                ]
+            )
 
-    @roughness_enabled.setter
-    def roughness_enabled(self, value):
-        if (
-            self._layer_type == self._edb.Cell.LayerType.SignalLayer
-            or self._layer_type == self._edb.Cell.LayerType.ConductingLayer
-        ):
-            self._roughness_enabled = value
-            self.update_layers()
+            if f_val and p_dist < f_val or not f_val:
+                f_id = face
+                f_val = p_dist
+        return f_id
 
     @pyaedt_function_handler()
-    def assign_roughness_model_top(
-        self, model_type="huray", huray_radius="0.5um", huray_surface_ratio="2.9", groisse_roughness="1um"
-    ):
-        """Assign roughness model on conductor top.
+    def largest_face(self, n=1):
+        """Return only the face with the greatest area.
 
-        Parameters
-        ----------
-        model_type : str, optional
-            Type of roughness model. The default is ``"huray"``. Options are ``"huray"``, ``"groisse"``.
-        huray_radius : str, optional
-            Radius of huray model. The default is ``"0.5um"``.
-        huray_surface_ratio : str, float, optional.
-            Surface ratio of huray model. The default is ``"2.9"``.
-        groisse_roughness : str, float, optional
-            Roughness of groisse model. The default is ``"1um"``.
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
+        List of :class:`pyaedt.modeler.Object3d.FacePrimitive`
         """
-        if model_type == "huray":
-            self._roughness_model_top = [model_type, huray_radius, huray_surface_ratio]
-        elif model_type == "groisse":
-            self._roughness_model_top = [model_type, groisse_roughness]
-        else:
-            self._roughness_model_top = None
-        return self.update_layers()
+        f = []
+        for face in self.faces:
+            f.append((face.area, face))
+        f.sort(key=lambda tup: tup[0], reverse=True)
+        f_sorted = [x for y, x in f]
+        return f_sorted[:n]
 
     @pyaedt_function_handler()
-    def assign_roughness_model_bottom(
-        self, model_type="huray", huray_radius="0.5um", huray_surface_ratio="2.9", groisse_roughness="1um"
-    ):
-        """Assign roughness model on conductor bottom.
+    def longest_edge(self, n=1):
+        """Return only the edge with the greatest length.
 
-        Parameters
-        ----------
-        model_type : str, optional
-            Type of roughness model. The default is ``"huray"``. Options are ``"huray"``, ``"groisse"``.
-        huray_radius : str, optional
-            Radius of huray model. The default is ``"0.5um"``.
-        huray_surface_ratio : str, float, optional.
-            Surface ratio of huray model. The default is ``"2.9"``.
-        groisse_roughness : str, float, optional
-            Roughness of groisse model. The default is ``"1um"``.
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
+        List of :class:`pyaedt.modeler.Object3d.EdgePrimitive`
         """
-        if model_type == "huray":
-            self._roughness_model_bottom = [model_type, huray_radius, huray_surface_ratio]
-        elif model_type == "groisse":
-            self._roughness_model_bottom = [model_type, groisse_roughness]
-        else:
-            self._roughness_model_bottom = None
-        return self.update_layers()
+        e = []
+        for edge in self.edges:
+            e.append((edge.length, edge))
+        e.sort(key=lambda tup: tup[0], reverse=True)
+        e_sorted = [x for y, x in e]
+        return e_sorted[:n]
 
     @pyaedt_function_handler()
-    def assign_roughness_model_side(
-        self, model_type="huray", huray_radius="0.5um", huray_surface_ratio="2.9", groisse_roughness="1um"
-    ):
-        """Assign roughness model on conductor side.
+    def smallest_face(self, n=1):
+        """Return only the face with the smallest area.
 
-        Parameters
-        ----------
-        model_type : str, optional
-            Type of roughness model. The default is ``"huray"``. Options are ``"huray"``, ``"groisse"``.
-        huray_radius : str, optional
-            Radius of huray model. The default is ``"0.5um"``.
-        huray_surface_ratio : str, float, optional.
-            Surface ratio of huray model. The default is ``"2.9"``.
-        groisse_roughness : str, float, optional
-            Roughness of groisse model. The default is ``"1um"``.
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
+        List of :class:`pyaedt.modeler.Object3d.FacePrimitive`
         """
-        if model_type == "huray":
-            self._roughness_model_side = [model_type, huray_radius, huray_surface_ratio]
-        elif model_type == "groisse":
-            self._roughness_model_side = [model_type, groisse_roughness]
-        else:
-            self._roughness_model_side = None
-        return self.update_layers()
+        f = []
+        for face in self.faces:
+            f.append((face.area, face))
+        f.sort(key=lambda tup: tup[0])
+        f_sorted = [x for y, x in f]
+        return f_sorted[:n]
+
+    @pyaedt_function_handler()
+    def shortest_edge(self, n=1):
+        """Return only the edge with the smallest length.
+
+        Returns
+        -------
+        List of :class:`pyaedt.modeler.Object3d.EdgePrimitive`
+        """
+        e = []
+        for edge in self.edges:
+            e.append((edge.length, edge))
+        e.sort(
+            key=lambda tup: tup[0],
+        )
+        e_sorted = [x for y, x in e]
+        return e_sorted[:n]
 
     @property
-    def top_bottom_association(self):
-        """Top/bottom association layer.
+    def top_face_z(self):
+        """Top face in the Z direction of the object.
 
         Returns
         -------
-        int
-            Top/bottom association layer, where:
+        :class:`pyaedt.modeler.elements3d.FacePrimitive`
+
+        References
+        ----------
+
+        >>> oEditor.FaceCenter
 
-            * 0 - Top associated
-            * 1 - No association
-            * 2 - Bottom associated
-            * 4 - Number of top/bottom associations
-            * -1 -  Undefined.
         """
         try:
-            self._top_bottom_association = int(self._layer.GetTopBottomAssociation())
+            result = [(float(face.center[2]), face) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[-1][1]
         except:
-            pass
-        return self._top_bottom_association
+            return None
 
     @property
-    def lower_elevation(self):
-        """Lower elevation.
+    def bottom_face_z(self):
+        """Bottom face in the Z direction of the object.
 
         Returns
         -------
-        float
-            Lower elevation.
+        :class:`pyaedt.modeler.elements3d.FacePrimitive`
+
+        References
+        ----------
+
+        >>> oEditor.FaceCenter
+
         """
         try:
-            self._lower_elevation = self._cloned_layer.GetLowerElevation()
+            result = [(float(face.center[2]), face) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[0][1]
         except:
-            pass
-        return self._lower_elevation
-
-    @lower_elevation.setter
-    def lower_elevation(self, value):
-        self._lower_elevation = value
-        self.update_layers()
+            return None
 
     @property
-    def upper_elevation(self):
-        """Upper elevation.
+    def top_face_x(self):
+        """Top face in the X direction of the object.
 
         Returns
         -------
-        float
-            Upper elevation.
+        :class:`pyaedt.modeler.elements3d.FacePrimitive`
+
+        References
+        ----------
+
+        >>> oEditor.FaceCenter
+
         """
         try:
-            self._upper_elevation = self._cloned_layer.GetUpperElevation()
+            result = [(float(face.center[0]), face) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[-1][1]
         except:
-            pass
-        return self._upper_elevation
+            return None
 
     @property
-    def etch_factor(self):
-        """Etch factor.
+    def bottom_face_x(self):
+        """Bottom face in the X direction of the object.
 
         Returns
         -------
-        float
-            Etch factor if it exists, 0 otherwise.
+        :class:`pyaedt.modeler.elements3d.FacePrimitive`
+
+        References
+        ----------
+
+        >>> oEditor.FaceCenter
+
         """
-        if (
-            self._layer_type == self._edb.Cell.LayerType.SignalLayer
-            or self._layer_type == self._edb.Cell.LayerType.ConductingLayer
-        ):
-            try:
-                self._etch_factor = float(self._cloned_layer.GetEtchFactor().ToString())
-                return self._etch_factor
-            except:
-                pass
-        return 0
+        try:
+            result = [(float(face.center[0]), face) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[0][1]
+        except:
+            return None
 
-    @etch_factor.setter
-    def etch_factor(self, value):
-        if value is None:
-            value = 0
-        if (
-            self._layer_type == self._edb.Cell.LayerType.SignalLayer
-            or self._layer_type == self._edb.Cell.LayerType.ConductingLayer
-        ):
-            self._etch_factor = float(value)
-            self.update_layers()
-
-    @pyaedt_function_handler()
-    def plot(
-        self,
-        nets=None,
-        show_legend=True,
-        save_plot=None,
-        outline=None,
-        size=(2000, 1000),
-    ):
-        """Plot a layer to a Matplotlib 2D chart.
+    @property
+    def top_face_y(self):
+        """Top face in the Y direction of the object.
 
-        Parameters
+        Returns
+        -------
+        :class:`pyaedt.modeler.elements3d.FacePrimitive`
+
+        References
         ----------
-        nets : str, list, optional
-            Name of the nets to include in the plot. If `None` all the nets will be considered.
-        show_legend : bool, optional
-            If `True` the legend is shown in the plot. (default)
-            If `False` the legend is not shown.
-        save_plot : str, optional
-            If `None` the plot will be shown.
-            If a file path is specified the plot will be saved to such file.
-        outline : list, optional
-            List of points of the outline to plot.
-        size : tuple, optional
-            Image size in pixel (width, height).
-        """
-
-        self._pedblayers._pedbstackup._pedb.core_nets.plot(
-            nets=nets,
-            layers=self.name,
-            color_by_net=True,
-            show_legend=show_legend,
-            save_plot=save_plot,
-            outline=outline,
-            size=size,
-        )
 
-    @pyaedt_function_handler()
-    def init_vals(self):
-        """Initialize values."""
+        >>> oEditor.FaceCenter
+
+        """
         try:
-            self._name = self._layer.GetName()
-            self._layer_type = self._layer.GetLayerType()
-            self._thickness = self._layer.GetThicknessValue().ToString()
-            if (
-                self._layer_type == self._edb.Cell.LayerType.SignalLayer
-                or self._layer_type == self._edb.Cell.LayerType.ConductingLayer
-            ):
-                self._etch_factor = float(self._layer.GetEtchFactor().ToString())
-                self._filling_material_name = self._layer.GetFillMaterial()
-                self._negative_layer = self._layer.GetNegative()
-                self._roughness_enabled = self._layer.IsRoughnessEnabled()
-            self._material_name = self._layer.GetMaterial()
-            self._lower_elevation = self._layer.GetLowerElevation()
-            self._upper_elevation = self._layer.GetUpperElevation()
-            self._top_bottom_association = self._layer.GetTopBottomAssociation()
+            result = [(float(face.center[1]), face) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[-1][1]
         except:
-            pass
+            return None
 
-    @pyaedt_function_handler()
-    def update_layer_vals(
-        self,
-        layerName,
-        newLayer,
-        etchMap,
-        materialMap,
-        fillMaterialMap,
-        thicknessMap,
-        negativeMap,
-        roughnessMap,
-        layerTypeMap,
-    ):
-        """Update layer properties.
+    @property
+    def bottom_face_y(self):
+        """Bottom face in the X direction of the object.
 
-        Parameters
+        Returns
+        -------
+        :class:`pyaedt.modeler.elements3d.FacePrimitive`
+
+        References
         ----------
-        layerName :
 
-        newLayer :
+        >>> oEditor.FaceCenter
+
+        """
+        try:
+            result = [(float(face.center[1]), face) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[0][1]
+        except:
+            return None
 
-        materialMap :
+    @property
+    def top_edge_z(self):
+        """Top edge in the Z direction of the object. Midpoint is used as criteria to find the edge.
 
-        fillMaterialMap :
+        Returns
+        -------
+        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
 
-        thicknessMap :
+        References
+        ----------
 
-        negativeMap :
+        >>> oEditor.FaceCenter
 
-        roughnessMap :
+        """
+        try:
+            result = [(float(face.top_edge_z.midpoint[2]), face.top_edge_z) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[-1][1]
+        except:
+            return None
 
-        layerTypeMap :
+    @property
+    def bottom_edge_z(self):
+        """Bottom edge in the Z direction of the object. Midpoint is used as criteria to find the edge.
 
         Returns
         -------
-        type
-            Layer object.
+        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
 
         """
-        newLayer.SetName(layerName)
-
         try:
-            newLayer.SetLayerType(layerTypeMap)
+            result = [(float(face.bottom_edge_z.midpoint[2]), face.bottom_edge_z) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[0][1]
         except:
-            self._logger.error("Layer %s has unknown type %s.", layerName, layerTypeMap)
-            return False
-        if thicknessMap:
-            newLayer.SetThickness(self._get_edb_value(thicknessMap))
-        if materialMap:
-            newLayer.SetMaterial(materialMap)
-        if fillMaterialMap:
-            newLayer.SetFillMaterial(fillMaterialMap)
-        if negativeMap:
-            newLayer.SetNegative(negativeMap)
-        if roughnessMap:
-            newLayer.SetRoughnessEnabled(roughnessMap)
-            models = [self._roughness_model_top, self._roughness_model_bottom, self._roughness_model_side]
-            regions = [
-                self._edb.Cell.RoughnessModel.Region.Top,
-                self._edb.Cell.RoughnessModel.Region.Side,
-                self._edb.Cell.RoughnessModel.Region.Bottom,
-            ]
-            for mdl, region in zip(models, regions):
-                if not mdl:
-                    continue
-                model_type = mdl[0]
-                if model_type == "huray":
-                    radius = self._get_edb_value(mdl[1])
-                    surface_ratio = self._get_edb_value(mdl[2])
-                    model = self._edb.Cell.HurrayRoughnessModel(radius, surface_ratio)
-                else:
-                    roughness = self._get_edb_value(mdl[1])
-                    model = self._edb.Cell.GroisseRoughnessModel(roughness)
-                newLayer.SetRoughnessModel(region, model)
-        if isinstance(etchMap, float) and int(layerTypeMap) in [0, 2]:
-            etchVal = float(etchMap)
-        else:
-            etchVal = 0.0
-        if etchVal != 0.0:
-            newLayer.SetEtchFactorEnabled(True)
-            newLayer.SetEtchFactor(self._get_edb_value(etchVal))
-        else:
-            newLayer.SetEtchFactor(self._get_edb_value(etchVal))
-            newLayer.SetEtchFactorEnabled(False)
-        return newLayer
+            return None
 
-    @pyaedt_function_handler()
-    def set_elevation(self, layer, elev):
-        """Update the layer elevation.
+    @property
+    def top_edge_x(self):
+        """Top edge in the X direction of the object. Midpoint is used as criteria to find the edge.
 
-        Parameters
-        ----------
-        layer :
-            Layer object.
-        elev : float
-            Layer elevation.
+        Returns
+        -------
+        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
+
+        """
+        try:
+            result = [(float(face.top_edge_x.midpoint[0]), face.top_edge_x) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[-1][1]
+        except:
+            return None
+
+    @property
+    def bottom_edge_x(self):
+        """Bottom edge in the X direction of the object. Midpoint is used as criteria to find the edge.
 
         Returns
         -------
-        type
-            The layer which was updated.
+        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
 
         """
+        try:
+            result = [(float(face.bottom_edge_x.midpoint[0]), face.bottom_edge_x) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[0][1]
+        except:
+            return None
 
-        layer.SetLowerElevation(self._get_edb_value(elev))
-        return layer
+    @property
+    def top_edge_y(self):
+        """Top edge in the Y direction of the object. Midpoint is used as criteria to find the edge.
 
-    @pyaedt_function_handler()
-    def update_layers(self):
-        """Update all layers.
+        Returns
+        -------
+        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
+
+        """
+        try:
+            result = [(float(face.top_edge_y.midpoint[1]), face.top_edge_y) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[-1][1]
+        except:
+            return None
+
+    @property
+    def bottom_edge_y(self):
+        """Bottom edge in the X direction of the object. Midpoint is used as criteria to find the edge.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
+        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
+
         """
-        thisLC = self._edb.Cell.LayerCollection(self._active_layout.GetLayerCollection())
-        layer_collection_mode = thisLC.GetMode()
-        layers = list(list(thisLC.Layers(self._edb.Cell.LayerTypeSet.AllLayerSet)))
-        layers.reverse()
-        newLayers = List[self._edb.Cell.Layer]()
-        el = 0.0
-        for lyr in layers:
-            if not lyr.IsStackupLayer():
-                newLayers.Add(lyr.Clone())
-                continue
-            layerName = lyr.GetName()
-
-            if layerName == self.name:
-                newLayer = lyr.Clone()
-                newLayer = self.update_layer_vals(
-                    self._name,
-                    newLayer,
-                    self._etch_factor,
-                    self._material_name,
-                    self._filling_material_name,
-                    self._thickness,
-                    self._negative_layer,
-                    self._roughness_enabled,
-                    self._layer_type,
-                )
-                newLayer = self.set_elevation(newLayer, el)
-                el += newLayer.GetThickness()
-            else:
-                newLayer = lyr.Clone()
-                newLayer = self.set_elevation(newLayer, el)
-                el += newLayer.GetThickness()
-            newLayers.Add(newLayer)
-
-        lcNew = self._edb.Cell.LayerCollection()
-        newLayers.Reverse()
-        if not lcNew.AddLayers(newLayers):
-            self._logger.error("Failed to set new layers when updating the stackup information.")
-            return False
-        lcNew.SetMode(layer_collection_mode)
-        if not self._active_layout.SetLayerCollection(lcNew):
-            self._logger.error("Failed to set new layer stackup mode when updating the stackup information.")
-            return False
-        self._pedblayers._update_edb_objects()
-        time.sleep(1)
-        return True
+        try:
+            result = [(float(face.bottom_edge_y.midpoint[1]), face.bottom_edge_y) for face in self.faces]
+            result = sorted(result, key=lambda tup: tup[0])
+            return result[0][1]
+        except:
+            return None
 
+    @property
+    def edges(self):
+        """Information for each edge in the given part.
 
-class EDBLayers(object):
-    """Manages EDB functionalities for all primitive layers.
+        Returns
+        -------
+        list of :class:`pyaedt.modeler.elements3d.EdgePrimitive`
 
-    .. deprecated:: 0.6.5
-        There is no need to use core_stackup anymore. You can instantiate new class stackup directly from edb class.
+        References
+        ----------
 
-    Parameters
-    ----------
-    edb_stackup : :class:`pyaedt.edb_core.stackup.EdbStackup`
-        Inherited AEDT object.
+        >>> oEditor.GetEdgeIDsFromObject
 
-    Examples
-    --------
-    >>> from pyaedt import Edb
-    >>> edb = Edb(myedb, edbversion="2021.2")
-    >>> edb_layers = edb.core_stackup.stackup_layers
-    """
+        """
+        if self.object_type == "Unclassified":
+            return []
+        edges = []
+        for edge in self._primitives.get_object_edges(self.name):
+            edge = int(edge)
+            edges.append(EdgePrimitive(self, edge))
+        return edges
 
-    def __init__(self, edb_stackup):
-        self._stackup_mode = None
-        self._pedbstackup = edb_stackup
-        self._edb_object = {}
-        self._edb_layer_collection = None
-        self._update_edb_objects()
+    @property
+    def vertices(self):
+        """Information for each vertex in the given part.
 
-    def __getitem__(self, layername):
-        """Retrieve a layer.
+        Returns
+        -------
+        list of :class:`pyaedt.modeler.elements3d.VertexPrimitive`
 
-        Parameters
+        References
         ----------
-        layername : str
-            Name of the layer.
+
+        >>> oEditor.GetVertexIDsFromObject
+
+        """
+        if self.object_type == "Unclassified":
+            return []
+        vertices = []
+
+        v = [i for i in self._primitives.get_object_vertices(self.name)]
+        if not v:
+            for el in self.edges:
+                pos = [float(p) for p in self._primitives.oeditor.GetEdgePositionAtNormalizedParameter(el.id, 0)]
+                vertices.append(VertexPrimitive(self, -1, pos))
+        if settings.aedt_version > "2022.2":
+            v = v[::-1]
+        for vertex in v:
+            vertex = int(vertex)
+            vertices.append(VertexPrimitive(self, vertex))
+        return vertices
+
+    @property
+    def _oeditor(self):
+        """Pointer to the oEditor object in the AEDT API. This property is
+        intended primarily for use by FacePrimitive, EdgePrimitive, and
+        VertexPrimitive child objects.
 
         Returns
         -------
-        type
-            EDB Layer
-        """
+        oEditor COM Object
 
-        return self.layers[layername]
+        """
+        return self._primitives.oeditor
 
     @property
-    def _logger(self):
+    def logger(self):
         """Logger."""
-        return self._pedbstackup._logger
+        return self._primitives.logger
 
     @property
-    def _edb(self):
-        return self._pedbstackup._edb
+    def surface_material_name(self):
+        """Surface material name of the object.
+
+        Returns
+        -------
+        str or None
+            Name of the surface material when successful, ``None`` and a warning message otherwise.
 
-    def _get_edb_value(self, value):
-        return self._pedbstackup._get_edb_value(value)
+        References
+        ----------
 
-    @property
-    def _builder(self):
-        return self._pedbstackup._builder
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
 
-    @property
-    def _active_layout(self):
-        return self._pedbstackup._active_layout
+        """
+        if self._surface_material is not None:
+            return self._surface_material
+        if "Surface Material" in self.valid_properties and self.model:
+            self._surface_material = _retry_ntimes(
+                10, self._oeditor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Surface Material"
+            )
+            return self._surface_material.strip('"')
 
     @property
-    def layers(self):
-        """Dictionary of layers.
+    def group_name(self):
+        """Group the object belongs to.
 
         Returns
         -------
-        dict[str, :class:`pyaedt.edb_core.edb_data.layer_data.EDBLayer`]
-            Dictionary of layers.
+        str
+            Name of the group.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+
         """
-        if not self._edb_object:
-            self._update_edb_objects()
-        return self._edb_object
+        if self._m_groupName is not None:
+            return self._m_groupName
+        if "Group" in self.valid_properties:
+            self._m_groupName = _retry_ntimes(
+                10, self._oeditor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Group"
+            )
+            return self._m_groupName
 
-    @property
-    def edb_layers(self):
-        """EDB layers.
+    @group_name.setter
+    def group_name(self, name):
+        """Assign Object to a specific group. it creates a new group if the group doesn't exist.
+
+        Parameters
+        ----------
+        name : str
+            Name of the group to assign. Group will be created if it does not exist.
 
         Returns
         -------
-        list
-            List of EDB layers.
+        str
+            Name of the group.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+
         """
-        allLayers = list(list(self.layer_collection.Layers(self._edb.Cell.LayerTypeSet.AllLayerSet)))
-        allStackuplayers = filter(
-            lambda lyr: (lyr.GetLayerType() == self._edb.Cell.LayerType.DielectricLayer)
-            or (
-                lyr.GetLayerType() == self._edb.Cell.LayerType.SignalLayer
-                or lyr.GetLayerType() == self._edb.Cell.LayerType.ConductingLayer
-            ),
-            allLayers,
-        )
-        return sorted(
-            allStackuplayers,
-            key=lambda lyr=self._edb.Cell.StackupLayer: lyr.Clone().GetLowerElevation(),
-        )
+
+        if not list(self._oeditor.GetObjectsInGroup(name)):
+            self._oeditor.CreateGroup(
+                [
+                    "NAME:GroupParameter",
+                    "ParentGroupID:=",
+                    "Model",
+                    "Parts:=",
+                    self._m_name,
+                    "SubmodelInstances:=",
+                    "",
+                    "Groups:=",
+                    "",
+                ]
+            )
+            groupName = _retry_ntimes(
+                10, self._oeditor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Group"
+            )
+            self._oeditor.ChangeProperty(
+                [
+                    "NAME:AllTabs",
+                    [
+                        "NAME:Attributes",
+                        ["NAME:PropServers", groupName],
+                        ["NAME:ChangedProps", ["NAME:Name", "Value:=", name]],
+                    ],
+                ]
+            )
+            self._m_groupName = name
+        else:
+            vgroup = ["NAME:Group", "Value:=", name]
+            self._change_property(vgroup)
+            self._m_groupName = name
 
     @property
-    def signal_layers(self):
-        """Signal layers.
+    def material_name(self):
+        """Material name of the object.
 
         Returns
         -------
-        dict[str, :class:`pyaedt.edb_core.edb_data.layer_data.EDBLayer`]
-            Dictionary of signal layers.
+        str or None
+            Name of the material when successful, ``None`` and a warning message otherwise.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+
         """
-        self._signal_layers = OrderedDict({})
-        for layer, edblayer in self.layers.items():
-            if (
-                edblayer._layer_type == self._edb.Cell.LayerType.SignalLayer
-                or edblayer._layer_type == self._edb.Cell.LayerType.ConductingLayer
-            ):
-                self._signal_layers[layer] = edblayer
-        return self._signal_layers
-
-    @property
-    def edb_layer_collection(self):
-        """Copy of EDB layer collection.
-
-        Returns
-        -------
-        class : Ansys.Ansoft.Edb.Cell.LayerCollection
-            Collection of layers.
-        """
-        if not self._edb_layer_collection:
-            lc_readonly = self._pedbstackup._active_layout.GetLayerCollection()
-            layers = list(list(lc_readonly.Layers(self._edb.Cell.LayerTypeSet.AllLayerSet)))
-            layer_collection = self._edb.Cell.LayerCollection()
-
-            flag_first_layer = True
-            for lyr in layers:
-                if not lyr.IsStackupLayer():
-                    continue
-                lyr_clone = lyr.Clone()
-                lyr_name = lyr.GetName()
-                if flag_first_layer:
-                    layer_collection.AddLayerTop(lyr_clone)
-                    flag_first_layer = False
-                else:
-                    layer_collection.AddLayerAbove(lyr_clone, lyr_name)
-            self._edb_layer_collection = layer_collection
-
-        return self._edb_layer_collection
-
-    @property
-    def layer_collection(self):
-        """Layer collection.
-
-        Returns
-        -------
-        type
-            Collection of layers.
-        """
-        return self._active_layout.GetLayerCollection()
-
-    @property
-    def layer_collection_mode(self):
-        """Layer collection mode."""
-        return self._edb.Cell.LayerCollectionMode
-
-    @property
-    def layer_types(self):
-        """Layer types.
-
-        Returns
-        -------
-        type
-            Types of layers.
-        """
-        return self._edb.Cell.LayerType
-
-    @property
-    def stackup_mode(self):
-        """Stackup mode.
-
-        Returns
-        -------
-        int
-            Type of the stackup mode, where:
-
-            * 0 - Laminate
-            * 1 - Overlapping
-            * 2 - Multizone
-        """
-        self._stackup_mode = self.layer_collection.GetMode()
-        return self._stackup_mode
-
-    @pyaedt_function_handler()
-    def _int_to_layer_types(self, val):
-        if int(val) == 0:
-            return self.layer_types.SignalLayer
-        elif int(val) == 1:
-            return self.layer_types.DielectricLayer
-        elif int(val) == 2:
-            return self.layer_types.ConductingLayer
-        elif int(val) == 3:
-            return self.layer_types.AirlinesLayer
-        elif int(val) == 4:
-            return self.layer_types.ErrorsLayer
-        elif int(val) == 5:
-            return self.layer_types.SymbolLayer
-        elif int(val) == 6:
-            return self.layer_types.MeasureLayer
-        elif int(val) == 8:
-            return self.layer_types.AssemblyLayer
-        elif int(val) == 9:
-            return self.layer_types.SilkscreenLayer
-        elif int(val) == 10:
-            return self.layer_types.SolderMaskLayer
-        elif int(val) == 11:
-            return self.layer_types.SolderPasteLayer
-        elif int(val) == 12:
-            return self.layer_types.GlueLayer
-        elif int(val) == 13:
-            return self.layer_types.WirebondLayer
-        elif int(val) == 14:
-            return self.layer_types.UserLayer
-        elif int(val) == 16:
-            return self.layer_types.SIwaveHFSSSolverRegions
-        elif int(val) == 18:
-            return self.layer_types.OutlineLayer
-
-    @pyaedt_function_handler()
-    def _layer_types_to_int(self, layer_type):
-        if not isinstance(layer_type, int):
-            if layer_type == self.layer_types.SignalLayer:
-                return 0
-            elif layer_type == self.layer_types.DielectricLayer:
-                return 1
-            elif layer_type == self.layer_types.ConductingLayer:
-                return 2
-            elif layer_type == self.layer_types.AirlinesLayer:
-                return 3
-            elif layer_type == self.layer_types.ErrorsLayer:
-                return 4
-            elif layer_type == self.layer_types.SymbolLayer:
-                return 5
-            elif layer_type == self.layer_types.MeasureLayer:
-                return 6
-            elif layer_type == self.layer_types.AssemblyLayer:
-                return 8
-            elif layer_type == self.layer_types.SilkscreenLayer:
-                return 9
-            elif layer_type == self.layer_types.SolderMaskLayer:
-                return 10
-            elif layer_type == self.layer_types.SolderPasteLayer:
-                return 11
-            elif layer_type == self.layer_types.GlueLayer:
-                return 12
-            elif layer_type == self.layer_types.WirebondLayer:
-                return 13
-            elif layer_type == self.layer_types.UserLayer:
-                return 14
-            elif layer_type == self.layer_types.SIwaveHFSSSolverRegions:
-                return 16
-            elif layer_type == self.layer_types.OutlineLayer:
-                return 18
-        elif isinstance(layer_type, int):
-            return layer_type
-
-    @stackup_mode.setter
-    def stackup_mode(self, value):
-        if value == 0 or value == self.layer_collection_mode.Laminate:
-            self.layer_collection.SetMode(self.layer_collection_mode.Laminate)
-        elif value == 1 or value == self.layer_collection_mode.Overlapping:
-            self.layer_collection.SetMode(self.layer_collection_mode.Overlapping)
-        elif value == 2 or value == self.layer_collection_mode.MultiZone:
-            self.layer_collection.SetMode(self.layer_collection_mode.MultiZone)
-
-    @pyaedt_function_handler()
-    def _update_edb_objects(self):
-        self._edb_object = OrderedDict({})
-        layers = self.edb_layers
-        for i in range(len(layers)):
-            self._edb_object[layers[i].GetName()] = EDBLayer(layers[i], self)
-        return True
+        if self._material_name is not None:
+            return self._material_name
+        if "Material" in self.valid_properties and self.model:
+            mat = _retry_ntimes(10, self._oeditor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Material")
+            self._material_name = ""
+            if mat:
+                self._material_name = mat.strip('"').lower()
+            return self._material_name
+        return ""
 
-    @pyaedt_function_handler()
-    def _update_stackup(self):
-        self._active_layout.SetLayerCollection(self.edb_layer_collection)
-        self._update_edb_objects()
-        return True
+    @material_name.setter
+    def material_name(self, mat):
+        matobj = self._primitives._materials.checkifmaterialexists(mat)
+        if matobj:
+            if not self.model:
+                self.model = True
+            vMaterial = ["NAME:Material", "Value:=", chr(34) + matobj.name + chr(34)]
+            self._change_property(vMaterial)
+            self._material_name = matobj.name.lower()
+            self._solve_inside = None
+        else:
+            self.logger.warning("Material %s does not exist.", mat)
 
-    @pyaedt_function_handler()
-    def insert_layer_above(
-        self,
-        layer_name,
-        base_layer,
-        material="copper",
-        fillMaterial="",
-        thickness="35um",
-        layerType=0,
-        negative_layer=False,
-        roughness_enabled=False,
-        etch_factor=None,
-    ):
-        """Insert a layer above the specified base layer.
+    @surface_material_name.setter
+    def surface_material_name(self, mat):
+        try:
+            if not self.model:
+                self.model = True
+            self._surface_material = mat
+            vMaterial = ["NAME:Surface Material", "Value:=", '"' + mat + '"']
+            self._change_property(vMaterial)
+            self._surface_material = mat
+        except:
+            self.logger.warning("Material %s does not exist", mat)
 
-        Parameters
-        ----------
-        layer_name : str
-            Name of the layer to add.
-        base_layer : str
-            Name of the layer after which to add the new layer.
-            The default is ``None``.
-        material : str, optional
-            Name of the material. The default is ``"copper"``.
-        fillMaterial : str, optional
-            Name of the fill material. The default is ``""``.)
-        thickness : str, optional
-            Thickness value, including units. The default is ``"35um"``.
-        layerType :
-            Type of the layer. The default is ``0``
-            ``0``: Signal layer.
-            ``1``: Dielectric layer.
-            ``2``: Conducting plane layer.
-            ``3``: Airline layer.
-            ``4``: Error layer.
-            ``5``: Symbol layer.
-            ``6``: Measure layer.
-            ``8``: Assembly layer.
-            ``9``: Silkscreen layer.
-            ``10``: Solder Mask layer.
-            ``11``: Solder Paste layer.
-        negative_layer : bool, optional
-            ``True`` when negative, ``False`` otherwise.
-        roughness_enabled : bool, optional
-            ``True`` if the layer has roughness, ``False`` otherwise.
-        etch_factor : optional
-            Etch value if any. The default is ``None``.
+    @property
+    def id(self):
+        """ID of the object.
 
         Returns
         -------
-        :class:`pyaedt.edb_core.edb_data.layer_data.EDBLayer`
-            Layer Object for stackup layers.
-        """
-
-        new_layer = self._edb.Cell.StackupLayer(
-            layer_name,
-            self._int_to_layer_types(layerType),
-            self._get_edb_value(0),
-            self._get_edb_value(0),
-            "",
-        )
-        edb_layer = EDBLayer(new_layer.Clone(), self._pedbstackup)
-        new_layer = edb_layer.update_layer_vals(
-            layer_name,
-            new_layer,
-            etch_factor,
-            material,
-            fillMaterial,
-            thickness,
-            negative_layer,
-            roughness_enabled,
-            self._int_to_layer_types(layerType),
-        )
-        self.edb_layer_collection.AddLayerAbove(new_layer, base_layer)
-        self._edb_object[layer_name] = edb_layer
-        self._update_stackup()
-        return self.layers[layer_name]
-
-    @pyaedt_function_handler()
-    def add_layer(
-        self,
-        layerName,
-        start_layer=None,
-        material="copper",
-        fillMaterial="",
-        thickness="35um",
-        layerType=0,
-        negative_layer=False,
-        roughness_enabled=False,
-        etchMap=None,
-    ):
-        """Add a layer after a specific layer.
+        int or None
+            ID of the object when successful, ``None`` otherwise.
 
-        Parameters
+        References
         ----------
-        layerName : str
-            Name of the layer to add.
-        start_layer : str, optional
-            Name of the layer after which to add the new layer.
-            The default is ``None``.
-        material : str, optional
-            Name of the material. The default is ``"copper"``.
-        fillMaterial : str, optional
-            Name of the fill material. The default is ``""``.)
-        thickness : str, optional
-            Thickness value, including units. The default is ``"35um"``.
-        layerType :
-            Type of the layer. The default is ``0``
-            ``0``: Signal layer.
-            ``1``: Dielectric layer.
-            ``2``: Conducting plane layer.
-            ``3``: Airline layer.
-            ``4``: Error layer.
-            ``5``: Symbol layer.
-            ``6``: Measure layer.
-            ``8``: Assembly layer.
-            ``9``: Silkscreen layer.
-            ``10``: Solder Mask layer.
-            ``11``: Solder Paste layer.
-        negative_layer : bool, optional
-            ``True`` when negative, ``False`` otherwise.
-        roughness_enabled : bool, optional
-            ``True`` if the layer has roughness, ``False`` otherwise.
-        etchMap : optional
-            Etch value if any. The default is ``None``.
+
+        >>> oEditor.GetObjectIDByName
+
+        """
+        if not self._id:
+            try:
+                self._id = self._primitives.oeditor.GetObjectIDByName(self._m_name)
+            except:
+                return None
+        return self._id
+
+    @property
+    def object_type(self):
+        """Type of the object.
+
+        Options are:
+             * Solid
+             * Sheet
+             * Line
 
         Returns
         -------
-        :class:`pyaedt.edb_core.edb_data.layer_data.EDBLayer`
-            Layer Object for stackup layers. Boolean otherwise (True in case of success).
-        """
-        thisLC = self._pedbstackup._active_layout.GetLayerCollection()
-        layers = list(list(thisLC.Layers(self._edb.Cell.LayerTypeSet.AllLayerSet)))
-        layers.reverse()
-        el = 0.0
-        lcNew = self._edb.Cell.LayerCollection()
-
-        if not layers or not start_layer:
-            if int(layerType) > 2:
-                newLayer = self._edb.Cell.Layer(layerName, self._int_to_layer_types(layerType))
-                lcNew.AddLayerTop(newLayer)
-            else:
-                newLayer = self._edb.Cell.StackupLayer(
-                    layerName,
-                    self._int_to_layer_types(layerType),
-                    self._get_edb_value(0),
-                    self._get_edb_value(0),
-                    "",
-                )
-                self._edb_object[layerName] = EDBLayer(newLayer.Clone(), self._pedbstackup)
-                newLayer = self._edb_object[layerName].update_layer_vals(
-                    layerName,
-                    newLayer,
-                    etchMap,
-                    material,
-                    fillMaterial,
-                    thickness,
-                    negative_layer,
-                    roughness_enabled,
-                    self._int_to_layer_types(layerType),
-                )
-                newLayer.SetLowerElevation(self._get_edb_value(el))
-
-                lcNew.AddLayerTop(newLayer)
-                el += newLayer.GetThickness()
-            for lyr in layers:
-                if not lyr.IsStackupLayer():
-                    continue
-                newLayer = lyr.Clone()
-                newLayer.SetLowerElevation(self._get_edb_value(el))
-                el += newLayer.GetThickness()
-                lcNew.AddLayerTop(newLayer)
-            for lyr in layers:
-                if not lyr.IsStackupLayer():
-                    lcNew.AddLayerTop(lyr.Clone())
-                    continue
-        else:
-            for lyr in layers:
-                if not lyr.IsStackupLayer():
-                    continue
-                if lyr.GetName() == start_layer:
-                    original_layer = lyr.Clone()
-                    original_layer.SetLowerElevation(self._get_edb_value(el))
-                    lcNew.AddLayerTop(original_layer)
-                    el += original_layer.GetThickness()
-                    newLayer = self._edb.Cell.StackupLayer(
-                        layerName,
-                        self._int_to_layer_types(layerType),
-                        self._get_edb_value(0),
-                        self._get_edb_value(0),
-                        "",
-                    )
-                    self._edb_object[layerName] = EDBLayer(newLayer.Clone(), self._pedbstackup)
-                    newLayer = self._edb_object[layerName].update_layer_vals(
-                        layerName,
-                        newLayer,
-                        etchMap,
-                        material,
-                        fillMaterial,
-                        thickness,
-                        negative_layer,
-                        roughness_enabled,
-                        self._int_to_layer_types(layerType),
-                    )
-                    newLayer.SetLowerElevation(self._get_edb_value(el))
-                    lcNew.AddLayerTop(newLayer)
-                    el += newLayer.GetThickness()
-                    # newLayers.Add(original_layer)
-                else:
-                    newLayer = lyr.Clone()
-                    newLayer.SetLowerElevation(self._get_edb_value(el))
-                    el += newLayer.GetThickness()
-                    lcNew.AddLayerTop(newLayer)
-            for lyr in layers:
-                if not lyr.IsStackupLayer():
-                    lcNew.AddLayerTop(lyr.Clone())
-                    continue
-        if not self._active_layout.SetLayerCollection(lcNew):
-            self._logger.error("Failed to set new layers when updating the stackup information.")
-            return False
-        self._update_edb_objects()
-        allLayers = [
-            i.GetName() for i in list(list(self.layer_collection.Layers(self._edb.Cell.LayerTypeSet.AllLayerSet)))
-        ]
-        if layerName in self.layers:
-            return self.layers[layerName]
-        elif layerName in allLayers:
-            return True
-        return False
+        str
+            Type of the object.
 
-    def add_outline_layer(self, outline_name="Outline"):
         """
-        Add an outline layer named ``"Outline"`` if it is not present.
+        if self._object_type:
+            return self._object_type
+        if self._m_name in list(self._oeditor.GetObjectsInGroup("Solids")):
+            self._object_type = "Solid"
+        elif self._m_name in list(self._oeditor.GetObjectsInGroup("Sheets")):
+            self._object_type = "Sheet"
+        elif self._m_name in list(self._oeditor.GetObjectsInGroup("Lines")):
+            self._object_type = "Line"
+        elif self._m_name in list(self._oeditor.GetObjectsInGroup("Unclassified")):  # pragma: no cover
+            self._object_type = "Unclassified"  # pragma: no cover
+        return self._object_type
+
+    @property
+    def is3d(self):
+        """Check for if the object is 3D.
 
         Returns
         -------
         bool
-            "True" if succeeded.
+            ``True`` when successful, ``False`` when failed.
+
         """
-        outlineLayer = self._edb.Cell.Layer.FindByName(self._active_layout.GetLayerCollection(), outline_name)
-        if outlineLayer.IsNull():
-            return self.add_layer(
-                outline_name,
-                layerType=self.layer_types.OutlineLayer,
-                material="",
-                thickness="",
-            )
+        if self.object_type == "Solid":
+            return True
         else:
             return False
 
-    @pyaedt_function_handler()
-    def remove_layer(self, layername):
-        """Remove a layer.
-
-        Parameters
-        ----------
-        layername : str
-            Name of the layer.
+    @property
+    def mass(self):
+        """Object mass.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-        """
-        thisLC = self._edb.Cell.LayerCollection(self._pedbstackup._active_layout.GetLayerCollection())
-        layers = list(list(thisLC.Layers(self._edb.Cell.LayerTypeSet.AllLayerSet)))
-        layers.reverse()
-        newLayers = List[self._edb.Cell.Layer]()
-        el = 0.0
-        for lyr in layers:
-            if not lyr.IsStackupLayer():
-                newLayers.Add(lyr.Clone())
-                continue
-            if not (layername == lyr.GetName()):
-                newLayer = lyr.Clone()
-                newLayer = self._edb_object[lyr.GetName()].set_elevation(newLayer, el)
-                el += newLayer.GetThickness()
-                newLayers.Add(newLayer)
-        lcNew = self._edb.Cell.LayerCollection()
-        newLayers.Reverse()
-        if not lcNew.AddLayers(newLayers) or not self._pedbstackup._active_layout.SetLayerCollection(lcNew):
-            self._logger.error("Failed to set new layers when updating the stackup information.")
-            return False
-        self._update_edb_objects()
-        return True
+        float or None
+            Mass of the object when successful, 0.0 otherwise. Mass of the volume in kg since AEDT mass density is
+            always in kg/m^3
 
+        References
+        ----------
 
-class LayerEdbClass(object):
-    """Manages Edb Layers. Replaces EDBLayer."""
+        >>> oEditor.GetObjectVolume
 
-    def __init__(self, pclass, name):
-        self._pclass = pclass
-        self._name = name
-        self._color = ()
-        self._type = ""
-        self._material = ""
-        self._conductivity = 0.0
-        self._permittivity = 0.0
-        self._loss_tangent = 0.0
-        self._dielectric_fill = ""
-        self._thickness = 0.0
-        self._etch_factor = 0.0
-        self._roughness_enabled = False
-        self._top_hallhuray_nodule_radius = 0.5e-6
-        self._top_hallhuray_surface_ratio = 2.9
-        self._bottom_hallhuray_nodule_radius = 0.5e-6
-        self._bottom_hallhuray_surface_ratio = 2.9
-        self._side_hallhuray_nodule_radius = 0.5e-6
-        self._side_hallhuray_surface_ratio = 2.9
-        self._material = None
-        self._upper_elevation = 0.0
-        self._lower_elevation = 0.0
+        """
+        if self.model and self.material_name:
+            volume = self._primitives.oeditor.GetObjectVolume(self._m_name)
+            units = self.object_units
+            mass_density = (
+                float(self._primitives._materials[self.material_name].mass_density.value)
+                * float(volume)
+                * float(AEDT_UNITS["Length"][str(units)]) ** 3
+            )
+            self._mass = mass_density
+        else:
+            self._mass = 0.0
+        return self._mass
 
     @property
-    def lower_elevation(self):
-        """Lower elevation.
+    def volume(self):
+        """Object volume.
 
         Returns
         -------
         float
-            Lower elevation.
-        """
-        try:
-            self._lower_elevation = self._edb_layer.GetLowerElevation()
-        except:
-            pass
-        return self._lower_elevation
+            Volume of the object when successful, 0.0 otherwise.
+
+        References
+        ----------
 
-    @lower_elevation.setter
-    def lower_elevation(self, value):
-        layer_clone = self._edb_layer
-        layer_clone.SetLowerElevation(self._pclass._edb_value(value))
-        self._pclass._set_layout_stackup(layer_clone, "change_attribute")
+        >>> oEditor.GetObjectVolume
+
+        """
+        if self.object_type == "Solid":
+            self._volume = float(self._primitives.oeditor.GetObjectVolume(self._m_name))
+        else:
+            self._volume = 0.0
+        return self._volume
 
     @property
-    def upper_elevation(self):
-        """Upper elevation.
+    def name(self):
+        """Name of the object as a string value.
 
         Returns
         -------
-        float
-            Upper elevation.
+        str
+           Name of object as a string value.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+
         """
-        try:
-            self._upper_elevation = self._edb_layer.GetUpperElevation()
-        except:
+        return self._m_name
+
+    @name.setter
+    def name(self, obj_name):
+        if obj_name not in self._primitives.object_names:
+            if obj_name != self._m_name:
+                vName = []
+                vName.append("NAME:Name")
+                vName.append("Value:=")
+                vName.append(obj_name)
+                vChangedProps = ["NAME:ChangedProps", vName]
+                vPropServers = ["NAME:PropServers"]
+                vPropServers.append(self._m_name)
+                vGeo3d = ["NAME:Geometry3DAttributeTab", vPropServers, vChangedProps]
+                vOut = ["NAME:AllTabs", vGeo3d]
+                _retry_ntimes(10, self._primitives.oeditor.ChangeProperty, vOut)
+                self._m_name = obj_name
+                self._primitives.add_new_objects()
+                self._primitives.cleanup_objects()
+        else:
             pass
-        return self._upper_elevation
 
     @property
-    def _edb(self):
-        return self._pclass._pedb.edb
+    def valid_properties(self):
+        """Valid properties.
+
+        References
+        ----------
+
+        >>> oEditor.GetProperties
+        """
+        if not self._all_props:
+            self._all_props = _retry_ntimes(10, self._oeditor.GetProperties, "Geometry3DAttributeTab", self._m_name)
+        return self._all_props
+
+    @property
+    def color(self):
+        """Part color as a tuple of integer values for `(Red, Green, Blue)` color values.
+
+        If the integer values are outside the range 0-255, then limit the values. Invalid inputs are ignored.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+
+        Examples
+        --------
+        >>> part.color = (255,255,0)
+
+        """
+        if self._color is not None:
+            return self._color
+        if "Color" in self.valid_properties:
+            color = _retry_ntimes(10, self._oeditor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Color")
+            if color:
+                b = (int(color) >> 16) & 255
+                g = (int(color) >> 8) & 255
+                r = int(color) & 255
+                self._color = (r, g, b)
+            else:
+                self._color = (0, 195, 255)
+            return self._color
+
+    @property
+    def color_string(self):
+        """Color tuple as a string in the format '(Red, Green, Blue)'.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+        """
+        return "({} {} {})".format(self.color[0], self.color[1], self.color[2])
+
+    @color.setter
+    def color(self, color_value):
+        color_tuple = None
+        if isinstance(color_value, str):
+            try:
+                color_tuple = rgb_color_codes[color_value]
+            except KeyError:
+                parse_string = color_value.replace(")", "").replace("(", "").split()
+                if len(parse_string) == 3:
+                    color_tuple = tuple([int(x) for x in parse_string])
+        else:
+            try:
+                color_tuple = tuple([int(x) for x in color_value])
+            except ValueError:
+                pass
+
+        if color_tuple:
+            try:
+                R = clamp(color_tuple[0], 0, 255)
+                G = clamp(color_tuple[1], 0, 255)
+                B = clamp(color_tuple[2], 0, 255)
+                vColor = ["NAME:Color", "R:=", str(R), "G:=", str(G), "B:=", str(B)]
+                self._change_property(vColor)
+                self._color = (R, G, B)
+            except TypeError:
+                color_tuple = None
+        else:
+            msg_text = "Invalid color input {} for object {}.".format(color_value, self._m_name)
+            self._primitives.logger.warning(msg_text)
+
+    @property
+    def transparency(self):
+        """Part transparency as a value between 0.0 and 1.0.
+
+        If the value is outside the range, then apply a limit. If the value is not a valid number, set to ``0.0``.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+
+        """
+        if self._transparency is not None:
+            return self._transparency
+        if "Transparent" in self.valid_properties:
+            transp = _retry_ntimes(
+                10, self._oeditor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Transparent"
+            )
+            try:
+                self._transparency = float(transp)
+            except:
+                self._transparency = 0.3
+            return self._transparency
+
+    @transparency.setter
+    def transparency(self, T):
+        try:
+            trans_float = float(T)
+            if trans_float < 0.0:
+                trans_float = 0.0
+            elif trans_float > 1.0:
+                trans_float = 1.0
+        except ValueError:
+            trans_float = 0.0
+        vTrans = ["NAME:Transparent", "Value:=", str(trans_float)]
+
+        self._change_property(vTrans)
+
+        self._transparency = trans_float
 
     @property
-    def _edb_layer(self):
-        for l in self._pclass._edb_layer_list:
-            if l.GetName() == self._name:
-                return l.Clone()
+    def object_units(self):
+        """Object units."""
+        return self._primitives.model_units
 
     @property
-    def is_stackup_layer(self):
-        """Determine whether this layer is a stackup layer.
+    def part_coordinate_system(self):
+        """Part coordinate system.
 
         Returns
         -------
-        bool
-            True if this layer is a stackup layer, False otherwise.
+        str
+            Name of the part coordinate system.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+
         """
-        return self._edb_layer.IsStackupLayer()
+        if self._part_coordinate_system is not None and not isinstance(self._part_coordinate_system, int):
+            return self._part_coordinate_system
+        if "Orientation" in self.valid_properties:
+            self._part_coordinate_system = _retry_ntimes(
+                10, self._oeditor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Orientation"
+            )
+            return self._part_coordinate_system
+
+    @part_coordinate_system.setter
+    def part_coordinate_system(self, sCS):
+        pcs = ["NAME:Orientation", "Value:=", sCS]
+        self._change_property(pcs)
+        self._part_coordinate_system = sCS
+        return True
 
     @property
-    def is_negative(self):
-        """Determine whether this layer is a negative layer.
+    def solve_inside(self):
+        """Part solve inside flag.
 
         Returns
         -------
         bool
-            True if this layer is a negative layer, False otherwise.
+            ``True`` when ``"solve-inside"`` is activated for the part, ``False`` otherwise.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+
         """
-        return self._edb_layer.GetNegative()
+        if self._solve_inside is not None:
+            return self._solve_inside
+        if "Solve Inside" in self.valid_properties and self.model:
+            solveinside = _retry_ntimes(
+                10, self._oeditor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Solve Inside"
+            )
+            if solveinside == "false" or solveinside == "False":
+                self._solve_inside = False
+            else:
+                self._solve_inside = True
+            return self._solve_inside
+        return None
 
-    @is_negative.setter
-    def is_negative(self, value):
-        layer_clone = self._edb_layer
-        layer_clone.SetNegative(value)
-        self._pclass._set_layout_stackup(layer_clone, "change_attribute")
+    @solve_inside.setter
+    def solve_inside(self, S):
+        if not self.model:
+            self.model = True
+        vSolveInside = []
+        # fS = self._to_boolean(S)
+        fs = S
+        vSolveInside.append("NAME:Solve Inside")
+        vSolveInside.append("Value:=")
+        vSolveInside.append(fs)
+        self._change_property(vSolveInside)
+        self._solve_inside = fs
 
     @property
-    def color(self):
-        """Retrieve color of the layer.
+    def display_wireframe(self):
+        """Wireframe property of the part.
 
         Returns
         -------
-        tuple
-            RGB.
+        bool
+            ``True`` when wirefame is activated for the part, ``False`` otherwise.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+
         """
-        layer_color = self._edb_layer.GetColor()
-        return layer_color.Item1, layer_color.Item2, layer_color.Item3
+        if self._wireframe is not None:
+            return self._wireframe
+        if "Display Wireframe" in self.valid_properties:
+            wireframe = _retry_ntimes(
+                10, self._oeditor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Display Wireframe"
+            )
+            if wireframe == "true" or wireframe == "True":
+                self._wireframe = True
+            else:
+                self._wireframe = False
+            return self._wireframe
 
-    @color.setter
-    def color(self, rgb):
-        layer_clone = self._edb_layer
-        layer_clone.SetColor(*rgb)
-        self._pclass._set_layout_stackup(layer_clone, "change_attribute")
-        self._color = rgb
+    @display_wireframe.setter
+    def display_wireframe(self, fWireframe):
+        vWireframe = ["NAME:Display Wireframe", "Value:=", fWireframe]
+        # fwf = self._to_boolean(wf)
+
+        self._change_property(vWireframe)
+        self._wireframe = fWireframe
+
+    @pyaedt_function_handler()
+    def history(self):
+        """Object history.
+
+        Returns
+        -------
+            :class:`pyaedt.modeler.cad.elements3d.BinaryTree` when successful,
+            ``False`` when failed.
+
+        """
+        try:
+            child_object = self._oeditor.GetChildObject(self.name)
+            parent = BinaryTreeNode(self.name, child_object, True)
+            return parent
+        except:
+            return False
 
     @property
-    def transparency(self):
-        """Retrieve transparency of the layer.
+    def model(self):
+        """Part model or non-model property.
 
         Returns
         -------
-        int
-            An integer between 0 and 100 with 0 being fully opaque and 100 being fully transparent.
+        bool
+            ``True`` when model, ``False`` otherwise.
+
+        References
+        ----------
+
+        >>> oEditor.GetPropertyValue
+        >>> oEditor.ChangeProperty
+
         """
-        return self._edb_layer.GetTransparency()
+        if self._model is not None:
+            return self._model
+        if "Model" in self.valid_properties:
+            mod = _retry_ntimes(10, self._oeditor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Model")
+            if mod == "false" or mod == "False":
+                self._model = False
+            else:
+                self._model = True
+            return self._model
 
-    @transparency.setter
-    def transparency(self, trans):
-        layer_clone = self._edb_layer
-        layer_clone.SetTransparency(trans)
-        self._pclass._set_layout_stackup(layer_clone, "change_attribute")
+    @model.setter
+    def model(self, fModel):
+        vArg1 = ["NAME:Model", "Value:=", fModel]
+        fModel = _to_boolean(fModel)
+        self._change_property(vArg1)
+        self._model = fModel
 
-    @property
-    def name(self):
-        """Retrieve name of the layer.
+    @pyaedt_function_handler()
+    def unite(self, object_list):
+        """Unite a list of objects with this object.
+
+        Parameters
+        ----------
+        object_list : list of str or list of pyaedt.modeler.object3d.Object3d
+            List of objects.
 
         Returns
         -------
-        str
+        :class:`pyaedt.modeler.cad.object3d.Object3d`
+           Object 3D object.
+
+        References
+        ----------
+
+        >>> oEditor.Unite
+
         """
-        return self._edb_layer.GetName()
+        unite_list = [self.name] + self._primitives.modeler.convert_to_selections(object_list, return_list=True)
+        self._primitives.modeler.unite(unite_list)
+        return self
 
-    @name.setter
-    def name(self, name):
-        layer_clone = self._edb_layer
-        layer_clone.SetName(name)
-        self._pclass._set_layout_stackup(layer_clone, "change_name", self._name)
-        self._name = name
-
-    @property
-    def type(self):
-        """Retrieve type of the layer."""
-        return re.sub(r"Layer$", "", self._edb_layer.GetLayerType().ToString()).lower()
-
-    @type.setter
-    def type(self, new_type):
-        if new_type == self.type:
-            return
-        if new_type == "signal":
-            self._edb_layer.SetLayerType(self._edb.Cell.LayerType.SignalLayer)
-            self._type = new_type
-        elif new_type == "dielectric":
-            self._edb_layer.SetLayerType(self._edb.Cell.LayerType.DielectricLayer)
-            self._type = new_type
-        else:
-            return
+    @pyaedt_function_handler()
+    def intersect(self, theList, keep_originals=False):
+        """Intersect the active object with a given list.
 
-    @property
-    def material(self):
-        """Get/Set the material loss_tangent.
+        Parameters
+        ----------
+        theList : list
+            List of objects.
+        keep_originals : bool, optional
+            Whether to keep the original object. The default is ``False``.
 
         Returns
         -------
-        float
+        :class:`pyaedt.modeler.cad.object3d.Object3d`
+            Retrieve the resulting 3D Object when succeeded.
+
+        References
+        ----------
+
+        >>> oEditor.Intersect
         """
-        return self._edb_layer.GetMaterial()
+        theList = [self.name] + self._primitives.modeler.convert_to_selections(theList, return_list=True)
+        self._primitives.modeler.intersect(theList, keep_originals)
+        return self
 
-    @material.setter
-    def material(self, name):
-        layer_clone = self._edb_layer
-        layer_clone.SetMaterial(name)
-        self._pclass._set_layout_stackup(layer_clone, "change_attribute")
-        self._material = name
+    @pyaedt_function_handler()
+    def split(self, plane, sides="Both"):
+        """Split the active object.
 
-    @property
-    def conductivity(self):
-        """Get the material conductivity.
+        Parameters
+        ----------
+        plane : str
+            Coordinate plane of the cut or the Application.PLANE object.
+            Choices for the coordinate plane are ``"XY"``, ``"YZ"``, and ``"ZX"``.
+        sides : str, optional
+            Which side to keep. Options are ``"Both"``, ``"PositiveOnly"``,
+            and ``"NegativeOnly"``. The default is ``"Both"``, in which case
+            all objects are kept after the split.
 
         Returns
         -------
-        float
+        list of str
+            List of split objects.
+
+        References
+        ----------
+
+        >>> oEditor.Split
         """
-        if self.material in self._pclass._pedb.materials.materials:
-            self._conductivity = self._pclass._pedb.materials[self.material].conductivity
-            return self._conductivity
+        return self._primitives.modeler.split(self.name, plane, sides)
 
-        return None
+    @pyaedt_function_handler()
+    def mirror(self, position, vector, duplicate=False):
+        """Mirror a selection.
 
-    @property
-    def permittivity(self):
-        """Get the material permittivity.
+        Parameters
+        ----------
+        position : list of int or float
+            Cartesian ``[x, y, z]`` coordinates or
+            the ``Application.Position`` object of a point in the plane used for the mirror operation.
+        vector : list of float
+            Vector in Cartesian coordinates ``[x1, y1, z1]``  or
+            the ``Application.Position`` object for the vector normal to the plane used for the mirror operation.
 
         Returns
         -------
-        float
+        :class:`pyaedt.modeler.cad.object3d.Object3d`
+            3D object.
+            ``False`` when failed.
+
+        References
+        ----------
+
+        >>> oEditor.Mirror
         """
-        if self.material in self._pclass._pedb.materials.materials:
-            self._permittivity = self._pclass._pedb.materials[self.material].permittivity
-            return self._permittivity
-        return None
+        if self._primitives.modeler.mirror(self.id, position=position, vector=vector, duplicate=duplicate):
+            return self
+        return False
 
-    @property
-    def loss_tangent(self):
-        """Get the material loss_tangent.
+    @pyaedt_function_handler()
+    def rotate(self, cs_axis, angle=90.0, unit="deg"):
+        """Rotate the selection.
+
+        Parameters
+        ----------
+        cs_axis : int
+            Coordinate system axis or the Application.AXIS object.
+        angle : float, optional
+            Angle of rotation. The units, defined by ``unit``, can be either
+            degrees or radians. The default is ``90.0``.
+        unit : text, optional
+             Units for the angle. Options are ``"deg"`` or ``"rad"``.
+             The default is ``"deg"``.
 
         Returns
         -------
-        float
+        :class:`pyaedt.modeler.cad.object3d.Object3d`
+            3D object. ``False`` when failed.
+
+        References
+        ----------
+
+        >>> oEditor.Rotate
         """
-        if self.material in self._pclass._pedb.materials.materials:
-            self._loss_tangent = self._pclass._pedb.materials[self.material].loss_tangent
-            return self._loss_tangent
-        return None
+        if self._primitives.modeler.rotate(self.id, cs_axis=cs_axis, angle=angle, unit=unit):
+            return self
+        return False
 
-    @property
-    def dielectric_fill(self):
-        """Retrieve material name of the layer dielectric fill."""
-        if self.type == "signal":
-            self._dielectric_fill = self._edb_layer.GetFillMaterial()
-            return self._dielectric_fill
-        else:
-            return
+    @pyaedt_function_handler()
+    def move(self, vector):
+        """Move objects from a list.
 
-    @dielectric_fill.setter
-    def dielectric_fill(self, name):
-        if self.type == "signal":
-            layer_clone = self._edb_layer
-            layer_clone.SetFillMaterial(name)
-            self._pclass._set_layout_stackup(layer_clone, "change_attribute")
-            self._dielectric_fill = name
-        else:
-            pass
+        Parameters
+        ----------
+        objid : list, Position object
+            List of object IDs.
+        vector : list
+            Vector of the direction move. It can be a list of the ``[x, y, z]``
+            coordinates or a Position object.
 
-    @property
-    def thickness(self):
-        """Retrieve thickness of the layer.
+        Returns
+        -------
+        :class:`pyaedt.modeler.cad.object3d.Object3d`
+            3D object.
+            ``False`` when failed.
+
+        References
+        ----------
+        >>> oEditor.Move
+        """
+        if self._primitives.modeler.move(self.id, vector=vector):
+            return self
+        return False
+
+    def duplicate_around_axis(self, cs_axis, angle=90, nclones=2, create_new_objects=True):
+        """Duplicate the object around the axis.
+
+        Parameters
+        ----------
+        cs_axis : Application.AXIS object
+            Coordinate system axis of the object.
+        angle : float
+            Angle of rotation in degrees. The default is ``90``.
+        nclones : int, optional
+            Number of clones. The default is ``2``.
+        create_new_objects : bool, optional
+            Whether to create copies as new objects. The default is ``True``.
 
         Returns
         -------
-        float
+        list of :class:`pyaedt.modeler.cad.object3d.Object3d`
+            List of names of the newly added objects.
+
+        References
+        ----------
+
+        >>> oEditor.DuplicateAroundAxis
+
         """
-        if not self.is_stackup_layer:  # pragma: no cover
-            return
-        self._thickness = self._edb_layer.GetThicknessValue().ToDouble()
-        return self._thickness
-
-    @thickness.setter
-    def thickness(self, value):
-        if not self.is_stackup_layer:  # pragma: no cover
-            return
-        layer_clone = self._edb_layer
-        layer_clone.SetThickness(self._pclass._edb_value(value))
-        self._pclass._set_layout_stackup(layer_clone, "change_attribute")
-        self._thickness = value
+        ret, added_objects = self._primitives.modeler.duplicate_around_axis(
+            self, cs_axis, angle, nclones, create_new_objects
+        )
+        return added_objects
 
-    @property
-    def etch_factor(self):
-        """Retrieve etch factor of this layer.
+    @pyaedt_function_handler()
+    def duplicate_along_line(self, vector, nclones=2, attachObject=False):
+        """Duplicate the object along a line.
+
+        Parameters
+        ----------
+        vector : list
+            List of ``[x1 ,y1, z1]`` coordinates for the vector or the Application.Position object.
+        nclones : int, optional
+            Number of clones. The default is ``2``.
+        attachObject : bool, optional
+            Whether to attach the object. The default is ``False``.
 
         Returns
         -------
-        float
+        list of :class:`pyaedt.modeler.cad.object3d.Object3d`
+            List of names of the newly added objects.
+
+        References
+        ----------
+
+        >>> oEditor.DuplicateAlongLine
+
         """
-        self._etch_factor = self._edb_layer.GetEtchFactor().ToDouble()
-        return self._etch_factor
+        ret, added_objects = self._primitives.modeler.duplicate_along_line(self, vector, nclones, attachObject)
+        return added_objects
 
-    @etch_factor.setter
-    def etch_factor(self, value):
-        if not self.is_stackup_layer:  # pragma: no cover
-            return
-        if not value:
-            layer_clone = self._edb_layer
-            layer_clone.SetEtchFactorEnabled(False)
-        else:
-            layer_clone = self._edb_layer
-            layer_clone.SetEtchFactorEnabled(True)
-            layer_clone.SetEtchFactor(self._pclass._edb_value(value))
-        self._pclass._set_layout_stackup(layer_clone, "change_attribute")
-        self._etch_factor = value
+    @pyaedt_function_handler()
+    def sweep_along_vector(self, sweep_vector, draft_angle=0, draft_type="Round"):
+        """Sweep the selection along a vector.
 
-    @property
-    def roughness_enabled(self):
-        """Determine whether roughness is enabled on this layer.
+        Parameters
+        ----------
+        sweep_vector : list
+            Application.Position object.
+        draft_angle : float, optional
+            Angle of the draft in degrees. The default is ``0``.
+        draft_type : str, optional
+            Type of the draft. Options are ``"Extended"``, ``"Round"``,
+            and ``"Natural"``. The default value is ``"Round``.
 
         Returns
         -------
         bool
+            ``True`` when model, ``False`` otherwise.
+
+        References
+        ----------
+
+        >>> oEditor.SweepAlongVector
+
         """
-        if not self.is_stackup_layer:  # pragma: no cover
-            return
-        self._roughness_enabled = self._edb_layer.IsRoughnessEnabled()
-        return self._roughness_enabled
-
-    @roughness_enabled.setter
-    def roughness_enabled(self, set_enable):
-        if not self.is_stackup_layer:  # pragma: no cover
-            return
-        self._roughness_enabled = set_enable
-        if set_enable:
-            layer_clone = self._edb_layer
-            layer_clone.SetRoughnessEnabled(True)
-            self._pclass._set_layout_stackup(layer_clone, "change_attribute")
-            self.assign_roughness_model()
-        else:
-            layer_clone = self._edb_layer
-            layer_clone.SetRoughnessEnabled(False)
-            self._pclass._set_layout_stackup(layer_clone, "change_attribute")
+        self._primitives.modeler.sweep_along_vector(self, sweep_vector, draft_angle, draft_type)
+        return self
 
-    @property
-    def top_hallhuray_nodule_radius(self):
-        """Retrieve huray model nodule radius on top of the conductor."""
-        top_roughness_model = self.get_roughness_model("top")
-        if top_roughness_model:
-            self._top_hallhuray_nodule_radius = top_roughness_model.NoduleRadius.ToDouble()
-        return self._top_hallhuray_nodule_radius
+    @pyaedt_function_handler()
+    def sweep_along_path(
+        self, sweep_object, draft_angle=0, draft_type="Round", is_check_face_intersection=False, twist_angle=0
+    ):
+        """Sweep the selection along a vector.
 
-    @top_hallhuray_nodule_radius.setter
-    def top_hallhuray_nodule_radius(self, value):
-        self._top_hallhuray_nodule_radius = value
+        Parameters
+        ----------
+        sweep_object : :class:`pyaedt.modeler.object3d.Object3d`
+            Application.Position object.
+        draft_angle : float, optional
+            Angle of the draft in degrees. The default is ``0``.
+        draft_type : str
+            Type of the draft. Options are ``"Extended"``, ``"Round"``,
+            and ``"Natural"``. The default is ``"Round``.
+        is_check_face_intersection : bool, optional
+           The default value is ``False``.
+        twist_angle : float, optional
+            Angle at which to twist or rotate in degrees. The default value is ``0``.
 
-    @property
-    def top_hallhuray_surface_ratio(self):
-        """Retrieve huray model surface ratio on top of the conductor."""
-        top_roughness_model = self.get_roughness_model("top")
-        if top_roughness_model:
-            self._top_hallhuray_surface_ratio = top_roughness_model.SurfaceRatio.ToDouble()
-        return self._top_hallhuray_surface_ratio
+        Returns
+        -------
+        :class:`pyaedt.modeler.cad.object3d.Object3d`
+            Swept object.
 
-    @top_hallhuray_surface_ratio.setter
-    def top_hallhuray_surface_ratio(self, value):
-        self._top_hallhuray_surface_ratio = value
+        References
+        ----------
 
-    @property
-    def bottom_hallhuray_nodule_radius(self):
-        """Retrieve huray model nodule radius on bottom of the conductor."""
-        bottom_roughness_model = self.get_roughness_model("bottom")
-        if bottom_roughness_model:
-            self._bottom_hallhuray_nodule_radius = bottom_roughness_model.NoduleRadius.ToDouble()
-        return self._bottom_hallhuray_nodule_radius
+        >>> oEditor.SweepAlongPath
 
-    @bottom_hallhuray_nodule_radius.setter
-    def bottom_hallhuray_nodule_radius(self, value):
-        self._bottom_hallhuray_nodule_radius = value
+        """
+        self._primitives.modeler.sweep_along_path(
+            self, sweep_object, draft_angle, draft_type, is_check_face_intersection, twist_angle
+        )
+        return self
 
-    @property
-    def bottom_hallhuray_surface_ratio(self):
-        """Retrieve huray model surface ratio on bottom of the conductor."""
-        bottom_roughness_model = self.get_roughness_model("bottom")
-        if bottom_roughness_model:
-            self._bottom_hallhuray_surface_ratio = bottom_roughness_model.SurfaceRatio.ToDouble()
-        return self._bottom_hallhuray_surface_ratio
+    @pyaedt_function_handler()
+    def sweep_around_axis(self, cs_axis, sweep_angle=360, draft_angle=0):
+        """Sweep around an axis.
 
-    @bottom_hallhuray_surface_ratio.setter
-    def bottom_hallhuray_surface_ratio(self, value):
-        self._bottom_hallhuray_surface_ratio = value
+        Parameters
+        ----------
+        cs_axis : :class:`pyaedt.generic.constants.AXIS`
+            Coordinate system of the axis.
+        sweep_angle : float, optional
+             Sweep angle in degrees. The default is ``360``.
+        draft_angle : float, optional
+            Angle of the draft. The default is ``0``.
 
-    @property
-    def side_hallhuray_nodule_radius(self):
-        """Retrieve huray model nodule radius on sides of the conductor."""
-        side_roughness_model = self.get_roughness_model("side")
-        if side_roughness_model:
-            self._side_hallhuray_nodule_radius = side_roughness_model.NoduleRadius.ToDouble()
-        return self._side_hallhuray_nodule_radius
+        Returns
+        -------
+        :class:`pyaedt.modeler.cad.object3d.Object3d`
+            Swept object.
 
-    @side_hallhuray_nodule_radius.setter
-    def side_hallhuray_nodule_radius(self, value):
-        self._side_hallhuray_nodule_radius = value
+        References
+        ----------
 
-    @property
-    def side_hallhuray_surface_ratio(self):
-        """Retrieve huray model surface ratio on sides of the conductor."""
-        side_roughness_model = self.get_roughness_model("side")
-        if side_roughness_model:
-            self._side_hallhuray_surface_ratio = side_roughness_model.SurfaceRatio.ToDouble()
-        return self._side_hallhuray_surface_ratio
+        >>> oEditor.SweepAroundAxis
 
-    @side_hallhuray_surface_ratio.setter
-    def side_hallhuray_surface_ratio(self, value):
-        self._side_hallhuray_surface_ratio = value
+        """
+        self._primitives.modeler.sweep_around_axis(self, cs_axis, sweep_angle, draft_angle)
+        return self
 
     @pyaedt_function_handler()
-    def get_roughness_model(self, surface="top"):
-        """Get roughness model of the layer.
+    def section(self, plane, create_new=True, section_cross_object=False):
+        """Section the object.
 
         Parameters
         ----------
-        surface : str, optional
-            Where to fetch roughness model. The default is ``"top"``. Options are ``"top"``, ``"bottom"``, ``"side"``.
+        plane : pyaedt.generic.constants.PLANE
+            Coordinate system of the plane object. Application.PLANE object
+        create_new : bool, optional
+            Whether to create an object. The default is ``True``.
+        section_cross_object : bool, optional
+            The default is ``False``.
+
+        Returns
+        -------
+        :class:`pyaedt.modeler.cad.object3d.Object3d`
+            3D object.
+
+        References
+        ----------
+
+        >>> oEditor.Section
+
+        """
+        self._primitives.modeler.section(self, plane, create_new, section_cross_object)
+        return self
+
+    @pyaedt_function_handler()
+    def clone(self):
+        """Clone the object and return the new 3D object.
 
         Returns
         -------
-        ``"Ansys.Ansoft.Edb.Cell.RoughnessModel"``
+        :class:`pyaedt.modeler.cad.object3d.Object3d`
+            3D object that was added.
+
+        References
+        ----------
+
+        >>> oEditor.Clone
 
         """
-        if not self.is_stackup_layer:  # pragma: no cover
-            return
-        if surface == "top":
-            return self._edb_layer.GetRoughnessModel(self._pclass._pedb.edb.Cell.RoughnessModel.Region.Top)
-        elif surface == "bottom":
-            return self._edb_layer.GetRoughnessModel(self._pclass._pedb.edb.Cell.RoughnessModel.Region.Bottom)
-        elif surface == "side":
-            return self._edb_layer.GetRoughnessModel(self._pclass._pedb.edb.Cell.RoughnessModel.Region.Side)
+        new_obj_tuple = self._primitives.modeler.clone(self.id)
+        success = new_obj_tuple[0]
+        assert success, "Could not clone the object {}.".format(self.name)
+        new_name = new_obj_tuple[1][0]
+        return self._primitives[new_name]
 
     @pyaedt_function_handler()
-    def assign_roughness_model(
-        self,
-        model_type="huray",
-        huray_radius="0.5um",
-        huray_surface_ratio="2.9",
-        groisse_roughness="1um",
-        apply_on_surface="all",
-    ):
-        """Assign roughness model on this layer.
+    def subtract(self, tool_list, keep_originals=True):
+        """Subtract one or more parts from the object.
 
         Parameters
         ----------
-        model_type : str, optional
-            Type of roughness model. The default is ``"huray"``. Options are ``"huray"``, ``"groisse"``.
-        huray_radius : str, float, optional
-            Radius of huray model. The default is ``"0.5um"``.
-        huray_surface_ratio : str, float, optional.
-            Surface ratio of huray model. The default is ``"2.9"``.
-        groisse_roughness : str, float, optional
-            Roughness of groisse model. The default is ``"1um"``.
-        apply_on_surface : str, optional.
-            Where to assign roughness model. The default is ``"all"``. Options are ``"top"``, ``"bottom"``,
-             ``"side"``.
+        tool_list : str, Object3d, or list of str and Object3d.
+            List of parts to subtract from this part.
+        keep_originals : bool, optional
+            Whether to keep the tool parts after subtraction. The default
+            is ``True``. If ``False``, the parts are deleted.
+
         Returns
         -------
+        :class:`pyaedt.modeler.cad.object3d.Object3d`
+            Modified 3D object following the subtraction.
+
+        References
+        ----------
+
+        >>> oEditor.Subtract
 
         """
-        if not self.is_stackup_layer:  # pragma: no cover
-            return
-
-        radius = self._pclass._edb_value(huray_radius)
-        self._hurray_nodule_radius = huray_radius
-        surface_ratio = self._pclass._edb_value(huray_surface_ratio)
-        self._hurray_surface_ratio = huray_surface_ratio
-        groisse_roughness = self._pclass._edb_value(groisse_roughness)
-        regions = []
-        if apply_on_surface == "all":
-            self._side_roughness = "all"
-            regions = [
-                self._pclass._pedb.edb.Cell.RoughnessModel.Region.Top,
-                self._pclass._pedb.edb.Cell.RoughnessModel.Region.Side,
-                self._pclass._pedb.edb.Cell.RoughnessModel.Region.Bottom,
-            ]
-        elif apply_on_surface == "top":
-            self._side_roughness = "top"
-            regions = [self._pclass._pedb.edb.Cell.RoughnessModel.Region.Top]
-        elif apply_on_surface == "bottom":
-            self._side_roughness = "bottom"
-            regions = [self._pclass._pedb.edb.Cell.RoughnessModel.Region.Bottom]
-        elif apply_on_surface == "side":
-            self._side_roughness = "side"
-            regions = [self._pclass._pedb.edb.Cell.RoughnessModel.Region.Side]
-
-        layer_clone = self._edb_layer
-        layer_clone.SetRoughnessEnabled(True)
-        for r in regions:
-            if model_type == "huray":
-                model = self._pclass._pedb.edb.Cell.HurrayRoughnessModel(radius, surface_ratio)
-            else:
-                model = self._pclass._pedb.edb.Cell.GroisseRoughnessModel(groisse_roughness)
-            layer_clone.SetRoughnessModel(r, model)
-        return self._pclass._set_layout_stackup(layer_clone, "change_attribute")
-
-    @pyaedt_function_handler()
-    def _json_format(self):
-        dict_out = {}
-        self._color = self.color
-        self._dielectric_fill = self.dielectric_fill
-        self._etch_factor = self.etch_factor
-        self._material = self.material
-        self._name = self.name
-        self._roughness_enabled = self.roughness_enabled
-        self._thickness = self.thickness
-        self._type = self.type
-        self._roughness_enabled = self.roughness_enabled
-        self._top_hallhuray_nodule_radius = self.top_hallhuray_nodule_radius
-        self._top_hallhuray_surface_ratio = self.top_hallhuray_surface_ratio
-        self._side_hallhuray_nodule_radius = self.side_hallhuray_nodule_radius
-        self._side_hallhuray_surface_ratio = self.side_hallhuray_surface_ratio
-        self._bottom_hallhuray_nodule_radius = self.bottom_hallhuray_nodule_radius
-        self._bottom_hallhuray_surface_ratio = self.bottom_hallhuray_surface_ratio
-        for k, v in self.__dict__.items():
-            if (
-                not k == "_pclass"
-                and not k == "_conductivity"
-                and not k == "_permittivity"
-                and not k == "_loss_tangent"
-            ):
-                dict_out[k[1:]] = v
-        return dict_out
-
-    def _load_layer(self, layer):
-        if layer:
-            self.color = layer["color"]
-            self.type = layer["type"]
-            if isinstance(layer["material"], str):
-                self.material = layer["material"]
-            else:
-                self._pclass._pedb.materials._load_materials(layer["material"])
-                self.material = layer["material"]["name"]
-            if layer["dielectric_fill"]:
-                if isinstance(layer["dielectric_fill"], str):
-                    self.dielectric_fill = layer["dielectric_fill"]
-                else:
-                    self._pclass._pedb.materials._load_materials(layer["dielectric_fill"])
-                    self.dielectric_fill = layer["dielectric_fill"]["name"]
-            self.thickness = layer["thickness"]
-            self.etch_factor = layer["etch_factor"]
-            self.roughness_enabled = layer["roughness_enabled"]
-            if self.roughness_enabled:
-                self.top_hallhuray_nodule_radius = layer["top_hallhuray_nodule_radius"]
-                self.top_hallhuray_surface_ratio = layer["top_hallhuray_surface_ratio"]
-                self.assign_roughness_model(
-                    "huray",
-                    layer["top_hallhuray_nodule_radius"],
-                    layer["top_hallhuray_surface_ratio"],
-                    apply_on_surface="top",
-                )
-                self.bottom_hallhuray_nodule_radius = layer["bottom_hallhuray_nodule_radius"]
-                self.bottom_hallhuray_surface_ratio = layer["bottom_hallhuray_surface_ratio"]
-                self.assign_roughness_model(
-                    "huray",
-                    layer["bottom_hallhuray_nodule_radius"],
-                    layer["bottom_hallhuray_surface_ratio"],
-                    apply_on_surface="bottom",
-                )
-                self.side_hallhuray_nodule_radius = layer["side_hallhuray_nodule_radius"]
-                self.side_hallhuray_surface_ratio = layer["side_hallhuray_surface_ratio"]
-                self.assign_roughness_model(
-                    "huray",
-                    layer["side_hallhuray_nodule_radius"],
-                    layer["side_hallhuray_surface_ratio"],
-                    apply_on_surface="side",
-                )
+        self._primitives.modeler.subtract(self.name, tool_list, keep_originals)
+        return self
+
+    @pyaedt_function_handler()
+    def wrap_sheet(self, object_name, imprinted=False):
+        """Execute the sheet wrapping around an object. This object can be either the sheet or the object.
+        If wrapping produces an unclassified operation it will be reverted.
+
+        Parameters
+        ----------
+        object_name : str, :class:`pyaedt.modeler.Object3d.Object3d`
+            Object name or solid object or sheet name.
+        imprinted : bool, optional
+            Either if imprint or not over the sheet. Default is `False`.
+
+        Returns
+        -------
+        bool
+            Command execution status.
+        """
+        object_name = self._primitives.convert_to_selections(object_name, False)
+        if self.object_type == "Sheet" and object_name in self._primitives.solid_names:
+            return self._primitives.wrap_sheet(self.name, object_name, imprinted)
+        elif self.object_type == "Solid" and object_name in self._primitives.sheet_names:
+            return self._primitives.wrap_sheet(object_name, self.name, imprinted)
+        else:
+            msg = "Error in command execution."
+            msg += " Either one of the two objects has to be a sheet and the other an object."
+            self.logger.error(msg)
+            return False
+
+    @pyaedt_function_handler()
+    def delete(self):
+        """Delete the object.
+
+        References
+        ----------
+
+        >>> oEditor.Delete
+        """
+        arg = ["NAME:Selections", "Selections:=", self._m_name]
+        self._oeditor.Delete(arg)
+        self._primitives.cleanup_objects()
+        self.__dict__ = {}
+
+    @pyaedt_function_handler()
+    def faces_by_area(self, area, area_filter="==", tolerance=1e-12):
+        """Filter faces by area.
+
+        Parameters
+        ----------
+        area : float
+            Value of the area to filter in model units.
+        area_filter : str, optional
+            Comparer symbol.
+            Default value is "==".
+        tolerance : float, optional
+            tolerance for comparison.
+
+        Returns
+        -------
+        list of :class:`pyaedt.modeler.elements3d.FacePrimitive`
+            List of face primitives.
+        """
+
+        filters = ["==", "<=", ">=", "<", ">"]
+        if area_filter not in filters:
+            raise ValueError('Symbol not valid, enter one of the following: "==", "<=", ">=", "<", ">"')
+
+        faces = []
+        for face in self.faces:
+            if area_filter == "==":
+                if abs(face.area - area) < tolerance:
+                    faces.append(face)
+            if area_filter == ">=":
+                if (face.area - area) >= -tolerance:
+                    faces.append(face)
+            if area_filter == "<=":
+                if (face.area - area) <= tolerance:
+                    faces.append(face)
+            if area_filter == ">":
+                if (face.area - area) > 0:
+                    faces.append(face)
+            if area_filter == "<":
+                if (face.area - area) < 0:
+                    faces.append(face)
+
+        return faces
+
+    @pyaedt_function_handler()
+    def edges_by_length(self, length, length_filter="==", tolerance=1e-12):
+        """Filter edges by length.
+
+        Parameters
+        ----------
+        length : float
+            Value of the length to filter.
+        length_filter : str, optional
+            Comparer symbol.
+            Default value is "==".
+        tolerance : float, optional
+            tolerance for comparison.
+
+        Returns
+        -------
+        list of :class:`pyaedt.modeler.elements3d.EdgePrimitive`
+            List of edge primitives.
+        """
+        filters = ["==", "<=", ">=", "<", ">"]
+        if length_filter not in filters:
+            raise ValueError('Symbol not valid, enter one of the following: "==", "<=", ">=", "<", ">"')
+
+        edges = []
+        for edge in self.edges:
+            if length_filter == "==":
+                if abs(edge.length - length) < tolerance:
+                    edges.append(edge)
+            if length_filter == ">=":
+                if (edge.length - length) >= -tolerance:
+                    edges.append(edge)
+            if length_filter == "<=":
+                if (edge.length - length) <= tolerance:
+                    edges.append(edge)
+            if length_filter == ">":
+                if (edge.length - length) > 0:
+                    edges.append(edge)
+            if length_filter == "<":
+                if (edge.length - length) < 0:
+                    edges.append(edge)
+
+        return edges
+
+    @pyaedt_function_handler()
+    def _change_property(self, vPropChange):
+        return self._primitives._change_geometry_property(vPropChange, self._m_name)
+
+    def __str__(self):
+        return """
+         {}
+         name: {}    id: {}    object_type: {}
+         --- read/write properties  ----
+         solve_inside: {}
+         model: {}
+         material_name: {}
+         color: {}
+         transparency: {}
+         display_wireframe {}
+         part_coordinate_system: {}
+         """.format(
+            type(self),
+            self.name,
+            self.id,
+            self.object_type,
+            self.solve_inside,
+            self.model,
+            self.material_name,
+            self.color,
+            self.transparency,
+            self.display_wireframe,
+            self.part_coordinate_system,
+        )
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/nets_data.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/nets_data.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,15 +7,15 @@
     """Manages EDB functionalities for a primitives.
     It Inherits EDB Object properties.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edb = Edb(myedb, edbversion="2021.2")
-    >>> edb_net = edb.core_nets.nets["GND"]
+    >>> edb_net = edb.nets.nets["GND"]
     >>> edb_net.name # Class Property
     >>> edb_net.GetName() # EDB Object Property
     """
 
     def __getattr__(self, key):
         try:
             return self[key]
@@ -23,16 +23,16 @@
             try:
                 return getattr(self.net_object, key)
             except AttributeError:
                 raise AttributeError("Attribute not present")
 
     def __init__(self, raw_net, core_app):
         self._app = core_app
-        self._core_components = core_app.core_components
-        self._core_primitive = core_app.core_primitives
+        self._core_components = core_app.components
+        self._core_primitive = core_app.modeler
         self.net_object = raw_net
 
     @property
     def name(self):
         """Return the Net Name.
 
         Returns
@@ -126,15 +126,15 @@
             If a file path is specified the plot will be saved to such file.
         outline : list, optional
             List of points of the outline to plot.
         size : tuple, optional
             Image size in pixel (width, height).
         """
 
-        self._app.core_nets.plot(
+        self._app.nets.plot(
             self.name,
             layers=layers,
             show_legend=show_legend,
             save_plot=save_plot,
             outline=outline,
             size=size,
         )
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/padstacks_data.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/padstacks_data.py`

 * *Files 1% similar despite different names*

```diff
@@ -24,15 +24,15 @@
     pedbpadstack : str
         Inherited AEDT object.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edb = Edb(myedb, edbversion="2021.2")
-    >>> edb_pad_properties = edb.core_padstack.definitions["MyPad"].pad_by_layer["TOP"]
+    >>> edb_pad_properties = edb.padstacks.definitions["MyPad"].pad_by_layer["TOP"]
     """
 
     def __init__(self, edb_padstack, layer_name, pad_type, p_edb_padstack):
         self._edb_padstack = edb_padstack
         self._pedbpadstack = p_edb_padstack
         self.layer_name = layer_name
         self.pad_type = pad_type
@@ -313,15 +313,15 @@
     ppadstack : str
         Inherited AEDT object.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edb = Edb(myedb, edbversion="2021.2")
-    >>> edb_padstack = edb.core_padstack.definitions["MyPad"]
+    >>> edb_padstack = edb.padstacks.definitions["MyPad"]
     """
 
     def __init__(self, edb_padstack, ppadstack):
         self.edb_padstack = edb_padstack
         self._ppadstack = ppadstack
         self.pad_by_layer = {}
         self.antipad_by_layer = {}
@@ -647,15 +647,15 @@
         """
         if self.via_start_layer == self.via_stop_layer:
             self._ppadstack._pedb.logger.error("Microvias cannot be applied when Start and Stop Layers are the same.")
         layout = self._ppadstack._pedb._active_layout
         layers = self._ppadstack._pedb.stackup.signal_layers
         layer_names = [i for i in list(layers.keys())]
         if convert_only_signal_vias:
-            signal_nets = [i for i in list(self._ppadstack._pedb.core_nets.signal_nets.keys())]
+            signal_nets = [i for i in list(self._ppadstack._pedb.nets.signal_nets.keys())]
         topl, topz, bottoml, bottomz = self._ppadstack._pedb.stackup.stackup_limits(True)
         start_elevation = layers[self.via_start_layer].lower_elevation
         diel_thick = abs(start_elevation - layers[self.via_stop_layer].upper_elevation)
         rad1 = self.hole_properties[0] / 2
         rad2 = self.hole_properties[0] / 2 - math.tan(hole_wall_angle * diel_thick * math.pi / 180)
 
         if start_elevation < (topz + bottomz) / 2:
@@ -884,15 +884,15 @@
     _pedb :
         Inherited AEDT object.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edb = Edb(myedb, edbversion="2021.2")
-    >>> edb_padstack_instance = edb.core_padstack.instances[0]
+    >>> edb_padstack_instance = edb.padstacks.instances[0]
     """
 
     def __getattr__(self, key):
         try:
             return self[key]
         except:
             try:
@@ -958,18 +958,16 @@
                 1
                 if polygon_data.PointInPolygon(
                     self._pedb.edb.Geometry.PointData(self._pedb.edb_value(pos[0]), self._pedb.edb_value(pos[1]))
                 )
                 else 0
             )
         else:
-            plane = self._pedb.core_primitives.Shape(
-                "rectangle", pointA=self.bounding_box[0], pointB=self.bounding_box[1]
-            )
-            rectangle_data = self._pedb.core_primitives.shape_to_polygon_data(plane)
+            plane = self._pedb.modeler.Shape("rectangle", pointA=self.bounding_box[0], pointB=self.bounding_box[1])
+            rectangle_data = self._pedb.modeler.shape_to_polygon_data(plane)
             int_val = polygon_data.GetIntersectionType(rectangle_data)
         # Intersection type:
         # 0 = objects do not intersect
         # 1 = this object fully inside other (no common contour points)
         # 2 = other object fully inside this
         # 3 = common contour points 4 = undefined intersection
         if int_val == 0:
@@ -981,16 +979,16 @@
         else:
             return False
 
     @property
     def component(self):
         """Get component this padstack belong to."""
         comp_name = self._edb_padstackinstance.GetComponent().GetName()
-        if comp_name in self._pedb.core_components.components:
-            return self._pedb.core_components.components[comp_name]
+        if comp_name in self._pedb.components.components:
+            return self._pedb.components.components[comp_name]
         else:  # pragma: no cover
             return ""
 
     @property
     def pin(self):
         """Return Edb padstack object."""
         return self._edb_padstackinstance
@@ -1180,16 +1178,16 @@
     @net_name.setter
     def net_name(self, val):
         if not isinstance(val, str):
             try:
                 self._edb_padstackinstance.SetNet(val)
             except:
                 raise AttributeError("Value inserted not found. Input has to be net name or net object.")
-        elif val in self._pedb.core_nets.nets:
-            net = self._pedb.core_nets.nets[val].net_object
+        elif val in self._pedb.nets.netlist:
+            net = self._pedb.nets.nets[val].net_object
             self._edb_padstackinstance.SetNet(net)
         else:
             raise AttributeError("Value inserted not found. Input has to be net name or net object.")
 
     @property
     def is_pin(self):
         """Determines whether this padstack instance is a layout pin.
@@ -1300,15 +1298,15 @@
             Name of the pin in AEDT.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_padstack.instances[111].get_aedt_pin_name()
+        >>> edbapp.padstacks.instances[111].get_aedt_pin_name()
 
         """
         if is_ironpython:
             name = _clr.Reference[String]()
             self._edb_padstackinstance.GetProductProperty(self._pedb.edb.ProductId.Designer, 11, name)
         else:
             val = String("")
@@ -1372,18 +1370,18 @@
         Returns
         -------
         list
             List of the voids that include this padstack instance.
         """
         x_pos = self._pedb.edb_value(self.position[0])
         y_pos = self._pedb.edb_value(self.position[1])
-        point_data = self._pedb.core_primitives._edb.Geometry.PointData(x_pos, y_pos)
+        point_data = self._pedb.modeler._edb.Geometry.PointData(x_pos, y_pos)
 
         voids = []
-        for prim in self._pedb.core_primitives.get_primitives(net_name, layer_name, is_void=True):
+        for prim in self._pedb.modeler.get_primitives(net_name, layer_name, is_void=True):
             if prim.primitive_object.GetPolygonData().PointInPolygon(point_data):
                 voids.append(prim)
         return voids
 
     @property
     def pingroups(self):
         """Pin groups that the pin belongs to.
@@ -1467,25 +1465,25 @@
         bool, List,  :class:`pyaedt.edb_core.edb_data.primitives.EDBPrimitives`
             Polygon when successful, ``False`` when failed, list of list if `return_points=True`.
 
         Examples
         --------
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", edbversion="2021.2")
-        >>> edb_layout = edbapp.core_primitives
-        >>> list_of_padstack_instances = list(edbapp.core_padstack.instances.values())
+        >>> edb_layout = edbapp.modeler
+        >>> list_of_padstack_instances = list(edbapp.padstacks.instances.values())
         >>> padstack_inst = list_of_padstack_instances[0]
         >>> padstack_inst.create_rectangle_in_pad("TOP")
         """
 
         padstack_center = self.position
         rotation = self.rotation  # in radians
         padstack_name = self.padstack_definition
         try:
-            padstack = self._pedb.core_padstack.definitions[padstack_name]
+            padstack = self._pedb.padstacks.definitions[padstack_name]
         except KeyError:  # pragma: no cover
             return False
         try:
             padstack_pad = padstack.pad_by_layer[layer_name]
         except KeyError:  # pragma: no cover
             try:
                 padstack_pad = padstack.pad_by_layer[padstack.via_start_layer]
@@ -1625,25 +1623,25 @@
             )
             rect = rectangles[0]
             for i in range(4):
                 rect[i] = _translate(_rotate(rect[i]))
 
         if rect is None or len(rect) != 4:
             return False
-        path = self._pedb.core_primitives.Shape("polygon", points=rect)
-        pdata = self._pedb.core_primitives.shape_to_polygon_data(path)
+        path = self._pedb.modeler.Shape("polygon", points=rect)
+        pdata = self._pedb.modeler.shape_to_polygon_data(path)
         new_rect = []
         for point in pdata.Points:
             p_transf = self._edb_padstackinstance.GetComponent().GetTransform().TransformPoint(point)
             new_rect.append([p_transf.X.ToDouble(), p_transf.Y.ToDouble()])
         if return_points:
             return new_rect
         else:
-            path = self._pedb.core_primitives.Shape("polygon", points=new_rect)
-            created_polygon = self._pedb.core_primitives.create_polygon(path, layer_name)
+            path = self._pedb.modeler.Shape("polygon", points=new_rect)
+            created_polygon = self._pedb.modeler.create_polygon(path, layer_name)
             return created_polygon
 
     @pyaedt_function_handler()
     def get_connected_object_id_set(self):
         """Produce a list of all geometries physically connected to a given layout object.
 
         Returns
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/primitives_data.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/primitives_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -9,15 +9,15 @@
     """Manages EDB functionalities for a primitives.
     It Inherits EDB Object properties.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edb = Edb(myedb, edbversion="2021.2")
-    >>> edb_prim = edb.core_primitives.primitives[0]
+    >>> edb_prim = edb.modeler.primitives[0]
     >>> edb_prim.is_void # Class Property
     >>> edb_prim.IsVoid() # EDB Object Property
     """
 
     def __getattr__(self, key):
         try:
             return self[key]
@@ -26,17 +26,38 @@
                 return getattr(self.primitive_object, key)
             except AttributeError:
                 raise AttributeError("Attribute not present")
 
     def __init__(self, raw_primitive, core_app):
         self._app = core_app
         self._core_stackup = core_app.stackup
-        self._core_net = core_app.core_nets
+        self._core_net = core_app.nets
         self.primitive_object = raw_primitive
 
+    @property
+    def width(self):
+        """Path width.
+
+        Returns
+        -------
+        float
+            Path width or None.
+        """
+        if self.type == "Path":
+            return self.primitive_object.GetWidth()
+        return
+
+    @width.setter
+    def width(self, value):
+        if self.type == "Path":
+            if isinstance(value, (int, str, float)):
+                self.primitive_object.SetWidth(self._app.edb_value(value))
+            else:
+                self.primitive_object.SetWidth(value)
+
     @pyaedt_function_handler()
     def area(self, include_voids=True):
         """Return the total area.
 
         Parameters
         ----------
         include_voids : bool, optional
@@ -396,15 +417,15 @@
         Returns
         -------
         Converted polygon.
 
         """
         if self.type == "Path":
             polygon_data = self.primitive_object.GetPolygonData()
-            polygon = self._app.core_primitives.create_polygon(polygon_data, self.layer_name, [], self.net_name)
+            polygon = self._app.modeler.create_polygon(polygon_data, self.layer_name, [], self.net_name)
             self.primitive_object.Delete()
             return polygon
 
     @pyaedt_function_handler()
     def add_void(self, point_list):
         """Add a void to current primitive.
 
@@ -415,16 +436,16 @@
 
         Returns
         -------
         bool
             ``True`` if successful, either  ``False``.
         """
         if isinstance(point_list, list):
-            plane = self._app.core_primitives.Shape("polygon", points=point_list)
-            _poly = self._app.core_primitives.shape_to_polygon_data(plane)
+            plane = self._app.modeler.Shape("polygon", points=point_list)
+            _poly = self._app.modeler.shape_to_polygon_data(plane)
             if _poly is None or _poly.IsNull() or _poly is False:
                 self._logger.error("Failed to create void polygon data")
                 return False
             prim = self._app.edb.Cell.Primitive.Polygon.Create(
                 self._app.active_layout, self.layer_name, self.primitive_object.GetNet(), _poly
             )
         elif isinstance(point_list, EDBPrimitives):
@@ -479,33 +500,33 @@
                             convert_py_list_to_net_list(p), convert_py_list_to_net_list(void_to_subtract)
                         )
                         for polys_clean in polys_cleans:
                             if not polys_clean.IsNull():
                                 void_to_append = [v for v in list_void if polys_clean.GetIntersectionType(v) == 2]
                                 new_polys.append(
                                     EDBPrimitives(
-                                        self._app.core_primitives.create_polygon(
+                                        self._app.modeler.create_polygon(
                                             polys_clean, self.layer_name, net_name=self.net_name, voids=void_to_append
                                         ),
                                         self._app,
                                     )
                                 )
                     else:
                         new_polys.append(
                             EDBPrimitives(
-                                self._app.core_primitives.create_polygon(
+                                self._app.modeler.create_polygon(
                                     p, self.layer_name, net_name=self.net_name, voids=list_void
                                 ),
                                 self._app,
                             )
                         )
                 else:
                     new_polys.append(
                         EDBPrimitives(
-                            self._app.core_primitives.create_polygon(
+                            self._app.modeler.create_polygon(
                                 p, self.layer_name, net_name=self.net_name, voids=list_void
                             ),
                             self._app,
                         )
                     )
         self.delete()
         for prim in primitives:
@@ -564,33 +585,33 @@
                             convert_py_list_to_net_list(p), convert_py_list_to_net_list(void_to_subtract)
                         )
                         for polys_clean in polys_cleans:
                             if not polys_clean.IsNull():
                                 void_to_append = [v for v in list_void if polys_clean.GetIntersectionType(v) == 2]
                         new_polys.append(
                             EDBPrimitives(
-                                self._app.core_primitives.create_polygon(
+                                self._app.modeler.create_polygon(
                                     polys_clean, self.layer_name, net_name=self.net_name, voids=void_to_append
                                 ),
                                 self._app,
                             )
                         )
                     else:
                         new_polys.append(
                             EDBPrimitives(
-                                self._app.core_primitives.create_polygon(
+                                self._app.modeler.create_polygon(
                                     p, self.layer_name, net_name=self.net_name, voids=list_void
                                 ),
                                 self._app,
                             )
                         )
                 else:
                     new_polys.append(
                         EDBPrimitives(
-                            self._app.core_primitives.create_polygon(
+                            self._app.modeler.create_polygon(
                                 p, self.layer_name, net_name=self.net_name, voids=list_void
                             ),
                             self._app,
                         )
                     )
         self.delete()
         for prim in primitives:
@@ -639,17 +660,15 @@
                     for void in voids:
                         void_pdata = void.primitive_object.GetPolygonData()
                         int_data2 = p.GetIntersectionType(void_pdata)
                         if int_data2 > 1:
                             list_void.append(void_pdata)
                 new_polys.append(
                     EDBPrimitives(
-                        self._app.core_primitives.create_polygon(
-                            p, self.layer_name, net_name=self.net_name, voids=list_void
-                        ),
+                        self._app.modeler.create_polygon(p, self.layer_name, net_name=self.net_name, voids=list_void),
                         self._app,
                     )
                 )
         self.delete()
         for prim in primitives:
             if isinstance(prim, EDBPrimitives):
                 prim.delete()
@@ -834,36 +853,32 @@
                 width,
                 end_cap_style[1],
                 end_cap_style[2],
                 corner_style,
                 center_line,
             )
             if cloned_path:
-                # forcing primitives dictionary update
-                self._app.core_primitives.primitives  # pragma no cover
                 return cloned_path
         cloned_poly = self._app.edb.Cell.Primitive.Polygon.Create(
             self._app.active_layout, self.layer_name, self.net, self.polygon_data
         )
         if cloned_poly:
-            # forcing primitives dictionary update
-            self._app.core_primitives.primitives  # pragma no cover
             return cloned_poly
         return False
 
 
 class EDBArcs(object):
     """Manages EDB Arc Data functionalities.
     It Inherits EDB primitives arcs properties.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edb = Edb(myedb, edbversion="2021.2")
-    >>> prim_arcs = edb.core_primitives.primitives[0].arcs
+    >>> prim_arcs = edb.modeler.primitives[0].arcs
     >>> prim_arcs.center # arc center
     >>> prim_arcs.points # arc point list
     >>> prim_arcs.mid_point # arc mid point
     """
 
     def __init__(self, app, arc):
         self._app = app
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/simulation_configuration.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/simulation_configuration.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/siwave_simulation_setup_data.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/siwave_simulation_setup_data.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/sources.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/sources.py`

 * *Files 2% similar despite different names*

```diff
@@ -481,14 +481,15 @@
         return self._source_type
 
 
 class CommonExcitation(object):
     def __init__(self, pedb, edb_terminal):
         self._pedb = pedb
         self._edb_terminal = edb_terminal
+        self._reference_object = None
 
     @property
     def _edb(self):
         return self._pedb.edb
 
     @property
     def name(self):
@@ -536,158 +537,58 @@
 
         Returns
         -------
         int
         """
         return self._edb_terminal.GetBoundaryType()
 
-
-class ExcitationPorts(CommonExcitation):
-    """Manages excitation properties.
-
-    Parameters
-    ----------
-    pedb : pyaedt.edb.Edb
-        Edb object from Edblib.
-    edb_terminal : Ansys.Ansoft.Edb.Cell.Terminal.EdgeTerminal
-        Edge terminal instance from Edb.
-
-
-    Examples
-    --------
-    This example shows how to access this class.
-    >>> from pyaedt import Edb
-    >>> edb = Edb("myaedb.aedb")
-    >>> exc = edb.excitations
-    >>> print(exc["Port1"].name)
-    """
-
-    def __init__(self, pedb, edb_terminal):
-        CommonExcitation.__init__(self, pedb, edb_terminal)
-        self._reference_object = None
-
-    @property
-    def _edb_properties(self):
-        p = self._edb_terminal.GetProductSolverOption(self._edb.ProductId.Designer, "HFSS")
-        return p
-
-    @property
-    def hfss_type(self):
-        """Get hfss port type."""
-        txt = re.search(r"'HFSS Type'='.*?'", self._edb_properties).group()
-        return txt.split("=")[1].replace("'", "")
-
-    @property
-    def horizontal_extent_factor(self):
-        """Get horizontal extent factor."""
-        txt = re.search(r"'Horizontal Extent Factor'='.*?'", self._edb_properties).group()
-        return float(txt.split("=")[1].replace("'", ""))
-
-    @property
-    def vertical_extent_factor(self):
-        """Get vertical extent factor."""
-        txt = re.search(r"'Vertical Extent Factor'='.*?'", self._edb_properties).group()
-        return float(txt.split("=")[1].replace("'", ""))
-
-    @property
-    def radial_extent_factor(self):
-        """Get radial extent factor."""
-        txt = re.search(r"'Radial Extent Factor'='.*?'", self._edb_properties).group()
-        return float(txt.split("=")[1].replace("'", ""))
-
-    @property
-    def pec_launch_width(self):
-        """Get pec launch width."""
-        txt = re.search(r"'PEC Launch Width'='.*?'", self._edb_properties).group()
-        return txt.split("=")[1].replace("'", "")
-
-    @property
-    def impedance(self):
-        """Impedance of the port."""
-        return self._edb_terminal.GetImpedance().ToDouble()
-
-    @property
-    def is_circuit(self):
-        """Return ``True`` if is a circuit port."""
-        return self._edb_terminal.GetIsCircuitPort()
-
-    @property
-    def magnitude(self):
-        """Magnitude."""
-        return self._edb_terminal.GetSourceAmplitude().ToDouble()
-
-    @property
-    def phase(self):
-        """Phase."""
-        return self._edb_terminal.GetSourcePhase().ToDouble()
-
-    @property
-    def renormalize(self):
-        """Either if renormalize is active or not."""
-        return self._edb_terminal.GetPortPostProcessingProp().DoRenormalize
-
-    @property
-    def deembed(self):
-        """Either if deembed is active or not."""
-        return self._edb_terminal.GetPortPostProcessingProp().DoDeembed
-
-    @property
-    def deembed_gapport_inductance(self):
-        """Deembed Gap Port Inductance value."""
-        return self._edb_terminal.GetPortPostProcessingProp().DoDeembedGapL
-
-    @property
-    def deembed_length(self):
-        """Deembed Length."""
-        return self._edb_terminal.GetPortPostProcessingProp().DeembedLength.ToDouble()
-
-    @property
-    def renormalize_z0(self):
-        """Renormalize Z0 value (real, imag)."""
-        return (
-            self._edb_terminal.GetPortPostProcessingProp().RenormalizionZ0.ToComplex().Item1,
-            self._edb_terminal.GetPortPostProcessingProp().RenormalizionZ0.ToComplex().Item2,
-        )
-
     @property
     def reference_object(self):
         """This returns the object assigned as reference. It can be a primitive or a padstack instance.
 
 
         Returns
         -------
         :class:`pyaedt.edb_core.edb_data.padstacks_data.EDBPadstackInstance` or
         :class:`pyaedt.edb_core.edb_data.primitives_data.EDBPrimitives`
         """
         if not self._reference_object:
             term = self._edb_terminal
-            if self.terminal_type == self._pedb.edb.Cell.Terminal.TerminalType.EdgeTerminal:
-                edges = self._edb_terminal.GetEdges()
-                edgeType = edges[0].GetEdgeType()
-                if edgeType == self._pedb.edb.Cell.Terminal.EdgeType.PadEdge:
-                    self._reference_object = self.get_pad_edge_terminal_reference_pin()
+            try:
+                if self.terminal_type == self._pedb.edb.Cell.Terminal.TerminalType.EdgeTerminal:
+                    edges = self._edb_terminal.GetEdges()
+                    edgeType = edges[0].GetEdgeType()
+                    if edgeType == self._pedb.edb.Cell.Terminal.EdgeType.PadEdge:
+                        self._reference_object = self.get_pad_edge_terminal_reference_pin()
+                    else:
+                        self._reference_object = self.get_edge_terminal_reference_primitive()
+                elif self.terminal_type == self._pedb.edb.Cell.Terminal.TerminalType.PinGroupTerminal:
+                    self._reference_object = self.get_pin_group_terminal_reference_pin()
+                elif self.terminal_type == self._pedb.edb.Cell.Terminal.TerminalType.PointTerminal:
+                    self._reference_object = self.get_point_terminal_reference_primitive()
+                elif self.terminal_type == self._pedb.edb.Cell.Terminal.TerminalType.PadstackInstanceTerminal:
+                    self._reference_object = self.get_padstack_terminal_reference_pin()
                 else:
-                    self._reference_object = self.get_edge_terminal_reference_primitive()
-            elif self.terminal_type == self._pedb.edb.Cell.Terminal.TerminalType.PinGroupTerminal:
-                self._reference_object = self.get_pin_group_terminal_reference_pin()
-            elif self.terminal_type == self._pedb.edb.Cell.Terminal.TerminalType.PointTerminal:
-                self._reference_object = self.get_point_terminal_reference_primitive()
-            elif self.terminal_type == self._pedb.edb.Cell.Terminal.TerminalType.PadstackInstanceTerminal:
-                self._reference_object = self.get_padstack_terminal_reference_pin()
-            else:
-                self._pedb.logger.warning("Invalid Terminal Type={}".format(term.GetTerminalType()))  # pragma: no cover
+                    self._pedb.logger.warning(
+                        "Invalid Terminal Type={}".format(term.GetTerminalType())
+                    )  # pragma: no cover
+            except:
+                pass
         return self._reference_object
 
     @property
     def reference_net_name(self):
         """Net name to which reference_object belongs."""
-        ref_obj = self._reference_object if self._reference_object else self.reference_object
-        if ref_obj:
-            return ref_obj.net_name
-        return  # pragma: no cover
+        try:
+            ref_obj = self._reference_object if self._reference_object else self.reference_object
+            if ref_obj:
+                return ref_obj.net_name
+        except:
+            pass
+        return ""
 
     @pyaedt_function_handler()
     def get_padstack_terminal_reference_pin(self, gnd_net_name_preference=None):
         """Get a list of pad stacks instances and serves Coax wave ports,
         pingroup terminals, PadEdge terminals.
 
         Parameters
@@ -702,15 +603,15 @@
 
         if self._edb_terminal.GetIsCircuitPort():
             return self.get_pin_group_terminal_reference_pin()
         _, padStackInstance, layer = self._edb_terminal.GetParameters()
 
         # Get the pastack instance of the terminal
         compInst = self._edb_terminal.GetComponent()
-        pins = self._pedb.core_components.get_pin_from_component(compInst.GetName())
+        pins = self._pedb.components.get_pin_from_component(compInst.GetName())
         return self._get_closest_pin(padStackInstance, pins, gnd_net_name_preference)
 
     @pyaedt_function_handler()
     def get_pin_group_terminal_reference_pin(self, gnd_net_name_preference=None):
         """Return a list of pins and serves terminals connected to pingroups.
 
         Parameters
@@ -784,20 +685,20 @@
         shape_pd = self._pedb.edb.Geometry.PointData(X, Y)
         layer_name = layer.GetName()
         for primitive in self._pedb.active_layout.Primitives:
             if primitive.GetLayer().GetName() == layer_name:
                 prim_shape_data = primitive.GetPolygonData()
                 if prim_shape_data.PointInPolygon(shape_pd):
                     return EDBPrimitives(primitive, self._pedb)
-        for vias in self._pedb.core_padstack.instances.values():
+        for vias in self._pedb.padstacks.instances.values():
             if layer_name in vias.layer_range_names:
-                plane = self._pedb.core_primitives.Shape(
+                plane = self._pedb.modeler.Shape(
                     "rectangle", pointA=vias.position, pointB=vias.padstack_definition.bounding_box[1]
                 )
-                rectangle_data = vias._pedb.core_primitives.shape_to_polygon_data(plane)
+                rectangle_data = vias._pedb.modeler.shape_to_polygon_data(plane)
                 if rectangle_data.PointInPolygon(shape_pd):
                     return vias
         return None
 
     @pyaedt_function_handler()
     def get_pad_edge_terminal_reference_pin(self, gnd_net_name_preference=None):
         """Get the closest pin padstack instances and serves any edge terminal connected to a pad.
@@ -808,29 +709,29 @@
             Preferred reference net name. Optianal, default is `None` which will auto compute the gnd name.
 
         Returns
         -------
         :class:`pyaedt.edb_core.edb_data.padstacks_data.EDBPadstackInstance`
         """
         comp_inst = self._edb_terminal.GetComponent()
-        pins = self._pedb.core_components.get_pin_from_component(comp_inst.GetName())
+        pins = self._pedb.components.get_pin_from_component(comp_inst.GetName())
         try:
             edges = self._edb_terminal.GetEdges()
         except AttributeError:
             return None
         _, pad_edge_pstack_inst, pad_edge_layer, pad_edge_polygon_data = edges[0].GetParameters()
         return self._get_closest_pin(pad_edge_pstack_inst, pins, gnd_net_name_preference)
 
     @pyaedt_function_handler()
     def _get_closest_pin(self, ref_pin, pin_list, gnd_net=None):
         _, pad_stack_inst_point, rotation = ref_pin.GetPositionAndRotation()  # get the xy of the padstack
         if gnd_net is not None:
             power_ground_net_names = [gnd_net]
         else:
-            power_ground_net_names = [net for net in self._pedb.core_nets.power_nets.keys()]
+            power_ground_net_names = [net for net in self._pedb.nets.power_nets.keys()]
         comp_ref_pins = [i for i in pin_list if i.GetNet().GetName() in power_ground_net_names]
         if len(comp_ref_pins) == 0:
             self._pedb.logger.error(
                 "Terminal with PadStack Instance Name {} component has no reference pins.".format(ref_pin.GetName())
             )  # pragma: no cover
             return None  # pragma: no cover
         closest_pin_distance = None
@@ -848,14 +749,121 @@
             else:
                 closest_pin_distance = distance
                 pin_obj = pin
         if pin_obj:
             return EDBPadstackInstance(pin_obj, self._pedb)
 
 
+class ExcitationPorts(CommonExcitation):
+    """Manages excitation properties.
+
+    Parameters
+    ----------
+    pedb : pyaedt.edb.Edb
+        EDB object from the ``Edblib`` library.
+    edb_terminal : Ansys.Ansoft.Edb.Cell.Terminal.EdgeTerminal
+        Edge terminal instance from EDB.
+
+
+    Examples
+    --------
+    This example shows how to access the ``ExcitationPorts`` class.
+    >>> from pyaedt import Edb
+    >>> edb = Edb("myaedb.aedb")
+    >>> exc = edb.excitations
+    >>> print(exc["Port1"].name)
+    """
+
+    def __init__(self, pedb, edb_terminal):
+        CommonExcitation.__init__(self, pedb, edb_terminal)
+
+    @property
+    def _edb_properties(self):
+        p = self._edb_terminal.GetProductSolverOption(self._edb.ProductId.Designer, "HFSS")
+        return p
+
+    @property
+    def hfss_type(self):
+        """HFSS port type."""
+        txt = re.search(r"'HFSS Type'='.*?'", self._edb_properties).group()
+        return txt.split("=")[1].replace("'", "")
+
+    @property
+    def horizontal_extent_factor(self):
+        """Horizontal extent factor."""
+        txt = re.search(r"'Horizontal Extent Factor'='.*?'", self._edb_properties).group()
+        return float(txt.split("=")[1].replace("'", ""))
+
+    @property
+    def vertical_extent_factor(self):
+        """Vvertical extent factor."""
+        txt = re.search(r"'Vertical Extent Factor'='.*?'", self._edb_properties).group()
+        return float(txt.split("=")[1].replace("'", ""))
+
+    @property
+    def radial_extent_factor(self):
+        """Radial extent factor."""
+        txt = re.search(r"'Radial Extent Factor'='.*?'", self._edb_properties).group()
+        return float(txt.split("=")[1].replace("'", ""))
+
+    @property
+    def pec_launch_width(self):
+        """Launch width for the printed electronic component (PEC)."""
+        txt = re.search(r"'PEC Launch Width'='.*?'", self._edb_properties).group()
+        return txt.split("=")[1].replace("'", "")
+
+    @property
+    def impedance(self):
+        """Impedance of the port."""
+        return self._edb_terminal.GetImpedance().ToDouble()
+
+    @property
+    def is_circuit(self):
+        """Whether it is a circuit port."""
+        return self._edb_terminal.GetIsCircuitPort()
+
+    @property
+    def magnitude(self):
+        """Magnitude."""
+        return self._edb_terminal.GetSourceAmplitude().ToDouble()
+
+    @property
+    def phase(self):
+        """Phase."""
+        return self._edb_terminal.GetSourcePhase().ToDouble()
+
+    @property
+    def renormalize(self):
+        """Whether renormalize is active."""
+        return self._edb_terminal.GetPortPostProcessingProp().DoRenormalize
+
+    @property
+    def deembed(self):
+        """Whether deembed is active."""
+        return self._edb_terminal.GetPortPostProcessingProp().DoDeembed
+
+    @property
+    def deembed_gapport_inductance(self):
+        """Inductance value of the deembed gap port."""
+        return self._edb_terminal.GetPortPostProcessingProp().DoDeembedGapL
+
+    @property
+    def deembed_length(self):
+        """Deembed Length."""
+        return self._edb_terminal.GetPortPostProcessingProp().DeembedLength.ToDouble()
+
+    @property
+    def renormalize_z0(self):
+        """Renormalize Z0 value (real, imag)."""
+        return (
+            self._edb_terminal.GetPortPostProcessingProp().RenormalizionZ0.ToComplex().Item1,
+            self._edb_terminal.GetPortPostProcessingProp().RenormalizionZ0.ToComplex().Item2,
+        )
+
+
 class ExcitationSources(CommonExcitation):
     """Manage sources properties.
 
     Parameters
     ----------
     pedb : pyaedt.edb.Edb
         Edb object from Edblib.
@@ -949,7 +957,28 @@
 
 
 class ExcitationDifferential(ExcitationBundle):
     """Manages differential excitation properties."""
 
     def __init__(self, pedb, edb_boundle_terminal):
         ExcitationBundle.__init__(self, pedb, edb_boundle_terminal)
+
+    @property
+    def net_name(self):
+        """Net name.
+
+        Returns
+        -------
+        str
+             Name of the net.
+        """
+        return self._edb_bundle_terminal.GetNet().GetName()
+
+    @property
+    def net(self):
+        """Net object.
+
+        Returns
+        -------
+        :class:`pyaedt.edb_core.edb_data.nets_data.EDBNetsData`
+        """
+        return EDBNetsData(self._edb_bundle_terminal.GetNet(), self._pedb)
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/utilities.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/utilities.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/edb_data/variables.py` & `pyaedt-0.6.70/pyaedt/edb_core/edb_data/variables.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/general.py` & `pyaedt-0.6.70/pyaedt/edb_core/general.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/hfss.py` & `pyaedt-0.6.70/pyaedt/edb_core/hfss.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,21 +14,21 @@
 from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import is_ironpython
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.modeler.geometry_operators import GeometryOperators
 
 
 class EdbHfss(object):
-    """Manages EDB method to configure Hfss setup accessible from `Edb.core_hfss` property.
+    """Manages EDB method to configure Hfss setup accessible from `Edb.hfss` property.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edbapp = Edb("myaedbfolder")
-    >>> edb_hfss = edb_3dedbapp.core_hfss
+    >>> edb_hfss = edb_3dedbapp.hfss
     """
 
     def __init__(self, p_edb):
         self._pedb = p_edb
 
     @property
     def _logger(self):
@@ -98,15 +98,15 @@
         if not isinstance(point_on_edge, self._edb.Geometry.PointData):
             point_on_edge = self._edb.Geometry.PointData(
                 self._get_edb_value(point_on_edge[0]), self._get_edb_value(point_on_edge[1])
             )
         if hasattr(prim_id, "GetId"):
             prim = prim_id
         else:
-            prim = [i for i in self._pedb.core_primitives.primitives if i.id == prim_id][0].primitive_object
+            prim = [i for i in self._pedb.modeler.primitives if i.id == prim_id][0].primitive_object
         pos_edge = self._edb.Cell.Terminal.PrimitiveEdge.Create(prim, point_on_edge)
         pos_edge = convert_py_list_to_net_list(pos_edge, self._edb.Cell.Terminal.Edge)
         return self._edb.Cell.Terminal.EdgeTerminal.Create(
             prim.GetLayout(), prim.GetNet(), terminal_name, pos_edge, isRef=is_ref
         )
 
     @pyaedt_function_handler()
@@ -116,17 +116,17 @@
         Returns
         -------<
         dict
             Dictionary of trace width data.
         """
         nets = {}
         for net in self._pedb.excitations_nets:
-            smallest = self._pedb.core_nets.nets[net].get_smallest_trace_width()
+            smallest = self._pedb.nets[net].get_smallest_trace_width()
             if smallest < 1e10:
-                nets[net] = self._pedb.core_nets.nets[net].get_smallest_trace_width()
+                nets[net] = self._pedb.nets[net].get_smallest_trace_width()
         return nets
 
     @pyaedt_function_handler()
     def create_circuit_port_on_pin(self, pos_pin, neg_pin, impedance=50, port_name=None):
         """Create Circuit Port on Pin.
 
         Parameters
@@ -138,24 +138,24 @@
         impedance : float
             Port Impedance
         port_name : str, optional
             Port Name
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> pins =edbapp.core_components.get_pin_from_component("U2A5")
-        >>> edbapp.core_hfss.create_circuit_port_on_pin(pins[0], pins[1],50,"port_name")
+        >>> pins =edbapp.components.get_pin_from_component("U2A5")
+        >>> edbapp.hfss.create_circuit_port_on_pin(pins[0], pins[1],50,"port_name")
 
         Returns
         -------
         str
             Port Name.
 
         """
-        return self._pedb.core_siwave.create_circuit_port_on_pin(pos_pin, neg_pin, impedance, port_name)
+        return self._pedb.siwave.create_circuit_port_on_pin(pos_pin, neg_pin, impedance, port_name)
 
     @pyaedt_function_handler()
     def create_voltage_source_on_pin(self, pos_pin, neg_pin, voltage_value=3.3, phase_value=0, source_name=""):
         """Create a voltage source.
 
         Parameters
         ----------
@@ -176,20 +176,18 @@
             Source Name.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> pins =edbapp.core_components.get_pin_from_component("U2A5")
-        >>> edbapp.core_hfss.create_voltage_source_on_pin(pins[0], pins[1],50,"source_name")
+        >>> pins =edbapp.components.get_pin_from_component("U2A5")
+        >>> edbapp.hfss.create_voltage_source_on_pin(pins[0], pins[1],50,"source_name")
         """
-        return self._pedb.core_siwave.create_voltage_source_on_pin(
-            pos_pin, neg_pin, voltage_value, phase_value, source_name
-        )
+        return self._pedb.siwave.create_voltage_source_on_pin(pos_pin, neg_pin, voltage_value, phase_value, source_name)
 
     @pyaedt_function_handler()
     def create_current_source_on_pin(self, pos_pin, neg_pin, current_value=0.1, phase_value=0, source_name=""):
         """Create a current source.
 
         Parameters
         ----------
@@ -210,21 +208,19 @@
             Source Name.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> pins =edbapp.core_components.get_pin_from_component("U2A5")
-        >>> edbapp.core_hfss.create_current_source_on_pin(pins[0], pins[1],50,"source_name")
+        >>> pins =edbapp.components.get_pin_from_component("U2A5")
+        >>> edbapp.hfss.create_current_source_on_pin(pins[0], pins[1],50,"source_name")
         """
 
-        return self._pedb.core_siwave.create_current_source_on_pin(
-            pos_pin, neg_pin, current_value, phase_value, source_name
-        )
+        return self._pedb.siwave.create_current_source_on_pin(pos_pin, neg_pin, current_value, phase_value, source_name)
 
     @pyaedt_function_handler()
     def create_resistor_on_pin(self, pos_pin, neg_pin, rvalue=1, resistor_name=""):
         """Create a Resistor boundary between two given pins.
 
         Parameters
         ----------
@@ -243,18 +239,18 @@
             Name of the Resistor.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> pins =edbapp.core_components.get_pin_from_component("U2A5")
-        >>> edbapp.core_hfss.create_resistor_on_pin(pins[0], pins[1],50,"res_name")
+        >>> pins =edbapp.components.get_pin_from_component("U2A5")
+        >>> edbapp.hfss.create_resistor_on_pin(pins[0], pins[1],50,"res_name")
         """
-        return self._pedb.core_siwave.create_resistor_on_pin(pos_pin, neg_pin, rvalue, resistor_name)
+        return self._pedb.siwave.create_resistor_on_pin(pos_pin, neg_pin, rvalue, resistor_name)
 
     @pyaedt_function_handler()
     def create_circuit_port_on_net(
         self,
         positive_component_name,
         positive_net_name,
         negative_component_name=None,
@@ -286,17 +282,17 @@
         str
             The name of the port.
 
         Examples
         --------
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_hfss.create_circuit_port_on_net("U2A5", "V1P5_S3", "U2A5", "GND", 50, "port_name")
+        >>> edbapp.hfss.create_circuit_port_on_net("U2A5", "V1P5_S3", "U2A5", "GND", 50, "port_name")
         """
-        return self._pedb.core_siwave.create_circuit_port_on_net(
+        return self._pedb.siwave.create_circuit_port_on_net(
             positive_component_name,
             positive_net_name,
             negative_component_name,
             negative_net_name,
             impedance_value,
             port_name,
         )
@@ -338,17 +334,17 @@
             Source Name.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edb.core_hfss.create_voltage_source_on_net("U2A5", "V1P5_S3", "U2A5", "GND", 3.3, 0, "source_name")
+        >>> edb.hfss.create_voltage_source_on_net("U2A5", "V1P5_S3", "U2A5", "GND", 3.3, 0, "source_name")
         """
-        return self._pedb.core_siwave.create_voltage_source_on_net(
+        return self._pedb.siwave.create_voltage_source_on_net(
             positive_component_name,
             positive_net_name,
             negative_component_name,
             negative_net_name,
             voltage_value,
             phase_value,
             source_name,
@@ -391,17 +387,17 @@
             Source Name.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edb.core_hfss.create_current_source_on_net("U2A5", "V1P5_S3", "U2A5", "GND", 0.1, 0, "source_name")
+        >>> edb.hfss.create_current_source_on_net("U2A5", "V1P5_S3", "U2A5", "GND", 0.1, 0, "source_name")
         """
-        return self._pedb.core_siwave.create_current_source_on_net(
+        return self._pedb.siwave.create_current_source_on_net(
             positive_component_name,
             positive_net_name,
             negative_component_name,
             negative_net_name,
             current_value,
             phase_value,
             source_name,
@@ -430,15 +426,15 @@
         """
         coax = []
         if not isinstance(ref_des_list, list):
             ref_des_list = [ref_des_list]
         if not isinstance(net_list, list):
             net_list = [net_list]
         for ref in ref_des_list:
-            for _, py_inst in self._pedb.core_components.components[ref].pins.items():
+            for _, py_inst in self._pedb.components.components[ref].pins.items():
                 if py_inst.net_name in net_list and py_inst.is_pin:
                     port_name = "{}_{}_{}".format(ref, py_inst.net_name, py_inst.pin.GetName())
                     (
                         res,
                         from_layer_pos,
                         to_layer_pos,
                     ) = py_inst.pin.GetLayerRange()
@@ -496,15 +492,15 @@
         Returns
         -------
         tuple
             The tuple contains: (port_name, pyaedt.edb_core.edb_data.sources.ExcitationDifferential).
 
         Examples
         --------
-        >>> edb.core_hfss.create_differential_wave_port(0, ["-50mm", "-0mm"], 1, ["-50mm", "-0.2mm"])
+        >>> edb.hfss.create_differential_wave_port(0, ["-50mm", "-0mm"], 1, ["-50mm", "-0.2mm"])
         """
         if not port_name:
             port_name = generate_unique_name("diff")
 
         if isinstance(positive_primitive_id, EDBPrimitives):
             positive_primitive_id = positive_primitive_id.id
 
@@ -564,15 +560,15 @@
         Returns
         -------
         tuple
             The tuple contains: (port_name, pyaedt.edb_core.edb_data.sources.ExcitationDifferential).
 
         Examples
         --------
-        >>> edb.core_hfss.create_bundle_wave_port(0, ["-50mm", "-0mm"], 1, ["-50mm", "-0.2mm"])
+        >>> edb.hfss.create_bundle_wave_port(0, ["-50mm", "-0mm"], 1, ["-50mm", "-0.2mm"])
         """
         if not port_name:
             port_name = generate_unique_name("bundle_port")
 
         if isinstance(primitives_id[0], EDBPrimitives):
             primitives_id = [i.id for i in primitives_id]
 
@@ -675,15 +671,15 @@
         >>> edb_path = path_to_edb
         >>> edb = Edb(edb_path)
         >>> poly_list = [poly for poly in list(edb.active_layout.Primitives) if poly.GetPrimitiveType() == 2]
         >>> port_poly = [poly for poly in poly_list if poly.GetId() == 17][0]
         >>> ref_poly = [poly for poly in poly_list if poly.GetId() == 19][0]
         >>> port_location = [-65e-3, -13e-3]
         >>> ref_location = [-63e-3, -13e-3]
-        >>> edb.core_hfss.create_edge_port_on_polygon(polygon=port_poly, reference_polygon=ref_poly,
+        >>> edb.hfss.create_edge_port_on_polygon(polygon=port_poly, reference_polygon=ref_poly,
         >>> terminal_point=port_location, reference_point=ref_location)
 
         """
         if not polygon:
             self._logger.error("No polygon provided for port {} creation".format(port_name))
             return False
         if reference_layer:
@@ -762,15 +758,15 @@
         Returns
         -------
         tuple
             The tuple contains: (Port name, pyaedt.edb_core.edb_data.sources.Excitation).
 
         Examples
         --------
-        >>> edb.core_hfss.create_wave_port(0, ["-50mm", "-0mm"])
+        >>> edb.hfss.create_wave_port(0, ["-50mm", "-0mm"])
         """
         if not port_name:
             port_name = generate_unique_name("Terminal_")
 
         if isinstance(prim_id, EDBPrimitives):
             prim_id = prim_id.id
 
@@ -787,15 +783,15 @@
         )
         pos_edge_term.SetProductSolverOption(
             self._pedb.edb.ProductId.Designer,
             "HFSS",
             prop,
         )
         if pos_edge_term:
-            return port_name, self._pedb.core_hfss.excitations[port_name]
+            return port_name, self._pedb.hfss.excitations[port_name]
         else:
             return False
 
     @pyaedt_function_handler()
     def create_edge_port_vertical(
         self,
         prim_id,
@@ -859,15 +855,15 @@
         )
         pos_edge_term.SetProductSolverOption(
             self._pedb.edb.ProductId.Designer,
             "HFSS",
             prop,
         )
         if pos_edge_term:
-            return port_name, self._pedb.core_hfss.excitations[port_name]
+            return port_name, self._pedb.hfss.excitations[port_name]
         else:
             return False
 
     @pyaedt_function_handler()
     def create_edge_port_horizontal(
         self,
         prim_id,
@@ -1039,122 +1035,14 @@
             round(_bbox.Item1.Y.ToDouble(), digit_resolution),
             round(_bbox.Item2.X.ToDouble(), digit_resolution),
             round(_bbox.Item2.Y.ToDouble(), digit_resolution),
         ]
         return layout_bbox
 
     @pyaedt_function_handler()
-    def create_circuit_ports_on_components_no_pin_group(
-        self,
-        signal_nets=None,
-        power_nets=None,
-        simulation_setup=None,
-        component_list=None,
-    ):
-        """Create circuit ports on given components.
-        For each component, create a coplanar circuit port at each signalNet pin.
-        Use the closest powerNet pin as a reference, regardless of component.
-
-        Parameters
-        ----------
-        signal_nets : list, optional if simulation_setup is provided
-            List of signal net names. This list is ignored if a ``simulation_setup`` object is provided.
-
-        power_nets : list, optional if a ``simulatiom_setup`` object is provided
-            List of power net names. This list is ignored if a ``simulation_setup`` object
-            is provided.
-
-        component_list : list optional if simulatiom_setup provided.
-            The list of component names. will be ignored if simulation_setup object is provided
-
-        Returns
-        -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-        """
-        if simulation_setup:
-            if not isinstance(simulation_setup, SimulationConfiguration):
-                self._logger.error(
-                    "simulation setup was provided but must be an instance of \
-                    edb_data.simulation_configuration.SimulationConfiguration"
-                )
-                return False
-            signal_nets = simulation_setup.signal_nets
-            power_nets = simulation_setup.power_nets
-            component_list = simulation_setup.coplanar_instances
-        else:
-            if not component_list:
-                return False
-
-        if not simulation_setup.coplanar_instances:
-            return False
-
-        layout = self._active_layout
-        l_inst = layout.GetLayoutInstance()
-        edb_power_nets = [self._pedb.core_nets.find_or_create_net(net) for net in power_nets]
-        for inst in component_list:
-            comp = self._edb.Cell.Hierarchy.Component.FindByName(layout, inst)
-            if comp.IsNull():
-                self._logger.warning("SetupCoplanarInstances: could not find {0}".format(inst))
-                continue
-            # Get the portLayer based on the component's pin placement
-            cmp_layer = self._edb.Cell.Hierarchy.Component.GetPlacementLayer(comp)
-            # Get the bbox of the comp
-            bb = self._edb.Geometry.PolygonData.CreateFromBBox(l_inst.GetLayoutObjInstance(comp, None).GetBBox())
-            bb_c = bb.GetBoundingCircleCenter()
-            # Expand x5 to create testing polygon...
-            bb.Scale(5, bb_c)
-            # Find the closest pin in the Ground/Power nets...
-            hit = l_inst.FindLayoutObjInstance(bb, cmp_layer, convert_py_list_to_net_list(edb_power_nets))
-            all_hits = [list(hit.Item1.Items) + list(hit.Item2.Items)]
-            hit_pinsts = [
-                obj
-                for obj in all_hits
-                if obj.GetLayoutObj().GetObjType() == self._edb.Cell.LayoutObjType.PadstackInstance
-            ]
-            if not hit_pinsts:
-                self._logger.error("SetupCoplanarInstances: could not find a pin in the vicinity of {0}".format(inst))
-                continue
-            # Iterate each pin in the component that's on the signal nets and create a circuit port
-            pin_list = [
-                obj
-                for obj in list(comp.LayoutObjs)
-                if obj.GetObjType() == self._edb.Cell.LayoutObjType.PadstackInstance
-                and obj.GetNet().GetName() in signal_nets
-            ]
-            for ii, pin in enumerate(pin_list):
-                pin_c = l_inst.GetLayoutObjInstance(pin, None).GetCenter()
-                ref_pinst = None
-                ref_pt = None
-                ref_dist = None
-                for hhLoi in hit_pinsts:
-                    this_c = hhLoi.GetCenter()
-                    this_dist = this_c.Distance(pin_c)
-                    if ref_pt is None or this_dist < ref_dist:
-                        ref_pinst = hhLoi.GetLayoutObj()
-                        ref_pt = this_c
-                        ref_dist = this_dist
-
-                port_nm = "PORT_{0}_{1}@{2}".format(comp.GetName(), ii, pin.GetNet().GetName())
-                ## TO complete and check for embefing in create_port_on_component
-                ###########################
-                ###########################
-                self._edbutils.HfssUtilities.CreateCircuitPortFromPoints(
-                    port_nm,
-                    layout,
-                    pin_c,
-                    cmp_layer,
-                    pin.GetNet(),
-                    ref_pt,
-                    cmp_layer,
-                    ref_pinst.GetNet(),
-                )
-        return True
-
-    @pyaedt_function_handler()
     def configure_hfss_extents(self, simulation_setup=None):
         """Configure the HFSS extent box.
 
         Parameters
         ----------
         simulation_setup :
             Edb_DATA.SimulationConfiguration object
@@ -1508,15 +1396,15 @@
         """
         if not isinstance(simulation_setup, SimulationConfiguration):
             self._logger.error(
                 "Layout defeaturing requires an edb_data.simulation_configuration.SimulationConfiguration object."
             )
             return False
         self._logger.info("Starting Layout Defeaturing")
-        polygon_list = self._pedb.core_primitives.polygons
+        polygon_list = self._pedb.modeler.polygons
         polygon_with_voids = self._pedb.core_layout.get_poly_with_voids(polygon_list)
         self._logger.info("Number of polygons with voids found: {0}".format(str(polygon_with_voids.Count)))
         for _poly in polygon_list:
             voids_from_current_poly = _poly.Voids
             new_poly_data = self._pedb.core_layout.defeature_polygon(setup_info=simulation_setup, poly=_poly)
             _poly.SetPolygonData(new_poly_data)
             if len(voids_from_current_poly) > 0:
@@ -1562,16 +1450,16 @@
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
 
         if positive_pin and negative_pin:
-            positive_pin_term = self._pedb.core_components._create_terminal(positive_pin)
-            negative_pin_term = self._pedb.core_components._create_terminal(negative_pin)
+            positive_pin_term = self._pedb.components._create_terminal(positive_pin)
+            negative_pin_term = self._pedb.components._create_terminal(negative_pin)
             positive_pin_term.SetBoundaryType(self._edb.Cell.Terminal.BoundaryType.RlcBoundary)
             negative_pin_term.SetBoundaryType(self._edb.Cell.Terminal.BoundaryType.RlcBoundary)
             rlc = self._edb.Utility.Rlc()
             rlc.IsParallel = True
             rlc.REnabled = True
             rlc.LEnabled = True
             rlc.CEnabled = True
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/bom/bom.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/bom/bom.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/bom/bom_item.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/bom/bom_item.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/bom/characteristics.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/bom/characteristics.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/bom/refdes.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/bom/refdes.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/color.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/color.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/content.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/content.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/dictionary_color.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/dictionary_color.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/dictionary_fill.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/dictionary_fill.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/dictionary_line.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/dictionary_line.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/entry_line.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/entry_line.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/fill.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/fill.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/content/standard_geometries_dictionary.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/content/standard_geometries_dictionary.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/assembly_drawing.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/assembly_drawing.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/cad_data.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/cad_data.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/component.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/component.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/drill.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/drill.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/feature.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/feature.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/layer.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/layer.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/layer_feature.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/layer_feature.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/logical_net.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/logical_net.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/outline.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/outline.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/package.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/package.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_def.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_def.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_hole_def.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_hole_def.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_instance.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_instance.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_pad_def.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/padstack_pad_def.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/path.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/path.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/phy_net.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/phy_net.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/pin.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/pin.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/polygon.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/polygon.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/profile.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/profile.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup_group.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup_group.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup_layer.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/stackup_layer.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_data/step.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_data/step.py`

 * *Files 1% similar despite different names*

```diff
@@ -121,15 +121,15 @@
                 package = Package(self._ipc)
                 package.add_component_outline(component)
                 package.name = component.part_name
                 package.height = ""
                 package.type = component.type
                 pin_number = 0
                 for _, pin in component.pins.items():
-                    geometry_type, pad_parameters, pos_x, pos_y, rot = self._pedb.core_padstack.get_pad_parameters(
+                    geometry_type, pad_parameters, pos_x, pos_y, rot = self._pedb.padstacks.get_pad_parameters(
                         pin._edb_padstackinstance, component.placement_layer, 0
                     )
                     position = pin._position if pin._position else pin.position
 
                     pin_pos_x = self._ipc.from_meter_to_units(position[0], self.units)
                     pin_pos_y = self._ipc.from_meter_to_units(position[1], self.units)
                     primitive_ref = ""
@@ -219,15 +219,15 @@
                 pdef_name = (
                     padstack_instance._pdef if padstack_instance._pdef else padstack_instance.padstack_definition
                 )
                 padstack_def = padstack_defs[pdef_name]
 
                 comp_name = padstack_instance.GetComponent().GetName()
                 if padstack_instance.is_pin and comp_name:
-                    component_inst = self._pedb.core_components.components[comp_name]
+                    component_inst = self._pedb.components.components[comp_name]
                     layers[layer_name].add_component_padstack_instance_feature(
                         component_inst, padstack_instance, top_bottom_layers, padstack_def
                     )
                 else:
                     layers[layer_name].add_via_instance_feature(padstack_instance, padstack_def, layer_name)
 
     @pyaedt_function_handler()
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/cad_header.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/cad_header.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/ecad.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/ecad.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ecad/spec.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ecad/spec.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/history_record.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/history_record.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/ipc2581.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/ipc2581.py`

 * *Files 2% similar despite different names*

```diff
@@ -45,15 +45,15 @@
         self.add_layer_features()
         self._pedb.logger.info("Parsing Drills...")
         self.add_drills()
         self._pedb.logger.info("Parsing EDB Completed!")
 
     @pyaedt_function_handler()
     def add_pdstack_definition(self):
-        for padstack_name, padstackdef in self._pedb.core_padstack.definitions.items():
+        for padstack_name, padstackdef in self._pedb.padstacks.definitions.items():
             padstack_def = PadstackDef()
             padstack_def.name = padstack_name
             padstack_def.padstack_hole_def.name = padstack_name
             if padstackdef.hole_properties:
                 padstack_def.padstack_hole_def.diameter = self.from_meter_to_units(
                     padstackdef.hole_properties[0], self.units
                 )
@@ -195,15 +195,15 @@
                     padstack_def.add_padstack_pad_def(layer=layer, pad_use="THERMAL", primitive_ref=primitive_ref)
             if not padstack_def.name in self.ecad.cad_data.cad_data_step.padstack_defs:
                 self.ecad.cad_data.cad_data_step.padstack_defs[padstack_def.name] = padstack_def
 
     @pyaedt_function_handler()
     def add_bom(self):
         # Bom
-        for part_name, components in self._pedb.core_components.components_by_partname.items():
+        for part_name, components in self._pedb.components.components_by_partname.items():
             bom_item = BomItem()
             bom_item.part_name = part_name
             bom_item.quantity = len(components)
             bom_item.pin_count = components[0].numpins
             bom_item.category = "ELECTRICAL"
             bom_item.charactistics.device_type = components[0].type
             bom_item.charactistics.category = "ELECTRICAL"
@@ -293,37 +293,37 @@
             #    pass
         self.ecad.cad_data.add_layer(layer_name="Drill", layer_function="DRILL", layer_side="ALL", polarity="POSITIVE")
         self.content.add_layer_ref("Drill")
         self.content.dict_colors.add_color("{}".format("Drill"), "255", "255", "255")
 
     @pyaedt_function_handler()
     def add_components(self):
-        for item in self._pedb.core_components.components.values():
+        for item in self._pedb.components.components.values():
             self.ecad.cad_data.cad_data_step.add_component(item)
 
     @pyaedt_function_handler()
     def add_logical_nets(self):
-        nets = [i for i in self._pedb.core_nets.nets.values()]
+        nets = [i for i in self._pedb.nets.nets.values()]
         for net in nets:
             self.ecad.cad_data.cad_data_step.add_logical_net(net)
 
     @pyaedt_function_handler()
     def add_layer_features(self):
         layers = {i: j for i, j in self._pedb.stackup.signal_layers.items()}
-        padstack_instances = list(self._pedb.core_padstack.instances.values())
-        padstack_defs = {i: k for i, k in self._pedb.core_padstack.definitions.items()}
-        polys = {i: j for i, j in self._pedb.core_primitives.primitives_by_layer.items()}
+        padstack_instances = list(self._pedb.padstacks.instances.values())
+        padstack_defs = {i: k for i, k in self._pedb.padstacks.definitions.items()}
+        polys = {i: j for i, j in self._pedb.modeler.primitives_by_layer.items()}
         for layer_name, layer in layers.items():
             self.ecad.cad_data.cad_data_step.add_layer_feature(layer, polys[layer_name])
         self.ecad.cad_data.cad_data_step.add_padstack_instances(padstack_instances, padstack_defs)
 
     @pyaedt_function_handler()
     def add_drills(self):
         via_list = [
-            obj for obj in list(self._pedb.core_padstack.instances.values()) if not obj.start_layer == obj.stop_layer
+            obj for obj in list(self._pedb.padstacks.instances.values()) if not obj.start_layer == obj.stop_layer
         ]
         l1 = len(list(self._pedb.stackup.signal_layers.keys()))
 
         self.ecad.cad_data.cad_data_step.add_drill_layer_feature(via_list, "DRILL_1-{}".format(l1))
 
     @pyaedt_function_handler()
     def from_meter_to_units(self, value, units):
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/ipc2581/logistic_header.py` & `pyaedt-0.6.70/pyaedt/edb_core/ipc2581/logistic_header.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/layout.py` & `pyaedt-0.6.70/pyaedt/edb_core/layout.py`

 * *Files 2% similar despite different names*

```diff
@@ -7,21 +7,21 @@
 from pyaedt.edb_core.edb_data.utilities import EDBStatistics
 from pyaedt.edb_core.general import convert_py_list_to_net_list
 from pyaedt.generic.clr_module import Tuple
 from pyaedt.generic.general_methods import pyaedt_function_handler
 
 
 class EdbLayout(object):
-    """Manages EDB methods for primitives management accessible from `Edb.core_primitives` property.
+    """Manages EDB methods for primitives management accessible from `Edb.modeler` property.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edbapp = Edb("myaedbfolder", edbversion="2021.2")
-    >>> edb_layout = edbapp.core_primitives
+    >>> edb_layout = edbapp.modeler
     """
 
     def __init__(self, p_edb):
         self._pedb = p_edb
 
     @property
     def _edb(self):
@@ -102,15 +102,15 @@
 
         Returns
         -------
         dict
             Dictionary of primitives with nat names as keys.
         """
         _prim_by_net = {}
-        for net in list(self._pedb.core_nets.nets.keys()):
+        for net in list(self._pedb.nets.nets.keys()):
             _prim_by_net[net] = [
                 EDBPrimitives(i, self._pedb) for i in self._active_layout.Primitives if i.GetNet().GetName() == net
             ]
         return _prim_by_net
 
     @property
     def primitives_by_layer(self):
@@ -223,16 +223,16 @@
         Returns
         -------
         list
             List of bounding box coordinates in the format ``[-x, -y, +x, +y]``.
 
         Examples
         --------
-        >>> poly = edb_core.core_primitives.get_polygons_by_layer("GND")
-        >>> bounding = edb_core.core_primitives.get_polygon_bounding_box(poly[0])
+        >>> poly = edb_core.modeler.get_polygons_by_layer("GND")
+        >>> bounding = edb_core.modeler.get_polygon_bounding_box(poly[0])
         """
         bounding = []
         try:
             bounding_box = polygon.GetPolygonData().GetBBox()
             bounding = [
                 bounding_box.Item1.X.ToDouble(),
                 bounding_box.Item1.Y.ToDouble(),
@@ -259,16 +259,16 @@
         -------
         list
             List of doubles.
 
         Examples
         --------
 
-        >>> poly = edb_core.core_primitives.get_polygons_by_layer("GND")
-        >>> points  = edb_core.core_primitives.get_polygon_points(poly[0])
+        >>> poly = edb_core.modeler.get_polygons_by_layer("GND")
+        >>> points  = edb_core.modeler.get_polygon_points(poly[0])
 
         """
         points = []
         i = 0
         continue_iterate = True
         prev_point = None
         while continue_iterate:
@@ -407,15 +407,15 @@
             ``"Sharp"`` and ``"Mitered"``. The default is ``"Round"``.
 
         Returns
         -------
         :class:`pyaedt.edb_core.edb_data.primitives_data.EDBPrimitives`
             ``True`` when successful, ``False`` when failed.
         """
-        net = self._pedb.core_nets.find_or_create_net(net_name)
+        net = self._pedb.nets.find_or_create_net(net_name)
         if start_cap_style.lower() == "round":
             start_cap_style = self._edb.Cell.Primitive.PathEndCapStyle.Round
         elif start_cap_style.lower() == "extended":
             start_cap_style = self._edb.Cell.Primitive.PathEndCapStyle.Extended  # pragma: no cover
         else:
             start_cap_style = self._edb.Cell.Primitive.PathEndCapStyle.Flat  # pragma: no cover
         if end_cap_style.lower() == "round":
@@ -505,38 +505,44 @@
 
     @pyaedt_function_handler()
     def create_polygon(self, main_shape, layer_name, voids=[], net_name=""):
         """Create a polygon based on a list of points and voids.
 
         Parameters
         ----------
-        main_shape :
-            Shape of the main object.
+        main_shape : list of points or PolygonData or ``modeler.Shape``
+            Shape or point lists of the main object.
         layer_name : str
             Name of the layer on which to create the polygon.
         voids : list, optional
-            List of shape objects for voids. The default is``[]``.
+            List of shape objects for voids or points that creates the shapes. The default is``[]``.
         net_name : str, optional
             Name of the net. The default is ``""``.
 
         Returns
         -------
         bool, :class:`pyaedt.edb_core.edb_data.primitives.EDBPrimitives`
             Polygon when successful, ``False`` when failed.
         """
-        net = self._pedb.core_nets.find_or_create_net(net_name)
-        if isinstance(main_shape, EdbLayout.Shape):
+        net = self._pedb.nets.find_or_create_net(net_name)
+        if isinstance(main_shape, list):
+            shape = self.Shape("polygon", points=main_shape)
+            polygonData = self.shape_to_polygon_data(shape)
+        elif isinstance(main_shape, EdbLayout.Shape):
             polygonData = self.shape_to_polygon_data(main_shape)
         else:
             polygonData = main_shape
         if polygonData is None or polygonData.IsNull() or polygonData is False:
             self._logger.error("Failed to create main shape polygon data")
             return False
         for void in voids:
-            if isinstance(void, EdbLayout.Shape):
+            if isinstance(void, list):
+                void = self.Shape("polygon", points=void)
+                voidPolygonData = self.shape_to_polygon_data(void)
+            elif isinstance(void, EdbLayout.Shape):
                 voidPolygonData = self.shape_to_polygon_data(void)
             else:
                 voidPolygonData = void
             if voidPolygonData is None or voidPolygonData.IsNull() or polygonData is False:
                 self._logger.error("Failed to create void polygon data")
                 return False
             polygonData.AddHole(voidPolygonData)
@@ -560,15 +566,15 @@
         net_name : str, optional
             Name of the net on which create the polygon.
 
         Returns
         -------
         :class:`pyaedt.edb_core.edb_data.primitives_data.EDBPrimitives`
         """
-        net = self._pedb.core_nets.find_or_create_net(net_name)
+        net = self._pedb.nets.find_or_create_net(net_name)
         plane = self.Shape("polygon", points=point_list)
         _poly = self.shape_to_polygon_data(plane)
         if _poly is None or _poly.IsNull() or _poly is False:
             self._logger.error("Failed to create main shape polygon data")
             return False
         polygon = self._edb.Cell.Primitive.Polygon.Create(self._active_layout, layer_name, net, _poly)
         if polygon.IsNull():
@@ -618,15 +624,15 @@
             Rotation of the rectangle. The default is ``"0deg"``.
 
         Returns
         -------
          :class:`pyaedt.edb_core.edb_data.primitives_data.EDBPrimitives`
             Rectangle when successful, ``False`` when failed.
         """
-        edb_net = self._pedb.core_nets.find_or_create_net(net_name)
+        edb_net = self._pedb.nets.find_or_create_net(net_name)
         if representation_type == "LowerLeftUpperRight":
             rep_type = self._edb.Cell.Primitive.RectangleRepresentationType.LowerLeftUpperRight
             rect = self._edb.Cell.Primitive.Rectangle.Create(
                 self._active_layout,
                 layer_name,
                 edb_net,
                 rep_type,
@@ -674,15 +680,15 @@
             default name is assigned.
 
         Returns
         -------
         :class:`pyaedt.edb_core.edb_data.primitives_data.EDBPrimitives`
             Objects of the circle created when successful.
         """
-        edb_net = self._pedb.core_nets.find_or_create_net(net_name)
+        edb_net = self._pedb.nets.find_or_create_net(net_name)
 
         circle = self._edb.Cell.Primitive.Circle.Create(
             self._active_layout,
             layer_name,
             edb_net,
             self._get_edb_value(x),
             self._get_edb_value(y),
@@ -705,15 +711,15 @@
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> Edb.core_primitives.delete_primitives(net_names=["GND"])
+        >>> Edb.modeler.delete_primitives(net_names=["GND"])
         """
         if not isinstance(net_names, list):  # pragma: no cover
             net_names = [net_names]
 
         for p in self.primitives[:]:
             if p.net_name in net_names:
                 p.delete()
@@ -1098,15 +1104,15 @@
                     for v in all_voids:
                         for void in v:
                             if int(item.GetIntersectionType(void.GetPolygonData())) == 2:
                                 item.AddHole(void.GetPolygonData())
                     poly = self._edb.Cell.Primitive.Polygon.Create(
                         self._active_layout,
                         lay,
-                        self._pedb.core_nets.nets[net].net_object,
+                        self._pedb.nets.nets[net].net_object,
                         item,
                     )
                 list_to_delete = [i for i in poly_by_nets[net]]
                 for v in all_voids:
                     for void in v:
                         for poly in poly_by_nets[net]:
                             if int(void.GetPolygonData().GetIntersectionType(poly.GetPolygonData())) >= 2:
@@ -1117,18 +1123,18 @@
                                 if id >= 0:
                                     list_to_delete.pop(id)
 
                 [i.Delete() for i in list_to_delete]
 
         if delete_padstack_gemometries:
             self._logger.info("Deleting Padstack Definitions")
-            for pad in self._pedb.core_padstack.definitions:
-                p1 = self._pedb.core_padstack.definitions[pad].edb_padstack.GetData()
+            for pad in self._pedb.padstacks.definitions:
+                p1 = self._pedb.padstacks.definitions[pad].edb_padstack.GetData()
                 if len(p1.GetLayerNames()) > 1:
-                    self._pedb.core_padstack.remove_pads_from_padstack(pad)
+                    self._pedb.padstacks.remove_pads_from_padstack(pad)
         return True
 
     @pyaedt_function_handler()
     def defeature_polygon(self, setup_info, poly, max_surface_deviation=0.001):
         """Defeature the polygon based on the maximum surface deviation criteria.
 
         Parameters
@@ -1240,34 +1246,32 @@
         -------
 
         EDBStatistics object.
 
         """
         stat_model = EDBStatistics()
         stat_model.num_layers = len(list(self._pedb.stackup.stackup_layers.values()))
-        stat_model.num_capacitors = len(self._pedb.core_components.capacitors)
-        stat_model.num_resistors = len(self._pedb.core_components.resistors)
-        stat_model.num_inductors = len(self._pedb.core_components.inductors)
+        stat_model.num_capacitors = len(self._pedb.components.capacitors)
+        stat_model.num_resistors = len(self._pedb.components.resistors)
+        stat_model.num_inductors = len(self._pedb.components.inductors)
         stat_model.layout_size = self._pedb._hfss.get_layout_bounding_box(self._active_layout)
         stat_model.num_discrete_components = (
-            len(self._pedb.core_components.Others)
-            + len(self._pedb.core_components.ICs)
-            + len(self._pedb.core_components.IOs)
+            len(self._pedb.components.Others) + len(self._pedb.components.ICs) + len(self._pedb.components.IOs)
         )
-        stat_model.num_inductors = len(self._pedb.core_components.inductors)
-        stat_model.num_resistors = len(self._pedb.core_components.resistors)
-        stat_model.num_capacitors = len(self._pedb.core_components.capacitors)
-        stat_model.num_nets = len(self._pedb.core_nets.nets)
-        stat_model.num_traces = len(self._pedb.core_primitives.paths)
-        stat_model.num_polygons = len(self._pedb.core_primitives.polygons)
-        stat_model.num_vias = len(self._pedb.core_padstack.instances)
+        stat_model.num_inductors = len(self._pedb.components.inductors)
+        stat_model.num_resistors = len(self._pedb.components.resistors)
+        stat_model.num_capacitors = len(self._pedb.components.capacitors)
+        stat_model.num_nets = len(self._pedb.nets.nets)
+        stat_model.num_traces = len(self._pedb.modeler.paths)
+        stat_model.num_polygons = len(self._pedb.modeler.polygons)
+        stat_model.num_vias = len(self._pedb.padstacks.instances)
         stat_model.stackup_thickness = self._pedb.stackup.get_layout_thickness()
         if evaluate_area:
             if net_list:
-                netlist = list(self._pedb.core_nets.nets.keys())
+                netlist = list(self._pedb.nets.nets.keys())
                 _poly = self._pedb.get_conformal_polygon_from_netlist(netlist)
             else:
                 _poly = self._pedb.get_conformal_polygon_from_netlist()
             stat_model.occupying_surface = _poly.Area()
             outline_surface = (stat_model.layout_size[2] - stat_model.layout_size[0]) * (
                 stat_model.layout_size[3] - stat_model.layout_size[1]
             )
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/materials.py` & `pyaedt-0.6.70/pyaedt/edb_core/materials.py`

 * *Files 0% similar despite different names*

```diff
@@ -448,15 +448,15 @@
         ----------
         name : str
             Name of the new material.
         permittivity : float
             Permittivity of the new material.
         loss_tangent : float
             Loss tangent of the new material.
-        permeability: float
+        permeability : float
             Permeability of the new material.
 
         Returns
         -------
         :class:`pyaedt.edb_core.materials.Material`
         """
         if not name in self.materials:
@@ -762,15 +762,15 @@
             The float value of the property.
 
 
         Examples
         --------
         >>> from pyaedt import Edb
         >>> edb_app = Edb()
-        >>> returned_tuple = edb_app.core_stackup.get_property_by_material_name("conductivity", "copper")
+        >>> returned_tuple = edb_app.materials.get_property_by_material_name("conductivity", "copper")
         >>> edb_value = returned_tuple[0]
         >>> float_value = returned_tuple[1]
 
         """
         if self._edb.Definition.MaterialDef.FindByName(self._pedb._db, material_name).IsNull():
             self._pedb.logger.error("This material doesn't exists.")
         else:
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/nets.py` & `pyaedt-0.6.70/pyaedt/edb_core/nets.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,33 +1,53 @@
 from __future__ import absolute_import  # noreorder
 
 import math
 import os
 import time
+import warnings
 
 from pyaedt.edb_core.edb_data.nets_data import EDBNetsData
 from pyaedt.edb_core.edb_data.padstacks_data import EDBPadstackInstance
+from pyaedt.edb_core.edb_data.primitives_data import EDBPrimitives
 from pyaedt.edb_core.general import convert_py_list_to_net_list
 from pyaedt.generic.constants import CSS4_COLORS
 from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import is_ironpython
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.modeler.geometry_operators import GeometryOperators
 
 
 class EdbNets(object):
-    """Manages EDB methods for nets management accessible from `Edb.core_nets` property.
+    """Manages EDB methods for nets management accessible from `Edb.nets` property.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edbapp = Edb("myaedbfolder", edbversion="2021.2")
-    >>> edb_nets = edbapp.core_nets
+    >>> edb_nets = edbapp.nets
     """
 
+    @pyaedt_function_handler()
+    def __getitem__(self, name):
+        """Get  a net from the Edb project.
+
+        Parameters
+        ----------
+        name : str, int
+
+        Returns
+        -------
+        :class:` :class:`pyaedt.edb_core.edb_data.nets_data.EDBNetsData`
+
+        """
+        if name in self.nets:
+            return self.nets[name]
+        self._pedb.logger.error("Component or definition not found.")
+        return
+
     def __init__(self, p_edb):
         self._pedb = p_edb
 
     @property
     def _builder(self):
         """ """
         return self._pedb.builder
@@ -68,44 +88,85 @@
         """
         nets = {}
         for net in self._active_layout.Nets:
             nets[net.GetName()] = EDBNetsData(net, self._pedb)
         return nets
 
     @property
+    def netlist(self):
+        """Return the cell netlist.
+
+        Returns
+        -------
+        list
+            Net names.
+        """
+        return list(self.nets.keys())
+
+    @property
     def signal_nets(self):
         """Signal nets.
 
+        .. deprecated:: 0.6.62
+           Use :func:`signal` instead.
+
+        Returns
+        -------
+        dict[str, :class:`pyaedt.edb_core.edb_data.EDBNetsData`]
+            Dictionary of signal nets.
+        """
+        warnings.warn("Use :func:`signal` instead.", DeprecationWarning)
+        return self.signal
+
+    @property
+    def power_nets(self):
+        """Power nets.
+
+        .. deprecated:: 0.6.62
+           Use :func:`power` instead.
+
+        Returns
+        -------
+        dict[str, :class:`pyaedt.edb_core.edb_data.EDBNetsData`]
+            Dictionary of power nets.
+        """
+        warnings.warn("Use :func:`power` instead.", DeprecationWarning)
+        return self.power
+
+    @property
+    def signal(self):
+        """Signal nets.
+
         Returns
         -------
         dict[str, :class:`pyaedt.edb_core.edb_data.EDBNetsData`]
             Dictionary of signal nets.
         """
         nets = {}
         for net, value in self.nets.items():
             if not value.IsPowerGround():
                 nets[net] = value
         return nets
 
     @property
-    def power_nets(self):
+    def power(self):
         """Power nets.
 
         Returns
         -------
         dict[str, :class:`pyaedt.edb_core.edb_data.EDBNetsData`]
             Dictionary of power nets.
         """
         nets = {}
         for net, value in self.nets.items():
             if value.IsPowerGround():
                 nets[net] = value
         return nets
 
-    @property
+    @pyaedt_function_handler()
     def eligible_power_nets(self, threshold=0.3):
         """Return a list of nets calculated by area to be eligible for PWR/Ground net classification.
             It uses the same algorithm implemented in SIwave.
 
         Parameters
         ----------
         threshold : float, optional
@@ -302,15 +363,15 @@
             codes.append(79)
             objects_lists.append([vertices, codes, "b", "Outline", 1.0, 1.5, "contour"])
             n_label += 1
         top_layer = list(self._pedb.stackup.signal_layers.keys())[0]
         bottom_layer = list(self._pedb.stackup.signal_layers.keys())[-1]
         if plot_components_on_top or plot_components_on_bottom:
             nc = 0
-            for comp in self._pedb.core_components.components.values():
+            for comp in self._pedb.components.components.values():
                 if not comp.is_enabled:
                     continue
                 net_names = comp.nets
                 if nets and not any([i in nets for i in net_names]):
                     continue
                 layer_name = comp.placement_layer
                 if layer_name not in layers:
@@ -336,15 +397,15 @@
                     objects_lists.append([vertices, codes, label_colors[label], label, 1.0, 2.0, "contour"])
                     n_label += 1
                 else:
                     objects_lists.append([vertices, codes, label_colors[label], None, 1.0, 2.0, "contour"])
                 nc += 1
             self._logger.debug("Plotted {} component(s)".format(nc))
 
-        for path in self._pedb.core_primitives.paths:
+        for path in self._pedb.modeler.paths:
             if path.is_void:
                 continue
             net_name = path.net_name
             layer_name = path.layer_name
             if nets and (net_name not in nets or layer_name not in layers):
                 continue
             try:
@@ -382,15 +443,15 @@
 
             if create_label and n_label <= max_labels:
                 objects_lists.append([x, y, label_colors[label], label, 0.4, "fill"])
                 n_label += 1
             else:
                 objects_lists.append([x, y, label_colors[label], None, 0.4, "fill"])
 
-        for poly in self._pedb.core_primitives.polygons:
+        for poly in self._pedb.modeler.polygons:
             if poly.is_void:
                 continue
             net_name = poly.net_name
             layer_name = poly.layer_name
             if nets and (net_name != "" and net_name not in nets or layer_name not in layers):
                 continue
             xt, yt = poly.points()
@@ -450,15 +511,15 @@
                 n_label += 1
             else:
                 if layer_name == "Outline":
                     objects_lists.append([vertices, codes, label_colors[label], None, 1.0, 2.0, "contour"])
                 else:
                     objects_lists.append([vertices, codes, label_colors[label], None, 0.4, "path"])
 
-        for circle in self._pedb.core_primitives.circles:
+        for circle in self._pedb.modeler.circles:
             if circle.is_void:
                 continue
             net_name = circle.net_name
             layer_name = circle.layer_name
             if nets and (net_name not in nets or layer_name not in layers):
                 continue
             x, y = circle.points()
@@ -493,15 +554,15 @@
 
             if create_label and n_label <= max_labels:
                 objects_lists.append([x, y, label_colors[label], label, 0.4, "fill"])
                 n_label += 1
             else:
                 objects_lists.append([x, y, label_colors[label], None, 0.4, "fill"])
 
-        for rect in self._pedb.core_primitives.rectangles:
+        for rect in self._pedb.modeler.rectangles:
             if rect.is_void:
                 continue
             net_name = rect.net_name
             layer_name = rect.layer_name
             if nets and (net_name not in nets or layer_name not in layers):
                 continue
             x, y = rect.points()
@@ -664,16 +725,16 @@
         power_nets_names = list(self.power_nets.keys())
         for netname in netname_list:
             if netname in power_nets_names:
                 return True
         return False
 
     @pyaedt_function_handler()
-    def get_dcconnected_net_list(self, ground_nets=["GND"]):
-        """Retrieve the nets connected to DC through inductors.
+    def get_dcconnected_net_list(self, ground_nets=["GND"], res_value=0.001):
+        """Get the nets connected to the direct current through inductors.
 
         .. note::
            Only inductors are considered.
 
         Parameters
         ----------
         ground_nets : list, optional
@@ -681,24 +742,32 @@
 
         Returns
         -------
         list
             List of nets connected to DC through inductors.
         """
         temp_list = []
-        for refdes, comp_obj in self._pedb.core_components.inductors.items():
+        for _, comp_obj in self._pedb.components.inductors.items():
             numpins = comp_obj.numpins
 
             if numpins == 2:
                 nets = comp_obj.nets
                 if not set(nets).intersection(set(ground_nets)):
                     temp_list.append(set(nets))
                 else:
                     pass
+        for _, comp_obj in self._pedb.components.resistors.items():
+            numpins = comp_obj.numpins
 
+            if numpins == 2 and self._pedb._decompose_variable_value(comp_obj.res_value) <= res_value:
+                nets = comp_obj.nets
+                if not set(nets).intersection(set(ground_nets)):
+                    temp_list.append(set(nets))
+                else:
+                    pass
         dcconnected_net_list = []
 
         while not not temp_list:
             s = temp_list.pop(0)
             interseciton_flag = False
             for i in temp_list:
                 if not not s.intersection(i):
@@ -733,35 +802,35 @@
                 net_group.extend(ng)
                 break
 
         if not flag_in_ng:
             net_group.append(power_net_name)
 
         component_list = []
-        rats = self._pedb.core_components.get_rats()
+        rats = self._pedb.components.get_rats()
         for net in net_group:
             for el in rats:
                 if net in el["net_name"]:
                     i = 0
                     for n in el["net_name"]:
                         if n == net:
                             df = [el["refdes"][i], el["pin_name"][i], net]
                             component_list.append(df)
                         i += 1
 
         component_type = []
         for el in component_list:
             refdes = el[0]
-            comp_type = self._pedb.core_components._cmp[refdes].type
+            comp_type = self._pedb.components._cmp[refdes].type
             component_type.append(comp_type)
             el.append(comp_type)
 
-            comp_partname = self._pedb.core_components._cmp[refdes].partname
+            comp_partname = self._pedb.components._cmp[refdes].partname
             el.append(comp_partname)
-            pins = self._pedb.core_components.get_pin_from_component(component=refdes, netName=el[2])
+            pins = self._pedb.components.get_pin_from_component(component=refdes, netName=el[2])
             el.append("-".join([i.GetName() for i in pins]))
 
         component_list_columns = [
             "refdes",
             "pin_name",
             "net_name",
             "component_type",
@@ -777,38 +846,63 @@
         if edb_net is not None:
             return edb_net
 
     @pyaedt_function_handler()
     def delete_nets(self, netlist):
         """Delete one or more nets from EDB.
 
+        .. deprecated:: 0.6.62
+           Use :func:`delete` method instead.
+
         Parameters
         ----------
         netlist : str or list
             One or more nets to delete.
 
         Returns
         -------
         list
             List of nets that were deleted.
 
         Examples
         --------
 
-        >>> deleted_nets = edb_core.core_nets.delete_nets(["Net1","Net2"])
+        >>> deleted_nets = edb_core.nets.delete(["Net1","Net2"])
+        """
+        warnings.warn("Use :func:`delete` method instead.", DeprecationWarning)
+        return self.delete(netlist=netlist)
+
+    @pyaedt_function_handler()
+    def delete(self, netlist):
+        """Delete one or more nets from EDB.
+
+        Parameters
+        ----------
+        netlist : str or list
+            One or more nets to delete.
+
+        Returns
+        -------
+        list
+            List of nets that were deleted.
+
+        Examples
+        --------
+
+        >>> deleted_nets = edb_core.nets.delete(["Net1","Net2"])
         """
         if isinstance(netlist, str):
             netlist = [netlist]
 
-        self._pedb.core_primitives.delete_primitives(netlist)
-        self._pedb.core_padstack.delete_padstack_instances(netlist)
+        self._pedb.modeler.delete_primitives(netlist)
+        self._pedb.padstacks.delete_padstack_instances(netlist)
 
         nets_deleted = []
 
-        for i in self._pedb.core_nets.nets.values():
+        for i in self._pedb.nets.nets.values():
             if i.name in netlist:
                 i.net_object.Delete()
                 nets_deleted.append(i.name)
         return nets_deleted
 
     @pyaedt_function_handler()
     def find_or_create_net(self, net_name="", start_with="", contain="", end_with=""):
@@ -898,59 +992,63 @@
 
         Returns
         -------
         bool
             ``True`` if the net is found in component pins.
 
         """
-        if component_name not in self._pedb.core_components.components:
+        if component_name not in self._pedb.components.components:
             return False
-        for net in self._pedb.core_components.components[component_name].nets:
+        for net in self._pedb.components.components[component_name].nets:
             if net_name == net:
                 return True
         return False
 
     @pyaedt_function_handler()
-    def find_and_fix_disjoint_nets(self, net_list=None, keep_only_main_net=False, clean_disjoints_less_than=0.0):
+    def find_and_fix_disjoint_nets(
+        self, net_list=None, keep_only_main_net=False, clean_disjoints_less_than=0.0, order_by_area=False
+    ):
         """Find and fix disjoint nets from a given netlist.
 
         Parameters
         ----------
         net_list : str, list, optional
             List of nets on which check disjoints. If `None` is provided then the algorithm will loop on all nets.
         keep_only_main_net : bool, optional
             Remove all secondary nets other than principal one (the one with more objects in it). Default is `False`.
         clean_disjoints_less_than : bool, optional
             Clean all disjoint nets with area less than specified area in square meters. Default is `0.0` to disable it.
-
+        order_by_area : bool, optional
+            Whether if the naming order has to be by number of objects (fastest) or area (slowest but more accurate).
+            Default is ``False``.
         Returns
         -------
         List
             New nets created.
 
         Examples
         --------
 
-        >>> renamed_nets = edb_core.core_nets.find_and_fix_disjoint_nets(["GND","Net2"])
+        >>> renamed_nets = edb_core.nets.find_and_fix_disjoint_nets(["GND","Net2"])
         """
         timer_start = self._logger.reset_timer()
 
         if not net_list:
             net_list = list(self.nets.keys())
         elif isinstance(net_list, str):
             net_list = [net_list]
         _objects_list = {}
         _padstacks_list = {}
-        for prim in self._pedb.core_primitives.primitives:
+        for prim in self._pedb.modeler.primitives:
             n_name = prim.net_name
             if n_name in _objects_list:
                 _objects_list[n_name].append(prim)
             else:
                 _objects_list[n_name] = [prim]
-        for pad in list(self._pedb.core_padstack.instances.values()):
+        for pad in list(self._pedb.padstacks.instances.values()):
             n_name = pad.net_name
             if n_name in _padstacks_list:
                 _padstacks_list[n_name].append(pad)
             else:
                 _padstacks_list[n_name] = [pad]
         new_nets = []
         disjoints_objects = []
@@ -963,19 +1061,41 @@
             for i in _padstacks_list.get(net, []):
                 obj_dict[i.id] = i
             objs = list(obj_dict.values())
             l = len(objs)
             while l > 0:
                 l1 = objs[0].get_connected_object_id_set()
                 l1.append(objs[0].id)
-                net_groups.append(l1)
+                repetition = False
+                for net_list in net_groups:
+                    if set(l1).intersection(net_list):
+                        net_groups.append([i for i in l1 if i not in net_list])
+                        repetition = True
+                if not repetition:
+                    net_groups.append(l1)
                 objs = [i for i in objs if i.id not in l1]
                 l = len(objs)
             if len(net_groups) > 1:
-                sorted_list = sorted(net_groups, key=len, reverse=True)
+
+                def area_calc(elem):
+                    sum = 0
+                    for el in elem:
+                        try:
+                            if isinstance(obj_dict[el], EDBPrimitives):
+                                if not obj_dict[el].is_void:
+                                    sum += obj_dict[el].area()
+                        except:
+                            pass
+                    return sum
+
+                if order_by_area:
+                    areas = [area_calc(i) for i in net_groups]
+                    sorted_list = [x for _, x in sorted(zip(areas, net_groups), reverse=True)]
+                else:
+                    sorted_list = sorted(net_groups, key=len, reverse=True)
                 for disjoints in sorted_list[1:]:
                     if keep_only_main_net:
                         for geo in disjoints:
                             try:
                                 obj_dict[geo].delete()
                             except KeyError:
                                 pass
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/padstack.py` & `pyaedt-0.6.70/pyaedt/edb_core/padstack.py`

 * *Files 17% similar despite different names*

```diff
@@ -9,23 +9,47 @@
 from pyaedt.edb_core.general import convert_py_list_to_net_list
 from pyaedt.generic.clr_module import Array
 from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import pyaedt_function_handler
 
 
 class EdbPadstacks(object):
-    """Manages EDB methods for nets management accessible from `Edb.core_padstack` property.
+    """Manages EDB methods for nets management accessible from `Edb.padstacks` property.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edbapp = Edb("myaedbfolder", edbversion="2021.2")
-    >>> edb_padstacks = edbapp.core_padstack
+    >>> edb_padstacks = edbapp.padstacks
     """
 
+    @pyaedt_function_handler()
+    def __getitem__(self, name):
+        """Get  a padstack definition or instance from the Edb project.
+
+        Parameters
+        ----------
+        name : str, int
+
+        Returns
+        -------
+        :class:`pyaedt.edb_core.edb_data.components_data.EDBComponent`
+
+        """
+        if name in self.instances:
+            return self.instances[name]
+        elif name in self.definitions:
+            return self.definitions[name]
+        else:
+            for i in list(self.instances.values()):
+                if i.name == name or i.aedt_name == name:
+                    return i
+        self._pedb.logger.error("Component or definition not found.")
+        return
+
     def __init__(self, p_edb):
         self._pedb = p_edb
 
     @property
     def _builder(self):
         """ """
         return self._pedb.builder
@@ -158,15 +182,15 @@
 
         """
         warnings.warn("Use `definitions` property instead.", DeprecationWarning)
         return self.definitions
 
     @property
     def instances(self):
-        """List of all padstack instances.
+        """Dictionary  of all padstack instances (vias and pins).
 
         Returns
         -------
         dict[str, :class:`pyaedt.edb_core.edb_data.padstacks_data.EDBPadstackInstance`]
             List of padstack instances.
 
         """
@@ -174,14 +198,54 @@
         padstack_instances = {}
         edb_padstack_inst_list = list(self._active_layout.PadstackInstances)
         for edb_padstack_instance in edb_padstack_inst_list:
             padstack_instances[edb_padstack_instance.GetId()] = EDBPadstackInstance(edb_padstack_instance, self._pedb)
         return padstack_instances
 
     @property
+    def pins(self):
+        """Dictionary  of all pins instances (belonging to component).
+
+        Returns
+        -------
+        dic[str, :class:`pyaedt.edb_core.edb_data.definitions.EDBPadstackInstance`]
+            Dictionary of EDBPadstackInstance Components.
+
+
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> pin_net_name = edbapp.pins[424968329].netname
+        """
+        pins = {}
+        for instancename, instance in self.instances.items():
+            if instance.is_pin and instance.component:
+                pins[instancename] = instance
+        return pins
+
+    @property
+    def vias(self):
+        """Dictionary  of all vias instances not belonging to component.
+
+        Returns
+        -------
+        dic[str, :class:`pyaedt.edb_core.edb_data.definitions.EDBPadstackInstance`]
+            Dictionary of EDBPadstackInstance Components.
+
+
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> pin_net_name = edbapp.pins[424968329].netname
+        """
+        pnames = list(self.pins.keys())
+        vias = {i: j for i, j in self.instances.items() if i not in pnames}
+        return vias
+
+    @property
     def padstack_instances(self):
         """List of padstack instances.
 
         .. deprecated:: 0.6.58
         Use :func:`instances` property instead.
 
         Returns
@@ -337,15 +401,15 @@
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> Edb.core_padstack.delete_padstack_instances(net_names=["GND"])
+        >>> Edb.padstacks.delete_padstack_instances(net_names=["GND"])
         """
         if not isinstance(net_names, list):  # pragma: no cover
             net_names = [net_names]
 
         for p_id, p in self.instances.items():
             if p.net_name in net_names:
                 if not p.delete():  # pragma: no cover
@@ -461,21 +525,21 @@
         dict
             Dictionary of pins if the operation is successful.
             ``False`` is returned if the net does not belong to the component.
 
         """
         pinlist = []
         if refdes:
-            if refdes in self._pedb.core_components.components:
+            if refdes in self._pedb.components.components:
                 if netname:
-                    for pin, val in self._pedb.core_components.components[refdes].pins.items():
+                    for pin, val in self._pedb.components.components[refdes].pins.items():
                         if val.net_name == netname:
                             pinlist.append(val)
                 else:
-                    for pin in self._pedb.core_components.components[refdes].pins.values():
+                    for pin in self._pedb.components.components[refdes].pins.values():
                         pinlist.append(pin)
             elif netname:
                 for pin in self._pedb.pins:
                     if pin.net_name == netname:
                         pinlist.append(pin)
             else:
                 self._logger.error("At least a component or a net name has to be provided")
@@ -636,14 +700,99 @@
         offset_x="0.0",
         offset_y="0.0",
         rotation="0.0",
         has_hole=True,
         pad_offset_x="0.0",
         pad_offset_y="0.0",
         pad_rotation="0.0",
+    ):  # pragma: no cover
+        """Create a padstack.
+
+        .. deprecated:: 0.6.62
+        Use :func:`create` method instead.
+
+        Parameters
+        ----------
+        padstackname : str, optional
+            Name of the padstack. The default is ``None``.
+        holediam : str, optional
+            Diameter of the hole with units. The default is ``"300um"``.
+        paddiam : str, optional
+            Diameter of the pad with units. The default is ``"400um"``.
+        antipaddiam : str, optional
+            Diameter of the antipad with units. The default is ``"600um"``.
+        startlayer : str, optional
+            Starting layer. The default is ``None``, in which case the top
+            is the starting layer.
+        endlayer : str, optional
+            Ending layer. The default is ``None``, in which case the bottom
+            is the ending layer.
+        antipad_shape : str, optional
+            Shape of the antipad. The default is ``"Circle"``. Options are ``"Circle"`` and ``"Bullet"``.
+        x_size : str, optional
+            Only applicable to bullet shape. The default is ``"600um"``.
+        y_size : str, optional
+            Only applicable to bullet shape. The default is ``"600um"``.
+        corner_radius :
+            Only applicable to bullet shape. The default is ``"300um"``.
+        offset_x : str, optional
+            X offset of antipad. The default is ``"0.0"``.
+        offset_y : str, optional
+            Y offset of antipad. The default is ``"0.0"``.
+        rotation : str, optional
+            rotation of antipad. The default is ``"0.0"``.
+        has_hole : bool, optional
+            Whether this padstack has a hole.
+        Returns
+        -------
+        str
+            Name of the padstack if the operation is successful.
+        """
+        warnings.warn("Use :func:`create` method instead.", DeprecationWarning)
+        return self.create(
+            padstackname=padstackname,
+            holediam=holediam,
+            paddiam=paddiam,
+            antipaddiam=antipaddiam,
+            startlayer=startlayer,
+            endlayer=endlayer,
+            antipad_shape=antipad_shape,
+            x_size=x_size,
+            y_size=y_size,
+            corner_radius=corner_radius,
+            offset_x=offset_x,
+            offset_y=offset_y,
+            rotation=rotation,
+            has_hole=has_hole,
+            pad_offset_x=pad_offset_x,
+            pad_offset_y=pad_offset_y,
+            pad_rotation=pad_rotation,
+        )
+
+    @pyaedt_function_handler()
+    def create(
+        self,
+        padstackname=None,
+        holediam="300um",
+        paddiam="400um",
+        antipaddiam="600um",
+        startlayer=None,
+        endlayer=None,
+        pad_shape="Circle",
+        antipad_shape="Circle",
+        x_size="600um",
+        y_size="600um",
+        corner_radius="300um",
+        offset_x="0.0",
+        offset_y="0.0",
+        rotation="0.0",
+        has_hole=True,
+        pad_offset_x="0.0",
+        pad_offset_y="0.0",
+        pad_rotation="0.0",
     ):
         """Create a padstack.
 
         Parameters
         ----------
         padstackname : str, optional
             Name of the padstack. The default is ``None``.
@@ -655,14 +804,16 @@
             Diameter of the antipad with units. The default is ``"600um"``.
         startlayer : str, optional
             Starting layer. The default is ``None``, in which case the top
             is the starting layer.
         endlayer : str, optional
             Ending layer. The default is ``None``, in which case the bottom
             is the ending layer.
+        pad_shape : str, optional
+            Shape of the pad. The default is ``"Circle``. Options are ``"Circle"`` and ``"Rectangle"``.
         antipad_shape : str, optional
             Shape of the antipad. The default is ``"Circle"``. Options are ``"Circle"`` and ``"Bullet"``.
         x_size : str, optional
             Only applicable to bullet shape. The default is ``"600um"``.
         y_size : str, optional
             Only applicable to bullet shape. The default is ``"600um"``.
         corner_radius :
@@ -671,14 +822,21 @@
             X offset of antipad. The default is ``"0.0"``.
         offset_y : str, optional
             Y offset of antipad. The default is ``"0.0"``.
         rotation : str, optional
             rotation of antipad. The default is ``"0.0"``.
         has_hole : bool, optional
             Whether this padstack has a hole.
+        pad_offset_x : str, optional
+            Padstack offset in X direction.
+        pad_offset_y : str, optional
+            Padstack offset in Y direction.
+        pad_rotation : str, optional
+            Padstack rotation.
+
         Returns
         -------
         str
             Name of the padstack if the operation is successful.
         """
         holediam = self._get_edb_value(holediam)
         paddiam = self._get_edb_value(paddiam)
@@ -711,29 +869,34 @@
         padstackData.SetHoleRange(self._edb.Definition.PadstackHoleRange.UpperPadToLowerPad)
         padstackData.SetMaterial("copper")
         layers = list(self._pedb.stackup.signal_layers.keys())
         if not startlayer:
             startlayer = layers[0]
         if not endlayer:
             endlayer = layers[len(layers) - 1]
-
+        if pad_shape == "Circle":
+            pad_array = Array[type(paddiam)]([paddiam])
+            pad_shape = self._edb.Definition.PadGeometryType.Circle
+        elif pad_shape == "Rectangle":
+            pad_array = Array[type(x_size)]([x_size, y_size])
+            pad_shape = self._edb.Definition.PadGeometryType.Rectangle
         if antipad_shape == "Bullet":
             antipad_array = Array[type(x_size)]([x_size, y_size, corner_radius])
             antipad_shape = self._edb.Definition.PadGeometryType.Bullet
         else:
             antipad_array = Array[type(antipaddiam)]([antipaddiam])
             antipad_shape = self._edb.Definition.PadGeometryType.Circle
 
         for layer in ["Default"] + layers:
-            padparam_array = Array[type(paddiam)]([paddiam])
+            # padparam_array = Array[type(paddiam)]([paddiam])
             padstackData.SetPadParameters(
                 layer,
                 self._edb.Definition.PadType.RegularPad,
-                self._edb.Definition.PadGeometryType.Circle,
-                padparam_array,
+                pad_shape,
+                pad_array,
                 pad_offset_x,
                 pad_offset_y,
                 pad_rotation,
             )
 
             padstackData.SetPadParameters(
                 layer,
@@ -765,14 +928,35 @@
         else:
             return False
 
     @pyaedt_function_handler()
     def duplicate_padstack(self, target_padstack_name, new_padstack_name=""):
         """Duplicate a padstack.
 
+        .. deprecated:: 0.6.62
+        Use :func:`duplicate` method instead.
+
+        Parameters
+        ----------
+        target_padstack_name : str
+            Name of the padstack to be duplicated.
+        new_padstack_name : str, optional
+            Name of the new padstack.
+        Returns
+        -------
+        str
+            Name of the new padstack.
+        """
+        warnings.warn("Use :func:`create` method instead.", DeprecationWarning)
+        return self.duplicate(target_padstack_name=target_padstack_name, new_padstack_name=new_padstack_name)
+
+    @pyaedt_function_handler()
+    def duplicate(self, target_padstack_name, new_padstack_name=""):
+        """Duplicate a padstack.
+
         Parameters
         ----------
         target_padstack_name : str
             Name of the padstack to be duplicated.
         new_padstack_name : str, optional
             Name of the new padstack.
         Returns
@@ -788,27 +972,27 @@
 
         padstack_definition = self._edb.Definition.PadstackDef.Create(self.db, new_padstack_name)
         padstack_definition.SetData(new_padstack_definition_data)
 
         return new_padstack_name
 
     @pyaedt_function_handler()
-    def place_padstack(
+    def place(
         self,
         position,
         definition_name,
         net_name="",
         via_name="",
         rotation=0.0,
         fromlayer=None,
         tolayer=None,
         solderlayer=None,
         is_pin=False,
     ):
-        """Place the padstack.
+        """Place a via.
 
         Parameters
         ----------
         position : list
             List of float values for the [x,y] positions where the via is to be placed.
         definition_name : str
             Name of the padstack definition.
@@ -821,25 +1005,27 @@
             is ``0``.
         fromlayer :
             The default is ``None``.
         tolayer :
             The default is ``None``.
         solderlayer :
             The default is ``None``.
+        is_pin : bool, optiona
+            Whether if the padstack is a pin or not. Default is `False`.
 
         Returns
         -------
-
+        :class:`pyaedt.edb_core.edb_data.padstacks_data.EDBPadstackInstance`
         """
         padstack = None
         for pad in list(self.definitions.keys()):
             if pad == definition_name:
                 padstack = self.definitions[pad].edb_padstack
         position = self._edb.Geometry.PointData(self._get_edb_value(position[0]), self._get_edb_value(position[1]))
-        net = self._pedb.core_nets.find_or_create_net(net_name)
+        net = self._pedb.nets.find_or_create_net(net_name)
         rotation = self._get_edb_value(rotation * math.pi / 180)
         sign_layers_values = {i: v for i, v in self._pedb.stackup.signal_layers.items()}
         sign_layers = list(sign_layers_values.keys())
         if not fromlayer:
             fromlayer = sign_layers_values[sign_layers[0]]._edb_layer
         else:
             fromlayer = sign_layers_values[fromlayer]._edb_layer
@@ -867,14 +1053,69 @@
             py_padstack_instance = EDBPadstackInstance(padstack_instance, self._pedb)
 
             return py_padstack_instance
         else:
             return False
 
     @pyaedt_function_handler()
+    def place_padstack(
+        self,
+        position,
+        definition_name,
+        net_name="",
+        via_name="",
+        rotation=0.0,
+        fromlayer=None,
+        tolayer=None,
+        solderlayer=None,
+        is_pin=False,
+    ):
+        """Place the padstack.
+
+        .. deprecated:: 0.6.62
+        Use :func:`place` method instead.
+
+        Parameters
+        ----------
+        position : list
+            List of float values for the [x,y] positions where the via is to be placed.
+        definition_name : str
+            Name of the padstack definition.
+        net_name : str, optional
+            Name of the net. The default is ``""``.
+        via_name : str, optional
+            The default is ``""``.
+        rotation : float, optional
+            Rotation of the padstack in degrees. The default
+            is ``0``.
+        fromlayer :
+            The default is ``None``.
+        tolayer :
+            The default is ``None``.
+        solderlayer :
+            The default is ``None``.
+
+        Returns
+        -------
+
+        """
+        warnings.warn(" Use :func:`place` method instead.", DeprecationWarning)
+        return self.place(
+            position=position,
+            definition_name=definition_name,
+            net_name=net_name,
+            via_name=via_name,
+            rotation=rotation,
+            fromlayer=fromlayer,
+            tolayer=tolayer,
+            solderlayer=solderlayer,
+            is_pin=is_pin,
+        )
+
+    @pyaedt_function_handler()
     def remove_pads_from_padstack(self, padstack_name, layer_name=None):
         """Remove the Pad from a padstack on a specific layer by setting it as a 0 thickness circle.
 
         Parameters
         ----------
         padstack_name : str
             padstack name
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/siwave.py` & `pyaedt-0.6.70/pyaedt/edb_core/siwave.py`

 * *Files 4% similar despite different names*

```diff
@@ -21,26 +21,26 @@
 from pyaedt.generic.general_methods import _retry_ntimes
 from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.modeler.geometry_operators import GeometryOperators
 
 
 class EdbSiwave(object):
-    """Manages EDB methods related to Siwave Setup accessible from `Edb.core_siwave` property.
+    """Manages EDB methods related to Siwave Setup accessible from `Edb.siwave` property.
 
     Parameters
     ----------
     edb_class : :class:`pyaedt.edb.Edb`
         Inherited parent object.
 
     Examples
     --------
     >>> from pyaedt import Edb
     >>> edbapp = Edb("myaedbfolder", edbversion="2021.2")
-    >>> edb_siwave = edbapp.core_siwave
+    >>> edb_siwave = edbapp.siwave
     """
 
     def __init__(self, p_edb):
         self._pedb = p_edb
 
     @property
     def _builder(self):
@@ -214,16 +214,16 @@
         impedance : float
             Port Impedance
         port_name : str, optional
             Port Name
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> pins = edbapp.core_components.get_pin_from_component("U2A5")
-        >>> edbapp.core_siwave.create_circuit_port_on_pin(pins[0], pins[1], 50, "port_name")
+        >>> pins = edbapp.components.get_pin_from_component("U2A5")
+        >>> edbapp.siwave.create_circuit_port_on_pin(pins[0], pins[1], 50, "port_name")
 
         Returns
         -------
         str
             Port Name.
 
         """
@@ -273,50 +273,50 @@
         if not pins_name:
             pins_name = []
         if pins_name:
             if not isinstance(pins_name, list):  # pragma no cover
                 pins_name = [pins_name]
             if not reference_net:
                 self._logger.info("no reference net provided, searching net {} instead.".format(layer_name))
-                reference_net = self._pedb.core_nets.get_net_by_name(layer_name)
+                reference_net = self._pedb.nets.get_net_by_name(layer_name)
                 if not reference_net:  # pragma no cover
                     self._logger.error("reference net {} not found.".format(layer_name))
                     return False
             else:
                 if not isinstance(reference_net, self._edb.Cell.Net):  # pragma no cover
-                    reference_net = self._pedb.core_nets.get_net_by_name(reference_net)
+                    reference_net = self._pedb.nets.get_net_by_name(reference_net)
                 if not reference_net:
                     self._logger.error("Net {} not found".format(reference_net))
                     return False
             for pin_name in pins_name:  # pragma no cover
                 pin = [
                     pin
-                    for pin in self._pedb.core_padstack.get_pinlist_from_component_and_net(component_name)
+                    for pin in self._pedb.padstacks.get_pinlist_from_component_and_net(component_name)
                     if pin.GetName() == pin_name
                 ][0]
                 term_name = "{}_{}_{}".format(pin.GetComponent().GetName(), pin.GetNet().GetName(), pin.GetName())
                 res, start_layer, stop_layer = pin.GetLayerRange()
                 if res:
                     pin_instance = pin._edb_padstackinstance
                     positive_terminal = self._edb.Cell.Terminal.PadstackInstanceTerminal.Create(
                         self._active_layout, pin_instance.GetNet(), term_name, pin_instance, start_layer
                     )
                     positive_terminal.SetBoundaryType(self._edb.Cell.Terminal.BoundaryType.PortBoundary)
                     positive_terminal.SetImpedance(self._edb.Utility.Value(impedance))
                     positive_terminal.SetIsCircuitPort(True)
-                    pos = self._pedb.core_components.get_pin_position(pin_instance)
+                    pos = self._pedb.components.get_pin_position(pin_instance)
                     position = self._edb.Geometry.PointData(
                         self._edb.Utility.Value(pos[0]), self._edb.Utility.Value(pos[1])
                     )
                     negative_terminal = self._edb.Cell.Terminal.PointTerminal.Create(
                         self._active_layout,
                         reference_net,
                         "{}_ref".format(term_name),
                         position,
-                        self._pedb.core_stackup.signal_layers[layer_name]._layer,
+                        self._pedb.stackup.signal_layers[layer_name]._edb_layer,
                     )
                     negative_terminal.SetBoundaryType(self._edb.Cell.Terminal.BoundaryType.PortBoundary)
                     negative_terminal.SetImpedance(self._edb.Utility.Value(impedance))
                     negative_terminal.SetIsCircuitPort(True)
                     if positive_terminal.SetReferenceTerminal(negative_terminal):
                         self._logger.info("Port {} successfully created".format(term_name))
                         return positive_terminal
@@ -345,16 +345,16 @@
             Source Name.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> pins = edbapp.core_components.get_pin_from_component("U2A5")
-        >>> edbapp.core_siwave.create_voltage_source_on_pin(pins[0], pins[1], 50, "source_name")
+        >>> pins = edbapp.components.get_pin_from_component("U2A5")
+        >>> edbapp.siwave.create_voltage_source_on_pin(pins[0], pins[1], 50, "source_name")
         """
 
         voltage_source = VoltageSource()
         voltage_source.positive_node.net = pos_pin.GetNet().GetName()
         voltage_source.negative_node.net = neg_pin.GetNet().GetName()
         voltage_source.magnitude = voltage_value
         voltage_source.phase = phase_value
@@ -395,16 +395,16 @@
             Source Name.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> pins = edbapp.core_components.get_pin_from_component("U2A5")
-        >>> edbapp.core_siwave.create_current_source_on_pin(pins[0], pins[1], 50, "source_name")
+        >>> pins = edbapp.components.get_pin_from_component("U2A5")
+        >>> edbapp.siwave.create_current_source_on_pin(pins[0], pins[1], 50, "source_name")
         """
         current_source = CurrentSource()
         current_source.positive_node.net = pos_pin.GetNet().GetName()
         current_source.negative_node.net = neg_pin.GetNet().GetName()
         current_source.magnitude = current_value
         current_source.phase = phase_value
         if not source_name:
@@ -442,16 +442,16 @@
             Name of the resistor.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> pins =edbapp.core_components.get_pin_from_component("U2A5")
-        >>> edbapp.core_siwave.create_resistor_on_pin(pins[0], pins[1],50,"res_name")
+        >>> pins =edbapp.components.get_pin_from_component("U2A5")
+        >>> edbapp.siwave.create_resistor_on_pin(pins[0], pins[1],50,"res_name")
         """
         resistor = ResistorSource()
         resistor.positive_node.net = pos_pin.GetNet().GetName()
         resistor.negative_node.net = neg_pin.GetNet().GetName()
         resistor.rvalue = rvalue
         if not resistor_name:
             resistor_name = "Res_{}_{}_{}_{}".format(
@@ -466,21 +466,21 @@
         resistor.negative_node.component_node = neg_pin.GetComponent()
         resistor.negative_node.node_pins = neg_pin
         return self._create_terminal_on_pins(resistor)
 
     @pyaedt_function_handler()
     def _check_gnd(self, component_name):
         negative_net_name = None
-        if self._pedb.core_nets.is_net_in_component(component_name, "GND"):
+        if self._pedb.nets.is_net_in_component(component_name, "GND"):
             negative_net_name = "GND"
-        elif self._pedb.core_nets.is_net_in_component(component_name, "PGND"):
+        elif self._pedb.nets.is_net_in_component(component_name, "PGND"):
             negative_net_name = "PGND"
-        elif self._pedb.core_nets.is_net_in_component(component_name, "AGND"):
+        elif self._pedb.nets.is_net_in_component(component_name, "AGND"):
             negative_net_name = "AGND"
-        elif self._pedb.core_nets.is_net_in_component(component_name, "DGND"):
+        elif self._pedb.nets.is_net_in_component(component_name, "DGND"):
             negative_net_name = "DGND"
         if not negative_net_name:
             raise ValueError("No GND, PGND, AGND, DGND found. Please setup the negative net name manually.")
         return negative_net_name
 
     @pyaedt_function_handler()
     def create_circuit_port_on_net(
@@ -518,28 +518,28 @@
             The name of the port.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edbapp.core_siwave.create_circuit_port_on_net("U2A5", "V1P5_S3", "U2A5", "GND", 50, "port_name")
+        >>> edbapp.siwave.create_circuit_port_on_net("U2A5", "V1P5_S3", "U2A5", "GND", 50, "port_name")
         """
         if not negative_component_name:
             negative_component_name = positive_component_name
         if not negative_net_name:
             negative_net_name = self._check_gnd(negative_component_name)
         circuit_port = CircuitPort()
         circuit_port.positive_node.net = positive_net_name
         circuit_port.negative_node.net = negative_net_name
         circuit_port.impedance = impedance_value
-        pos_node_cmp = self._pedb.core_components.get_component_by_name(positive_component_name)
-        neg_node_cmp = self._pedb.core_components.get_component_by_name(negative_component_name)
-        pos_node_pins = self._pedb.core_components.get_pin_from_component(positive_component_name, positive_net_name)
-        neg_node_pins = self._pedb.core_components.get_pin_from_component(negative_component_name, negative_net_name)
+        pos_node_cmp = self._pedb.components.get_component_by_name(positive_component_name)
+        neg_node_cmp = self._pedb.components.get_component_by_name(negative_component_name)
+        pos_node_pins = self._pedb.components.get_pin_from_component(positive_component_name, positive_net_name)
+        neg_node_pins = self._pedb.components.get_pin_from_component(negative_component_name, negative_net_name)
         if port_name == "":
             port_name = "Port_{}_{}_{}_{}".format(
                 positive_component_name,
                 positive_net_name,
                 negative_component_name,
                 negative_net_name,
             )
@@ -587,29 +587,29 @@
             The name of the source.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edb.core_siwave.create_voltage_source_on_net("U2A5","V1P5_S3","U2A5","GND",3.3,0,"source_name")
+        >>> edb.siwave.create_voltage_source_on_net("U2A5","V1P5_S3","U2A5","GND",3.3,0,"source_name")
         """
         if not negative_component_name:
             negative_component_name = positive_component_name
         if not negative_net_name:
             negative_net_name = self._check_gnd(negative_component_name)
         voltage_source = VoltageSource()
         voltage_source.positive_node.net = positive_net_name
         voltage_source.negative_node.net = negative_net_name
         voltage_source.magnitude = voltage_value
         voltage_source.phase = phase_value
-        pos_node_cmp = self._pedb.core_components.get_component_by_name(positive_component_name)
-        neg_node_cmp = self._pedb.core_components.get_component_by_name(negative_component_name)
-        pos_node_pins = self._pedb.core_components.get_pin_from_component(positive_component_name, positive_net_name)
-        neg_node_pins = self._pedb.core_components.get_pin_from_component(negative_component_name, negative_net_name)
+        pos_node_cmp = self._pedb.components.get_component_by_name(positive_component_name)
+        neg_node_cmp = self._pedb.components.get_component_by_name(negative_component_name)
+        pos_node_pins = self._pedb.components.get_pin_from_component(positive_component_name, positive_net_name)
+        neg_node_pins = self._pedb.components.get_pin_from_component(negative_component_name, negative_net_name)
 
         if source_name == "":
             source_name = "Vsource_{}_{}_{}_{}".format(
                 positive_component_name,
                 positive_net_name,
                 negative_component_name,
                 negative_net_name,
@@ -658,29 +658,29 @@
             The name of the source.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edb.core_siwave.create_current_source_on_net("U2A5", "V1P5_S3", "U2A5", "GND", 0.1, 0, "source_name")
+        >>> edb.siwave.create_current_source_on_net("U2A5", "V1P5_S3", "U2A5", "GND", 0.1, 0, "source_name")
         """
         if not negative_component_name:
             negative_component_name = positive_component_name
         if not negative_net_name:
             negative_net_name = self._check_gnd(negative_component_name)
         current_source = CurrentSource()
         current_source.positive_node.net = positive_net_name
         current_source.negative_node.net = negative_net_name
         current_source.magnitude = current_value
         current_source.phase = phase_value
-        pos_node_cmp = self._pedb.core_components.get_component_by_name(positive_component_name)
-        neg_node_cmp = self._pedb.core_components.get_component_by_name(negative_component_name)
-        pos_node_pins = self._pedb.core_components.get_pin_from_component(positive_component_name, positive_net_name)
-        neg_node_pins = self._pedb.core_components.get_pin_from_component(negative_component_name, negative_net_name)
+        pos_node_cmp = self._pedb.components.get_component_by_name(positive_component_name)
+        neg_node_cmp = self._pedb.components.get_component_by_name(negative_component_name)
+        pos_node_pins = self._pedb.components.get_pin_from_component(positive_component_name, positive_net_name)
+        neg_node_pins = self._pedb.components.get_pin_from_component(negative_component_name, negative_net_name)
 
         if source_name == "":
             source_name = "Port_{}_{}_{}_{}".format(
                 positive_component_name,
                 positive_net_name,
                 negative_component_name,
                 negative_net_name,
@@ -717,21 +717,21 @@
             The name of the source.
 
         Examples
         --------
 
         >>> from pyaedt import Edb
         >>> edbapp = Edb("myaedbfolder", "project name", "release version")
-        >>> edb.core_siwave.create_dc_terminal("U2A5", "V1P5_S3", "source_name")
+        >>> edb.siwave.create_dc_terminal("U2A5", "V1P5_S3", "source_name")
         """
 
         dc_source = DCTerminal()
         dc_source.positive_node.net = net_name
-        pos_node_cmp = self._pedb.core_components.get_component_by_name(component_name)
-        pos_node_pins = self._pedb.core_components.get_pin_from_component(component_name, net_name)
+        pos_node_cmp = self._pedb.components.get_component_by_name(component_name)
+        pos_node_pins = self._pedb.components.get_pin_from_component(component_name, net_name)
 
         if source_name == "":
             source_name = "DC_{}_{}".format(
                 component_name,
                 net_name,
             )
         dc_source.name = source_name
@@ -841,16 +841,16 @@
         :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveDCSimulationSetup`
             Setup object class.
 
         Examples
         --------
         >>> from pyaedt import Edb
         >>> edb = Edb("pathtoaedb", edbversion="2021.2")
-        >>> edb.core_siwave.add_siwave_ac_analysis()
-        >>> edb.core_siwave.add_siwave_dc_analysis2("my_setup")
+        >>> edb.siwave.add_siwave_ac_analysis()
+        >>> edb.siwave.add_siwave_dc_analysis2("my_setup")
 
         """
         setup = self._pedb.create_siwave_dc_setup(name)
         self.create_exec_file(add_dc=True)
         return setup
 
     @pyaedt_function_handler()
@@ -862,31 +862,31 @@
         source : VoltageSource, CircuitPort, CurrentSource, DCTerminal or ResistorSource
             Name of the source.
 
         """
         if source.name in [i.GetName() for i in list(self._active_layout.Terminals)]:
             source.name = generate_unique_name(source.name, n=3)
             self._logger.warning("Port already exists with same name. Renaming to {}".format(source.name))
-        pos_pin_group = self._pedb.core_components.create_pingroup_from_pins(source.positive_node.node_pins)
-        pos_node_net = self._pedb.core_nets.get_net_by_name(source.positive_node.net)
+        pos_pin_group = self._pedb.components.create_pingroup_from_pins(source.positive_node.node_pins)
+        pos_node_net = self._pedb.nets.get_net_by_name(source.positive_node.net)
 
         pos_pingroup_term_name = source.name
         pos_pingroup_terminal = _retry_ntimes(
             10,
             self._edb.Cell.Terminal.PinGroupTerminal.Create,
             self._active_layout,
             pos_node_net,
             pos_pingroup_term_name,
             pos_pin_group,
             False,
         )
         time.sleep(0.5)
         if source.negative_node.node_pins:
-            neg_pin_group = self._pedb.core_components.create_pingroup_from_pins(source.negative_node.node_pins)
-            neg_node_net = self._pedb.core_nets.get_net_by_name(source.negative_node.net)
+            neg_pin_group = self._pedb.components.create_pingroup_from_pins(source.negative_node.node_pins)
+            neg_node_net = self._pedb.nets.get_net_by_name(source.negative_node.net)
             neg_pingroup_term_name = source.name + "_N"
             neg_pingroup_terminal = _retry_ntimes(
                 20,
                 self._edb.Cell.Terminal.PinGroupTerminal.Create,
                 self._active_layout,
                 neg_node_net,
                 neg_pingroup_term_name,
@@ -1150,17 +1150,18 @@
 
         Returns
         -------
         class:`pyaedt.edb_core.components.Components`
             Created EDB component.
 
         """
-        return self._pedb.core_components.create_rlc_component(
+        return self._pedb.components.create(
             pins,
             component_name=component_name,
+            is_rlc=True,
             r_value=r_value,
             c_value=c_value,
             l_value=l_value,
             is_parallel=is_parallel,
         )  # pragma no cover
 
     @pyaedt_function_handler
@@ -1181,15 +1182,15 @@
         PinGroup
         """
         if not isinstance(pin_numbers, list):
             pin_numbers = [pin_numbers]
         pin_numbers = [str(p) for p in pin_numbers]
         if group_name is None:
             group_name = self._edb.Cell.Hierarchy.PinGroup.GetUniqueName(self._active_layout)
-        comp = self._pedb.core_components.components[reference_designator]
+        comp = self._pedb.components.components[reference_designator]
         pins = [pin.pin for name, pin in comp.pins.items() if name in pin_numbers]
         edb_pingroup = self._edb.Cell.Hierarchy.PinGroup.Create(
             self._active_layout, group_name, convert_py_list_to_net_list(pins)
         )
 
         if edb_pingroup.IsNull():  # pragma: no cover
             return False
@@ -1210,15 +1211,15 @@
         group_name : str, optional
             Name of the pin group. The default value is ``None``.
 
         Returns
         -------
         PinGroup
         """
-        pins = self._pedb.core_components.get_pin_from_component(reference_designator, net_name)
+        pins = self._pedb.components.get_pin_from_component(reference_designator, net_name)
         pin_names = [p.GetName() for p in pins]
         return self.create_pin_group(reference_designator, pin_names, group_name)
 
     @pyaedt_function_handler
     def create_current_source_on_pin_group(
         self, pos_pin_group_name, neg_pin_group_name, magnitude=1, phase=0, name=None
     ):
```

### Comparing `pyaedt-0.6.61/pyaedt/edb_core/stackup.py` & `pyaedt-0.6.70/pyaedt/edb_core/stackup.py`

 * *Files 13% similar despite different names*

```diff
@@ -8,15 +8,14 @@
 from collections import OrderedDict
 import json
 import logging
 import math
 import os.path
 import warnings
 
-from pyaedt.edb_core.edb_data.layer_data import EDBLayers
 from pyaedt.edb_core.edb_data.layer_data import LayerEdbClass
 from pyaedt.edb_core.general import convert_py_list_to_net_list
 from pyaedt.generic.general_methods import ET
 from pyaedt.generic.general_methods import is_ironpython
 from pyaedt.generic.general_methods import pyaedt_function_handler
 from pyaedt.misc.aedtlib_personalib_install import write_pretty_xml
 
@@ -29,15 +28,14 @@
         np = None
 
     try:
         import pandas as pd
     except ImportError:
         pd = None
 
-
 logger = logging.getLogger(__name__)
 
 
 class Stackup(object):
     """Manages EDB methods for stackup accessible from `Edb.stackup` property."""
 
     def __getitem__(self, item):
@@ -93,19 +91,59 @@
         elif int(val) == 14:
             return self.layer_types.UserLayer
         elif int(val) == 16:
             return self.layer_types.SIwaveHFSSSolverRegions
         elif int(val) == 17:
             return self.layer_types.PostprocessingLayer
         elif int(val) == 18:
+            return self.layer_types.OutlineLayer
+        elif int(val) == 16:
             return self.layer_types.LayerTypesCount
         elif int(val) == -1:
             return self.layer_types.UndefinedLayerType
 
     @pyaedt_function_handler()
+    def _layer_types_to_int(self, layer_type):
+        if not isinstance(layer_type, int):
+            if layer_type == self.layer_types.SignalLayer:
+                return 0
+            elif layer_type == self.layer_types.DielectricLayer:
+                return 1
+            elif layer_type == self.layer_types.ConductingLayer:
+                return 2
+            elif layer_type == self.layer_types.AirlinesLayer:
+                return 3
+            elif layer_type == self.layer_types.ErrorsLayer:
+                return 4
+            elif layer_type == self.layer_types.SymbolLayer:
+                return 5
+            elif layer_type == self.layer_types.MeasureLayer:
+                return 6
+            elif layer_type == self.layer_types.AssemblyLayer:
+                return 8
+            elif layer_type == self.layer_types.SilkscreenLayer:
+                return 9
+            elif layer_type == self.layer_types.SolderMaskLayer:
+                return 10
+            elif layer_type == self.layer_types.SolderPasteLayer:
+                return 11
+            elif layer_type == self.layer_types.GlueLayer:
+                return 12
+            elif layer_type == self.layer_types.WirebondLayer:
+                return 13
+            elif layer_type == self.layer_types.UserLayer:
+                return 14
+            elif layer_type == self.layer_types.SIwaveHFSSSolverRegions:
+                return 16
+            elif layer_type == self.layer_types.OutlineLayer:
+                return 18
+        elif isinstance(layer_type, int):
+            return
+
+    @pyaedt_function_handler()
     def create_symmetric_stackup(
         self,
         layer_count,
         inner_layer_thickness="17um",
         outer_layer_thickness="50um",
         dielectric_thickness="100um",
         dielectric_material="fr4_epoxy",
@@ -337,14 +375,30 @@
         _lays = OrderedDict()
         for name, obj in self.layers.items():
             if obj._edb_layer.GetLayerType() in layer_type:
                 _lays[name] = obj
         return _lays
 
     @property
+    def dielectric_layers(self):
+        """Dielectric layers.
+
+        Returns
+        -------
+        dict[str, :class:`pyaedt.edb_core.edb_data.layer_data.EDBLayer`]
+            Dictionary of dielectric layers.
+        """
+        layer_type = self._pedb.edb.Cell.LayerType.DielectricLayer
+        _lays = OrderedDict()
+        for name, obj in self.layers.items():
+            if obj._edb_layer.GetLayerType() == layer_type:
+                _lays[name] = obj
+        return _lays
+
+    @property
     def non_stackup_layers(self):
         """Retrieve the dictionary of signal layers.
 
         Returns
         -------
         Dict[str, :class:`pyaedt.edb_core.edb_data.layer_data.LayerEdbClass`]
         """
@@ -403,14 +457,16 @@
             _lc.AddLayerAbove(layer_clone, base_layer)
         elif operation == "add_on_top":
             _lc.AddLayerTop(layer_clone)
         elif operation == "add_on_bottom":
             _lc.AddLayerBottom(layer_clone)
         elif operation == "add_at_elevation":
             _lc.AddStackupLayerAtElevation(layer_clone)
+        elif operation == "non_stackup":
+            _lc.AddLayerBottom(layer_clone)
         result = self._pedb._active_layout.SetLayerCollection(_lc)
         self.refresh_layer_collection()
         return result
 
     @pyaedt_function_handler()
     def _create_stackup_layer(self, layer_name, thickness, layer_type="signal"):
         if layer_type == "signal":
@@ -464,14 +520,35 @@
             _layer_type = self._pedb.edb.Cell.LayerType.UndefinedLayerType
 
         result = self._pedb.edb.Cell.Layer(layer_name, _layer_type)
         self.refresh_layer_collection()
         return result
 
     @pyaedt_function_handler()
+    def add_outline_layer(self, outline_name="Outline"):
+        """Add an outline layer named ``"Outline"`` if it is not present.
+
+        Returns
+        -------
+        bool
+            "True" if successful, ``False`` if failed.
+        """
+        outlineLayer = self._pedb.edb.Cell.Layer.FindByName(self._pedb.active_layout.GetLayerCollection(), outline_name)
+        if outlineLayer.IsNull():
+            return self.add_layer(
+                outline_name,
+                layer_type="outline",
+                material="",
+                fillMaterial="",
+                thickness="",
+            )
+        else:
+            return False
+
+    @pyaedt_function_handler()
     def add_layer(
         self,
         layer_name,
         base_layer=None,
         method="add_on_top",
         layer_type="signal",
         material="copper",
@@ -581,15 +658,15 @@
                 new_layer_collection.AddLayerBottom(lyr)
 
         result = self._pedb._active_layout.SetLayerCollection(new_layer_collection)
         self.refresh_layer_collection()
         return result
 
     @pyaedt_function_handler
-    def export_stackup(self, fpath, file_format="xml", include_material_with_layer=False):
+    def export(self, fpath, file_format="xml", include_material_with_layer=False):
         """Export stackup definition to a CSV or JSON file.
 
         Parameters
         ----------
         fpath : str
             File path to csv or json file.
         file_format : str, optional
@@ -600,15 +677,15 @@
             when a JSON file is exported. The default is ``False``, which keeps the material definition
             section in the JSON file. If ``True``, the material definition is included inside the layer ones.
 
         Examples
         --------
         >>> from pyaedt import Edb
         >>> edb = Edb()
-        >>> edb.stackup.export_stackup("stackup.xml")
+        >>> edb.stackup.export("stackup.xml")
         """
         if len(fpath.split(".")) == 1:
             fpath = "{}.{}".format(fpath, file_format)
 
         if fpath.endswith(".csv"):
             return self._export_layer_stackup_to_csv_xlsx(fpath, file_format="csv")
         elif fpath.endswith(".xlsx"):
@@ -617,14 +694,43 @@
             return self._export_layer_stackup_to_json(fpath, include_material_with_layer)
         elif fpath.endswith(".xml"):
             return self._export_xml(fpath)
         else:
             self._logger.warning("Layer stackup format is not supported. Skipping import.")
             return False
 
+    @pyaedt_function_handler
+    def export_stackup(self, fpath, file_format="xml", include_material_with_layer=False):
+        """Export stackup definition to a CSV or JSON file.
+
+        .. deprecated:: 0.6.61
+           Use :func:`export` instead.
+
+        Parameters
+        ----------
+        fpath : str
+            File path to CSV or JSON file.
+        file_format : str, optional
+            Format of the file to export. The default is ``"csv"``. Options are ``"csv"``, ``"xlsx"``
+            and ``"json"``.
+        include_material_with_layer : bool, optional.
+            Whether to include the material definition inside layer objects. This parameter is only used
+            when a JSON file is exported. The default is ``False``, which keeps the material definition
+            section in the JSON file. If ``True``, the material definition is included inside the layer ones.
+
+        Examples
+        --------
+        >>> from pyaedt import Edb
+        >>> edb = Edb()
+        >>> edb.stackup.export_stackup("stackup.xml")
+        """
+
+        self._logger.warning("Method export_stackup is deprecated. Use .export.")
+        return self.export(fpath, file_format=file_format, include_material_with_layer=include_material_with_layer)
+
     @pyaedt_function_handler()
     def _export_layer_stackup_to_csv_xlsx(self, fpath=None, file_format=None):
         if not pd:
             self._pedb.logger.error("Pandas is needed. Please, install it first.")
             return False
         if is_ironpython:
             return
@@ -729,14 +835,34 @@
             self.refresh_layer_collection()
             return True
 
     @pyaedt_function_handler()
     def stackup_limits(self, only_metals=False):
         """Retrieve stackup limits.
 
+        .. deprecated:: 0.6.62
+           Use :func:`Edb.stackup.limits` function instead.
+
+        Parameters
+        ----------
+        only_metals : bool, optional
+            Whether to retrieve only metals. The default is ``False``.
+
+        Returns
+        -------
+        bool
+            ``True`` when successful, ``False`` when failed.
+        """
+        warnings.warn("`stackup_limits` is deprecated. Use `limits` property instead.", DeprecationWarning)
+        return self.limits(only_metals=only_metals)
+
+    @pyaedt_function_handler()
+    def limits(self, only_metals=False):
+        """Retrieve stackup limits.
+
         Parameters
         ----------
         only_metals : bool, optional
             Whether to retrieve only metals. The default is ``False``.
 
         Returns
         -------
@@ -827,15 +953,15 @@
                 new_lc.AddStackupLayerAtElevation(cloned_via_layer)
 
             layer_list = convert_py_list_to_net_list(non_stackup_layers)
             new_lc.AddLayers(layer_list)
             if not self._pedb.active_layout.SetLayerCollection(new_lc):
                 self._pedb.logger.error("Failed to Flip Stackup.")
                 return False
-            for pyaedt_cmp in list(self._pedb.core_components.components.values()):
+            for pyaedt_cmp in list(self._pedb.components.components.values()):
                 cmp = pyaedt_cmp.edbcomponent
                 cmp_type = cmp.GetComponentType()
                 cmp_prop = cmp.GetComponentProperty().Clone()
                 try:
                     if (
                         cmp_prop.GetSolderBallProperty().GetPlacement()
                         == self._pedb.Definition.SolderballPlacement.AbovePadstack
@@ -860,15 +986,15 @@
                         cmp_prop.SetDieProperty(die_prop)
                     else:
                         die_prop.SetOrientation(self._pedb.Definition.DieOrientation.ChipDown)
                         cmp_prop.SetDieProperty(die_prop)
                 cmp.SetComponentProperty(cmp_prop)
 
             lay_list = list(new_lc.Layers(self._pedb.edb.Cell.LayerTypeSet.SignalLayerSet))
-            for padstack in list(self._pedb.core_padstack.instances.values()):
+            for padstack in list(self._pedb.padstacks.instances.values()):
                 start_layer_id = [lay.GetLayerId() for lay in list(lay_list) if lay.GetName() == padstack.start_layer]
                 stop_layer_id = [lay.GetLayerId() for lay in list(lay_list) if lay.GetName() == padstack.stop_layer]
                 layer_map = padstack._edb_padstackinstance.GetLayerMap()
                 layer_map.SetMapping(stop_layer_id[0], start_layer_id[0])
                 padstack._edb_padstackinstance.SetLayerMap(layer_map)
             self.refresh_layer_collection()
             return True
@@ -888,22 +1014,22 @@
         bottom_layer = self.stackup_layers[layers_name[0]]
         top_layer = self.stackup_layers[layers_name[-1]]
         thickness = top_layer.lower_elevation + top_layer.thickness - bottom_layer.lower_elevation
         return thickness
 
     @pyaedt_function_handler()
     def _get_solder_height(self, layer_name):
-        for el, val in self._pedb.core_components.components.items():
+        for _, val in self._pedb.components.components.items():
             if val.solder_ball_height and val.placement_layer == layer_name:
                 return val.solder_ball_height
         return 0
 
     @pyaedt_function_handler()
     def _remove_solder_pec(self, layer_name):
-        for el, val in self._pedb.core_components.components.items():
+        for _, val in self._pedb.components.components.items():
             if val.solder_ball_height and val.placement_layer == layer_name:
                 comp_prop = val.component_property
                 port_property = comp_prop.GetPortProperty().Clone()
                 port_property.SetReferenceSizeAuto(False)
                 port_property.SetReferenceSize(self._edb_value(0.0), self._edb_value(0.0))
                 comp_prop.SetPortProperty(port_property)
                 val.edbcomponent.SetComponentProperty(comp_prop)
@@ -914,15 +1040,15 @@
         This method identifies the solder-ball height and adjust the dielectric thickness on top (or bottom) to fit
         the thickness in order to merge another layout.
 
         Returns
         -------
         bool
         """
-        for el, val in self._pedb.core_components.components.items():
+        for el, val in self._pedb.components.components.items():
             if val.solder_ball_height:
                 layer = val.placement_layer
                 if layer == list(self.stackup_layers.keys())[0]:
                     self.add_layer(
                         "Bottom_air",
                         base_layer=list(self.stackup_layers.keys())[-1],
                         method="insert_below",
@@ -980,18 +1106,18 @@
             ``True`` when succeed ``False`` if not.
 
         Examples
         --------
         >>> edb1 = Edb(edbpath=targetfile1,  edbversion="2021.2")
         >>> edb2 = Edb(edbpath=targetfile2, edbversion="2021.2")
 
-        >>> hosting_cmp = edb1.core_components.get_component_by_name("U100")
-        >>> mounted_cmp = edb2.core_components.get_component_by_name("BGA")
+        >>> hosting_cmp = edb1.components.get_component_by_name("U100")
+        >>> mounted_cmp = edb2.components.get_component_by_name("BGA")
 
-        >>> vector, rotation, solder_ball_height = edb1.core_components.get_component_placement_vector(
+        >>> vector, rotation, solder_ball_height = edb1.components.get_component_placement_vector(
         ...                                                     mounted_component=mounted_cmp,
         ...                                                     hosting_component=hosting_cmp,
         ...                                                     mounted_component_pin1="A12",
         ...                                                     mounted_component_pin2="A14",
         ...                                                     hosting_component_pin1="A12",
         ...                                                     hosting_component_pin2="A14")
         >>> edb2.stackup.place_in_layout(edb1.active_cell, angle=0.0, offset_x=vector[0],
@@ -1078,16 +1204,16 @@
         bool
             ``True`` when succeed ``False`` if not.
 
         Examples
         --------
         >>> edb1 = Edb(edbpath=targetfile1,  edbversion="2021.2")
         >>> edb2 = Edb(edbpath=targetfile2, edbversion="2021.2")
-        >>> hosting_cmp = edb1.core_components.get_component_by_name("U100")
-        >>> mounted_cmp = edb2.core_components.get_component_by_name("BGA")
+        >>> hosting_cmp = edb1.components.get_component_by_name("U100")
+        >>> mounted_cmp = edb2.components.get_component_by_name("BGA")
         >>> edb2.stackup.place_in_layout(edb1.active_cell, angle=0.0, offset_x="1mm",
         ...                                   offset_y="2mm", flipped_stackup=False, place_on_top=True,
         ...                                   )
         """
         _angle = angle * math.pi / 180.0
 
         if solder_height <= 0:
@@ -1268,15 +1394,15 @@
         Examples
         --------
         >>> edb = Edb(edbpath=targetfile1,  edbversion="2021.2")
         >>> edb.stackup.residual_copper_area_per_layer()
         """
         temp_data = {name: 0 for name, _ in self.signal_layers.items()}
         outline_area = 0
-        for i in self._pedb.core_primitives.primitives:
+        for i in self._pedb.modeler.primitives:
             layer_name = i.GetLayer().GetName()
             if layer_name.lower() == "outline":
                 if i.area() > outline_area:
                     outline_area = i.area()
             elif layer_name not in temp_data:
                 continue
             elif not i.is_void:
@@ -1690,841 +1816,533 @@
                 pval = {i: str(j) for i, j in pval.items()}
                 ET.SubElement(el, pname, pval)
 
         write_pretty_xml(root, file_path)
         return True
 
     @pyaedt_function_handler
-    def import_stackup(self, file_path):
+    def load(self, file_path):
         """Import stackup from a file. The file format can be XML, CSV, or JSON.
 
+
         Parameters
         ----------
         file_path : str
             Path to stackup file.
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         Examples
         --------
         >>> from pyaedt import Edb
         >>> edb = Edb()
-        >>> edb.stackup.import_stackup("stackup.xml")
+        >>> edb.stackup.load("stackup.xml")
         """
 
         if file_path.endswith(".csv"):
             return self._import_csv(file_path)
         elif file_path.endswith(".json"):
             return self._import_json(file_path)
         elif file_path.endswith(".xml"):
             return self._import_xml(file_path)
         else:
             return False
 
+    @pyaedt_function_handler
+    def import_stackup(self, file_path):
+        """Import stackup from a file. The file format can be XML, CSV, or JSON.
+
+        .. deprecated:: 0.6.61
+           Use :func:`load` instead.
+
+        Parameters
+        ----------
+        file_path : str
+            Path to stackup file.
+        Returns
+        -------
+        bool
+            ``True`` when successful, ``False`` when failed.
+
+        Examples
+        --------
+        >>> from pyaedt import Edb
+        >>> edb = Edb()
+        >>> edb.stackup.import_stackup("stackup.xml")
+        """
+
+        self._logger.warning("Method export_stackup is deprecated. Use .export.")
+        return self.load(file_path)
+
     @pyaedt_function_handler()
     def plot(
         self,
-        show_legend=True,
         save_plot=None,
         size=(2000, 1500),
         plot_definitions=None,
         first_layer=None,
         last_layer=None,
+        scale_elevation=True,
     ):
-        """Plot actual stackup and, optionally, overlap padstack definitions.
+        """Plot current stackup and, optionally, overlap padstack definitions.
+        Plot supports only 'Laminate' and 'Overlapping' stackup types.
 
         Parameters
         ----------
-        show_legend : bool, optional
-            If ``True`` the legend is shown in the plot. (default)
-            If ``False`` the legend is not shown.
         save_plot : str, optional
             If ``None`` the plot will be shown.
             If a file path is specified the plot will be saved to such file.
-
         size : tuple, optional
             Image size in pixel (width, height). Default value is ``(2000, 1500)``
         plot_definitions : str, list, optional
             List of padstack definitions to plot on the stackup.
+            It is supported only for Laminate mode.
         first_layer : str or :class:`pyaedt.edb_core.edb_data.layer_data.LayerEdbClass`
             First layer to plot from the bottom. Default is `None` to start plotting from bottom.
         last_layer : str or :class:`pyaedt.edb_core.edb_data.layer_data.LayerEdbClass`
             Last layer to plot from the bottom. Default is `None` to plot up to top layer.
+        scale_elevation : bool, optional
+            The real layer thickness is scaled so that max_thickness = 3 * min_thickness.
+            Default is `True`.
 
         Returns
         -------
         :class:`matplotlib.plt`
         """
         if is_ironpython:
             return False
         from pyaedt.generic.constants import CSS4_COLORS
         from pyaedt.generic.plot import plot_matplotlib
 
-        thick = abs(self.get_layout_thickness()) * 1e6
-        x_min = -3 * thick
-        x_max = 3 * thick
-        objects_lists = []
-
-        layers_name = list(self.stackup_layers.keys())
-        bottom_layer = self.stackup_layers[layers_name[-1]]
-        top_layer = self.stackup_layers[layers_name[0]]
-        start_plot = False
-        if not last_layer:
-            last_layer = top_layer
-        elif isinstance(last_layer, str):
-            last_layer = self.layers[last_layer]
-        if not first_layer:
-            first_layer = bottom_layer
+        layer_names = list(self.stackup_layers.keys())
+        if first_layer is None or first_layer not in layer_names:
+            bottom_layer = layer_names[-1]
         elif isinstance(first_layer, str):
-            first_layer = self.layers[first_layer]
-        limits = [first_layer.lower_elevation * 1e6, (last_layer.lower_elevation + last_layer.thickness) * 1e6]
-
-        for layername, layerval in self.layers.items():
-            if layername == last_layer.name:
-                start_plot = True
-            if start_plot and layerval.thickness is not None:
-                x = [x_min, x_min, x_max, x_max]
-                lel = layerval.lower_elevation * 1e6
-                uel = layerval.upper_elevation * 1e6
-                y = [lel, uel, uel, lel]
-                color = [float(i) / 256 for i in layerval.color]
-                if color == [1.0, 1.0, 1.0]:
-                    color = [0.9, 0.9, 0.9]
-                objects_lists.append(
-                    [x, y, color, "{} {}um".format(layername, round(layerval.thickness * 1e6, 2)), 0.4, "fill"]
-                )
-            if layername == first_layer.name:
-                start_plot = False
-        delta = (x_max - x_min) / 20
-        x_start = x_min + delta
-        if plot_definitions:
-            if not isinstance(plot_definitions, list):
-                plot_definitions = [plot_definitions]
-            color_index = 0
-            color_keys = list(CSS4_COLORS.keys())
-            max_plots = 20
-
-            for definition in plot_definitions:
-                if isinstance(definition, str):
-                    definition = self._pedb.core_padstack.definitions[definition]
-                min_lel = 1e12
-                max_lel = -1e12
-                max_x = 0
-                name_assigned = definition.name
-                for layer, defs in definition.pad_by_layer.items():
-                    vals = defs.parameters_values
-                    if vals:
-                        pad = 0.5 * vals[0] * 1e6
-                        max_x = max(pad, max_x)
-                        x = [x_start - pad, x_start - pad, x_start + pad, x_start + pad]
-                        lel = self[layer].lower_elevation * 1e6
-                        uel = self[layer].upper_elevation * 1e6
-                        min_lel = min(lel, min_lel)
-                        max_lel = max(uel, max_lel)
-                        y = [lel, uel, uel, lel]
-                        objects_lists.append([x, y, color_keys[color_index], name_assigned, 1.0, "fill"])
-                        name_assigned = None
-                if definition.hole_properties:
-                    hole_rad = definition.hole_properties[0] * 1e6
-                    x = [x_start - hole_rad, x_start - hole_rad, x_start + hole_rad, x_start + hole_rad]
-                    y = [min_lel, max_lel, max_lel, min_lel]
-                    objects_lists.append([x, y, color_keys[color_index], name_assigned, 0.7, "fill"])
-                    max_x = max(max_x, hole_rad)
-                    rad = hole_rad * (100 - definition.hole_plating_ratio) / 100
-                    x = [x_start - rad, x_start - rad, x_start + rad, x_start + rad]
-                    y = [min_lel, max_lel, max_lel, min_lel]
-                    objects_lists.append([x, y, color_keys[color_index], name_assigned, 1.0, "fill"])
-                color_index += 1
-                if color_index == max_plots:
-                    self._logger.warning("Maximum number of definition plotted.")
-                    break
-                x_start += max(delta, 2.5 * max_x)
-
-        x_limits = [x_min, 2 * x_max]
-        plot_matplotlib(
-            objects_lists,
-            size,
-            show_legend,
-            "X (um)",
-            "Y (um)",
-            "Stackup",
-            save_plot,
-            x_limits=x_limits,
-            y_limits=limits,
-        )
-
-
-class EdbStackup(object):
-    """Manages EDB methods for stackup and material management accessible from the
-     ``Edb.core_stackup`` property (deprecated).
-
-    .. deprecated:: 0.6.5
-        This class has been deprecated and replaced by the ``Stackup`` class.
-
-    Examples
-    --------
-    >>> from pyaedt import Edb
-    >>> edbapp = Edb("myaedbfolder", edbversion="2021.2")
-    >>> edb_stackup = edbapp.core_stackup
-    """
-
-    def __init__(self, p_edb):
-        self._pedb = p_edb
-        self._layer_dict = None
-
-    @property
-    def _builder(self):
-        """ """
-        return self._pedb.builder
-
-    def _get_edb_value(self, value):
-        return self._pedb.edb_value(value)
-
-    @property
-    def _edb(self):
-        """ """
-        return self._pedb.edb
-
-    @property
-    def _active_layout(self):
-        """ """
-        return self._pedb.active_layout
-
-    @property
-    def _cell(self):
-        """ """
-        return self._pedb.cell
-
-    @property
-    def _db(self):
-        """ """
-        return self._pedb.db
-
-    @property
-    def _logger(self):
-        """ """
-        return self._pedb.logger
-
-    @property
-    def stackup_layers(self):
-        """Stackup layers.
-
-        Returns
-        -------
-        :class:`pyaedt.edb_core.EDBData.EDBLayers`
-            Dictionary of stackup layers.
-        """
-        if not self._layer_dict:
-            self._layer_dict = EDBLayers(self)
-        return self._layer_dict
-
-    @property
-    def signal_layers(self):
-        """Dictionary of all signal layers.
-
-        Returns
-        -------
-        dict[str, :class:`pyaedt.edb_core.EDB_Data.EDBLayer`]
-            List of signal layers.
-        """
-        return self.stackup_layers.signal_layers
-
-    @property
-    def layer_types(self):
-        """Layer types.
-
-        Returns
-        -------
-        type
-            Types of layers.
-        """
-        return self._pedb.edb.Cell.LayerType
-
-    @property
-    def materials(self):
-        """Materials.
-
-        Returns
-        -------
-        dict
-            Dictionary of materials.
-        """
-        return self._pedb.materials
-
-    @pyaedt_function_handler()
-    def create_dielectric(self, name, permittivity=1, loss_tangent=0):
-        """Create a dielectric with simple properties.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.materials.create_dielectric` function instead.
-
-        Parameters
-        ----------
-        name : str
-            Name of the dielectric.
-        permittivity : float, optional
-            Permittivity of the dielectric. The default is ``1``.
-        loss_tangent : float, optional
-            Loss tangent for the material. The default is ``0``.
-
-        Returns
-        -------
-        type
-            Material definition.
-        """
-        warnings.warn("Use `Edb.materials.create_dielectric` function instead.", DeprecationWarning)
-        return self._pedb.materials.add_dielectric_material(name, permittivity=permittivity, loss_tangent=loss_tangent)
-
-    @pyaedt_function_handler()
-    def create_conductor(self, name, conductivity=1e6):
-        """Create a conductor with simple properties.
-
-        .. deprecated:: 0.6.27
-           Use the :func:`Edb.materials.add_conductor_material` function instead.
-
-        Parameters
-        ----------
-        name : str
-            Name of the conductor.
-        conductivity : float, optional
-            Conductivity of the conductor. The default is ``1e6``.
-
-        Returns
-        -------
-        :class:`pyaedt.edb_core.materials.Material`
-            Material definition.
-        """
-        warnings.warn("Use `Edb.materials.add_conductor_material` function instead.", DeprecationWarning)
-
-        return self._pedb.materials.add_conductor_material(name, conductivity=conductivity)
-
-    @pyaedt_function_handler()
-    def create_debye_material(
-        self,
-        name,
-        relative_permittivity_low,
-        relative_permittivity_high,
-        loss_tangent_low,
-        loss_tangent_high,
-        lower_freqency,
-        higher_frequency,
-    ):
-        """Create a dielectric with the Debye model.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.materials.add_debye_material` function instead.
-
-        Parameters
-        ----------
-        name : str
-            Name of the dielectric.
-        relative_permittivity_low : float
-            Relative permittivity of the dielectric at the frequency specified
-            for ``lower_frequency``.
-        relative_permittivity_high : float
-            Relative permittivity of the dielectric at the frequency specified
-            for ``higher_frequency``.
-        loss_tangent_low : float
-            Loss tangent for the material at the frequency specified
-            for ``lower_frequency``.
-        loss_tangent_high : float
-            Loss tangent for the material at the frequency specified
-            for ``higher_frequency``.
-        lower_freqency : float
-            Value for the lower frequency.
-        higher_frequency : float
-            Value for the higher frequency.
-
-        Returns
-        -------
-        type
-            Material definition.
-        """
-        warnings.warn("Use `Edb.materials.add_debye_material` function instead.", DeprecationWarning)
-
-        return self._pedb.materials.add_debye_material(
-            name=name,
-            permittivity_low=relative_permittivity_low,
-            permittivity_high=relative_permittivity_high,
-            loss_tangent_low=loss_tangent_low,
-            loss_tangent_high=loss_tangent_high,
-            lower_freqency=lower_freqency,
-            higher_frequency=higher_frequency,
-        )
-
-    @pyaedt_function_handler()
-    def create_multipole_debye_material(
-        self,
-        name,
-        frequencies,
-        relative_permittivities,
-        loss_tangents,
-    ):
-        """Create a dielectric with the Multipole Debye model.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.materials.add_multipole_debye_material` function instead.
-
-        Parameters
-        ----------
-        name : str
-            Name of the dielectic.
-        frequencies : list
-            Frequencies in GHz.
-        relative_permittivities : list
-            Relative permittivities at each frequency.
-        loss_tangents : list
-            Loss tangents at each frequency.
-
-        Returns
-        -------
-        type
-            Material definition.
-
-        Examples
-        --------
-        >>> from pyaedt import Edb
-        >>> edb = Edb()
-        >>> freq = [0, 2, 3, 4, 5, 6]
-        >>> rel_perm = [1e9, 1.1e9, 1.2e9, 1.3e9, 1.5e9, 1.6e9]
-        >>> loss_tan = [0.025, 0.026, 0.027, 0.028, 0.029, 0.030]
-        >>> diel = edb.core_stackup.create_multipole_debye_material("My_MP_Debye", freq, rel_perm, loss_tan)
-        """
-        warnings.warn("Use `Edb.materials.add_multipole_debye_material` function instead.", DeprecationWarning)
-
-        return self._pedb.materials.add_multipole_debye_material(
-            name=name,
-            frequencies=frequencies,
-            permittivities=relative_permittivities,
-            loss_tangents=loss_tangents,
-        )
-
-    @pyaedt_function_handler()
-    def get_layout_thickness(self):
-        """Return the layout thickness.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.stackup.get_layout_thickness` function instead.
-
-        Returns
-        -------
-        float
-            The thickness value.
-        """
-        warnings.warn("Use `Edb.materials.get_layout_thickness` function instead.", DeprecationWarning)
-
-        return self._pedb.stackup.get_layout_thickness()
-
-    @pyaedt_function_handler()
-    def duplicate_material(self, material_name, new_material_name):
-        """Duplicate a material from the database.
-        It duplicates these five properties: ``permittivity``, ``permeability``, ``conductivity``,
-        ``dielectriclosstangent``, and ``magneticlosstangent``.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.stackup.duplicate` function instead.
-
-        Parameters
-        ----------
-        material_name : str
-            Name of the existing material.
-        new_material_name : str
-            Name of the new duplicated material.
-
-        Returns
-        -------
-        EDB material : class: 'Ansys.Ansoft.Edb.Definition.MaterialDef'
-
-
-        Examples
-        --------
-
-        >>> from pyaedt import Edb
-        >>> edb_app = Edb()
-        >>> my_material = edb_app.core_stackup.duplicate_material("copper", "my_new_copper")
-
-        """
-        warnings.warn("Use `Edb.materials.duplicate` function instead.", DeprecationWarning)
-
-        return self._pedb.materials.duplicate(material_name, new_material_name)
-
-    @pyaedt_function_handler
-    def material_name_to_id(self, property_name):
-        """Convert a material property name to a material property ID.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.materials.material_name_to_id` function instead.
-
-        Parameters
-        ----------
-        property_name : str
-            Name of the material property.
-
-        Returns
-        -------
-        ID of the material property.
-        """
-        warnings.warn("Use `Edb.materials.material_name_to_id` function instead.", DeprecationWarning)
-
-        return self._pedb.materials.material_name_to_id(property_name)
-
-    @pyaedt_function_handler()
-    def get_property_by_material_name(self, property_name, material_name):
-        """Get the property of a material. If it is executed in IronPython,
-         you must only use the first element of the returned tuple, which is a float.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.materials.get_property_by_material_name` function instead.
-
-        Parameters
-        ----------
-        material_name : str
-            Name of the existing material.
-        property_name : str
-            Name of the material property.
-            ``permittivity``
-            ``permeability``
-            ``conductivity``
-            ``dielectric_loss_tangent``
-            ``magnetic_loss_tangent``
-
-        Returns
-        -------
-        float
-            The float value of the property.
-
-
-        Examples
-        --------
-        >>> from pyaedt import Edb
-        >>> edb_app = Edb()
-        >>> returned_tuple = edb_app.core_stackup.get_property_by_material_name("conductivity", "copper")
-        >>> edb_value = returned_tuple[0]
-        >>> float_value = returned_tuple[1]
-
-        """
-        warnings.warn("Use `Edb.materials.get_property_by_material_name` function instead.", DeprecationWarning)
-
-        return self._pedb.materials.get_property_by_material_name(property_name, material_name)
-
-    @pyaedt_function_handler()
-    def adjust_solder_dielectrics(self):
-        """Adjust the stack-up by adding or modifying dielectric layers that contains Solder Balls.
-        This method identifies the solder-ball height and adjust the dielectric thickness on top (or bottom) to fit
-        the thickness in order to merge another layout.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.stackup.adjust_solder_dielectrics` function instead.
-
-        Returns
-        -------
-        bool
-        """
-        warnings.warn("Use `Edb.stackup.adjust_solder_dielectrics` function instead.", DeprecationWarning)
-
-        return self._pedb.stackup.adjust_solder_dielectrics()
-
-    @pyaedt_function_handler()
-    def place_in_layout(
-        self,
-        edb,
-        angle=0.0,
-        offset_x=0.0,
-        offset_y=0.0,
-        flipped_stackup=True,
-        place_on_top=True,
-    ):
-        """Place current Cell into another cell using layer placement method.
-        Flip the current layer stackup of a layout if requested. Transform parameters currently not supported.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.stackup.place_in_layout` function instead.
-
-        Parameters
-        ----------
-        edb : Edb
-            Cell on which to place the current layout. If None the Cell will be applied on an empty new Cell.
-        angle : double, optional
-            The rotation angle applied on the design.
-        offset_x : double, optional
-            The x offset value.
-        offset_y : double, optional
-            The y offset value.
-        flipped_stackup : bool, optional
-            Either if the current layout is inverted.
-            If `True` and place_on_top is `True` the stackup will be flipped before the merge.
-        place_on_top : bool, optional
-            Either if place the current layout on Top or Bottom of destination Layout.
-
-        Returns
-        -------
-        bool
-            ``True`` when succeed ``False`` if not.
-
-        Examples
-        --------
-        >>> edb1 = Edb(edbpath=targetfile1,  edbversion="2021.2")
-        >>> edb2 = Edb(edbpath=targetfile2, edbversion="2021.2")
-
-        >>> hosting_cmp = edb1.core_components.get_component_by_name("U100")
-        >>> mounted_cmp = edb2.core_components.get_component_by_name("BGA")
-
-        >>> vector, rotation, solder_ball_height = edb1.core_components.get_component_placement_vector(
-        ...                                                     mounted_component=mounted_cmp,
-        ...                                                     hosting_component=hosting_cmp,
-        ...                                                     mounted_component_pin1="A12",
-        ...                                                     mounted_component_pin2="A14",
-        ...                                                     hosting_component_pin1="A12",
-        ...                                                     hosting_component_pin2="A14")
-        >>> edb2.core_stackup.place_in_layout(edb1.active_cell, angle=0.0, offset_x=vector[0],
-        ...                                   offset_y=vector[1], flipped_stackup=False, place_on_top=True,
-        ...                                   )
-        """
-        warnings.warn("Use `Edb.stackup.place_in_layout` function instead.", DeprecationWarning)
+            bottom_layer = first_layer
+        elif isinstance(first_layer, LayerEdbClass):
+            bottom_layer = first_layer.name
+        else:
+            raise AttributeError("first_layer must be str or class `pyaedt.edb_core.edb_data.layer_data.LayerEdbClass`")
+        if last_layer is None or last_layer not in layer_names:
+            top_layer = layer_names[0]
+        elif isinstance(last_layer, str):
+            top_layer = last_layer
+        elif isinstance(last_layer, LayerEdbClass):
+            top_layer = last_layer.name
+        else:
+            raise AttributeError("last_layer must be str or class `pyaedt.edb_core.edb_data.layer_data.LayerEdbClass`")
 
-        return self._pedb.stackup.place_in_layout(
-            edb=edb,
-            angle=angle,
-            offset_x=offset_x,
-            offset_y=offset_y,
-            flipped_stackup=flipped_stackup,
-            place_on_top=place_on_top,
-        )
+        stackup_mode = self.stackup_mode
+        if stackup_mode not in ["Laminate", "Overlapping"]:
+            raise AttributeError("stackup plot supports only 'Laminate' and 'Overlapping' stackup types.")
+
+        # build the layers data
+        layers_data = []
+        skip_flag = True
+        for layer in self.stackup_layers.values():  # start from top
+            if layer.name != top_layer and skip_flag:
+                continue
+            else:
+                skip_flag = False
+            layers_data.append([layer, layer.lower_elevation, layer.upper_elevation, layer.thickness])
+            if layer.name == bottom_layer:
+                break
+        layers_data.reverse()  # let's start from the bottom
+
+        # separate dielectric and signal if overlapping stackup
+        if stackup_mode == "Overlapping":
+            dielectric_layers = [l for l in layers_data if l[0].type == "dielectric"]
+            signal_layers = [l for l in layers_data if l[0].type == "signal"]
+
+        # compress the thicknesses if required
+        if scale_elevation:
+            min_thickness = min([i[3] for i in layers_data if i[3] != 0])
+            max_thickness = max([i[3] for i in layers_data])
+            c = 3  # max_thickness = c * min_thickness
+
+            def _compress_t(y):
+                m = min_thickness
+                M = max_thickness
+                k = (c - 1) * m / (M - m)
+                if y > 0:
+                    return (y - m) * k + m
+                else:
+                    return 0.0
 
-    @pyaedt_function_handler()
-    def place_in_layout_3d_placement(
-        self,
-        edb,
-        angle=0.0,
-        offset_x=0.0,
-        offset_y=0.0,
-        flipped_stackup=True,
-        place_on_top=True,
-        solder_height=0,
-    ):
-        """Place current Cell into another cell using 3d placement method.
-        Flip the current layer stackup of a layout if requested. Transform parameters currently not supported.
+            if stackup_mode == "Laminate":
+                l0 = layers_data[0]
+                compressed_layers_data = [[l0[0], l0[1], _compress_t(l0[3]), _compress_t(l0[3])]]  # the first row
+                lp = compressed_layers_data[0]
+                for li in layers_data[1:]:  # the other rows
+                    ct = _compress_t(li[3])
+                    compressed_layers_data.append([li[0], lp[2], lp[2] + ct, ct])
+                    lp = compressed_layers_data[-1]
+                layers_data = compressed_layers_data
+
+            elif stackup_mode == "Overlapping":
+                compressed_diels = []
+                first_diel = True
+                for li in dielectric_layers:
+                    ct = _compress_t(li[3])
+                    if first_diel:
+                        if li[1] > 0:
+                            l0le = _compress_t(li[1])
+                        else:
+                            l0le = li[1]
+                        compressed_diels.append([li[0], l0le, l0le + ct, ct])
+                        first_diel = False
+                    else:
+                        lp = compressed_diels[-1]
+                        compressed_diels.append([li[0], lp[2], lp[2] + ct, ct])
 
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.stackup.place_in_layout_3d_placement` function instead.
+                def _convert_elevation(el):
+                    inside = False
+                    for i, li in enumerate(dielectric_layers):
+                        if li[1] <= el <= li[2]:
+                            inside = True
+                            break
+                    if inside:
+                        u = (el - li[1]) / (li[2] - li[1])
+                        cli = compressed_diels[i]
+                        cel = cli[1] + u * (cli[2] - cli[1])
+                    else:
+                        cel = el
+                    return cel
 
-        Parameters
-        ----------
-        edb : Edb
-            Cell on which to place the current layout. If None the Cell will be applied on an empty new Cell.
-        angle : double, optional
-            The rotation angle applied on the design.
-        offset_x : double, optional
-            The x offset value.
-        offset_y : double, optional
-            The y offset value.
-        flipped_stackup : bool, optional
-            Either if the current layout is inverted.
-            If `True` and place_on_top is `True` the stackup will be flipped before the merge.
-        place_on_top : bool, optional
-            Either if place the current layout on Top or Bottom of destination Layout.
-        solder_height : float, optional
-            Solder Ball or Bumps eight.
-            This value will be added to the elevation to align the two layouts.
+                compressed_signals = []
+                for li in signal_layers:
+                    cle = _convert_elevation(li[1])
+                    cue = _convert_elevation(li[2])
+                    ct = cue - cle
+                    compressed_signals.append([li[0], cle, cue, ct])
+
+                dielectric_layers = compressed_diels
+                signal_layers = compressed_signals
+
+        # create the data for the plot
+        diel_alpha = 0.4
+        signal_alpha = 0.6
+        zero_thickness_alpha = 1.0
+        annotation_fontsize = 14
+        annotation_x_margin = 0.01
+        annotations = []
+        plot_data = []
+        if stackup_mode == "Laminate":
+            min_thickness = min([i[3] for i in layers_data if i[3] != 0])
+            for ly in layers_data:
+                layer = ly[0]
 
-        Returns
-        -------
-        bool
-            ``True`` when succeed ``False`` if not.
+                # set color and label
+                color = [float(i) / 256 for i in layer.color]
+                if color == [1.0, 1.0, 1.0]:
+                    color = [0.9, 0.9, 0.9]
+                label = "{}, {}, thick: {:.3f}um, elev: {:.3f}um".format(
+                    layer.name, layer.material, layer.thickness * 1e6, layer.lower_elevation * 1e6
+                )
 
-        Examples
-        --------
-        >>> edb1 = Edb(edbpath=targetfile1,  edbversion="2021.2")
-        >>> edb2 = Edb(edbpath=targetfile2, edbversion="2021.2")
-        >>> hosting_cmp = edb1.core_components.get_component_by_name("U100")
-        >>> mounted_cmp = edb2.core_components.get_component_by_name("BGA")
-        >>> edb2.core_stackup.place_in_layout(edb1.active_cell, angle=0.0, offset_x="1mm",
-        ...                                   offset_y="2mm", flipped_stackup=False, place_on_top=True,
-        ...                                   )
-        """
-        warnings.warn("Use `Edb.stackup.place_in_layout_3d_placement` function instead.", DeprecationWarning)
+                # create patch
+                x = [0, 0, 1, 1]
+                if ly[3] > 0:
+                    le = ly[1]  # lower elevation
+                    ue = ly[2]  # upper elevation
+                    y = [le, ue, ue, le]
+                    plot_data.insert(0, [x, y, color, label, signal_alpha, "fill"])
+                else:
+                    le = ly[1] - min_thickness * 0.1  # make the zero thickness layers more visible
+                    ue = ly[2] + min_thickness * 0.1
+                    y = [le, ue, ue, le]
+                    # put the zero thickness layers on top
+                    plot_data.append([x, y, color, label, zero_thickness_alpha, "fill"])
+
+                # create annotation
+                y_pos = (le + ue) / 2
+                if layer.type == "dielectric":
+                    x_pos = -annotation_x_margin
+                    annotations.append(
+                        [x_pos, y_pos, layer.name, {"fontsize": annotation_fontsize, "horizontalalignment": "right"}]
+                    )
+                elif layer.type == "signal":
+                    x_pos = 1.0 + annotation_x_margin
+                    annotations.append([x_pos, y_pos, layer.name, {"fontsize": annotation_fontsize}])
+
+            # evaluate the legend reorder
+            legend_order = []
+            for ly in layers_data:
+                name = ly[0].name
+                for i, a in enumerate(plot_data):
+                    iname = a[3].split(",")[0]
+                    if name == iname:
+                        legend_order.append(i)
+                        break
 
-        return self._pedb.stackup.place_in_layout_3d_placement(
-            edb=edb,
-            angle=angle,
-            offset_x=offset_x,
-            offset_y=offset_y,
-            flipped_stackup=flipped_stackup,
-            place_on_top=place_on_top,
-            solder_height=solder_height,
-        )
+        elif stackup_mode == "Overlapping":
+            min_thickness = min([i[3] for i in signal_layers if i[3] != 0])
+            columns = []  # first column is x=[0,1], second column is x=[1,2] and so on...
+            for ly in signal_layers:
+                le = ly[1]  # lower elevation
+                t = ly[3]  # thickness
+                put_in_column = 0
+                cell_position = 0
+                for c in columns:
+                    uep = c[-1][0][2]  # upper elevation of the last entry of that column
+                    tp = c[-1][0][3]  # thickness of the last entry of that column
+                    if le < uep or (abs(le - uep) < 1e-15 and tp == 0 and t == 0):
+                        put_in_column += 1
+                        cell_position = len(c)
+                    else:
+                        break
+                if len(columns) < put_in_column + 1:  # add a new column if required
+                    columns.append([])
+                # put zeros at the beginning of the column until there is the first layer
+                if cell_position != 0:
+                    fill_cells = cell_position - 1 - len(columns[put_in_column])
+                    for i in range(fill_cells):
+                        columns[put_in_column].append(0)
+                # append the layer to the proper column and row
+                x = [put_in_column + 1, put_in_column + 1, put_in_column + 2, put_in_column + 2]
+                columns[put_in_column].append([ly, x])
+
+            # fill the columns matrix with zeros on top
+            n_rows = max([len(i) for i in columns])
+            for c in columns:
+                while len(c) < n_rows:
+                    c.append(0)
+            # expand to the right the fill for the signals that have no overlap on the right
+            width = len(columns) + 1
+            for i, c in enumerate(columns[:-1]):
+                for j, r in enumerate(c):
+                    if r != 0:  # and dname == r[0].name:
+                        if columns[i + 1][j] == 0:
+                            # nothing on the right, so expand the fill
+                            x = r[1]
+                            r[1] = [x[0], x[0], width, width]
+
+            for c in columns:
+                for r in c:
+                    if r != 0:
+                        ly = r[0]
+                        layer = ly[0]
+                        x = r[1]
+
+                        # set color and label
+                        color = [float(i) / 256 for i in layer.color]
+                        if color == [1.0, 1.0, 1.0]:
+                            color = [0.9, 0.9, 0.9]
+                        label = "{}, {}, thick: {:.3f}um, elev: {:.3f}um".format(
+                            layer.name, layer.material, layer.thickness * 1e6, layer.lower_elevation * 1e6
+                        )
 
-    @pyaedt_function_handler()
-    def place_a3dcomp_3d_placement(self, a3dcomp_path, angle=0.0, offset_x=0.0, offset_y=0.0, place_on_top=True):
-        """Place a 3D Component into current layout.
-         3D Component ports are not visible via EDB. They will be visible after the EDB has been opened in Ansys
-         Electronics Desktop as a project.
+                        if ly[3] > 0:
+                            le = ly[1]  # lower elevation
+                            ue = ly[2]  # upper elevation
+                            y = [le, ue, ue, le]
+                            plot_data.insert(0, [x, y, color, label, signal_alpha, "fill"])
+                        else:
+                            le = ly[1] - min_thickness * 0.1  # make the zero thickness layers more visible
+                            ue = ly[2] + min_thickness * 0.1
+                            y = [le, ue, ue, le]
+                            # put the zero thickness layers on top
+                            plot_data.append([x, y, color, label, zero_thickness_alpha, "fill"])
+
+                        # create annotation
+                        x_pos = 1.0
+                        y_pos = (le + ue) / 2
+                        annotations.append([x_pos, y_pos, layer.name, {"fontsize": annotation_fontsize}])
+
+            # order the annotations based on y_pos (it is necessary later to move them to avoid text overlapping)
+            annotations.sort(key=lambda e: e[1])
+            # move all the annotations to the final x (it could be larger than 1 due to additional columns)
+            width = len(columns) + 1
+            for i, a in enumerate(annotations):
+                a[0] = width + annotation_x_margin * width
+
+            for ly in dielectric_layers:
+                layer = ly[0]
+                # set color and label
+                color = [float(i) / 256 for i in layer.color]
+                if color == [1.0, 1.0, 1.0]:
+                    color = [0.9, 0.9, 0.9]
+                label = "{}, {}, thick: {:.3f}um, elev: {:.3f}um".format(
+                    layer.name, layer.material, layer.thickness * 1e6, layer.lower_elevation * 1e6
+                )
+                # create the patch
+                le = ly[1]  # lower elevation
+                ue = ly[2]  # upper elevation
+                y = [le, ue, ue, le]
+                x = [0, 0, width, width]
+                plot_data.insert(0, [x, y, color, label, diel_alpha, "fill"])
+
+                # create annotation
+                x_pos = -annotation_x_margin * width
+                y_pos = (le + ue) / 2
+                annotations.append(
+                    [x_pos, y_pos, layer.name, {"fontsize": annotation_fontsize, "horizontalalignment": "right"}]
+                )
 
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.stackup.place_a3dcomp_3d_placement` function instead.
+            # evaluate the legend reorder
+            legend_order = []
+            for ly in dielectric_layers:
+                name = ly[0].name
+                for i, a in enumerate(plot_data):
+                    iname = a[3].split(",")[0]
+                    if name == iname:
+                        legend_order.append(i)
+                        break
+            for ly in signal_layers:
+                name = ly[0].name
+                for i, a in enumerate(plot_data):
+                    iname = a[3].split(",")[0]
+                    if name == iname:
+                        legend_order.append(i)
+                        break
 
-        Parameters
-        ----------
-        a3dcomp_path : str
-            Path to the 3D Component file (\\*.a3dcomp) to place.
-        angle : double, optional
-            Clockwise rotation angle applied to the a3dcomp.
-        offset_x : double, optional
-            The x offset value.
-            The default value is ``0.0``.
-        offset_y : double, optional
-            The y offset value.
-            The default value is ``0.0``.
-        place_on_top : bool, optional
-            Whether to place the 3D Component on the top or the bottom of this layout.
-            If ``False`` then the 3D Component will also be flipped over around its X axis.
+        # calculate the extremities of the plot
+        x_min = 0.0
+        x_max = max([max(i[0]) for i in plot_data])
+        if stackup_mode == "Laminate":
+            y_min = layers_data[0][1]
+            y_max = layers_data[-1][2]
+        elif stackup_mode == "Overlapping":
+            y_min = min(dielectric_layers[0][1], signal_layers[0][1])
+            y_max = max(dielectric_layers[-1][2], signal_layers[-1][2])
+
+        # move the annotations to avoid text overlapping
+        new_annotations = []
+        for i, a in enumerate(annotations):
+            if i > 0 and abs(a[1] - annotations[i - 1][1]) < (y_max - y_min) / 75:
+                new_annotations[-1][2] = str(new_annotations[-1][2]) + ", " + str(a[2])
+            else:
+                new_annotations.append(a)
+        annotations = new_annotations
 
-        Returns
-        -------
-        bool
-            ``True`` if successful and ``False`` if not.
+        if plot_definitions:
+            if stackup_mode == "Overlapping":
+                self._logger.warning("Plot of padstacks are supported only for Laminate mode.")
 
-        Examples
-        --------
-        >>> edb1 = Edb(edbpath=targetfile1,  edbversion="2021.2")
-        >>> a3dcomp_path = "connector.a3dcomp"
-        >>> edb1.core_stackup.place_a3dcomp_3d_placement(a3dcomp_path, angle=0.0, offset_x="1mm",
-        ...                                   offset_y="2mm", flipped_stackup=False, place_on_top=True,
-        ...                                   )
-        """
-        warnings.warn("Use `Edb.stackup.place_a3dcomp_3d_placement` function instead.", DeprecationWarning)
+            max_plots = 10
 
-        return self._pedb.stackup.place_a3dcomp_3d_placement(
-            a3dcomp_path=a3dcomp_path, angle=angle, offset_x=offset_x, offset_y=offset_y, place_on_top=place_on_top
-        )
+            if not isinstance(plot_definitions, list):
+                plot_definitions = [plot_definitions]
+            color_index = 0
+            color_keys = list(CSS4_COLORS.keys())
+            delta = 1 / (max_plots + 1)  # padstack spacing in plot coordinates
+            x_start = delta
 
-    @pyaedt_function_handler()
-    def flip_design(self):
-        """Flip the current design of a layout.
+            # find the max padstack size to calculate the scaling factor
+            max_padstak_size = 0
+            for definition in plot_definitions:
+                if isinstance(definition, str):
+                    definition = self._pedb.padstacks.definitions[definition]
+                for layer, defs in definition.pad_by_layer.items():
+                    pad_shape = defs.geometry_type
+                    params = defs.parameters_values
+                    if pad_shape in [1, 2, 6]:
+                        pad_size = params[0]
+                    elif pad_shape in [3, 4, 5]:
+                        pad_size = max(params[0], params[1])
+                    else:
+                        pad_size = 1e-4
+                    max_padstak_size = max(pad_size, max_padstak_size)
+                if definition.hole_properties:
+                    hole_d = definition.hole_properties[0]
+                    max_padstak_size = max(hole_d, max_padstak_size)
+            scaling_f_pad = (2 / ((max_plots + 1) * 3)) / max_padstak_size
 
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.stackup.flip_design` function instead.
+            for definition in plot_definitions:
+                if isinstance(definition, str):
+                    definition = self._pedb.padstacks.definitions[definition]
+                min_le = 1e12
+                max_ue = -1e12
+                max_x = 0
+                padstack_name = definition.name
+                annotations.append([x_start, y_max, padstack_name, {"rotation": 45}])
 
-        Returns
-        -------
-        bool
-            ``True`` when succeed ``False`` if not.
+                via_start_layer = definition.via_start_layer
+                via_stop_layer = definition.via_stop_layer
 
-        Examples
-        --------
-        >>> edb = Edb(edbpath=targetfile,  edbversion="2021.2")
-        >>> edb.core_stackup.flip_design()
-        >>> edb.save()
-        >>> edb.close_edb()
-        """
-        warnings.warn("Use `Edb.stackup.flip_design` function instead.", DeprecationWarning)
+                if stackup_mode == "Overlapping":
+                    # here search the column using the first and last layer. Pick the column with max index.
+                    pass
 
-        return self._pedb.stackup.flip_design()
+                for layer, defs in definition.pad_by_layer.items():
+                    pad_shape = defs.geometry_type
+                    params = defs.parameters_values
+                    if pad_shape in [1, 2, 6]:
+                        pad_size = params[0]
+                    elif pad_shape in [3, 4, 5]:
+                        pad_size = max(params[0], params[1])
+                    else:
+                        pad_size = 1e-4
 
-    @pyaedt_function_handler()
-    def create_djordjevicsarkar_material(
-        self, name, relative_permittivity, loss_tangent, test_frequency, dc_permittivity=None, dc_conductivity=None
-    ):
-        """Create a Djordjevic_Sarkar dielectric.
+                    if stackup_mode == "Laminate":
+                        x = [
+                            x_start - pad_size / 2 * scaling_f_pad,
+                            x_start - pad_size / 2 * scaling_f_pad,
+                            x_start + pad_size / 2 * scaling_f_pad,
+                            x_start + pad_size / 2 * scaling_f_pad,
+                        ]
+                        le = [e[1] for e in layers_data if e[0].name == layer][0]
+                        ue = [e[2] for e in layers_data if e[0].name == layer][0]
+                        y = [le, ue, ue, le]
+                        # create the patch for that signal layer
+                        plot_data.append([x, y, color_keys[color_index], None, 1.0, "fill"])
+                    elif stackup_mode == "Overlapping":
+                        # here evaluate the x based on the column evaluated before and the pad size
+                        pass
 
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.materials.add_djordjevicsarkar_material` function instead.
+                    min_le = min(le, min_le)
+                    max_ue = max(ue, max_ue)
+                if definition.hole_properties:
+                    # create patch for the hole
+                    hole_radius = definition.hole_properties[0] / 2 * scaling_f_pad
+                    x = [x_start - hole_radius, x_start - hole_radius, x_start + hole_radius, x_start + hole_radius]
+                    y = [min_le, max_ue, max_ue, min_le]
+                    plot_data.append([x, y, color_keys[color_index], None, 0.7, "fill"])
+                    # create patch for the dielectric
+                    max_x = max(max_x, hole_radius)
+                    rad = hole_radius * (100 - definition.hole_plating_ratio) / 100
+                    x = [x_start - rad, x_start - rad, x_start + rad, x_start + rad]
+                    plot_data.append([x, y, color_keys[color_index], None, 1.0, "fill"])
 
-        Parameters
-        ----------
-        name : str
-            Name of the dielectic.
-        relative_permittivity : float
-            Relative permittivity of the dielectric.
-        loss_tangent : float
-            Loss tangent for the material.
-        test_frequency : float
-            Test frequency in GHz for the dielectric.
-        dc_permittivity : float, optional
-            DC Relative permittivity of the dielectric.
-        dc_conductivity : float, optional
-            DC Conductivity of the dielectric.
-        Returns
-        -------
-        type
-            Material definition.
-        """
-        warnings.warn("Use `Edb.materials.add_djordjevicsarkar_material` function instead.", DeprecationWarning)
+                color_index += 1
+                if color_index == max_plots:
+                    self._logger.warning("Maximum number of definitions plotted.")
+                    break
+                x_start += delta
 
-        return self._pedb.materials.add_djordjevicsarkar_material(
-            name=name,
-            permittivity=relative_permittivity,
-            loss_tangent=loss_tangent,
-            test_frequency=test_frequency,
-            dc_permittivity=dc_permittivity,
-            dc_conductivity=dc_conductivity,
+        # plot the stackup
+        plt = plot_matplotlib(
+            plot_data,
+            size=size,
+            show_legend=False,
+            xlabel="",
+            ylabel="",
+            title="",
+            snapshot_path=None,
+            x_limits=[x_min, x_max],
+            y_limits=[y_min, y_max],
+            annotations=annotations,
+            show=False,
         )
-
-    @pyaedt_function_handler()
-    def stackup_limits(self, only_metals=False):
-        """Retrieve stackup limits.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.stackup.stackup_limits` function instead.
-
-        Parameters
-        ----------
-        only_metals : bool, optional
-            Whether to retrieve only metals. The default is ``False``.
-
-        Returns
-        -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-        """
-        warnings.warn("Use `Edb.stackup.stackup_limits` function instead.", DeprecationWarning)
-
-        return self._pedb.stackup.stackup_limits(only_metals=only_metals)
-
-    def create_symmetric_stackup(
-        self,
-        layer_count,
-        inner_layer_thickness="17um",
-        outer_layer_thickness="50um",
-        dielectric_thickness="100um",
-        dielectric_material="FR4_epoxy",
-        soldermask=True,
-        soldermask_thickness="20um",
-    ):
-        """Create a symmetric stackup.
-
-        .. deprecated:: 0.6.27
-           Use :func:`Edb.stackup.create_symmetric_stackup` function instead.
-
-        Parameters
-        ----------
-        layer_count : int
-            Number of layer count.
-        inner_layer_thickness : str, float, optional
-            Thickness of inner conductor layer.
-        outer_layer_thickness : str, float, optional
-            Thickness of outer conductor layer.
-        dielectric_thickness : str, float, optional
-            Thickness of dielectric layer.
-        dielectric_material : str, optional
-            Material of dielectric layer.
-        soldermask : bool, optional
-            Whether to create soldermask layers. The default is``True``.
-        soldermask_thickness : str, optional
-            Thickness of soldermask layer.
-        Returns
-        -------
-        bool
-        """
-        warnings.warn("Use `Edb.stackup.create_symmetric_stackup` function instead.", DeprecationWarning)
-
-        return self._pedb.stackup.create_symmetric_stackup(
-            layer_count=layer_count,
-            inner_layer_thickness=inner_layer_thickness,
-            outer_layer_thickness=outer_layer_thickness,
-            dielectric_thickness=dielectric_thickness,
-            dielectric_material=dielectric_material,
-            soldermask=soldermask,
-            soldermask_thickness=soldermask_thickness,
+        # we have to customize some defaults, so we plot or save the figure here
+        plt.axis("off")
+        plt.box(False)
+        plt.title("Stackup\n ", fontsize=28)
+        # evaluates the number of legend column based on the layer name max length
+        ncol = 3 if max([len(n) for n in layer_names]) < 15 else 2
+        handles, labels = plt.gca().get_legend_handles_labels()
+        plt.legend(
+            [handles[idx] for idx in legend_order],
+            [labels[idx] for idx in legend_order],
+            bbox_to_anchor=(0, -0.05),
+            loc="upper left",
+            borderaxespad=0,
+            ncol=ncol,
         )
+        plt.tight_layout()
+        if save_plot:
+            plt.savefig(save_plot)
+        else:
+            plt.show()
+        return plt
```

### Comparing `pyaedt-0.6.61/pyaedt/emit.py` & `pyaedt-0.6.70/pyaedt/emit.py`

 * *Files 2% similar despite different names*

```diff
@@ -242,26 +242,31 @@
             for t, v in zip(unit_type, unit_value):
                 if t not in valid_type:
                     warnings.warn("[{}] units are not supported by EMIT. The options are: {}: ".format(t, valid_type))
                     return False
                 if v not in valid_units[t]:
                     warnings.warn("[{}] are not supported by EMIT. The options are: {}: ".format(v, valid_units[t]))
                     return False
+                ut = EmitConstants.EMIT_UNIT_TYPE_STRING_TO_ENUM[t]
+                self._emit_api.set_units(ut, v)
                 self._units[t] = v
         else:
             if unit_type not in valid_type:
                 warnings.warn(
                     "[{}] units are not supported by EMIT. The options are: {}: ".format(unit_type, valid_type)
                 )
                 return False
             if unit_value not in valid_units[unit_type]:
                 warnings.warn(
                     "[{}] are not supported by EMIT. The options are: {}: ".format(unit_value, valid_units[unit_type])
                 )
                 return False
+            # keep the backend global units synced
+            ut = EmitConstants.EMIT_UNIT_TYPE_STRING_TO_ENUM[unit_type]
+            self._emit_api.set_units(ut, unit_value)
             self._units[unit_type] = unit_value
         return True
 
     @pyaedt_function_handler()
     def get_units(self, unit_type=""):
         """Get units for the component.
```

### Comparing `pyaedt-0.6.61/pyaedt/emit_core/Couplings.py` & `pyaedt-0.6.70/pyaedt/emit_core/Couplings.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/emit_core/EmitConstants.py` & `pyaedt-0.6.70/pyaedt/emit_core/EmitConstants.py`

 * *Files 26% similar despite different names*

```diff
@@ -1,7 +1,10 @@
+import os
+import sys
+
 from pyaedt.emit_core import EMIT_MODULE
 
 
 def result_type():
     """
     Get a result type.
 
@@ -59,20 +62,49 @@
     try:
         inter_type = EMIT_MODULE.interferer_type()
     except NameError:
         raise ValueError("An Emit object must be initialized before any static member of EmitConstants is accessed.")
     return inter_type
 
 
+def unit_type():
+    """Get a ``unit_type`` object.
+    Returns
+    -------
+    :class:`EmitConstants.unit_type`
+        Type of unit. Options are ``"Power"``, ``"Frequency"``, ``"Length"``,
+        ``"Time"``, ``"Voltage"``, ``"DataRate"``, and ``"Resistance"``.
+    Examples
+    >>> unit_type = EmitConstants.unit_type()
+    """
+    try:
+        unit_type = EMIT_MODULE.unit_type()
+    except NameError:
+        raise ValueError("An Emit object must be initialized before any static member of EmitConstants is accessed.")
+    return unit_type
+
+
 EMIT_UNIT_TYPE = ["Power", "Frequency", "Length", "Time", "Voltage", "Data Rate", "Resistance"]
 """Valid unit type."""
 
 EMIT_VALID_UNITS = {
     "Power": ["mW", "W", "kW", "dBm", "dBW"],
     "Frequency": ["Hz", "kHz", "MHz", "GHz", "THz"],
     "Length": ["pm", "nm", "um", "mm", "cm", "dm", "meter", "km", "mil", "in", "ft", "yd", "mile"],
     "Time": ["ps", "ns", "us", "ms", "s"],
     "Voltage": ["mV", "V"],
     "Data Rate": ["bps", "kbps", "Mbps", "Gbps"],
     "Resistance": ["uOhm", "mOhm", "Ohm", "kOhm", "megOhm", "GOhm"],
 }
 """Valid units for each unit type."""
+
+desktop_path = os.environ.get("ANSYSEM_ROOT232")
+if desktop_path and sys.version_info < (3, 8):
+    EMIT_UNIT_TYPE_STRING_TO_ENUM = {
+        "Power": unit_type().power,
+        "Frequency": unit_type().frequency,
+        "Length": unit_type().length,
+        "Time": unit_type().time,
+        "Voltage": unit_type().voltage,
+        "Data Rate": unit_type().dataRate,
+        "Resistance": unit_type().resistance,
+    }
```

### Comparing `pyaedt-0.6.61/pyaedt/emit_core/results/results.py` & `pyaedt-0.6.70/pyaedt/emit_core/results/results.py`

 * *Files 16% similar despite different names*

```diff
@@ -136,55 +136,85 @@
         Returns
         -------
         revision_names : list str
             List of all revision names.
         """
         return [rev.name for rev in self.revisions]
 
-    @pyaedt_function_handler()
-    def analyze(self, revision_name=None):
+    @pyaedt_function_handler
+    def get_revision(self, revision_name=None):
         """
-        Analyze the specified design.
+        Load the specified revision.
 
         Parameters
         ----------
         revision_name : str
-            Revision to analyze. The default is ``None``,in which case the most recent revision
-            is loaded if it matches the current design revision.
+            Revision to load. If revision_name = None, the
+            latest revision will be returned.
 
         Returns
         -------
         rev:class:`pyaedt.modules.Revision`
-            Specified ``Revision`` object that was generated.
+            Specified ``Revision`` object that was loaded.
 
         Examples
         --------
-        >>> rev = aedtapp.results.analyze()
+        >>> rev = aedtapp.results.get_revision("Revision 15")
         >>> interferers = rev.get_interferer_names()
         >>> receivers = rev.get_receiver_names()
         """
+        # no revisions to load, create a new one
+        if len(self.revisions) == 0:
+            return self.analyze()
+        # retrieve the latest revision if nothing specified
         if revision_name is None:
-            # analyze the current design revision
-            if self.current_revision is None:
-                self.current_revision = self._add_revision()
-            elif (
-                self.current_revision.revision_number
-                == self.emit_project.odesktop.GetActiveProject().GetActiveDesign().GetRevision()
-            ):
-                # Revision exists for design rev #, load if it needed
-                if not self.current_revision.revision_loaded:
-                    self.current_revision._load_revision()
-            else:
-                # there are changes since the current revision was analyzed, create
-                # a new revision
-                self.current_revision.revision_loaded = False
-                self.current_revision = self._add_revision()
+            # unload the current revision and load the latest
+            self.current_revision.revision_loaded = False
+            self.current_revision = self.revisions[-1]
+            self.current_revision._load_revision()
         else:
             rev = [x for x in self.revisions if revision_name == x.name]
             if len(rev) > 0:
                 # unload the current revision and load the specified revision
                 self.current_revision.revision_loaded = False
                 self.current_revision = rev[0]
                 self.current_revision._load_revision()
             else:
-                print("{} not found.".format(revision_name))
+                warnings.warn("{} not found.".format(revision_name))
+        return self.current_revision
+
+    @pyaedt_function_handler()
+    def analyze(self):
+        """
+        Analyze the current revision or create a new revision if
+         the design has changed.
+
+        Parameters
+        ----------
+
+        Returns
+        -------
+        rev:class:`pyaedt.modules.Revision`
+            Specified ``Revision`` object that was generated.
+
+        Examples
+        --------
+        >>> rev = aedtapp.results.analyze()
+        >>> interferers = rev.get_interferer_names()
+        >>> receivers = rev.get_receiver_names()
+        """
+        # No revisions exist, add one
+        if self.current_revision is None:
+            self.current_revision = self._add_revision()
+        # no changes since last created revision, load it
+        elif (
+            self.revisions[-1].revision_number
+            == self.emit_project.odesktop.GetActiveProject().GetActiveDesign().GetRevision()
+        ):
+            self.get_revision(self.revisions[-1].name)
+        else:
+            # there are changes since the current revision was analyzed, create
+            # a new revision
+            self.current_revision.revision_loaded = False
+            self.current_revision = self._add_revision()
+
         return self.current_revision
```

### Comparing `pyaedt-0.6.61/pyaedt/emit_core/results/revision.py` & `pyaedt-0.6.70/pyaedt/emit_core/results/revision.py`

 * *Files 8% similar despite different names*

```diff
@@ -1,12 +1,11 @@
 import os
 import warnings
 
 import pyaedt.emit_core.EmitConstants as emitConsts
-import pyaedt.generic.constants as consts
 from pyaedt.generic.general_methods import pyaedt_function_handler
 
 
 class Revision:
     """
     Provides the ``Revision`` object.
 
@@ -29,16 +28,17 @@
     >>> domain = aedtapp.interaction_domain()
     >>> rev.run(domain)
     """
 
     def __init__(self, parent_results, emit_obj, name=""):
         design = emit_obj.odesktop.GetActiveProject().GetActiveDesign()
         subfolder = ""
+        proj_name = emit_obj.oproject.GetName()
         for f in os.scandir(emit_obj.oproject.GetPath()):
-            if os.path.splitext(f.name)[1].lower() == ".aedtresults":
+            if os.path.splitext(f.name)[0] == proj_name and os.path.splitext(f.name)[1].lower() == ".aedtresults":
                 subfolder = os.path.join(f.path, "EmitDesign1")
         default_behaviour = not os.path.exists(os.path.join(subfolder, "{}.emit".format(name)))
         if default_behaviour:
             print("The most recently generated revision will be used because the revision specified does not exist.")
         if name == "" or default_behaviour:
             # if there are no results yet, add a new Result
             result_files = os.listdir(subfolder)
@@ -59,14 +59,19 @@
 
         self.emit_project = emit_obj
         """Emit project."""
 
         self.revision_number = design.GetRevision()
         """Unique revision number from the Emit design"""
 
+        result_props = design.GetResultProperties(name)
+        # Strip off the 'Timestamp='
+        self.timestamp = result_props[1][10:]
+        """Unique timestamp for the revision"""
+
         self.parent_results = parent_results
         """Parent Results object"""
 
         # load the revision after creating it
         self.revision_loaded = False
         """``True`` if the revision is loaded and ``False`` if it is not."""
         self._load_revision()
@@ -83,15 +88,14 @@
             For example, "Revision 1.emit"
 
         Examples
         ----------
         >>> aedtapp.results.revision.load_revision()
         """
         if self.revision_loaded:
-            print("Specified result already loaded.")
             return
         self.parent_results._unload_revisions()
         self.emit_project._emit_api.load_project(self.path)
         self.revision_loaded = True
 
     @staticmethod
     def result_mode_error():
@@ -123,49 +127,19 @@
         >>> domain = aedtapp.results.interaction_domain()
         >>> rev.run(domain)
 
         """
         self._load_revision()
         engine = self.emit_project._emit_api.get_engine()
         interaction = engine.run(domain)
+        # save the revision
+        self.emit_project._emit_api.save_project()
         return interaction
 
     @pyaedt_function_handler()
-    def get_max_simultaneous_interferers(self):
-        """
-        Get the number of maximum simultaneous interferers.
-
-        Returns
-        -------
-        max_interferers : int
-            Maximum number of simultaneous interferers associated with engine
-
-        Examples
-        ----------
-        >>> max_num = aedtapp.results.current_revision.get_max_simultaneous_interferers()
-        """
-        self._load_revision()
-        engine = self.emit_project._emit_api.get_engine()
-        max_interferers = engine.max_simultaneous_interferers
-        return max_interferers
-
-    @pyaedt_function_handler()
-    def set_max_simultaneous_interferers(self, val):
-        """
-        Set the number of maximum simultaneous interferers.
-
-        Examples
-        ----------
-        >>> max_num = aedtapp.results.current_revision.set_max_simultaneous_interferers(3)
-        """
-        self._load_revision()
-        engine = self.emit_project._emit_api.get_engine()
-        engine.max_simultaneous_interferers = val
-
-    @pyaedt_function_handler()
     def is_domain_valid(self, domain):
         """
         Return ``True`` if the given domain is valid for the current revision.
 
         Parameters
         ----------
         domain :
@@ -316,25 +290,65 @@
         tx_rx : tx_rx_mode object
             Specifies whether to get ``tx`` or ``rx`` radio freqs.
         units : str
             Units for the frequencies.
 
         Returns
         -------
-        freq:class:`list of float`
+        freqs : List of float
             List of ``tx`` or ``rx`` radio/emitter frequencies.
 
         Examples
         ----------
         >>> freqs = aedtapp.results.current_revision.get_active_frequencies(
                 'Bluetooth', 'Rx - Base Data Rate', Emit.tx_rx_mode.rx)
         """
         if self.revision_loaded:
-            freq = self.emit_project._emit_api.get_active_frequencies(radio_name, band_name, tx_rx_mode)
-            # Emit api returns freqs in Hz, convert to user's desired units.
-            if not units or units not in emitConsts.EMIT_VALID_UNITS["Frequency"]:
-                units = self.emit_project._units["Frequency"]
-            freq = consts.unit_converter(freq, "Freq", "Hz", units)
+            freqs = self.emit_project._emit_api.get_active_frequencies(radio_name, band_name, tx_rx_mode, units)
         else:
-            freq = None
+            freqs = None
             self.result_mode_error()
-        return freq
+        return freqs
+
+    @pyaedt_function_handler
+    def set_notes(self, notes):
+        """
+        Add notes to the revision.
+
+        Parameters
+        ----------
+        notes : str
+            Notes to add to the revision.
+
+        Returns
+        -------
+        None
+
+        Examples
+        ----------
+        >>> notes = "Added a filter to the WiFi Radio."
+        >>> freqs = aedtapp.results.current_revision.set_notes(notes)
+        """
+        design = self.emit_project.odesktop.GetActiveProject().GetActiveDesign()
+        design.SetResultNotes(self.name, notes)
+        self.emit_project._emit_api.save_project()
+
+    @pyaedt_function_handler
+    def get_notes(self):
+        """
+        Get the current revision's notes.
+
+        Parameters
+        ----------
+        None
+
+        Returns
+        -------
+        notes : str
+            Notes to add to the revision.
+
+        Examples
+        ----------
+        >>> notes = aedtapp.results.current_revision.get_notes()
+        """
+        design = self.emit_project.odesktop.GetActiveProject().GetActiveDesign()
+        return design.GetResultNotes(self.name)
```

### Comparing `pyaedt-0.6.61/pyaedt/generic/DataHandlers.py` & `pyaedt-0.6.70/pyaedt/generic/DataHandlers.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/LoadAEDTFile.py` & `pyaedt-0.6.70/pyaedt/generic/LoadAEDTFile.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/clr_module.py` & `pyaedt-0.6.70/pyaedt/generic/clr_module.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/configurations.py` & `pyaedt-0.6.70/pyaedt/generic/configurations.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/constants.py` & `pyaedt-0.6.70/pyaedt/generic/constants.py`

 * *Files 1% similar despite different names*

```diff
@@ -154,15 +154,15 @@
     input_units : str
         Input units. Default is `"meter"`.
     output_units : str
         Output units. Default is `"mm"`.
 
     Returns
     -------
-    float
+    float, list
         Converted value.
     """
     if unit_system in AEDT_UNITS:
         if input_units not in AEDT_UNITS[unit_system]:
             warnings.warn("Unknown units: '{}'".format(input_units))
             return values
         elif output_units not in AEDT_UNITS[unit_system]:
@@ -894,50 +894,14 @@
         UNIM,
         DCM,
         CPSM,
         NSSM,
     ) = range(0, 52)
 
 
-class CoordinateSystemAxis(object):
-    """CoordinateSystemAxis class.
-
-    .. deprecated:: 0.4.8
-        Use :func:`AXIS` instead."""
-
-    (XAxis, YAxis, ZAxis) = range(0, 3)
-
-
-class CoordinateSystemPlane(object):
-    """CoordinateSystemPlane class.
-
-    .. deprecated:: 0.4.8
-        Use :func:`PLANE` instead."""
-
-    (YZPlane, ZXPlane, XYPlane) = range(0, 3)
-
-
-class Plane(object):
-    """Plane class.
-
-    .. deprecated:: 0.4.8
-        Use :func:`VIEW` instead."""
-
-    (XYPlane, YZPlane, ZXPlane, ISO) = ("XY", "YZ", "ZX", "iso")
-
-
-class GravityDirection(object):
-    """GravityDirection class.
-
-    .. deprecated:: 0.4.8
-        Use :func:`GRAVITY` instead."""
-
-    (XNeg, YNeg, ZNeg, XPos, YPos, ZPos) = range(0, 6)
-
-
 CSS4_COLORS = {
     "chocolate": "#D2691E",
     "darkgreen": "#006400",
     "orangered": "#FF4500",
     "darkseagreen": "#8FBC8F",
     "darkmagenta": "#8B008B",
     "saddlebrown": "#8B4513",
```

### Comparing `pyaedt-0.6.61/pyaedt/generic/design_types.py` & `pyaedt-0.6.70/pyaedt/generic/design_types.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/filesystem.py` & `pyaedt-0.6.70/pyaedt/generic/filesystem.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/general_methods.py` & `pyaedt-0.6.70/pyaedt/generic/general_methods.py`

 * *Files 2% similar despite different names*

```diff
@@ -200,14 +200,40 @@
         wrapper = _function_handler_wrapper(user_function)
         return update_wrapper(wrapper, user_function)
 
     return decorating_function
 
 
 @pyaedt_function_handler()
+def check_numeric_equivalence(a, b, relative_tolerance=1e-7):
+    """Check if two numeric values are equivalent to within a relative tolerance.
+
+    Paraemters
+    ----------
+    a : int, float
+        Reference value to compare to.
+    b : int, float
+        Secondary value for the comparison.
+    relative_tolerance : float, optional
+        Relative tolerance for the equivalence test. The difference is relative to the first value.
+        The default is ``1E-7``.
+
+    Returns
+    -------
+    bool
+        ``True`` if the two passed values are equivalent.
+    """
+    if abs(a) > 0.0:
+        reldiff = abs(a - b) / a
+    else:
+        reldiff = abs(b)
+    return True if reldiff < relative_tolerance else False
+
+
+@pyaedt_function_handler()
 def check_and_download_file(local_path, remote_path, overwrite=True):
     """Check if a file is remote and either download it or return the path.
 
     Parameters
     ----------
     local_path : str
         Local path to save the file to.
@@ -1584,14 +1610,53 @@
         self._edb_dll_path = None
         self._lsf_num_cores = 2
         self._lsf_ram = 1000
         self._use_lsf_scheduler = False
         self._lsf_aedt_command = "ansysedt"
         self._lsf_timeout = 3600
         self._lsf_queue = None
+        self._aedt_environment_variables = {
+            "ANS_MESHER_PROC_DUMP_PREPOST_BEND_SM3": "1",
+            "ANSYSEM_FEATURE_SF6694_NON_GRAPHICAL_COMMAND_EXECUTION_ENABLE": "1",
+            "ANSYSEM_FEATURE_SF159726_SCRIPTOBJECT_ENABLE": "1",
+            "ANSYSEM_FEATURE_SF222134_CABLE_MODELING_ENHANCEMENTS_ENABLE": "1",
+            "ANSYSEM_FEATURE_F395486_RIGID_FLEX_BENDING_ENABLE": "1",
+        }
+        if is_linux:
+            self._aedt_environment_variables["ANS_NODEPCHECK"] = "1"
+        self._desktop_launch_timeout = 90
+
+    @property
+    def desktop_launch_timeout(self):
+        """Set the desktop launcher max timeout. Default is ``90`` seconds.
+
+        Returns
+        -------
+        int
+        """
+        return self._desktop_launch_timeout
+
+    @desktop_launch_timeout.setter
+    def desktop_launch_timeout(self, value):
+        self._desktop_launch_timeout = int(value)
+
+    @property
+    def aedt_environment_variables(self):
+        """Set environment variables to be set before launching a new aedt session.
+        This includes beta features enablemement.
+
+        Returns
+        -------
+        dict
+        """
+        return self._aedt_environment_variables
+
+    @aedt_environment_variables.setter
+    def aedt_environment_variables(self, value):
+        self._aedt_environment_variables = value
 
     @property
     def lsf_queue(self):
         """LSF queue name. This attribute is valid only on Linux
         systems running LSF Scheduler."""
         return self._lsf_queue
```

### Comparing `pyaedt-0.6.61/pyaedt/generic/ibis_reader.py` & `pyaedt-0.6.70/pyaedt/generic/ibis_reader.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/near_field_import.py` & `pyaedt-0.6.70/pyaedt/generic/near_field_import.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/plot.py` & `pyaedt-0.6.70/pyaedt/generic/plot.py`

 * *Files 2% similar despite different names*

```diff
@@ -465,14 +465,16 @@
     show_legend=True,
     xlabel="",
     ylabel="",
     title="",
     snapshot_path=None,
     x_limits=None,
     y_limits=None,
+    annotations=None,
+    show=True,
 ):
     """Create a matplotlib plot based on a list of data.
 
     Parameters
     ----------
     plot_data : list of list
         List of plot data. Every item has to be in the following format
@@ -488,17 +490,21 @@
     ylabel : str
         Plot Y label.
     title : str
         Plot Title label.
     snapshot_path : str
         Full path to image file if a snapshot is needed.
     x_limits : list, optional
-        List of x limits (bottom and top).
+        List of x limits (left and right).
     y_limits : list, optional
         List of y limits (bottom and top).
+    annotations : list, optional
+        List of annotations to add to the plot. [x,y,string, dictionary of font options]
+    show : bool, optional
+        Whether to show the plot or return the matplotlib object. Default is `True`.
 
 
     Returns
     -------
     :class:`matplotlib.plt`
         Matplotlib fig object.
     """
@@ -519,23 +525,27 @@
         elif points[-1] == "contour":
             path = Path(points[0], points[1])
             patch = PathPatch(path, color=points[2], alpha=points[4], label=points[3], fill=False, linewidth=points[5])
             ax.add_patch(patch)
 
     ax.set(xlabel=xlabel, ylabel=ylabel, title=title)
     if show_legend:
-        ax.legend()
+        ax.legend(loc="upper right")
     # ax.axis("equal")
     if x_limits:
         ax.set_xlim(x_limits)
     if y_limits:
         ax.set_ylim(y_limits)
+    if annotations:
+        for annotation in annotations:
+            plt.text(annotation[0], annotation[1], annotation[2], **annotation[3])
+
     if snapshot_path:
         plt.savefig(snapshot_path)
-    else:
+    elif show:
         plt.show()
     return plt
 
 
 @pyaedt_function_handler()
 def plot_contour(qty_to_plot, x, y, size=(2000, 1600), xlabel="", ylabel="", title="", levels=64, snapshot_path=None):
     """Create a matplotlib contour plot.
```

### Comparing `pyaedt-0.6.61/pyaedt/generic/process.py` & `pyaedt-0.6.70/pyaedt/generic/process.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/python_optimizers.py` & `pyaedt-0.6.70/pyaedt/generic/python_optimizers.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/report_file_parser.py` & `pyaedt-0.6.70/pyaedt/generic/report_file_parser.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/toolkit.py` & `pyaedt-0.6.70/pyaedt/generic/toolkit.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/generic/touchstone_parser.py` & `pyaedt-0.6.70/pyaedt/generic/touchstone_parser.py`

 * *Files 5% similar despite different names*

```diff
@@ -132,14 +132,39 @@
 
         if plot:  # pragma: no cover
             for i in temp_list:
                 self.plot_s_db(*i, logx=self.log_x)
             plt.show()
         return temp_list
 
+    def plot(self, index_couples=None, show=True):
+        """Plot a list of curves.
+
+        Parameters
+        ----------
+        index_couples : list, optional
+            List of indexes couple to plot. Default is ``None`` to plot all ``port_tuples``.
+        show: bool
+            Whether to plot.
+
+        Returns
+        -------
+        :class:`matplotlib.plt`
+        """
+        temp_list = []
+        freq_idx = 0
+        if not index_couples:
+            index_couples = self.port_tuples[:]
+
+        for i in index_couples:
+            self.plot_s_db(*i, logx=self.log_x)
+        if show:
+            plt.show()
+        return plt
+
     def plot_return_losses(self):  # pragma: no cover
         """Plot all return losses.
 
         Parameters
         ----------
         Returns
         -------
```

### Comparing `pyaedt-0.6.61/pyaedt/hfss.py` & `pyaedt-0.6.70/pyaedt/hfss.py`

 * *Files 2% similar despite different names*

```diff
@@ -546,57 +546,14 @@
         props["Modes"] = modes
         props["ShowReporterFilter"] = False
         props["ReporterFilter"] = report_filter
         props["UseAnalyticAlignment"] = False
         return self._create_boundary(portname, props, "Wave Port")
 
     @pyaedt_function_handler()
-    def assigncoating(
-        self,
-        obj,
-        mat=None,
-        cond=58000000,
-        perm=1,
-        usethickness=False,
-        thickness="0.1mm",
-        roughness="0um",
-        isinfgnd=False,
-        istwoside=False,
-        isInternal=True,
-        issheelElement=False,
-        usehuray=False,
-        radius="0.5um",
-        ratio="2.9",
-    ):
-        """Assign finite conductivity to one or more objects of a given material.
-
-        .. deprecated:: 0.4.5
-           Use :func:`Hfss.assign_coating` instead.
-
-        """
-
-        warnings.warn("`assigncoating` is deprecated. Use `assign_coating` instead.", DeprecationWarning)
-        self.assign_coating(
-            obj,
-            mat,
-            cond,
-            perm,
-            usethickness,
-            thickness,
-            roughness,
-            isinfgnd,
-            istwoside,
-            isInternal,
-            issheelElement,
-            usehuray,
-            radius,
-            ratio,
-        )
-
-    @pyaedt_function_handler()
     def assign_coating(
         self,
         obj,
         mat=None,
         cond=58000000,
         perm=1,
         usethickness=False,
@@ -786,54 +743,14 @@
                 else:
                     setup[arg_name] = arg_value
         setup.auto_update = True
         setup.update()
         return setup
 
     @pyaedt_function_handler()
-    def create_frequency_sweep(
-        self,
-        setupname,
-        unit="GHz",
-        freqstart=1e-3,
-        freqstop=10,
-        sweepname=None,
-        num_of_freq_points=451,
-        sweeptype="Interpolating",
-        interpolation_tol=0.5,
-        interpolation_max_solutions=250,
-        save_fields=True,
-        save_rad_fields=False,
-    ):
-        """Create a frequency sweep.
-
-        .. deprecated:: 0.4.0
-           Use :func:`Hfss.create_linear_count_sweep` instead.
-
-        """
-        warnings.warn(
-            "`create_frequency_sweep` is deprecated. Use `create_linear_count_sweep` instead.",
-            DeprecationWarning,
-        )
-
-        return self.create_linear_count_sweep(
-            setupname=setupname,
-            unit=unit,
-            freqstart=freqstart,
-            freqstop=freqstop,
-            num_of_freq_points=num_of_freq_points,
-            sweepname=sweepname,
-            save_fields=save_fields,
-            save_rad_fields=save_rad_fields,
-            sweep_type=sweeptype,
-            interpolation_tol=interpolation_tol,
-            interpolation_max_solutions=interpolation_max_solutions,
-        )
-
-    @pyaedt_function_handler()
     def create_linear_count_sweep(
         self,
         setupname,
         unit,
         freqstart,
         freqstop,
         num_of_freq_points=None,
@@ -1810,14 +1727,23 @@
             The default is ``None``.
 
         Returns
         -------
         :class:`pyaedt.modules.Boundary.BoundaryObject`
             Boundary object.
 
+        Examples
+        --------
+        >>> aedtapp = Hfss()
+        >>> aedtapp.insert_design("Design_Terminal_2")
+        >>> aedtapp.solution_type = "Terminal"
+        >>> box1 = aedtapp.modeler.create_box([-100, -100, 0], [200, 200, 5], name="gnd2z", matname="copper")
+        >>> box2 = aedtapp.modeler.create_box([-100, -100, 20], [200, 200, 25], name="sig2z", matname="copper")
+        >>> aedtapp.modeler.fit_all()
+        >>> portz = aedtapp.create_spiral_lumped_port(box1, box2)
         """
         if not "Terminal" in self.solution_type:
             raise Exception("This method can be used only in Terminal solutions.")
         start_object = self.modeler.convert_to_selections(start_object)
         end_object = self.modeler.convert_to_selections(end_object)
 
         # find the closest faces (based on face center)
@@ -1881,15 +1807,15 @@
                 filling = 1.5
         # fmt: on
 
         name = generate_unique_name("P", n=3)
 
         spiral = self.modeler.create_spiral_on_face(closest_faces[0], spiral_width, filling_factor=filling)
         spiral.name = name
-        spiral.translate(move_vector_mid)
+        spiral.move(move_vector_mid)
         spiral_center = GeometryOperators.get_mid_point(closest_faces[0].center, closest_faces[1].center)
 
         # get the polyline center point (before width operation). They need to be moved as well.
         poly_points = [GeometryOperators.v_sum(i, move_vector_mid) for i in spiral.points]
 
         # get the vertices of the spiral created. These need to be divided in two lists, one following the external
         # contour (p1) and one following the internal contour (p2). We use poly_points to discern the points.
@@ -1953,15 +1879,15 @@
         )
 
         # assign pec to created polylines
         self.assign_perfecte_to_sheets(poly1, sourcename=start_object)
         self.assign_perfecte_to_sheets(poly2, sourcename=end_object)
 
         # create lumped port on spiral
-        port = self.create_lumped_port_to_sheet(spiral, reference_object_list=[poly2.name], portname=name)
+        port = self.lumped_port(spiral, reference=[poly2.name], name=name)
 
         return port
 
     @pyaedt_function_handler()
     def create_voltage_source_from_objects(self, startobj, endobject, axisdir=0, sourcename=None, source_on_plane=True):
         """Create a voltage source taking the closest edges of two objects.
 
@@ -2120,14 +2046,17 @@
         renorm=True,
         deembed_dist=0,
         port_on_plane=True,
         add_pec_cap=False,
     ):
         """Create a waveport taking the closest edges of two objects.
 
+        .. deprecated:: 0.6.62
+           Use :func:`wave_port` metho instead.
+
         Parameters
         ----------
         startobj :
             Starting object for the integration line.
         endobject :
             Ending object for the integration line.
         axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
@@ -2172,50 +2101,30 @@
         ...                                           "BoxWave2", "copper")
         >>> wave_port = hfss.create_wave_port_between_objects("BoxWave1", "BoxWave2",
         ...                                                   hfss.AxisDir.XNeg, 50, 1,
         ...                                                   "Wave Port", False)
         pyaedt INFO: Connection Correctly created
 
         """
-
-        if not self.modeler.does_object_exists(startobj) or not self.modeler.does_object_exists(endobject):
-            self.logger.error("One or both objects do not exist. Check and retry.")
-            return False
-        if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
-            sheet_name, point0, point1 = self.modeler._create_sheet_from_object_closest_edge(
-                startobj, endobject, axisdir, port_on_plane
-            )
-            if add_pec_cap:
-                dist = math.sqrt(self.modeler[sheet_name].faces[0].area)
-                if settings.aedt_version > "2022.2":
-                    self._create_pec_cap(sheet_name, startobj, -dist / 10)
-                else:
-                    self._create_pec_cap(sheet_name, startobj, dist / 10)
-            portname = self._get_unique_source_name(portname, "Port")
-
-            if "Modal" in self.solution_type:
-                return self._create_waveport_driven(
-                    sheet_name, point0, point1, impedance, portname, renorm, nummodes, deembed_dist
-                )
-            else:
-                faces = self.modeler.get_object_faces(sheet_name)
-                if deembed_dist == 0:
-                    deembed = None
-                else:
-                    deembed = deembed_dist
-                return self._create_port_terminal(
-                    faces[0],
-                    endobject,
-                    portname,
-                    renorm=renorm,
-                    deembed=deembed,
-                    iswaveport=True,
-                    impedance=impedance,
-                )
-        return False  # pragma: no cover
+        warnings.warn(
+            "`create_wave_port_between_objects` is deprecated. Use `wave_port` property instead.", DeprecationWarning
+        )
+        return self.wave_port(
+            signal=startobj,
+            reference=endobject,
+            integration_line=axisdir,
+            create_port_sheet=True,
+            impedance=impedance,
+            num_modes=nummodes,
+            name=portname,
+            renormalize=renorm,
+            deembed=deembed_dist,
+            port_on_plane=port_on_plane,
+            add_pec_cap=add_pec_cap,
+        )
 
     @pyaedt_function_handler()
     def create_floquet_port(
         self,
         face,
         lattice_origin=None,
         lattice_a_end=None,
@@ -2584,14 +2493,17 @@
         renorm=True,
         deembed_dist=0,
         vfactor=3,
         hfactor=5,
     ):
         """Create a waveport taking the closest edges of two objects.
 
+        .. deprecated:: 0.6.62
+            `create_wave_port_microstrip_between_objects` is deprecated. Use `wave_port` property instead.
+
         Parameters
         ----------
         startobj :
             Starting object for the integration line. This is typically the reference plane.
         endobject :
             Ending object for the integration line.
         axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
@@ -2637,45 +2549,32 @@
         ...                               name="GND1", matname="FR4_epoxy")
         >>> port = hfss.create_wave_port_microstrip_between_objects("GND1", "MS1",
         ...                                                         portname="MS1",
         ...                                                         axisdir=1)
         pyaedt INFO: Connection correctly created.
 
         """
-        if not self.modeler.does_object_exists(startobj) or not self.modeler.does_object_exists(endobject):
-            self.logger.error("One or both objects do not exist. Check and retry.")
-            return False
-        if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
-            sheet_name, point0, point1 = self.modeler._create_microstrip_sheet_from_object_closest_edge(
-                startobj, endobject, axisdir, vfactor, hfactor
-            )
-            dist = GeometryOperators.points_distance(point0, point1)
-            self._create_pec_cap(sheet_name, startobj, dist / 10)
-            portname = self._get_unique_source_name(portname, "Port")
-
-            if "Modal" in self.solution_type:
-                return self._create_waveport_driven(
-                    sheet_name, point0, point1, impedance, portname, renorm, nummodes, deembed_dist
-                )
-            else:
-                faces = self.modeler.get_object_faces(sheet_name)
-                if deembed_dist == 0:
-                    deembed = None
-                else:
-                    deembed = deembed_dist
-                return self._create_port_terminal(
-                    faces[0],
-                    endobject,
-                    portname,
-                    renorm=renorm,
-                    deembed=deembed,
-                    iswaveport=True,
-                    impedance=impedance,
-                )
-        return False
+        warnings.warn(
+            "`create_wave_port_microstrip_between_objects` is deprecated. Use `wave_port` property instead.",
+            DeprecationWarning,
+        )
+        return self.wave_port(
+            signal=startobj,
+            reference=endobject,
+            integration_line=axisdir,
+            create_port_sheet=True,
+            impedance=impedance,
+            num_modes=nummodes,
+            name=portname,
+            renormalize=renorm,
+            deembed=deembed_dist,
+            is_microstrip=True,
+            vfactor=vfactor,
+            hfactor=hfactor,
+        )
 
     @pyaedt_function_handler()
     def create_perfecte_from_objects(
         self, startobj, endobject, axisdir=0, sourcename=None, is_infinite_gnd=False, bound_on_plane=True
     ):
         """Create a Perfect E taking the closest edges of two objects.
 
@@ -2798,25 +2697,14 @@
                 sourcename = generate_unique_name("PerfH")
             elif sourcename in self.modeler.get_boundaries_name():
                 sourcename = generate_unique_name(sourcename)
             return self.create_boundary(self.BoundaryType.PerfectH, sheet_name, sourcename)
         return None
 
     @pyaedt_function_handler()
-    def SARSetup(self, Tissue_object_List_ID, TissueMass=1, MaterialDensity=1, voxel_size=1, Average_SAR_method=0):
-        """Define SAR settings.
-
-        .. deprecated:: 0.4.5
-           Use :func:`Hfss.sar_setup` instead.
-
-        """
-        warnings.warn("`SARSetup` is deprecated. Use `sar_setup` instead.", DeprecationWarning)
-        self.sar_setup(Tissue_object_List_ID, TissueMass, MaterialDensity, voxel_size, Average_SAR_method)
-
-    @pyaedt_function_handler()
     def sar_setup(self, Tissue_object_List_ID, TissueMass=1, MaterialDensity=1, voxel_size=1, Average_SAR_method=0):
         """Define SAR settings.
 
         Parameters
         ----------
         Tissue_object_List_ID : int
 
@@ -3167,14 +3055,17 @@
         nummodes=1,
         portname=None,
         renorm=True,
         terminal_references=None,
     ):
         """Create a waveport on sheet objects created starting from sheets.
 
+        .. deprecated:: 0.6.62
+            `create_wave_port_from_sheet` is deprecated. Use `wave_port` property instead.
+
         Parameters
         ----------
         sheet : str or int or list or :class:`pyaedt.modeler.object3d.Object3d`
             Name of the sheet.
         deemb : float, optional
             Deembedding value distance in model units. The default is ``0``.
         axisdir : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
@@ -3215,67 +3106,28 @@
         >>> hfss.solution_type = "Modal"
         >>> port = hfss.create_wave_port_from_sheet(circle, 5, hfss.AxisDir.XNeg, 40, 2,
         ...                                         "WavePortFromSheet", True)
         >>> port[0].name
         'WavePortFromSheet'
 
         """
-
-        sheet = self.modeler.convert_to_selections(sheet, True)[0]
-        if terminal_references:
-            terminal_references = self.modeler.convert_to_selections(terminal_references, True)
-        if isinstance(sheet, int):
-            try:
-                oname = self.modeler.oeditor.GetObjectNameByFaceID(sheet)
-            except:
-                oname = ""
-        else:
-            oname = ""
-        if "Modal" in self.solution_type:
-            if axisdir:
-                try:
-                    _, int_start, int_stop = self._get_reference_and_integration_points(sheet, axisdir, oname)
-                except (IndexError, TypeError):
-                    int_start = int_stop = None
-            else:
-                int_start = int_stop = None
-            portname = self._get_unique_source_name(portname, "Port")
-
-            return self._create_waveport_driven(
-                sheet, int_start, int_stop, impedance, portname, renorm, nummodes, deemb
-            )
-        else:
-            if isinstance(sheet, int):
-                faces = sheet
-            else:
-                faces = self.modeler.get_object_faces(sheet)[0]
-            if not faces:  # pragma: no cover
-                self.logger.error("Wrong Input object. it has to be a face id or a sheet.")
-                return False
-            if not portname:
-                portname = generate_unique_name("Port")
-            elif portname in self.excitations:
-                portname = generate_unique_name(portname)
-            if terminal_references:
-                if deemb == 0:
-                    deembed = None
-                else:
-                    deembed = deemb
-                return self._create_port_terminal(
-                    faces,
-                    terminal_references,
-                    portname,
-                    renorm=renorm,
-                    deembed=deembed,
-                    iswaveport=True,
-                    impedance=impedance,
-                )
-            else:
-                self.logger.error("Reference conductors are missing.")
-                return False
+        warnings.warn(
+            "`create_wave_port_from_sheet` is deprecated. Use `wave_port` property instead.", DeprecationWarning
+        )
+        return self.wave_port(
+            signal=sheet,
+            reference=terminal_references,
+            integration_line=axisdir,
+            create_port_sheet=False,
+            impedance=impedance,
+            num_modes=nummodes,
+            name=portname,
+            renormalize=renorm,
+            deembed=deemb,
+        )
 
     @pyaedt_function_handler()
     def create_wave_port(
         self,
         port_item,  # Item to use for wave port creation
         int_start,
         int_stop,
@@ -3285,14 +3137,17 @@
         nummodes=1,
         portname=None,
         renorm=True,
         terminal_references=None,
     ):
         """Assign a wave port to a face given a point on the face.
 
+        .. deprecated:: 0.6.62
+            `create_wave_port` is deprecated. Use `wave_port` property instead.
+
         Parameters
         ----------
         port_item : list, int
             Item for defining where to create the port.
             If a list is passed, then Cartesian [x,y,z] coordinates of a point on the face are
             expected. If an integer is passed, it is assumed to be a face ID.
         deemb : float, optional
@@ -3335,67 +3190,36 @@
         >>> setup = hfss.create_setup("Setup1")
         >>> setup["Frequency"] = "10GHz"
         >>> ports = [ hfss.create_wave_port([0, "a/2", "-wg_len/2"], portname="Port1", deembed=False),
         >>>  ...      hfss.create_wave_port([0, "a/2", "wg_len/2"], portname="Port2", deembed=False) ]
         >>> [print(name) for p.name in ports]
 
         """
-        # TODO: check that port_item is a planar sheet
-        if terminal_references:
-            terminal_references = self.modeler.convert_to_selections(terminal_references, True)
-        if isinstance(port_item, int):
-            try:
-                oname = self.modeler.oeditor.GetObjectNameByFaceID(port_item)
-            except:
-                oname = ""
-        else:
-            oname = ""
-        if "Modal" in self.solution_type:
-            if portname is None:
-                portname = self._get_unique_source_name(portname, "Port")
-
-            return self._create_waveport_driven(
-                port_item, int_start, int_stop, impedance, portname, renorm, nummodes, deemb
-            )
-        else:
-            if isinstance(port_item, int):
-                faces = port_item
-            else:
-                faces = self.modeler.get_object_faces(port_item)[0]
-            if not faces:  # pragma: no cover
-                self.logger.error("Input object is wrong. It must be a face ID or a sheet.")
-                return False
-            if not portname:
-                portname = generate_unique_name("Port")
-            elif portname in self.excitations:
-                portname = generate_unique_name(portname)
-            if terminal_references:
-                if deemb == 0:
-                    deembed = None
-                else:
-                    deembed = deemb
-                return self._create_port_terminal(
-                    faces,
-                    terminal_references,
-                    portname,
-                    renorm=renorm,
-                    deembed=deembed,
-                    iswaveport=True,
-                    impedance=impedance,
-                )
-            else:
-                self.logger.error("Reference conductors are missing.")
-                return False
+        warnings.warn("`create_wave_port` is deprecated. Use `wave_port` property instead.", DeprecationWarning)
+        return self.wave_port(
+            signal=port_item,
+            reference=terminal_references,
+            integration_line=[int_start, int_stop],
+            create_port_sheet=True,
+            impedance=impedance,
+            num_modes=nummodes,
+            name=portname,
+            renormalize=renorm,
+            deembed=deemb,
+        )
 
     @pyaedt_function_handler()
     def create_lumped_port_to_sheet(
         self, sheet_name, axisdir=0, impedance=50, portname=None, renorm=True, deemb=False, reference_object_list=[]
     ):
         """Create a lumped port taking one sheet.
 
+        .. deprecated:: 0.6.62
+            `create_lumped_port_to_sheet` is deprecated. Use `lumped` property instead.
+
         Parameters
         ----------
         sheet_name : str
             Name of the sheet.
         axisdir : int, :class:`pyaedt.application.Analysis.Analysis.AxisDir` or list, optional
             Direction of the integration line. It should be one of the values for ``Application.AxisDir``,
             which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``. It also accepts the list
@@ -3433,76 +3257,27 @@
         >>> h1 = hfss.create_lumped_port_to_sheet(rectangle.name, hfss.AxisDir.XNeg, 50,
         ...                                  "LumpedPortFromSheet", True, False)
         >>> h2 = hfss.create_lumped_port_to_sheet(rectangle.name, [rectangle.bottom_edge_x.midpoint,
         ...                                     rectangle.bottom_edge_y.midpoint], 50, "LumpedPortFromSheet", True,
         ...                                     False)
 
         """
-        sheet_name = self.modeler.convert_to_selections(sheet_name, False)
-        if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
-            if isinstance(axisdir, list):
-                if len(axisdir) != 2 or len(axisdir[0]) != len(axisdir[1]):
-                    self.logger.error("List of coordinates is not set correctly")
-                    return False
-                point0 = axisdir[0]
-                point1 = axisdir[1]
-            else:
-                point0, point1 = self.modeler.get_mid_points_on_dir(sheet_name, axisdir)
-
-            portname = self._get_unique_source_name(portname, "Port")
-
-            port = False
-            if "Modal" in self.solution_type:
-                port = self._create_lumped_driven(sheet_name, point0, point1, impedance, portname, renorm, deemb)
-            else:
-                if not reference_object_list:
-                    cond = self.get_all_conductors_names()
-                    touching = self.modeler.get_bodynames_from_position(point0)
-                    reference_object_list = []
-                    for el in touching:
-                        if el in cond:
-                            reference_object_list.append(el)
-                if isinstance(sheet_name, int):
-                    faces = sheet_name
-                else:
-                    faces = self.modeler.get_object_faces(sheet_name)[0]
-                if not faces:  # pragma: no cover
-                    self.logger.error("Wrong input object. It must be a face ID or a sheet.")
-                    return False
-                if deemb:
-                    deembed = 0
-                else:
-                    deembed = None
-                port = self._create_port_terminal(
-                    faces,
-                    reference_object_list,
-                    portname,
-                    renorm=renorm,
-                    deembed=deembed,
-                    iswaveport=False,
-                    impedance=impedance,
-                )
-
-            return port
-        return False
-
-    @pyaedt_function_handler()
-    def assig_voltage_source_to_sheet(self, sheet_name, axisdir=0, sourcename=None):
-        """Create a voltage source taking one sheet.
-
-        .. deprecated:: 0.4.0
-           Use :func:`Hfss.assign_voltage_source_to_sheet` instead.
-
-        """
-
         warnings.warn(
-            "`assig_voltage_source_to_sheet` is deprecated. Use `assign_voltage_source_to_sheet` instead.",
-            DeprecationWarning,
+            "`create_lumped_port_to_sheet` is deprecated. Use `lumped_port` property instead.", DeprecationWarning
+        )
+        return self.lumped_port(
+            signal=sheet_name,
+            reference=reference_object_list,
+            integration_line=axisdir,
+            create_port_sheet=False,
+            impedance=impedance,
+            name=portname,
+            renormalize=renorm,
+            deembed=deemb,
         )
-        self.assign_voltage_source_to_sheet(sheet_name, axisdir, sourcename)
 
     @pyaedt_function_handler()
     def assign_voltage_source_to_sheet(self, sheet_name, axisdir=0, sourcename=None):
         """Create a voltage source taking one sheet.
 
         Parameters
         ----------
@@ -6074,7 +5849,385 @@
             export_as_single_objects=True,
             air_objects=False,
         )
         for file in files:
             hdm.add_cad_model(file[0], file[1], file[2], self.modeler.model_units)
         hdm.add_hdm_bundle_from_file(filename)
         return hdm
+
+    @pyaedt_function_handler()
+    def circuit_port(
+        self,
+        signal,
+        reference,
+        port_location=0,
+        impedance=50,
+        name=None,
+        renormalize=True,
+        renorm_impedance=50,
+        deembed=False,
+    ):
+        """Create a circuit port from two objects.
+
+        The integration line is from edge 2 to edge 1.
+
+        Parameters
+        ----------
+        signal : int or :class:`pyaedt.modeler.object3d.Object3d` or
+         :class:`pyaedt.modeler.cad.FacePrimitive`or :class:`pyaedt.modeler.cad.EdgePrimitive`
+            Signal object.
+        reference : int or :class:`pyaedt.modeler.object3d.Object3d` or
+         :class:`pyaedt.modeler.cad.FacePrimitive`or :class:`pyaedt.modeler.cad.EdgePrimitive`
+            Reference object.
+        port_location : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
+            Position of the port when an object different from an edge is provided.
+            It should be one of the values for ``Application.AxisDir``,
+            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
+            The default is ``Application.AxisDir.XNeg``.
+        name : str, optional
+            Name of the port. The default is ``""``.
+        impedance : int, str, or float, optional
+            Impedance. The default is ``"50"``. You can also
+            enter a string that looks like this: ``"50+1i*55"``.
+        renormalize : bool, optional
+            Whether to renormalize the mode. The default is ``False``.
+            This parameter is ignored for a driven terminal.
+        renorm_impedance :  str, optional
+            Impedance. The default is ``50``.
+        deembed : bool, optional
+            Whether to deembed the port. The default is ``False``.
+
+        Returns
+        -------
+        :class:`pyaedt.modules.Boundary.BoundaryObject`
+            Boundary object.
+
+        References
+        ----------
+
+        >>> oModule.AssignCircuitPort
+
+        Examples
+        --------
+
+        Create two rectangles in the XY plane.
+        Select the first edge of each rectangle created previously.
+        Create a circuit port from the first edge of the first rectangle
+        toward the first edge of the second rectangle.
+
+        >>> plane = hfss.PLANE.XY
+        >>> rectangle1 = hfss.modeler.create_rectangle(plane, [10, 10, 10], [10, 10],
+        ...                                            name="rectangle1_for_port")
+        >>> edges1 = hfss.modeler.get_object_edges(rectangle1.id)
+        >>> first_edge = edges1[0]
+        >>> rectangle2 = hfss.modeler.create_rectangle(plane, [30, 10, 10], [10, 10],
+        ...                                            name="rectangle2_for_port")
+        >>> edges2 = hfss.modeler.get_object_edges(rectangle2.id)
+        >>> second_edge = edges2[0]
+        >>> hfss.solution_type = "Modal"
+        >>> hfss.circuit_port(first_edge, second_edge, name="PortExample",
+        ...                   impedance=50.1, renormalize=False,
+        ...                   renorm_impedance="50")
+        'PortExample'
+        """
+        if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
+            if not self.modeler.does_object_exists(signal) or not self.modeler.does_object_exists(reference):
+                out = self.modeler.convert_to_selections([signal, reference], True)
+                if isinstance(out[0], str) or isinstance(out[1], str):
+                    self.logger.error("Failed to create circuit port.")
+                    return False
+            else:
+                out, parallel = self.modeler.find_closest_edges(signal, reference, port_location)
+            name = self._get_unique_source_name(name, "Port")
+            return self._create_circuit_port(
+                out, impedance, name, renormalize, deembed, renorm_impedance=renorm_impedance
+            )
+        return False
+
+    @pyaedt_function_handler()
+    def lumped_port(
+        self,
+        signal,
+        reference=None,
+        create_port_sheet=False,
+        port_on_plane=True,
+        integration_line=0,
+        impedance=50,
+        name=None,
+        renormalize=True,
+        deembed=False,
+    ):
+        """Create a waveport taking the closest edges of two objects.
+
+        Parameters
+        ----------
+        signal : str, int, list or :class:`pyaedt.modeler.object3d.Object3d` or
+         :class:`pyaedt.modeler.elements3d.FacePrimitive`
+            Main object for port creation or starting object for the integration line.
+        reference : int, list or :class:`pyaedt.modeler.object3d.Object3d`
+            Ending object for the integration line or reference for Terminal solution. Can be multiple objects.
+        create_port_sheet : bool, optional
+            Whether to create a port sheet or use given start_object as port shee.
+        integration_line : int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
+            Position of the port. It should be one of the values for ``Application.AxisDir``,
+            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``.
+            The default is ``Application.AxisDir.XNeg``.
+            It can also be a list of 2 points.
+        port_on_plane : bool, optional
+            Whether to create the source on the plane orthogonal to ``AxisDir``.
+            The default is ``True``.
+        impedance : float, optional
+            Port impedance. The default is ``50``.
+        name : str, optional
+            name of the port. The default is ``None``.
+        renormalize : bool, optional
+            Whether to renormalize the mode. The default is ``True``.
+        deembed : float, optional
+            Deembed distance in millimeters. The default is ``0``,
+            in which case deembed is disabled.
+
+        Returns
+        -------
+        :class:`pyaedt.modules.Boundary.BoundaryObject`
+            Port object.
+
+        Examples
+        --------
+
+        Create two boxes that will be used to create a lumped port
+        named ``'LumpedPort'``.
+
+        >>> box1 = hfss.modeler.create_box([0, 0, 50], [10, 10, 5],
+        ...                                "BoxLumped1","copper")
+        >>> box2 = hfss.modeler.create_box([0, 0, 60], [10, 10, 5],
+        ...                                "BoxLumped2", "copper")
+        >>> hfss.lumped_port("BoxLumped1", "BoxLumped2",
+        ...                  hfss.AxisDir.XNeg, 50,
+        ...                  "LumpedPort", True, False)
+        pyaedt INFO: Connection Correctly created
+        'LumpedPort'
+
+        """
+        if create_port_sheet:
+            signal = self.modeler.convert_to_selections(signal)
+            reference = self.modeler.convert_to_selections(reference)
+            if not self.modeler.does_object_exists(signal) or not self.modeler.does_object_exists(reference):
+                self.logger.error("One or both objects do not exist. Check and retry.")
+                return False
+            sheet_name, point0, point1 = self.modeler._create_sheet_from_object_closest_edge(
+                signal, reference, integration_line, port_on_plane
+            )
+        else:
+            if isinstance(signal, list):
+                objs = self.modeler.get_faceid_from_position(signal)
+                if len(objs) == 1:
+                    signal = objs[0]
+                elif len(objs) > 1:
+                    self.logger.warning("More than 1 face found. Getting first.")
+                    signal = objs[0]
+                else:
+                    self.logger.error("No Faces found on given location.")
+                    return False
+            sheet_name = self.modeler.convert_to_selections(signal, False)
+            if isinstance(integration_line, list):
+                if len(integration_line) != 2 or len(integration_line[0]) != len(integration_line[1]):
+                    self.logger.error("List of coordinates is not set correctly")
+                    return False
+                point0 = integration_line[0]
+                point1 = integration_line[1]
+            else:
+                point0, point1 = self.modeler.get_mid_points_on_dir(sheet_name, integration_line)
+        if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
+            name = self._get_unique_source_name(name, "Port")
+
+            if "Modal" in self.solution_type:
+                return self._create_lumped_driven(sheet_name, point0, point1, impedance, name, renormalize, deembed)
+            else:
+                faces = self.modeler.get_object_faces(sheet_name)
+                if deembed:
+                    deembed = 0
+                else:
+                    deembed = None
+                return self._create_port_terminal(
+                    faces[0],
+                    reference,
+                    name,
+                    renorm=renormalize,
+                    deembed=deembed,
+                    iswaveport=False,
+                    impedance=impedance,
+                )
+        return False
+
+    @pyaedt_function_handler()
+    def wave_port(
+        self,
+        signal,
+        reference=None,
+        create_port_sheet=False,
+        create_pec_cap=False,
+        integration_line=0,
+        port_on_plane=True,
+        num_modes=1,
+        impedance=50,
+        name=None,
+        renormalize=True,
+        deembed=0,
+        is_microstrip=False,
+        vfactor=3,
+        hfactor=5,
+    ):
+        """Create a waveport from a sheet (``start_object``) or taking the closest edges of two objects.
+
+        Parameters
+        ----------
+        signal : int, str, :class:`pyaedt.modeler.object3d.Object3d` or
+         :class:`pyaedt.modeler.elements3d.FacePrimitive`
+            Main object for port creation or starting object for the integration line.
+        reference : int, str, list or :class:`pyaedt.modeler.object3d.Object3d`
+            Ending object for the integration line or reference for Terminal solution. Can be multiple objects.
+        create_port_sheet : bool, optional
+            Whether to create a port sheet or use given start_object as port shee.
+        create_pec_cap : bool, False
+            Whether to create a port cap or not.
+        integration_line : list or int or :class:`pyaedt.application.Analysis.Analysis.AxisDir`, optional
+            Position of the integration. It should be one of the values for ``Application.AxisDir``,
+            which are: ``XNeg``, ``YNeg``, ``ZNeg``, ``XPos``, ``YPos``, and ``ZPos``
+            The default is ``Application.AxisDir.XNeg``.
+            It can also be a list of 2 points.
+        port_on_plane : bool, optional
+            Whether to create the source on the plane orthogonal to ``AxisDir``.
+            The default is ``True``.
+        impedance : float, optional
+            Port impedance. The default is ``50``.
+        num_modes : int, optional
+            Number of modes. The default is ``1``.
+        name : str, optional
+            name of the port. The default is ``None``.
+        renormalize : bool, optional
+            Whether to renormalize the mode. The default is ``True``.
+        deembed : float, optional
+            Deembed distance in millimeters. The default is ``0``,
+            in which case deembed is disabled.
+        is_microstrip : bool, optional
+            Whether if the wave port will be created and is a microstrip port.
+            The default is ``False``.
+        vfactor : int, optional
+            Port vertical factor. Only valid if ``is_microstrip`` is enabled. The default is ``3``.
+        hfactor : int, optional
+            Port horizontal factor. Only valid if ``is_microstrip`` is enabled. The default is ``5``.
+
+        Returns
+        -------
+        :class:`pyaedt.modules.Boundary.BoundaryObject`
+            Port object.
+
+        References
+        ----------
+
+        >>> oModule.AssignWavePort
+
+        Examples
+        --------
+
+        Create a wave port supported by a microstrip line.
+
+        >>> ms = hfss.modeler.create_box([4, 5, 0], [1, 100, 0.2],
+        ...                               name="MS1", matname="copper")
+        >>> sub = hfss.modeler.create_box([0, 5, -2], [20, 100, 2],
+        ...                               name="SUB1", matname="FR4_epoxy")
+        >>> gnd = hfss.modeler.create_box([0, 5, -2.2], [20, 100, 0.2],
+        ...                               name="GND1", matname="FR4_epoxy")
+        >>> port = hfss.wave_port("GND1", "MS1",
+        ...                       name="MS1",
+        ...                        integration_line=1)
+        pyaedt INFO: Connection correctly created.
+
+        """
+        oname = ""
+
+        if create_port_sheet:
+            if not self.modeler.does_object_exists(signal) or not self.modeler.does_object_exists(reference):
+                self.logger.error("One or both objects do not exist. Check and retry.")
+                return False
+            if is_microstrip:
+                sheet_name, int_start, int_stop = self.modeler._create_microstrip_sheet_from_object_closest_edge(
+                    signal, reference, integration_line, vfactor, hfactor
+                )
+            else:
+                sheet_name, int_start, int_stop = self.modeler._create_sheet_from_object_closest_edge(
+                    signal, reference, integration_line, port_on_plane
+                )
+        else:
+            if isinstance(signal, list):
+                objs = self.modeler.get_faceid_from_position(signal)
+                if len(objs) == 1:
+                    signal = objs[0]
+                elif len(objs) > 1:
+                    self.logger.warning("More than 1 face found. Getting first.")
+                    signal = objs[0]
+                else:
+                    self.logger.error("No Faces found on given location.")
+                    return False
+            sheet_name = self.modeler.convert_to_selections(signal, True)[0]
+            if isinstance(sheet_name, int):
+                try:
+                    oname = self.modeler.oeditor.GetObjectNameByFaceID(sheet_name)
+                except:
+                    oname = ""
+            if reference:
+                reference = self.modeler.convert_to_selections(reference, True)
+            if integration_line:
+                if isinstance(integration_line, list):
+                    if len(integration_line) != 2 or len(integration_line[0]) != len(integration_line[1]):
+                        self.logger.error("List of coordinates is not set correctly")
+                        return False
+                    int_start = integration_line[0]
+                    int_stop = integration_line[1]
+                else:
+                    try:
+                        _, int_start, int_stop = self._get_reference_and_integration_points(
+                            sheet_name, integration_line, oname
+                        )
+                    except (IndexError, TypeError):
+                        int_start = int_stop = None
+            else:
+                int_start = int_stop = None
+        if self.solution_type in ["Modal", "Terminal", "Transient Network"]:
+            if create_pec_cap:
+                if oname:
+                    face = oname
+                else:
+                    face = sheet_name
+                dist = math.sqrt(self.modeler[face].faces[0].area)
+                if settings.aedt_version > "2022.2":
+                    self._create_pec_cap(face, signal, -dist / 10)
+                else:
+                    self._create_pec_cap(face, signal, dist / 10)
+            name = self._get_unique_source_name(name, "Port")
+
+            if "Modal" in self.solution_type:
+                return self._create_waveport_driven(
+                    sheet_name, int_start, int_stop, impedance, name, renormalize, num_modes, deembed
+                )
+            elif reference:
+                if isinstance(sheet_name, int):
+                    faces = [sheet_name]
+                else:
+                    faces = self.modeler.get_object_faces(sheet_name)
+                if deembed == 0:
+                    deembed = None
+                else:
+                    deembed = deembed
+                return self._create_port_terminal(
+                    faces[0],
+                    reference,
+                    name,
+                    renorm=renormalize,
+                    deembed=deembed,
+                    iswaveport=True,
+                    impedance=impedance,
+                )
+            else:
+                self.logger.error("Reference conductors are missing.")
+                return False
+        return False
```

### Comparing `pyaedt-0.6.61/pyaedt/hfss3dlayout.py` & `pyaedt-0.6.70/pyaedt/hfss3dlayout.py`

 * *Files 1% similar despite different names*

```diff
@@ -3,15 +3,14 @@
 from __future__ import absolute_import  # noreorder
 
 from collections import OrderedDict
 import fnmatch
 import io
 import os
 import re
-import warnings
 
 from pyaedt import is_ironpython
 from pyaedt import settings
 from pyaedt.application.Analysis3DLayout import FieldAnalysis3DLayout
 from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import open_file
 from pyaedt.generic.general_methods import parse_excitation_file
@@ -879,63 +878,14 @@
         settings.append(enable_intersections_check)
         settings.append("UseAlternativeMeshMethodsAsFallBack:=")
         settings.append(use_alternative_fallback)
         self.odesign.DesignOptions(settings, 0)
         return True
 
     @pyaedt_function_handler()
-    def create_frequency_sweep(
-        self,
-        setupname,
-        unit,
-        freqstart,
-        freqstop,
-        num_of_freq_points,
-        sweepname=None,
-        sweeptype="Interpolating",
-        interpolation_tol_percent=0.5,
-        interpolation_max_solutions=250,
-        save_fields=True,
-        save_rad_fields_only=False,
-        use_q3d_for_dc=False,
-    ):
-        """Create a frequency sweep.
-
-        .. deprecated:: 0.4.0
-           Use :func:`Hfss3dLayout.create_linear_count_sweep` instead.
-
-        """
-
-        warnings.warn(
-            "`create_frequency_sweep` is deprecated. Use `create_linear_count_sweep` instead.",
-            DeprecationWarning,
-        )
-        if sweeptype == "interpolating":
-            sweeptype = "Interpolating"
-        elif sweeptype == "discrete":
-            sweeptype = "Discrete"
-        elif sweeptype == "fast":
-            sweeptype = "Fast"
-
-        return self.create_linear_count_sweep(
-            setupname=setupname,
-            unit=unit,
-            freqstart=freqstart,
-            freqstop=freqstop,
-            num_of_freq_points=num_of_freq_points,
-            sweepname=sweepname,
-            save_fields=save_fields,
-            save_rad_fields_only=save_rad_fields_only,
-            sweep_type=sweeptype,
-            interpolation_tol_percent=interpolation_tol_percent,
-            interpolation_max_solutions=interpolation_max_solutions,
-            use_q3d_for_dc=use_q3d_for_dc,
-        )
-
-    @pyaedt_function_handler()
     def create_linear_count_sweep(
         self,
         setupname,
         unit,
         freqstart,
         freqstop,
         num_of_freq_points,
```

### Comparing `pyaedt-0.6.61/pyaedt/icepak.py` & `pyaedt-0.6.70/pyaedt/icepak.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/maxwell.py` & `pyaedt-0.6.70/pyaedt/maxwell.py`

 * *Files 0% similar despite different names*

```diff
@@ -2630,17 +2630,17 @@
                 return [convert(item) for item in obj]
             if isinstance(obj, dict):
                 return {convert(key): convert(value) for key, value in obj.items()}
             return obj
 
         solid_bodies = self.modeler.solid_bodies
         if objectfilter:
-            solid_ids = [i for i, j in self.modeler.object_id_dict.items() if j.name in objectfilter]
+            solid_ids = [i for i, j in self.modeler._object_names_to_ids.items() if j.name in objectfilter]
         else:
-            solid_ids = [i for i in list(self.modeler.object_id_dict.keys())]
+            solid_ids = [i for i in list(self.modeler._object_names_to_ids.keys())]
         self.design_data = {
             "Project Directory": self.project_path,
             "Working Directory": self.working_directory,
             "Library Directories": self.library_list,
             "Dimension": self.modeler.dimension,
             "GeoMode": self.geometry_mode,
             "ModelUnits": self.modeler.model_units,
```

### Comparing `pyaedt-0.6.61/pyaedt/maxwellcircuit.py` & `pyaedt-0.6.70/pyaedt/maxwellcircuit.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/mechanical.py` & `pyaedt-0.6.70/pyaedt/mechanical.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/Console.py_build` & `pyaedt-0.6.70/pyaedt/misc/Console.py_build`

 * *Files 2% similar despite different names*

```diff
@@ -47,29 +47,30 @@
             "{}".format(edt_root),
         ]
         os.environ["LD_LIBRARY_PATH"] = ":".join(ld_library_path_dirs_to_add) + ":" + os.getenv("LD_LIBRARY_PATH", "")
 
         command = [
             term,
             "-e",
-            "{}".format(python_exe),
+            python_exe,
             "-i",
-            "{}".format(pyaedt_script),
+            pyaedt_script,
             str(oDesktop.GetProcessID()),
             str(oDesktop.GetVersion()[:6]),
         ]
+        subprocess.Popen(command)
     else:
         command = [
             '"{}"'.format(python_exe),
             "-i",
             '"{}"'.format(pyaedt_script),
             str(oDesktop.GetProcessID()),
             str(oDesktop.GetVersion()[:6]),
         ]
-    subprocess.Popen(" ".join(command))
+        subprocess.Popen(" ".join(command))
 
 
 def get_linux_terminal():
     for terminal in ["x-terminal-emulator", "konsole", "xterm", "gnome-terminal", "lxterminal", "mlterm"]:
         term = which(terminal)
         if term:
             return term
```

### Comparing `pyaedt-0.6.61/pyaedt/misc/Job_Settings.areg` & `pyaedt-0.6.70/pyaedt/misc/Job_Settings.areg`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/Jupyter.py_build` & `pyaedt-0.6.70/pyaedt/misc/Jupyter.py_build`

 * *Files 10% similar despite different names*

```diff
@@ -41,19 +41,30 @@
         with open(target, "w") as t:
             for line in source:
                 line = line.replace("PROCESSID", str(oDesktop.GetProcessID())).replace(
                     "AEDTVERSION", oDesktop.GetVersion()[:6]
                 )
                 t.write(line)
     if is_linux:
-        command = ["{}".format(jupyter_exe), "lab", "{}".format(target)]
+        edt_root = os.path.normpath(oDesktop.GetExeDir())
+        os.environ["ANSYSEM_ROOT{}".format(version)] = edt_root
+        ld_library_path_dirs_to_add = [
+            "{}/commonfiles/CPython/3_7/linx64/Release/python/lib".format(edt_root),
+            "{}/commonfiles/CPython/3_10/linx64/Release/python/lib".format(edt_root),
+            "{}/common/mono/Linux64/lib64".format(edt_root),
+            "{}/Delcross".format(edt_root),
+            "{}".format(edt_root),
+        ]
+        os.environ["LD_LIBRARY_PATH"] = ":".join(ld_library_path_dirs_to_add) + ":" + os.getenv("LD_LIBRARY_PATH", "")
+
+        command = [jupyter_exe, "lab", target]
+        subprocess.Popen(command)
     else:
         command = ['"{}"'.format(jupyter_exe), "lab", '"{}"'.format(target)]
-
-    subprocess.Popen(" ".join(command))
+        subprocess.Popen(" ".join(command))
 
 
 def generate_unique_name(rootname, suffix="", n=6):
     char_set = string.ascii_uppercase + string.digits
     unique_name = rootname + "_" + "".join(random.choice(char_set) for _ in range(n))
     if suffix:
         unique_name += suffix
```

### Comparing `pyaedt-0.6.61/pyaedt/misc/Run_PyAEDT_Script.py_build` & `pyaedt-0.6.70/pyaedt/misc/Run_PyAEDT_Script.py_build`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/Run_PyAEDT_Toolkit_Script.py_build` & `pyaedt-0.6.70/pyaedt/misc/Run_PyAEDT_Toolkit_Script.py_build`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/aedtlib_personalib_install.py` & `pyaedt-0.6.70/pyaedt/misc/aedtlib_personalib_install.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/amat.xml` & `pyaedt-0.6.70/pyaedt/misc/amat.xml`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/console_setup.py` & `pyaedt-0.6.70/pyaedt/misc/console_setup.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/images/gallery/PyAEDT.png` & `pyaedt-0.6.70/pyaedt/misc/images/gallery/PyAEDT.png`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/images/large/pyansys.png` & `pyaedt-0.6.70/pyaedt/misc/images/large/pyansys.png`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/install_extra_toolkits.py` & `pyaedt-0.6.70/pyaedt/misc/install_extra_toolkits.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/jupyter_template.ipynb` & `pyaedt-0.6.70/pyaedt/misc/jupyter_template.ipynb`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/misc.py` & `pyaedt-0.6.70/pyaedt/misc/misc.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/ml_data_file_train_100MHz_1GHz.json` & `pyaedt-0.6.70/pyaedt/misc/ml_data_file_train_100MHz_1GHz.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/ml_data_file_train_1GHz_10GHz.json` & `pyaedt-0.6.70/pyaedt/misc/ml_data_file_train_1GHz_10GHz.json`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/patch_svr_model_100MHz_1GHz.joblib` & `pyaedt-0.6.70/pyaedt/misc/patch_svr_model_100MHz_1GHz.joblib`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/patch_svr_model_1GHz_10GHz.joblib` & `pyaedt-0.6.70/pyaedt/misc/patch_svr_model_1GHz_10GHz.joblib`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/pyaedt_local_config.acf` & `pyaedt-0.6.70/pyaedt/misc/pyaedt_local_config.acf`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/pyansys-logo-black-cropped.png` & `pyaedt-0.6.70/pyaedt/misc/pyansys-logo-black-cropped.png`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/misc/template.acf` & `pyaedt-0.6.70/pyaedt/misc/template.acf`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/advanced_cad/actors.py` & `pyaedt-0.6.70/pyaedt/modeler/advanced_cad/actors.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/advanced_cad/multiparts.py` & `pyaedt-0.6.70/pyaedt/modeler/advanced_cad/multiparts.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/advanced_cad/oms.py` & `pyaedt-0.6.70/pyaedt/modeler/advanced_cad/oms.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/advanced_cad/parts.py` & `pyaedt-0.6.70/pyaedt/modeler/advanced_cad/parts.py`

 * *Files 1% similar despite different names*

```diff
@@ -88,25 +88,25 @@
         self.rot_axis = [False, False, False]  # [X, Y, Z] rotation Boolean
         if self._compdef["rotation_axis"]:
             rotations_axis = self._compdef["rotation_axis"].split(",")
             if self._compdef["rotation"]:
                 rotations = self._compdef["rotation"].split(",")
             else:
                 rotations = []
-            y = "0"
-            p = "0"
             r = "0"
-            for a in rotations:
-                if rotations_axis[rotations.index(a)].lower() == "x":  # roll
+            p = "0"
+            y = "0"
+            for i, a in enumerate(rotations):
+                if rotations_axis[i].lower() == "x":  # roll
                     r = a
                     self.rot_axis[2] = True
-                elif rotations_axis[rotations.index(a)].lower() == "y":  # pitch
+                elif rotations_axis[i].lower() == "y":  # pitch
                     p = a
                     self.rot_axis[1] = True
-                elif rotations_axis[rotations.index(a)].lower() == "z":  # yaw
+                elif rotations_axis[i].lower() == "z":  # yaw
                     y = a
                     self.rot_axis[0] = True
 
             self._yaw = y
             self._pitch = p
             self._roll = r
         else:
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/advanced_cad/stackup_3d.py` & `pyaedt-0.6.70/pyaedt/modeler/advanced_cad/stackup_3d.py`

 * *Files 1% similar despite different names*

```diff
@@ -2377,29 +2377,27 @@
         string_length = (
             self._signal_layer.elevation.name
             + " + "
             + self._signal_layer.thickness.name
             + " - "
             + reference_layer.elevation.name
         )
-        port = self.application.modeler.create_rectangle(
+        rect = self.application.modeler.create_rectangle(
             csPlane=constants.PLANE.YZ,
             position=[string_position_x, string_position_y, string_position_z],
             dimension_list=[string_width, string_length],
             name=self.name + "_port",
             matname=None,
         )
         if self.application.solution_type == "Modal":
             if axisdir is None:
                 axisdir = self.application.AxisDir.ZPos
-            port = self.application.create_lumped_port_to_sheet(port.name, portname=port_name, axisdir=axisdir)
+            port = self.application.lumped_port(rect.name, name=port_name, integration_line=axisdir)
         elif self.application.solution_type == "Terminal":
-            port = self.application.create_lumped_port_to_sheet(
-                port.name, portname=port_name, reference_object_list=[reference_layer.name]
-            )
+            port = self.application.lumped_port(rect.name, name=port_name, reference=[reference_layer.name])
         return port
 
     def quarter_wave_feeding_line(self, impedance_to_adapt=50):
         """Create a Trace to feed the patch. The trace length is the quarter wavelength, and this width is calculated
         to return the desired impedance.
 
         Parameters
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/cad/Modeler.py` & `pyaedt-0.6.70/pyaedt/modeler/cad/Modeler.py`

 * *Files 1% similar despite different names*

```diff
@@ -1095,15 +1095,15 @@
             object_list_new = []
             for element in object_list:
                 if isinstance(element, str):
                     if element.isnumeric():
                         object_list_new.append(int(element))
                     else:
                         if element in self._modeler.object_names:
-                            obj_id = self._modeler.object_id_dict[element]
+                            obj_id = self._modeler._object_names_to_ids[element]
                             for sel in self._modeler.object_list:
                                 if sel.id == obj_id:
                                     for f in sel.faces:
                                         object_list_new.append(f.id)
                                     break
                         else:
                             return []
@@ -1177,14 +1177,23 @@
         self._omaterial_manager = self._app.omaterial_manager
         Modeler.__init__(self, app)
         # TODO Refactor this as a dictionary with names as key
         self._coordinate_systems = None
         self._user_lists = None
         self._planes = None
         self._is3d = is3d
+        self._solids = []
+        self._sheets = []
+        self._lines = []
+        self._points = []
+        self._unclassified = []
+        self._all_object_names = []
+        self.objects = {}
+        self.user_defined_components = {}
+        self._object_names_to_ids = {}
 
     @property
     def coordinate_systems(self):
         """Coordinate Systems."""
         if self._coordinate_systems is None:
             self._coordinate_systems = self._get_coordinates_data()
         return self._coordinate_systems
@@ -1221,54 +1230,14 @@
         Returns
         -------
         :class:`pyaedt.modules.MaterialLib.Materials`
 
         """
         return self._app.materials
 
-    @pyaedt_function_handler()
-    def _convert_list_to_ids(self, input_list, convert_objects_ids_to_name=True):
-        """Convert a list to IDs.
-
-        .. deprecated:: 0.5.0
-           Use :func:`pyaedt.application.modeler.convert_to_selections` instead.
-
-        Parameters
-        ----------
-        input_list : list
-           List of object IDs.
-        convert_objects_ids_to_name : bool, optional
-             Whether to convert the object IDs to object names.
-             The default is ``True``.
-
-        Returns
-        -------
-        list
-            List of object names.
-
-        """
-        warnings.warn("`_convert_list_to_ids` is deprecated. Use `convert_to_selections` instead.", DeprecationWarning)
-
-        output_list = []
-        if type(input_list) is not list:
-            input_list = [input_list]
-        for el in input_list:
-            if type(el) is Object3d:
-                output_list = [i.name for i in input_list]
-            elif type(el) is EdgePrimitive or type(el) is FacePrimitive or type(el) is VertexPrimitive:
-                output_list = [i.id for i in input_list]
-            elif type(el) is int and convert_objects_ids_to_name:
-                if el in list(self.objects.keys()):
-                    output_list.append(self.objects[el].name)
-                else:
-                    output_list.append(el)
-            else:
-                output_list.append(el)
-        return output_list
-
     def _get_coordinates_data(self):
         coord = []
         id2name = {1: "Global"}
         name2refid = {}
         if self._app.design_properties and "ModelSetup" in self._app.design_properties:
             cs = self._app.design_properties["ModelSetup"]["GeometryCore"]["GeometryOperations"]["CoordinateSystems"]
             for ds in cs:
@@ -2522,38 +2491,32 @@
 
         Returns
         -------
         str or list
            Name of the objects corresponding to the one or more object IDs passed as arguments.
 
         """
-        if "netref.builtins.list" in str(type(object_id)):
-            list_new = []
-            for i in range(len(object_id)):
-                list_new.append(object_id[i])
-        elif not isinstance(object_id, list):
+        if not isinstance(object_id, list):
             object_id = [object_id]
         objnames = []
         for el in object_id:
-            if isinstance(el, int) and el in list(self.objects.keys()):
+            if isinstance(el, int) and el in self.objects:
                 objnames.append(self.objects[el].name)
             elif isinstance(el, int):
                 objnames.append(el)
             elif isinstance(el, Object3d):
                 objnames.append(el.name)
             elif isinstance(el, FacePrimitive) or isinstance(el, EdgePrimitive) or isinstance(el, VertexPrimitive):
                 objnames.append(el.id)
             elif isinstance(el, str):
                 objnames.append(el)
-            else:
-                return False
         if return_list:
             return objnames
         else:
-            return ",".join(objnames)
+            return ",".join([str(i) for i in objnames])
 
     @pyaedt_function_handler()
     def split(self, objects, plane, sides="Both"):
         """Split a list of objects.
 
         Parameters
         ----------
@@ -2762,15 +2725,15 @@
         """Duplicate a selection around an axis.
 
         Parameters
         ----------
         objid : list, str, int, Object3d or UserDefinedComponent
             Name or ID of the object.
         cs_axis :
-            Coordinate system axis or the Application.CoordinateSystemAxis object.
+            Coordinate system axis or the Application.AXIS object.
         angle : float, optional
             Angle rotation in degees. The default is ``90``.
         nclones : int, optional
             Number of clones. The default is ``2``.
         create_new_objects :
             Whether to create the copies as new objects. The
             default is ``True``.
@@ -2904,14 +2867,20 @@
 
         vArg1 = ["NAME:Selections", "Selections:=", selections, "NewPartsModelFlag:=", "Model"]
         vArg2 = ["NAME:SheetThickenParameters"]
         vArg2.append("Thickness:="), vArg2.append(self._arg_with_dim(thickness))
         vArg2.append("BothSides:="), vArg2.append(bBothSides)
 
         self.oeditor.ThickenSheet(vArg1, vArg2)
+
+        if isinstance(objid, list):
+            obj_list = []
+            for objl in objid:
+                obj_list.append(self.update_object(objl))
+            return obj_list
         return self.update_object(objid)
 
     @pyaedt_function_handler()
     def sweep_along_normal(self, obj_name, face_id, sweep_value=0.1):
         """Sweep the selection along the vector.
 
         Parameters
@@ -3046,15 +3015,15 @@
         """Sweep the selection around the axis.
 
         Parameters
         ----------
         objid : list, str, int, :class:`pyaedt.modeler.Object3d.Object3d`
             Name or ID of the object.
         cs_axis :
-            Coordinate system axis or the Application.CoordinateSystemAxis object.
+            Coordinate system axis or the Application.AXIS object.
         sweep_angle : float
             Sweep angle in degrees. The default is ``360``.
         draft_angle : float
             Draft angle in degrees. The default is ``0``.
         number_of_segments : int, optional
             Number of segments of the sweep operation. Default is ``0``.
 
@@ -3181,15 +3150,15 @@
         """Rotate the selection.
 
         Parameters
         ----------
         objid :  list, str, int, or  :class:`pyaedt.modeler.Object3d.Object3d`
              ID of the object.
         cs_axis
-            Coordinate system axis or the Application.CoordinateSystemAxis object.
+            Coordinate system axis or the Application.AXIS object.
         angle : float
             Angle of rotation. The units, defined by ``unit``, can be either
             degrees or radians. The default is ``90.0``.
         unit : text, optional
              Units for the angle. Options are ``"deg"`` or ``"rad"``.
              The default is ``"deg"``.
 
@@ -3586,53 +3555,14 @@
                 if obj.name == sel
             ]
             return objects_list_after_connection
         except:
             return False
 
     @pyaedt_function_handler()
-    def translate(self, objid, vector):
-        """Translate objects from a list.
-
-        .. deprecated:: 0.4.0
-           Use :func:`move` instead.
-
-        Parameters
-        ----------
-        objid : list, Position object
-            List of object IDs.
-        vector : list
-            Vector of the direction move. It can be a list of the ``[x, y, z]``
-            coordinates or a Position object.
-
-        Returns
-        -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
-        References
-        ----------
-
-        >>> oEditor.Move
-        """
-        warnings.warn("`translate` is deprecated. Use `move` instead.", DeprecationWarning)
-        Xvec, Yvec, Zvec = self._pos_with_arg(vector)
-        szSelections = self.convert_to_selections(objid)
-
-        vArg1 = ["NAME:Selections", "Selections:=", szSelections, "NewPartsModelFlag:=", "Model"]
-        vArg2 = ["NAME:TranslateParameters"]
-        vArg2.append("TranslateVectorX:="), vArg2.append(Xvec)
-        vArg2.append("TranslateVectorY:="), vArg2.append(Yvec)
-        vArg2.append("TranslateVectorZ:="), vArg2.append(Zvec)
-
-        if self.oeditor is not None:
-            self.oeditor.Move(vArg1, vArg2)
-        return True
-
-    @pyaedt_function_handler()
     def chassis_subtraction(self, chassis_part):
         """Subtract all non-vacuum objects from the main chassis object.
 
         Parameters
         ----------
         chassis_part : str
             Name of the main chassis object.
@@ -4292,47 +4222,14 @@
             sheet.subtract(cloned)
             cloned.name = sheet.name + "_Face1Vacuum"
             faces.append(sheet.name)
             faces.append(cloned.name)
         return faces
 
     @pyaedt_function_handler()
-    def load_objects_bytype(self, obj_type):
-        """Load all objects of a specified type.
-
-        .. deprecated:: 0.5.0
-           Use :func:`get_objects_in_group` property instead.
-
-        Parameters
-        ----------
-        obj_type : str
-            Type of the objects to load. Options are
-            ``"Solids"`` and ``"Sheets"``.
-
-        Returns
-        -------
-        list
-            List of the object names for the specified type.
-
-        References
-        ----------
-
-        >>> oEditor.GetObjectsInGroup
-        """
-
-        warnings.warn(
-            "`load_objects_bytype` is deprecated and will be removed in version 0.5.0. "
-            "Use `get_objects_in_group` method instead.",
-            DeprecationWarning,
-        )
-
-        objNames = list(self.oeditor.GetObjectsInGroup(obj_type))
-        return objNames
-
-    @pyaedt_function_handler()
     def get_line_ids(self):
         """Create a dictionary of object IDs for the lines in the design with the line name as the key."""
         line_ids = {}
         line_list = list(self.oeditor.GetObjectsInGroup("Lines"))
         for line_object in line_list:
             # TODO Problem with GetObjectIDByName
             try:
@@ -4378,15 +4275,15 @@
             Name of the edge if it exists, ``False`` otherwise.
 
         References
         ----------
 
         >>> oEditor.GetEdgeIDsFromObject
         """
-        for object in list(self.object_id_dict.keys()):
+        for object in list(self._object_names_to_ids.keys()):
             try:
                 oEdgeIDs = self.oeditor.GetEdgeIDsFromObject(object)
                 if str(edge_id) in oEdgeIDs:
                     return object
             except:
                 return False
         return False
@@ -4835,40 +4732,14 @@
         >>> oEditor.BreakUDMConnection
         """
         self.import_spaceclaim_document(SpaceClaimFile)
         self.break_spaceclaim_connection()
         return True
 
     @pyaedt_function_handler()
-    def load_hfss(self, cadfile):
-        """Load HFSS.
-
-        .. deprecated:: 0.4.41
-           Use :func:`import_3d_cad` property instead.
-
-        Parameters
-        ----------
-        cadfile : str
-            Name of the CAD file to load in HFSS.
-
-        Returns
-        -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
-        References
-        ----------
-
-        >>> oEditor.Import
-        """
-        warnings.warn("`load_hfss` is deprecated. Use `import_3d_cad` method instead.", DeprecationWarning)
-        self.import_3d_cad(cadfile, healing=True)
-        return True
-
-    @pyaedt_function_handler()
     def get_faces_from_materials(self, mats):
         """Select all outer faces given a list of materials.
 
         Parameters
         ----------
         mats : list
             List of materials to include in the search for outer
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/cad/Primitives.py` & `pyaedt-0.6.70/pyaedt/modeler/cad/Primitives.py`

 * *Files 2% similar despite different names*

```diff
@@ -307,18 +307,18 @@
         -------
         dict
 
         """
         obj_names = self.object_names
         missing = []
         for name in obj_names:
-            if name not in self.object_id_dict:
+            if name not in self._object_names_to_ids:
                 missing.append(name)
         non_existent = []
-        for name in self.object_id_dict:
+        for name in self._object_names_to_ids:
             if name not in obj_names and name not in self.unclassified_names:
                 non_existent.append(name)
         report = {"Missing Objects": missing, "Non-Existent Objects": non_existent}
         return report
 
     @pyaedt_function_handler()
     def create_point(self, position, name=None, color="(143 175 143)"):
@@ -516,15 +516,19 @@
         Returns
         -------
         :class:`pyaedt.modeler.object3d.Object3d`
            Updated 3D object.
 
         """
         o = self._resolve_object(obj)
-        o._update()
+        name = o.name
+
+        del self.objects[self._object_names_to_ids[name]]
+        del self._object_names_to_ids[name]
+        o = self._create_object(name)
         return o
 
     @pyaedt_function_handler()
     def value_in_object_units(self, value):
         """Convert one or more strings for numerical lengths to floating point values.
 
         Parameters
@@ -564,39 +568,34 @@
 
         if scalar:
             return numeric_list[0]
         else:
             return numeric_list
 
     @pyaedt_function_handler()
-    def does_object_exists(self, object):
-        """ "Check to see if an object exists.
+    def does_object_exists(self, obj_to_check):
+        """Check to see if an object exists.
 
         Parameters
         ----------
-        object : str, int
+        obj_to_check : str, int
             Object name or object ID.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         """
-        if isinstance(object, int):
-            if object in self.objects:
-                return True
-            else:
-                return False
+        if isinstance(obj_to_check, int) and obj_to_check in self.objects:
+            return True
+        elif obj_to_check in self.objects_by_name:
+            return True
         else:
-            for el in self.objects:
-                if self.objects[el].name == object:
-                    return True
-
-        return False
+            return False
 
     @pyaedt_function_handler()
     def create_region(self, pad_percent=300, is_percentage=True):
         """Create an air region.
 
         Parameters
         ----------
@@ -1256,15 +1255,15 @@
 
         References
         ----------
 
         >>> oEditor.Delete
 
         """
-        objnames = self.object_id_dict
+        objnames = self._object_names_to_ids
         num_del = 0
         for el in objnames:
             if case_sensitive:
                 if contained_string in el:
                     self.delete(el)
                     num_del += 1
             else:
@@ -1302,16 +1301,16 @@
 
         Returns
         -------
         int
             Object ID.
 
         """
-        if objname in self.object_id_dict:
-            return self.object_id_dict[objname]
+        if objname in self._object_names_to_ids:
+            return self._object_names_to_ids[objname]
         return None
 
     @pyaedt_function_handler()
     def get_object_from_name(self, objname):
         """Return the object from an object name.
 
         Parameters
@@ -1321,15 +1320,15 @@
 
         Returns
         -------
         :class:`pyaedt.modeler.object3d.Object3d`
             3D object returned.
 
         """
-        if objname in self.object_id_dict:
+        if objname in self._object_names_to_ids:
             object_id = self.get_obj_id(objname)
             return self.objects[object_id]
 
     @pyaedt_function_handler()
     def get_objects_w_string(self, stringname, case_sensitive=True):
         """Retrieve all objects with a given string in their names.
 
@@ -1343,41 +1342,53 @@
         Returns
         -------
         list
             List of object names with the given string.
 
         """
         list_objs = []
-        for el in self.objects:
+        for name in list(self.objects_by_name.keys()):
             if case_sensitive:
-                if stringname in self.objects[el].name:
-                    list_objs.append(self.objects[el].name)
+                if stringname in name:
+                    list_objs.append(name)
             else:
-                if stringname.lower() in self.objects[el].name.lower():
-                    list_objs.append(self.objects[el].name)
-
+                if stringname.lower() in name.lower():
+                    list_objs.append(name)
         return list_objs
 
     @pyaedt_function_handler()
     def refresh(self):
         """Refresh this object."""
         self._solids = []
         self._sheets = []
         self._lines = []
         self._points = []
         self._unclassified = []
         self._all_object_names = []
         self.objects = {}
         self.user_defined_components = {}
-        self.object_id_dict = {}
+        self._object_names_to_ids = {}
         self._currentId = 0
         self._refresh_object_types()
         self._refresh_all_ids_from_aedt_file()
         self.refresh_all_ids()
 
+    @property
+    def objects_by_name(self):
+        """Object dictionary organized by name.
+
+        Returns
+        -------
+        dict
+        """
+        obj_dict = {}
+        for _, v in self.objects.items():
+            obj_dict[v._m_name] = v
+        return obj_dict
+
     @pyaedt_function_handler()
     def cleanup_objects(self):
         """Clean up objects that no longer exist in the modeler because
         they were removed by previous operations.
 
         This method also updates object IDs that may have changed via
         a modeler operation such as :func:`pyaedt.modeler.Model3D.Modeler3D.unite`
@@ -1402,15 +1413,15 @@
                 # updated_id = obj.id  # By calling the object property we get the new id
                 new_object_id_dict[obj.name] = old_id
                 new_object_dict[old_id] = obj
         for old_id, obj in self.points.items():
             if obj.name in self._points:
                 new_points_dict[obj.name] = obj
         self.objects = new_object_dict
-        self.object_id_dict = new_object_id_dict
+        self._object_names_to_ids = new_object_id_dict
         self.points = new_points_dict
 
     @pyaedt_function_handler()
     def find_new_objects(self):
         """Find any new objects in the modeler that were created
         by previous operations.
 
@@ -1418,15 +1429,15 @@
         -------
         dict
             Dictionary of new objects.
 
         """
         new_objects = []
         for obj_name in self.object_names:
-            if obj_name not in self.object_id_dict:
+            if obj_name not in self._object_names_to_ids:
                 new_objects.append(obj_name)
         return new_objects
 
     @pyaedt_function_handler()
     def add_new_objects(self):
         """Add objects that have been created in the modeler by
         previous operations.
@@ -1436,19 +1447,19 @@
         list
             List of added objects.
 
         """
         added_objects = []
 
         for obj_name in self.object_names:
-            if obj_name not in self.object_id_dict:
+            if obj_name not in self._object_names_to_ids:
                 self._create_object(obj_name)
                 added_objects.append(obj_name)
         for obj_name in self.unclassified_names:
-            if obj_name not in self.object_id_dict:
+            if obj_name not in self._object_names_to_ids:
                 self._create_object(obj_name)
                 added_objects.append(obj_name)
         return added_objects
 
     @pyaedt_function_handler()
     def add_new_user_defined_component(self):
         """Add 3D components and user-defined models that have been created in the modeler by
@@ -1781,15 +1792,15 @@
         References
         ----------
 
         >>> oEditor.GetFaceIDs
 
         """
         oFaceIDs = []
-        if isinstance(partId, str) and partId in self.object_id_dict:
+        if isinstance(partId, str) and partId in self._object_names_to_ids:
             oFaceIDs = self.oeditor.GetFaceIDs(partId)
             oFaceIDs = [int(i) for i in oFaceIDs]
         elif partId in self.objects:
             o = self.objects[partId]
             name = o.name
             oFaceIDs = self.oeditor.GetFaceIDs(name)
             oFaceIDs = [int(i) for i in oFaceIDs]
@@ -1812,15 +1823,15 @@
         References
         ----------
 
         >>> oEditor.GetEdgeIDsFromObject
 
         """
         oEdgeIDs = []
-        if isinstance(partId, str) and partId in self.object_id_dict:
+        if isinstance(partId, str) and partId in self._object_names_to_ids:
             oEdgeIDs = self.oeditor.GetEdgeIDsFromObject(partId)
             oEdgeIDs = [int(i) for i in oEdgeIDs]
         elif partId in self.objects:
             o = self.objects[partId]
             oEdgeIDs = self.oeditor.GetEdgeIDsFromObject(o.name)
             oEdgeIDs = [int(i) for i in oEdgeIDs]
         return oEdgeIDs
@@ -1866,15 +1877,15 @@
         References
         ----------
 
         >>> oEditor.GetVertexIDsFromObject
 
         """
         oVertexIDs = []
-        if isinstance(partID, str) and partID in self.object_id_dict:
+        if isinstance(partID, str) and partID in self._object_names_to_ids:
             oVertexIDs = self.oeditor.GetVertexIDsFromObject(partID)
             oVertexIDs = [int(i) for i in oVertexIDs]
         elif partID in self.objects:
             o = self.objects[partID]
             oVertexIDs = self.oeditor.GetVertexIDsFromObject(o.name)
             oVertexIDs = [int(i) for i in oVertexIDs]
         return oVertexIDs
@@ -2088,16 +2099,16 @@
         Returns
         -------
         list
             List of midpoint coordinates. If the edge is not a segment with
             two vertices, an empty list is returned.
         """
 
-        if isinstance(partID, str) and partID in self.object_id_dict:
-            partID = self.object_id_dict[partID]
+        if isinstance(partID, str) and partID in self._object_names_to_ids:
+            partID = self._object_names_to_ids[partID]
 
         if partID in self.objects and self.objects[partID].object_type == "Line":
             vertices = self.get_object_vertices(partID)
         else:
             try:
                 vertices = self.get_edge_vertices(partID)
             except:
@@ -2822,29 +2833,36 @@
             o = Object3d(self, name)
             if pid:
                 new_id = pid
             else:
                 new_id = o.id
             o = self.get_existing_polyline(o)
             self.objects[new_id] = o
-            self.object_id_dict[o.name] = new_id
+            self._object_names_to_ids[o.name] = new_id
         else:
             o = Object3d(self, name)
-            history = o.history  # avoids creating the history twice
-            if history and history.command == "CreatePolyline":
+            commands = self._get_commands(name)
+            if commands and commands[0].startswith("CreatePolyline"):
                 o = self.get_existing_polyline(o)
             if pid:
                 new_id = pid
             else:
                 new_id = o.id
             self.objects[new_id] = o
-            self.object_id_dict[o.name] = new_id
+            self._object_names_to_ids[o.name] = new_id
         return o
 
     @pyaedt_function_handler()
+    def _get_commands(self, name):
+        try:
+            return self.oeditor.GetChildObject(name).GetChildNames()
+        except:
+            return []
+
+    @pyaedt_function_handler()
     def _create_user_defined_component(self, name):
         if name not in list(self.user_defined_components.keys()):
             native_component_properties = self._get_native_component_properties(name)
             if native_component_properties:
                 component_type = native_component_properties["NativeComponentDefinitionProvider"]["Type"]
                 o = UserDefinedComponent(self, name, native_component_properties, component_type)
             else:
@@ -3157,14 +3175,14 @@
         :class:`pyaedt.modeler.object3d.Object3d`
             Returns None if the part ID or the object name is not found.
 
         """
         if isinstance(partId, int):
             if partId in self.objects:
                 return self.objects[partId]
-        elif partId in self.object_id_dict:
-            return self.objects[self.object_id_dict[partId]]
+        elif partId in self._object_names_to_ids:
+            return self.objects[self._object_names_to_ids[partId]]
         elif partId in self.user_defined_components:
             return self.user_defined_components[partId]
         elif isinstance(partId, Object3d) or isinstance(partId, UserDefinedComponent):
             return partId
         return None
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/cad/Primitives2D.py` & `pyaedt-0.6.70/pyaedt/modeler/cad/Primitives2D.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/cad/Primitives3D.py` & `pyaedt-0.6.70/pyaedt/modeler/cad/Primitives3D.py`

 * *Files 0% similar despite different names*

```diff
@@ -897,16 +897,18 @@
         vArg2.append("RightHand:=")
         vArg2.append(right_hand)
         vArg2.append("RadiusIncrement:=")
         vArg2.append(self._arg_with_dim(radius_increment))
         vArg2.append("Thread:=")
         vArg2.append(self._arg_with_dim(thread))
 
-        new_name = self.oeditor.CreateHelix(vArg1, vArg2)
-        return self._create_object(new_name)
+        self.oeditor.CreateHelix(vArg1, vArg2)
+        if polyline_name in self._object_names_to_ids:
+            del self.objects[self._object_names_to_ids[polyline_name]]
+        return self._create_object(polyline_name)
 
     @pyaedt_function_handler()
     def convert_segments_to_line(self, object_name):
         """Convert a CreatePolyline list of segments to lines.
 
         This method applies to splines and 3-point arguments.
 
@@ -1093,14 +1095,15 @@
 
         pts.append((x1, 0, elevation))
         p1 = self.create_polyline(
             pts, xsection_type="Rectangle", xsection_width=width, xsection_height=thickness, matname=material
         )
         if name:
             p1.name = name
+            self._create_object(name)
         return p1
 
     @pyaedt_function_handler()
     def _create_reference_cs_from_3dcomp(self, udm_obj, password):
         """Create a new coordinate system from the 3d component reference one.
 
         Returns
@@ -2076,40 +2079,41 @@
         return returned_list
 
     @pyaedt_function_handler()
     def _make_winding(self, name, material, in_rad, out_rad, height, teta, turns, chamf, sep_layer):
         import math
 
         teta_r = radians(teta)
-        points_list1 = [
+        points = [
             [in_rad * cos(teta_r), -in_rad * sin(teta_r), height / 2 - chamf],
             [(in_rad + chamf) * cos(teta_r), -(in_rad + chamf) * sin(teta_r), height / 2],
             [out_rad - chamf, 0, height / 2],
             [out_rad, 0, height / 2 - chamf],
             [out_rad, 0, -height / 2 + chamf],
             [out_rad - chamf, 0, -height / 2],
             [(in_rad + chamf) * cos(teta_r), (in_rad + chamf) * sin(teta_r), -height / 2],
             [in_rad * cos(teta_r), in_rad * sin(teta_r), -height / 2 + chamf],
             [in_rad * cos(teta_r), in_rad * sin(teta_r), height / 2 - chamf],
         ]
-        list_positions = [i for i in points_list1[:]]
+
+        positions = [i for i in points[:]]
         import math
 
         angle = -2 * teta * math.pi / 180
         for i in range(1, turns):
-            for k in points_list1[1:]:
-                list_positions.append(
+            for point in points[1:]:
+                positions.append(
                     [
-                        k[0] * math.cos(i * angle) + k[1] * math.sin(i * angle),
-                        -k[0] * math.sin(i * angle) + k[1] * math.cos(i * angle),
-                        k[2],
+                        point[0] * math.cos(i * angle) + point[1] * math.sin(i * angle),
+                        -point[0] * math.sin(i * angle) + point[1] * math.cos(i * angle),
+                        point[2],
                     ]
                 )
 
-        polyline = self.create_polyline(position_list=points_list1, name=name, matname=material)
+        polyline = self.create_polyline(position_list=points, name=name, matname=material)
         union_polyline1 = [polyline.name]
         if turns > 1:
             union_polyline2 = polyline.duplicate_around_axis(
                 cs_axis="Z", angle=2 * teta, nclones=turns, create_new_objects=True
             )
         else:
             union_polyline2 = []
@@ -2121,23 +2125,23 @@
             else:
                 list_positions2.extend(self.get_vertices_of_line(p)[1:])
         self.delete(union_polyline)
         # del list_positions[0]
 
         if sep_layer:
             for i in range(4):
-                list_positions.pop()
-            list_positions.insert(0, [list_positions[0][0], list_positions[0][1], -height])
-            list_positions.append([list_positions[-1][0], list_positions[-1][1], -height])
-            true_polyline = self.create_polyline(position_list=list_positions, name=name, matname=material)
+                positions.pop()
+            positions.insert(0, [positions[0][0], positions[0][1], -height])
+            positions.append([positions[-1][0], positions[-1][1], -height])
+            true_polyline = self.create_polyline(position_list=positions, name=name, matname=material)
             true_polyline.rotate("Z", 180 - (turns - 1) * teta)
-            list_positions = self.get_vertices_of_line(true_polyline.name)
-            return [true_polyline, list_positions]
+            positions = self.get_vertices_of_line(true_polyline.name)
+            return [true_polyline, positions]
 
-        return list_positions
+        return positions
 
     @pyaedt_function_handler()
     def _make_double_linked_winding(
         self,
         name,
         material,
         in_rad,
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/cad/components_3d.py` & `pyaedt-0.6.70/pyaedt/modeler/cad/components_3d.py`

 * *Files 1% similar despite different names*

```diff
@@ -160,14 +160,15 @@
                 ),
             )
             if props:
                 self._update_props(self._props["NativeComponentDefinitionProvider"], props)
             self.native_properties = self._props["NativeComponentDefinitionProvider"]
             self.auto_update = True
 
+    @pyaedt_function_handler()
     def history(self):
         """Component history.
 
         Returns
         -------
             :class:`pyaedt.modeler.cad.elements3d.BinaryTree` when successful,
             ``False`` when failed.
@@ -375,15 +376,17 @@
         -------
         dict
            :class:`pyaedt.modeler.Object3d`
 
         """
         component_parts = list(self._primitives.oeditor.GetChildObject(self.name).GetChildNames())
         parts_id = [
-            self._primitives.object_id_dict[part] for part in self._primitives.object_id_dict if part in component_parts
+            self._primitives._object_names_to_ids[part]
+            for part in self._primitives._object_names_to_ids
+            if part in component_parts
         ]
         parts_dict = {part_id: self._primitives.objects[part_id] for part_id in parts_id}
         return parts_dict
 
     @property
     def target_coordinate_system(self):
         """Target coordinate system.
@@ -509,15 +512,15 @@
     @pyaedt_function_handler()
     def rotate(self, cs_axis, angle=90.0, unit="deg"):
         """Rotate the selection.
 
         Parameters
         ----------
         cs_axis
-            Coordinate system axis or the Application.CoordinateSystemAxis object.
+            Coordinate system axis or the Application.AXIS object.
         angle : float, optional
             Angle of rotation. The units, defined by ``unit``, can be either
             degrees or radians. The default is ``90.0``.
         unit : text, optional
              Units for the angle. Options are ``"deg"`` or ``"rad"``.
              The default is ``"deg"``.
 
@@ -571,15 +574,15 @@
 
     @pyaedt_function_handler()
     def duplicate_around_axis(self, cs_axis, angle=90, nclones=2, create_new_objects=True):
         """Duplicate the component around the axis.
 
         Parameters
         ----------
-        cs_axis : Application.CoordinateSystemAxis object
+        cs_axis : Application.AXIS object
             Coordinate system axis of the object.
         angle : float, optional
             Angle of rotation in degrees. The default is ``90``.
         nclones : int, optional
             Number of clones. The default is ``2``.
         create_new_objects : bool, optional
             Whether to create copies as new objects. The default is ``True``.
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/cad/elements3d.py` & `pyaedt-0.6.70/pyaedt/modeler/cad/elements3d.py`

 * *Files 2% similar despite different names*

```diff
@@ -104,16 +104,16 @@
 
         vArg1 = ["NAME:Selections", "Selections:=", self._object3d.name, "NewPartsModelFlag:=", "Model"]
         vArg2 = ["NAME:FilletParameters"]
         vArg2.append("Edges:="), vArg2.append(edge_id_list)
         vArg2.append("Vertices:="), vArg2.append(vertex_id_list)
         vArg2.append("Radius:="), vArg2.append(self._object3d._primitives._arg_with_dim(radius))
         vArg2.append("Setback:="), vArg2.append(self._object3d._primitives._arg_with_dim(setback))
-        self._object3d.m_Editor.Fillet(vArg1, ["NAME:Parameters", vArg2])
-        if self._object3d.name in list(self._object3d.m_Editor.GetObjectsInGroup("UnClassified")):
+        self._object3d._oeditor.Fillet(vArg1, ["NAME:Parameters", vArg2])
+        if self._object3d.name in list(self._object3d._oeditor.GetObjectsInGroup("UnClassified")):
             self._object3d._primitives._odesign.Undo()
             self._object3d.logger.error("Operation failed, generating an unclassified object. Check and retry.")
             return False
         return True
 
     @pyaedt_function_handler()
     def chamfer(self, left_distance=1, right_distance=None, angle=45, chamfer_type=0):
@@ -177,16 +177,16 @@
         elif chamfer_type == 3:
             vArg2.append("LeftDistance:="), vArg2.append(str(angle) + "deg")
             vArg2.append("RightDistance:="), vArg2.append(self._object3d._primitives._arg_with_dim(right_distance))
             vArg2.append("ChamferType:="), vArg2.append("Right Distance-Angle")
         else:
             self._object3d.logger.error("Wrong Type Entered. Type must be integer from 0 to 3")
             return False
-        self._object3d.m_Editor.Chamfer(vArg1, ["NAME:Parameters", vArg2])
-        if self._object3d.name in list(self._object3d.m_Editor.GetObjectsInGroup("UnClassified")):
+        self._object3d._oeditor.Chamfer(vArg1, ["NAME:Parameters", vArg2])
+        if self._object3d.name in list(self._object3d._oeditor.GetObjectsInGroup("UnClassified")):
             self._object3d.odesign.Undo()
             self._object3d.logger.error("Operation Failed generating Unclassified object. Check and retry")
             return False
         return True
 
 
 class VertexPrimitive(EdgeTypePrimitive, object):
@@ -200,15 +200,15 @@
         Object ID as determined by the parent object.
 
     """
 
     def __init__(self, object3d, objid, position=None):
         self.id = objid
         self._object3d = object3d
-        self.oeditor = object3d.m_Editor
+        self.oeditor = object3d._oeditor
         self._position = position
 
     @property
     def position(self):
         """Position of the vertex.
 
         Returns
@@ -250,15 +250,15 @@
         Object ID as determined by the parent object.
 
     """
 
     def __init__(self, object3d, edge_id):
         self.id = edge_id
         self._object3d = object3d
-        self.oeditor = object3d.m_Editor
+        self.oeditor = object3d._oeditor
 
     @property
     def segment_info(self):
         """Compute segment information using the object-oriented method (from AEDT 2021 R2
         with beta options). The method manages segment info for lines, circles and ellipse
         providing information about all of those.
 
@@ -440,15 +440,15 @@
         """
         self._id = obj_id
         self._object3d = object3d
 
     @property
     def oeditor(self):
         """Oeditor Module."""
-        return self._object3d.m_Editor
+        return self._object3d._oeditor
 
     @property
     def logger(self):
         """Logger."""
         return self._object3d.logger
 
     @property
@@ -960,15 +960,15 @@
         self._point_coordinate_system = "Global"
         self._color = None
         self._position = None
         self._primitives = primitives
         self._all_props = None
 
     @property
-    def m_Editor(self):
+    def _oeditor(self):
         """Pointer to the oEditor object in the AEDT API. This property is
         intended primarily for use by FacePrimitive, EdgePrimitive, and
         VertexPrimitive child objects.
 
         Returns
         -------
         oEditor COM Object
@@ -1024,21 +1024,21 @@
 
         References
         ----------
 
         >>> oEditor.GetProperties
         """
         if not self._all_props:
-            self._all_props = _retry_ntimes(10, self.m_Editor.GetProperties, "Geometry3DPointTab", self._name)
+            self._all_props = _retry_ntimes(10, self._oeditor.GetProperties, "Geometry3DPointTab", self._name)
         return self._all_props
 
     # Note: We currently cannot get the color property value because
     # when we try to access it, we only get access to the 'edit' button.
     # Following is the line that we would use but it currently returns 'edit'.
-    # color = _retry_ntimes(10, self.m_Editor.GetPropertyValue, "Geometry3DPointTab", self._name, "Color")
+    # color = _retry_ntimes(10, self._oeditor.GetPropertyValue, "Geometry3DPointTab", self._name, "Color")
     def set_color(self, color_value):
         """Set symbol color.
 
         Parameters
         ----------
         color_value : string
             String exposing the new color of the point in the format of "(001 255 255)".
@@ -1098,15 +1098,15 @@
         >>> oEditor.ChangeProperty
 
         """
         if self._point_coordinate_system is not None:
             return self._point_coordinate_system
         if "Orientation" in self.valid_properties:
             self._point_coordinate_system = _retry_ntimes(
-                10, self.m_Editor.GetPropertyValue, "Geometry3DPointTab", self._name, "Orientation"
+                10, self._oeditor.GetPropertyValue, "Geometry3DPointTab", self._name, "Orientation"
             )
             return self._point_coordinate_system
 
     @coordinate_system.setter
     def coordinate_system(self, new_coordinate_system):
         coordinate_system = ["NAME:Orientation", "Value:=", new_coordinate_system]
         self._change_property(coordinate_system)
@@ -1119,15 +1119,15 @@
 
         References
         ----------
 
         >>> oEditor.Delete
         """
         arg = ["NAME:Selections", "Selections:=", self._name]
-        self.m_Editor.Delete(arg)
+        self._oeditor.Delete(arg)
         self._primitives.cleanup_objects()
         self.__dict__ = {}
 
     @pyaedt_function_handler()
     def _change_property(self, vPropChange):
         return self._primitives._change_point_property(vPropChange, self.name)
 
@@ -1162,15 +1162,15 @@
         self._color = None
         self._root_point = None
         self._normal = None
         self._primitives = primitives
         self._all_props = None
 
     @property
-    def m_Editor(self):
+    def _oeditor(self):
         """Pointer to the oEditor object in the AEDT API. This property is
         intended primarily for use by FacePrimitive, EdgePrimitive, and
         VertexPrimitive child objects.
 
         Returns
         -------
         oEditor COM Object
@@ -1229,21 +1229,21 @@
 
         References
         ----------
 
         >>> oEditor.GetProperties
         """
         if not self._all_props:
-            self._all_props = _retry_ntimes(10, self.m_Editor.GetProperties, "Geometry3DPlaneTab", self._name)
+            self._all_props = _retry_ntimes(10, self._oeditor.GetProperties, "Geometry3DPlaneTab", self._name)
         return self._all_props
 
     # Note: You currently cannot get the color property value because
     # when you try to access it, you only get access to the 'edit' button.
     # Following is the line that you would use, but it currently returns 'edit'.
-    # color = _retry_ntimes(10, self.m_Editor.GetPropertyValue, "Geometry3DPlaneTab", self._name, "Color")
+    # color = _retry_ntimes(10, self._oeditor.GetPropertyValue, "Geometry3DPlaneTab", self._name, "Color")
     @pyaedt_function_handler()
     def set_color(self, color_value):
         """Set symbol color.
 
         Parameters
         ----------
         color_value : string
@@ -1304,15 +1304,15 @@
         >>> oEditor.ChangeProperty
 
         """
         if self._plane_coordinate_system is not None:
             return self._plane_coordinate_system
         if "Orientation" in self.valid_properties:
             self._plane_coordinate_system = _retry_ntimes(
-                10, self.m_Editor.GetPropertyValue, "Geometry3DPlaneTab", self._name, "Orientation"
+                10, self._oeditor.GetPropertyValue, "Geometry3DPlaneTab", self._name, "Orientation"
             )
             return self._plane_coordinate_system
 
     @coordinate_system.setter
     def coordinate_system(self, new_coordinate_system):
         coordinate_system = ["NAME:Orientation", "Value:=", new_coordinate_system]
         self._change_property(coordinate_system)
@@ -1325,15 +1325,15 @@
 
         References
         ----------
 
         >>> oEditor.Delete
         """
         arg = ["NAME:Selections", "Selections:=", self._name]
-        self.m_Editor.Delete(arg)
+        self._oeditor.Delete(arg)
         self._primitives.cleanup_objects()
         self.__dict__ = {}
 
     @pyaedt_function_handler()
     def _change_property(self, vPropChange):
         return self._primitives._change_plane_property(vPropChange, self.name)
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/cad/object3d.py` & `pyaedt-0.6.70/pyaedt/modules/DesignXPloration.py`

 * *Files 22% similar despite different names*

```diff
@@ -1,1920 +1,1407 @@
-# -*- coding: utf-8 -*-
-"""
-This module contains these classes: `Components3DLayout`,`CircuitComponent',
-`EdgePrimitive`, `EdgeTypePrimitive`, `FacePrimitive`, `Geometries3DLayout`,
-`Nets3DLayout`, `Objec3DLayout`, `Object3d`, `Padstack`, `PDSHole`, `PDSLayer`,
-`Pins3DLayout', and `VertexPrimitive`.
-
-This module provides methods and data structures for managing all properties of
-objects (points, lines, sheeets, and solids) within the AEDT 3D Modeler.
-
-"""
-from __future__ import absolute_import  # noreorder
-
-import os
-import re
-import warnings
-
-from pyaedt.generic.constants import AEDT_UNITS
-from pyaedt.generic.general_methods import _retry_ntimes
-from pyaedt.generic.general_methods import _to_boolean
-from pyaedt.generic.general_methods import _uname
-from pyaedt.generic.general_methods import clamp
-from pyaedt.generic.general_methods import is_ironpython
-from pyaedt.generic.general_methods import open_file
+from collections import OrderedDict
+import copy
+import csv
+
+from pyaedt.generic.DataHandlers import _arg2dict
+from pyaedt.generic.DataHandlers import _dict2arg
+from pyaedt.generic.general_methods import PropsManager
+from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import pyaedt_function_handler
-from pyaedt.generic.general_methods import rgb_color_codes
-from pyaedt.generic.general_methods import settings
-from pyaedt.modeler.cad.elements3d import BinaryTreeNode
-from pyaedt.modeler.cad.elements3d import EdgePrimitive
-from pyaedt.modeler.cad.elements3d import FacePrimitive
-from pyaedt.modeler.cad.elements3d import VertexPrimitive
+from pyaedt.modules.OptimetricsTemplates import defaultdoeSetup
+from pyaedt.modules.OptimetricsTemplates import defaultdxSetup
+from pyaedt.modules.OptimetricsTemplates import defaultoptiSetup
+from pyaedt.modules.OptimetricsTemplates import defaultparametricSetup
+from pyaedt.modules.OptimetricsTemplates import defaultsensitivitySetup
+from pyaedt.modules.OptimetricsTemplates import defaultstatisticalSetup
+from pyaedt.modules.SolveSweeps import SetupProps
 
 
-class Object3d(object):
-    """Manages object attributes for the AEDT 3D Modeler.
+class CommonOptimetrics(PropsManager, object):
+    """Creates and sets up optimizations.
 
     Parameters
     ----------
-    primitives : :class:`pyaedt.modeler.Primitives3D.Primitives3D`
-        Inherited parent object.
-    name : str
+    p_app :
 
-    Examples
-    --------
-    Basic usage demonstrated with an HFSS design:
+    name :
 
-    >>> from pyaedt import Hfss
-    >>> aedtapp = Hfss()
-    >>> prim = aedtapp.modeler
+    dictinputs
 
-    Create a part, such as box, to return an :class:`pyaedt.modeler.Object3d.Object3d`.
+    optimtype : str
+        Type of the optimization.
 
-    >>> id = prim.create_box([0, 0, 0], [10, 10, 5], "Mybox", "Copper")
-    >>> part = prim[id]
     """
 
-    def __init__(self, primitives, name=None):
-        """
-        Parameters
-        ----------
-        primitives : :class:`pyaedt.modeler.Primitives3D.Primitives3D`
-            Inherited parent object.
-        name : str
-        """
-        self._id = None
-        if name:
-            self._m_name = name
-        else:
-            self._m_name = _uname()
-        self._primitives = primitives
-        self.flags = ""
-        self._part_coordinate_system = "Global"
-        self._material_name = None
-        self._transparency = None
-        self._solve_inside = None
-        self._is_updated = False
-        self._all_props = None
-        self._surface_material = None
-        self._color = None
-        self._wireframe = None
-        self._part_coordinate_system = None
-        self._model = None
-        self._m_groupName = None
-        self._object_type = None
-        self._mass = 0.0
-        self._volume = 0.0
-
-    @pyaedt_function_handler()
-    def _bounding_box_unmodel(self):
-        """Bounding box of a part, unmodel/undo method.
-
-        This is done by setting all other objects as unmodel and getting the model bounding box.
-        Then an undo operation restore the design.
-
-        Returns
-        -------
-        list of [list of float]
-            List of six ``[x, y, z]`` positions of the bounding box containing
-            Xmin, Ymin, Zmin, Xmax, Ymax, and Zmax values.
-
-        """
-        objs_to_unmodel = [
-            val.name for i, val in self._primitives.objects.items() if val.model and val.name != self.name
-        ]
-        if objs_to_unmodel:
-            vArg1 = ["NAME:Model", "Value:=", False]
-            self._primitives._change_geometry_property(vArg1, objs_to_unmodel)
-        modeled = True
-        if not self.model:
-            vArg1 = ["NAME:Model", "Value:=", True]
-            self._primitives._change_geometry_property(vArg1, self.name)
-            modeled = False
-        bounding = self._primitives.get_model_bounding_box()
-        if objs_to_unmodel:
-            self._odesign.Undo()
-        if not modeled:
-            self._odesign.Undo()
-        if not settings.non_graphical:
-            self._primitives._app.odesktop.ClearMessages(
-                self._primitives._app.project_name, self._primitives._app.design_name, 1
-            )
-        return bounding
-
-    @pyaedt_function_handler()
-    def _bounding_box_sat(self):
-        """Bounding box of a part.
-
-        This is done by exporting a part as a SAT file and reading the bounding box information from the SAT file.
-        A list of six 3D position vectors is returned.
-
-        Returns
-        -------
-        list of [list of float]
-            List of six ``[x, y, z]`` positions of the bounding box containing
-            Xmin, Ymin, Zmin, Xmax, Ymax, and Zmax values.
-
-        References
-        ----------
-
-        >>> oEditor.GetModelBoundingBox
-
-        """
-        tmp_path = self._primitives._app.working_directory
-        filename = os.path.join(tmp_path, self.name + ".sat")
-
-        self._primitives._app.export_3d_model(self.name, tmp_path, ".sat", [self.name])
-
-        if not os.path.isfile(filename):
-            raise Exception("Cannot export the ACIS SAT file for object {}".format(self.name))
-
-        with open_file(filename, "r") as fh:
-            temp = fh.read().splitlines()
-        all_lines = [s for s in temp if s.startswith("body ")]
-
-        bb = []
-        if len(all_lines) == 1:
-            line = all_lines[0]
-            pattern = r".+ (.+) (.+) (.+) (.+) (.+) (.+) #$"
-            m = re.search(pattern, line)
-            if m:
-                try:
-                    for i in range(1, 7):
-                        bb.append(float(m.group(i)))
-                except:
-                    return False
+    def __init__(self, p_app, name, dictinputs, optimtype):
+        self.auto_update = False
+        self._app = p_app
+        self.omodule = self._app.ooptimetrics
+        self.name = name
+        self.soltype = optimtype
+
+        inputd = copy.deepcopy(dictinputs)
+
+        if optimtype == "OptiParametric":
+            self.props = SetupProps(self, inputd or copy.deepcopy(defaultparametricSetup))
+            if not inputd and self._app.design_type == "Icepak":
+                self.props["ProdOptiSetupDataV2"] = OrderedDict(
+                    {"SaveFields": False, "FastOptimetrics": False, "SolveWithCopiedMeshOnly": True}
+                )
+        if optimtype == "OptiDesignExplorer":
+            self.props = SetupProps(self, inputd or copy.deepcopy(defaultdxSetup))
+        if optimtype == "OptiOptimization":
+            self.props = SetupProps(self, inputd or copy.deepcopy(defaultoptiSetup))
+        if optimtype == "OptiSensitivity":
+            self.props = SetupProps(self, inputd or copy.deepcopy(defaultsensitivitySetup))
+        if optimtype == "OptiStatistical":
+            self.props = SetupProps(self, inputd or copy.deepcopy(defaultstatisticalSetup))
+        if optimtype == "OptiDXDOE":
+            self.props = SetupProps(self, inputd or copy.deepcopy(defaultdoeSetup))
+        if optimtype == "optiSLang":
+            self.props = SetupProps(self, inputd or copy.deepcopy(defaultdxSetup))
+        if inputd:
+            self.props.pop("ID", None)
+            self.props.pop("NextUniqueID", None)
+            self.props.pop("MoveBackwards", None)
+            self.props.pop("GoalSetupVersion", None)
+            self.props.pop("Version", None)
+            self.props.pop("SetupType", None)
+            if inputd.get("Sim. Setups"):
+                setups = inputd["Sim. Setups"]
+                for el in setups:
+                    if type(self._app.design_properties["SolutionManager"]["ID Map"]["Setup"]) is list:
+                        for setup in self._app.design_properties["SolutionManager"]["ID Map"]["Setup"]:
+                            if setup["I"] == el:
+                                setups[setups.index(el)] = setup["I"]
+                                break
+                    else:
+                        if self._app.design_properties["SolutionManager"]["ID Map"]["Setup"]["I"] == el:
+                            setups[setups.index(el)] = self._app.design_properties["SolutionManager"]["ID Map"][
+                                "Setup"
+                            ]["N"]
+                            break
+            if inputd.get("Goals", None):
+                if self._app._is_object_oriented_enabled():
+                    oparams = self.omodule.GetChildObject(self.name).GetCalculationInfo()
+                    oparam = [i for i in oparams[0]]
+                    calculation = ["NAME:Goal"]
+                    calculation.extend(oparam)
+                    arg1 = OrderedDict()
+                    _arg2dict(calculation, arg1)
+                    self.props["Goals"] = arg1
+        self.auto_update = True
+
+    @pyaedt_function_handler()
+    def _get_context(
+        self,
+        expressions,
+        condition,
+        goal_weight,
+        goal_value,
+        setup_sweep_name=None,
+        domain="Sweep",
+        intrinsics=None,
+        report_category=None,
+        context=None,
+        subdesign_id=None,
+        polyline_points=0,
+        is_goal=False,
+    ):
+        did = 3
+        if domain != "Sweep":
+            did = 1
+        sweepdefinition = OrderedDict()
+        sweepdefinition["ReportType"] = report_category
+        if not setup_sweep_name:
+            setup_sweep_name = self._app.nominal_sweep
+        sweepdefinition["Solution"] = setup_sweep_name
+        ctxt = OrderedDict({})
+
+        if self._app.solution_type in ["TR", "AC", "DC"]:
+            ctxt["SimValueContext"] = [did, 0, 2, 0, False, False, -1, 1, 0, 1, 1, "", 0, 0]
+            setup_sweep_name = self._app.solution_type
+            sweepdefinition["Solution"] = setup_sweep_name
+
+        elif self._app.solution_type in ["HFSS3DLayout"]:
+            if context == "Differential Pairs":
+                ctxt["SimValueContext"] = [
+                    did,
+                    0,
+                    2,
+                    0,
+                    False,
+                    False,
+                    -1,
+                    1,
+                    0,
+                    1,
+                    1,
+                    "",
+                    0,
+                    0,
+                    "EnsDiffPairKey",
+                    False,
+                    "1",
+                    "IDIID",
+                    False,
+                    "1",
+                ]
             else:
-                return False
-        else:
-            return False
-
-        try:
-            os.remove(filename)
-        except:
-            self.logger.warning("ERROR: Cannot remove temp file.")
-        return bb
-
-    @property
-    def bounding_box(self):
-        """Bounding box of a part.
-
-        A list of six 3D position vectors is returned.
-
-        Returns
-        -------
-        list of [list of float]
-            List of six ``[x, y, z]`` positions of the bounding box containing
-            Xmin, Ymin, Zmin, Xmax, Ymax, and Zmax values.
-
-        References
-        ----------
-
-        >>> oEditor.GetModelBoundingBox
+                ctxt["SimValueContext"] = [did, 0, 2, 0, False, False, -1, 1, 0, 1, 1, "", 0, 0, "IDIID", False, "1"]
 
-        """
-        if self.object_type == "Unclassified":
-            return [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
-        if not settings.disable_bounding_box_sat:
-            bounding = self._bounding_box_sat()
-            if bounding:
-                return bounding
+        elif self._app.solution_type in ["NexximLNA", "NexximTransient"]:
+            ctxt["SimValueContext"] = [did, 0, 2, 0, False, False, -1, 1, 0, 1, 1, "", 0, 0]
+            if subdesign_id:
+                ctxt_temp = ["NUMLEVELS", False, "1", "SUBDESIGNID", False, str(subdesign_id)]
+                ctxt["SimValueContext"].extend(ctxt_temp)
+            if context == "Differential Pairs":
+                ctxt_temp = ["USE_DIFF_PAIRS", False, "1"]
+                ctxt["SimValueContext"].extend(ctxt_temp)
+        elif context == "Differential Pairs":
+            ctxt["SimValueContext"] = ["Diff:=", "Differential Pairs", "Domain:=", domain]
+        elif self._app.solution_type in ["Q3D Extractor", "2D Extractor"]:
+            if not context:
+                ctxt["Context"] = "Original"
             else:
-                return self._bounding_box_unmodel()
+                ctxt["Context"] = context
+        elif context:
+            ctxt["Context"] = context
+            if context in self._app.modeler.line_names:
+                ctxt["PointCount"] = polyline_points
         else:
-            return self._bounding_box_unmodel()
-
-    @property
-    def bounding_dimension(self):
-        """Retrieve the dimension array of the bounding box.
-
-        Returns
-        -------
-        list
-            List of three float values representing the bounding box dimensions
-            in the form ``[dim_x, dim_y, dim_z]``.
-
-        References
-        ----------
-
-        >>> oEditor.GetModelBoundingBox
-        """
-        oBoundingBox = self.bounding_box
-        dimensions = []
-        dimensions.append(abs(float(oBoundingBox[0]) - float(oBoundingBox[3])))
-        dimensions.append(abs(float(oBoundingBox[1]) - float(oBoundingBox[4])))
-        dimensions.append(abs(float(oBoundingBox[2]) - float(oBoundingBox[5])))
-        return dimensions
-
-    @property
-    def _odesign(self):
-        """Design."""
-        return self._primitives._modeler._app._odesign
-
-    @pyaedt_function_handler()
-    def plot(self, show=True):
-        """Plot model with PyVista.
-
-        Parameters
-        ----------
-        show : bool, optional
-            Show the plot after generation.  The default value is ``True``.
-
-        Returns
-        -------
-        :class:`pyaedt.generic.plot.ModelPlotter`
-            Model Object.
-
-        Notes
-        -----
-        Works from AEDT 2021.2 in CPython only. PyVista has to be installed.
-        """
-        if not is_ironpython and self._primitives._app._aedt_version >= "2021.2":
-            return self._primitives._app.post.plot_model_obj(
-                objects=[self.name],
-                plot_as_separate_objects=True,
-                plot_air_objects=True,
-                show=show,
-            )
-
-    @pyaedt_function_handler()
-    def export_image(self, file_path=None):
-        """Export the current object to a specified file path.
-
-
-        .. note::
-           Works from AEDT 2021.2 in CPython only. PyVista has to be installed.
-
-        Parameters
-        ----------
-        file_path : str, optional
-            File name with full path. If `None` the exported image will be a ``png`` file that
-            will be saved in ``working_directory``.
-            To access the ``working_directory`` the use ``app.working_directory`` property.
-
-        Returns
-        -------
-        str
-            File path.
-        """
-        if not is_ironpython and self._primitives._app._aedt_version >= "2021.2":
-            if not file_path:
-                file_path = os.path.join(self._primitives._app.working_directory, self.name + ".png")
-            model_obj = self._primitives._app.post.plot_model_obj(
-                objects=[self.name],
-                show=False,
-                export_path=file_path,
-                plot_as_separate_objects=True,
-                clean_files=True,
+            ctxt = OrderedDict({"Domain": domain})
+        sweepdefinition["SimValueContext"] = ctxt
+        sweepdefinition["Calculation"] = expressions
+        sweepdefinition["Name"] = expressions
+        sweepdefinition["Ranges"] = OrderedDict({})
+        if context and context in self._app.modeler.line_names and intrinsics and "Distance" not in intrinsics:
+            sweepdefinition["Ranges"]["Range"] = ("Var:=", "Distance", "Type:=", "a")
+        if not setup_sweep_name:
+            setup_sweep_name = self._app.nominal_sweep
+            if not setup_sweep_name:
+                self._app.logger.error("Sweep not Available.")
+                return False
+        elif setup_sweep_name not in self._app.existing_analysis_sweeps:
+            self._app.logger.error("Sweep not Available.")
+            return False
+        if intrinsics:
+            for v, k in intrinsics.items():
+                if not k:
+                    r = ["Var:=", v, "Type:=", "a"]
+                elif isinstance(k, tuple):
+                    r = ["Var:=", v, "Type:=", "rd"]
+                    r.append("Start:=")
+                    r.append(k[0])
+                    r.append("Stop:=")
+                    r.append(k[1])
+                    r.append("DiscreteValues:=")
+                    r.append("")
+                elif isinstance(k, (list, str)):
+                    r = ["Var:=", v, "Type:=", "d"]
+                    r.append("DiscreteValues:=")
+                    if isinstance(k, list):
+                        r.append(",".join(k))
+                    else:
+                        r.append(k)
+
+                if not sweepdefinition["Ranges"]:
+                    sweepdefinition["Ranges"]["Range"] = tuple(r)
+                elif isinstance(sweepdefinition["Ranges"]["Range"], list):
+                    sweepdefinition["Ranges"]["Range"].append(tuple(r))
+                else:
+                    sweepdefinition["Ranges"]["Range"] = [sweepdefinition["Ranges"]["Range"]]
+                    sweepdefinition["Ranges"]["Range"].append(tuple(r))
+        if is_goal:
+            sweepdefinition["Condition"] = condition
+            sweepdefinition["GoalValue"] = OrderedDict(
+                {"GoalValueType": "Independent", "Format": "Real/Imag", "bG": ["v:=", "[{};]".format(goal_value)]}
             )
-            if model_obj:
-                return model_obj.image_file
-        return False
-
-    @property
-    def touching_objects(self):
-        """Get the objects that touch one of the vertex, edge midpoint or face of the object."""
-        if self.object_type == "Unclassified":
-            return []
-        list_names = []
-        for vertex in self.vertices:
-            body_names = self._primitives.get_bodynames_from_position(vertex.position)
-            a = [i for i in body_names if i != self.name and i not in list_names]
-            if a:
-                list_names.extend(a)
-        for edge in self.edges:
-            body_names = self._primitives.get_bodynames_from_position(edge.midpoint)
-            a = [i for i in body_names if i != self.name and i not in list_names]
-            if a:
-                list_names.extend(a)
-        for face in self.faces:
-            body_names = self._primitives.get_bodynames_from_position(face.center)
-            a = [i for i in body_names if i != self.name and i not in list_names]
-            if a:
-                list_names.extend(a)
-        return list_names
+            sweepdefinition["Weight"] = "[{};]".format(goal_weight)
+        return sweepdefinition
 
     @pyaedt_function_handler()
-    def get_touching_faces(self, object_name):
-        """Get the objects that touch one of the face center of each face of the object.
+    def update(self, update_dictionary=None):
+        """Update the setup based on stored properties.
 
         Parameters
         ----------
-        object_name : str, :class:`Object3d`
-            Object to check.
-        Returns
-        -------
-        list
-            list of objects and faces touching."""
-
-        _names = []
-        if isinstance(object_name, Object3d):
-            object_name = object_name.name
-        for face in self.faces:
-            body_names = self._primitives.get_bodynames_from_position(face.center)
-            if object_name in body_names:
-                _names.append(face)
-        return _names
-
-    @property
-    def faces(self):
-        """Information for each face in the given part.
+        update_dictionary : dict, optional
+            Dictionary to use. The  default is ``None``.
 
         Returns
         -------
-        list of :class:`pyaedt.modeler.elements3d.FacePrimitive`
+        bool
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oEditor.GetFaceIDs
-
-        """
-        if self.object_type == "Unclassified":
-            return []
-        faces = []
-        for face in list(self.m_Editor.GetFaceIDs(self.name)):
-            face = int(face)
-            faces.append(FacePrimitive(self, face))
-        return faces
-
-    @property
-    def faces_on_bounding_box(self):
-        """Return only the face ids of the faces touching the bounding box.
-
-        Returns
-        -------
-        List of :class:`pyaedt.modeler.Object3d.FacePrimitive`
-        """
-        f_list = []
-        for face in self.faces:
-            if face.is_on_bounding():
-                f_list.append(face)
-        return f_list
-
-    @property
-    def face_closest_to_bounding_box(self):
-        """Return only the face ids of the face closest to the bounding box.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.FacePrimitive`
-        """
-        b = [float(i) for i in list(self.m_Editor.GetModelBoundingBox())]
-        f_id = None
-        f_val = None
-        for face in self.faces:
-            c = face.center
-            p_dist = min(
-                [
-                    abs(c[0] - b[0]),
-                    abs(c[1] - b[1]),
-                    abs(c[2] - b[2]),
-                    abs(c[0] - b[3]),
-                    abs(c[1] - b[4]),
-                    abs(c[2] - b[5]),
-                ]
-            )
-
-            if f_val and p_dist < f_val or not f_val:
-                f_id = face
-                f_val = p_dist
-        return f_id
-
-    @pyaedt_function_handler()
-    def largest_face(self, n=1):
-        """Return only the face with the greatest area.
-
-        Returns
-        -------
-        List of :class:`pyaedt.modeler.Object3d.FacePrimitive`
-        """
-        f = []
-        for face in self.faces:
-            f.append((face.area, face))
-        f.sort(key=lambda tup: tup[0], reverse=True)
-        f_sorted = [x for y, x in f]
-        return f_sorted[:n]
-
-    @pyaedt_function_handler()
-    def longest_edge(self, n=1):
-        """Return only the edge with the greatest length.
-
-        Returns
-        -------
-        List of :class:`pyaedt.modeler.Object3d.EdgePrimitive`
+        >>> oModule.EditSetup
         """
-        e = []
-        for edge in self.edges:
-            e.append((edge.length, edge))
-        e.sort(key=lambda tup: tup[0], reverse=True)
-        e_sorted = [x for y, x in e]
-        return e_sorted[:n]
-
-    @pyaedt_function_handler()
-    def smallest_face(self, n=1):
-        """Return only the face with the smallest area.
+        if update_dictionary:
+            for el in update_dictionary:
+                self.props._setitem_without_update(el, update_dictionary[el])
+
+        arg = ["NAME:" + self.name]
+        _dict2arg(self.props, arg)
+
+        if self.soltype == "OptiParametric" and len(arg[8]) == 3:
+            arg[8] = ["NAME:Sweep Operations"]
+            for variation in self.props["Sweep Operations"].get("add", []):
+                arg[8].append("add:=")
+                arg[8].append(variation)
 
-        Returns
-        -------
-        List of :class:`pyaedt.modeler.Object3d.FacePrimitive`
-        """
-        f = []
-        for face in self.faces:
-            f.append((face.area, face))
-        f.sort(key=lambda tup: tup[0])
-        f_sorted = [x for y, x in f]
-        return f_sorted[:n]
+        self.omodule.EditSetup(self.name, arg)
+        return True
 
     @pyaedt_function_handler()
-    def shortest_edge(self, n=1):
-        """Return only the edge with the smallest length.
-
-        Returns
-        -------
-        List of :class:`pyaedt.modeler.Object3d.EdgePrimitive`
-        """
-        e = []
-        for edge in self.edges:
-            e.append((edge.length, edge))
-        e.sort(
-            key=lambda tup: tup[0],
-        )
-        e_sorted = [x for y, x in e]
-        return e_sorted[:n]
-
-    @property
-    def top_face_z(self):
-        """Top face in the Z direction of the object.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.FacePrimitive`
-
-        References
-        ----------
-
-        >>> oEditor.FaceCenter
-
-        """
-        try:
-            result = [(float(face.center[2]), face) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[-1][1]
-        except:
-            return None
-
-    @property
-    def bottom_face_z(self):
-        """Bottom face in the Z direction of the object.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.FacePrimitive`
-
-        References
-        ----------
-
-        >>> oEditor.FaceCenter
-
-        """
-        try:
-            result = [(float(face.center[2]), face) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[0][1]
-        except:
-            return None
-
-    @property
-    def top_face_x(self):
-        """Top face in the X direction of the object.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.FacePrimitive`
-
-        References
-        ----------
-
-        >>> oEditor.FaceCenter
-
-        """
-        try:
-            result = [(float(face.center[0]), face) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[-1][1]
-        except:
-            return None
-
-    @property
-    def bottom_face_x(self):
-        """Bottom face in the X direction of the object.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.FacePrimitive`
-
-        References
-        ----------
-
-        >>> oEditor.FaceCenter
-
-        """
-        try:
-            result = [(float(face.center[0]), face) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[0][1]
-        except:
-            return None
-
-    @property
-    def top_face_y(self):
-        """Top face in the Y direction of the object.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.FacePrimitive`
-
-        References
-        ----------
-
-        >>> oEditor.FaceCenter
-
-        """
-        try:
-            result = [(float(face.center[1]), face) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[-1][1]
-        except:
-            return None
-
-    @property
-    def bottom_face_y(self):
-        """Bottom face in the X direction of the object.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.FacePrimitive`
-
-        References
-        ----------
-
-        >>> oEditor.FaceCenter
-
-        """
-        try:
-            result = [(float(face.center[1]), face) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[0][1]
-        except:
-            return None
-
-    @property
-    def top_edge_z(self):
-        """Top edge in the Z direction of the object. Midpoint is used as criteria to find the edge.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
-
-        References
-        ----------
-
-        >>> oEditor.FaceCenter
-
-        """
-        try:
-            result = [(float(face.top_edge_z.midpoint[2]), face.top_edge_z) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[-1][1]
-        except:
-            return None
-
-    @property
-    def bottom_edge_z(self):
-        """Bottom edge in the Z direction of the object. Midpoint is used as criteria to find the edge.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
-
-        """
-        try:
-            result = [(float(face.bottom_edge_z.midpoint[2]), face.bottom_edge_z) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[0][1]
-        except:
-            return None
-
-    @property
-    def top_edge_x(self):
-        """Top edge in the X direction of the object. Midpoint is used as criteria to find the edge.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
-
-        """
-        try:
-            result = [(float(face.top_edge_x.midpoint[0]), face.top_edge_x) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[-1][1]
-        except:
-            return None
-
-    @property
-    def bottom_edge_x(self):
-        """Bottom edge in the X direction of the object. Midpoint is used as criteria to find the edge.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
-
-        """
-        try:
-            result = [(float(face.bottom_edge_x.midpoint[0]), face.bottom_edge_x) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[0][1]
-        except:
-            return None
-
-    @property
-    def top_edge_y(self):
-        """Top edge in the Y direction of the object. Midpoint is used as criteria to find the edge.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
-
-        """
-        try:
-            result = [(float(face.top_edge_y.midpoint[1]), face.top_edge_y) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[-1][1]
-        except:
-            return None
-
-    @property
-    def bottom_edge_y(self):
-        """Bottom edge in the X direction of the object. Midpoint is used as criteria to find the edge.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.elements3d.EdgePrimitive`
-
-        """
-        try:
-            result = [(float(face.bottom_edge_y.midpoint[1]), face.bottom_edge_y) for face in self.faces]
-            result = sorted(result, key=lambda tup: tup[0])
-            return result[0][1]
-        except:
-            return None
-
-    @property
-    def edges(self):
-        """Information for each edge in the given part.
-
-        Returns
-        -------
-        list of :class:`pyaedt.modeler.elements3d.EdgePrimitive`
-
-        References
-        ----------
-
-        >>> oEditor.GetEdgeIDsFromObject
-
-        """
-        if self.object_type == "Unclassified":
-            return []
-        edges = []
-        for edge in self._primitives.get_object_edges(self.name):
-            edge = int(edge)
-            edges.append(EdgePrimitive(self, edge))
-        return edges
-
-    @property
-    def vertices(self):
-        """Information for each vertex in the given part.
-
-        Returns
-        -------
-        list of :class:`pyaedt.modeler.elements3d.VertexPrimitive`
-
-        References
-        ----------
-
-        >>> oEditor.GetVertexIDsFromObject
-
-        """
-        if self.object_type == "Unclassified":
-            return []
-        vertices = []
-
-        v = [i for i in self._primitives.get_object_vertices(self.name)]
-        if not v:
-            for el in self.edges:
-                pos = [float(p) for p in self._primitives.oeditor.GetEdgePositionAtNormalizedParameter(el.id, 0)]
-                vertices.append(VertexPrimitive(self, -1, pos))
-        if settings.aedt_version > "2022.2":
-            v = v[::-1]
-        for vertex in v:
-            vertex = int(vertex)
-            vertices.append(VertexPrimitive(self, vertex))
-        return vertices
-
-    @property
-    def m_Editor(self):
-        """Pointer to the oEditor object in the AEDT API. This property is
-        intended primarily for use by FacePrimitive, EdgePrimitive, and
-        VertexPrimitive child objects.
-
-        Returns
-        -------
-        oEditor COM Object
-
-        """
-        return self._primitives.oeditor
-
-    @property
-    def logger(self):
-        """Logger."""
-        return self._primitives.logger
-
-    @property
-    def surface_material_name(self):
-        """Surface material name of the object.
+    def create(self):
+        """Create a setup.
 
         Returns
         -------
-        str or None
-            Name of the surface material when successful, ``None`` and a warning message otherwise.
-
-        References
-        ----------
-
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
-
-        """
-        if self._surface_material is not None:
-            return self._surface_material
-        if "Surface Material" in self.valid_properties and self.model:
-            self._surface_material = _retry_ntimes(
-                10, self.m_Editor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Surface Material"
-            )
-            return self._surface_material.strip('"')
-
-    @property
-    def group_name(self):
-        """Group the object belongs to.
-
-        Returns
-        -------
-        str
-            Name of the group.
+        bool
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
-
+        >>> oModule.InsertSetup
         """
-        if self._m_groupName is not None:
-            return self._m_groupName
-        if "Group" in self.valid_properties:
-            self._m_groupName = _retry_ntimes(
-                10, self.m_Editor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Group"
-            )
-            return self._m_groupName
+        arg = ["NAME:" + self.name]
+        _dict2arg(self.props, arg)
+        self.omodule.InsertSetup(self.soltype, arg)
+        return True
 
-    @group_name.setter
-    def group_name(self, name):
-        """Assign Object to a specific group. it creates a new group if the group doesn't exist.
+    @pyaedt_function_handler()
+    def _add_calculation(
+        self,
+        calculation,
+        ranges=None,
+        variables=None,
+        solution=None,
+        context=None,
+        subdesign_id=None,
+        polyline_points=1001,
+        report_type=None,
+        is_goal=False,
+        condition="<=",
+        goal_value=1,
+        goal_weight=1,
+    ):
+        self.auto_update = False
+        if not solution:
+            solution = self._app.nominal_sweep
+        setupname = solution.split(" ")[0]
+        if setupname not in self.props["Sim. Setups"]:
+            self.props["Sim. Setups"].append(setupname)
+        domain = "Time"
+        if (ranges and ("Freq" in ranges or "Phase" in ranges or "Theta" in ranges)) or self._app.solution_type in [
+            "Magnetostatic",
+            "Electrostatic",
+            "EddyCurrent",
+            "DCConduction",
+            "Eigenmode",
+        ]:
+            domain = "Sweep"
+        if not report_type:
+            report_type = self._app.design_solutions.report_type
+            if context and context in self._app.modeler.sheet_names:
+                report_type = "Fields"
+            elif self._app.solution_type in ["Q3D Extractor", "2D Extractor"]:
+                report_type = "Matrix"
+            elif context:
+                try:
+                    for f in self._app.field_setups:
+                        if context == f.name:
+                            report_type = "Far Fields"
+                except:
+                    pass
+        sweepdefinition = self._get_context(
+            calculation,
+            condition,
+            goal_weight,
+            goal_value,
+            solution,
+            domain,
+            ranges,
+            report_type,
+            context,
+            subdesign_id,
+            polyline_points,
+            is_goal,
+        )
+        dx_variables = {}
+        if variables:
+            for el in list(variables):
+                try:
+                    dx_variables[el] = self._app[el]
+                except:
+                    pass
+        for v in list(dx_variables.keys()):
+            self._activate_variable(v)
+        if self.soltype in ["OptiDesignExplorer", "OptiDXDOE"] and is_goal:
+            optigoalname = "CostFunctionGoals"
+        else:
+            optigoalname = "Goals"
+        if "Goal" in self.props[optigoalname]:
+            if type(self.props[optigoalname]["Goal"]) is not list:
+                self.props[optigoalname]["Goal"] = [self.props[optigoalname]["Goal"], sweepdefinition]
+            else:
+                self.props[optigoalname]["Goal"].append(sweepdefinition)
+        else:
+            self.props[optigoalname] = OrderedDict({})
+            self.props[optigoalname]["Goal"] = sweepdefinition
+        self.auto_update = True
+        return self.update()
+
+    @pyaedt_function_handler()
+    def _add_goal(
+        self,
+        optigoalname,
+        reporttype,
+        solution=None,
+        domain="Sweep",
+        calculation="",
+        calculation_type="discrete",
+        calc_val1="",
+        calc_val2="",
+        condition="==",
+        goal_value=1,
+        goal_weight=1,
+        goal_name=None,
+    ):
+        """Add an optimization goal to the setup.
 
         Parameters
         ----------
-        name : str
-            Name of the group to assign. Group will be created if it does not exist.
+        optigoalname : str
+            Name of the optimization goal.
+        reporttype : str, optional
+            Type of the report.
+        solution : str, optional
+            Type of the solution. The default is ``None``.
+        domain : str, optional
+            Type of the domain. The default is ``"Sweep"''.
+        calculation : str, optional
+            Name of the calculation. The default is ``""``.
+        calculation_type : str, optional
+            Type of the calculation. The default is ``"discrete"``.
+        calc_val1 : str, optional
+            First value for the calculation. The default is ``""``.
+        calc_val2 : str, optional
+            Second value for the calculation. The default is ``""``.
+        condition : str, optional
+            The condition for the calculation. The default is ``"=="``.
+        goal_value : optional
+            Value for the optimization goal. The default is ``1``.
+        goal_weight : optional
+            Weight for the optimization goal. The default is ``1``.
+        goal_name : str, optional
+            Name of the goal. The default is ``None``.
 
         Returns
         -------
-        str
-            Name of the group.
-
-        References
-        ----------
-
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
 
         """
-
-        if not list(self.m_Editor.GetObjectsInGroup(name)):
-            self.m_Editor.CreateGroup(
-                [
-                    "NAME:GroupParameter",
-                    "ParentGroupID:=",
-                    "Model",
-                    "Parts:=",
-                    self._m_name,
-                    "SubmodelInstances:=",
-                    "",
-                    "Groups:=",
-                    "",
-                ]
-            )
-            groupName = _retry_ntimes(
-                10, self.m_Editor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Group"
-            )
-            self.m_Editor.ChangeProperty(
-                [
-                    "NAME:AllTabs",
-                    [
-                        "NAME:Attributes",
-                        ["NAME:PropServers", groupName],
-                        ["NAME:ChangedProps", ["NAME:Name", "Value:=", name]],
-                    ],
-                ]
-            )
-            self._m_groupName = name
+        self.auto_update = False
+        sweepdefinition = OrderedDict()
+        sweepdefinition["ReportType"] = reporttype
+        if not solution:
+            solution = self._app.nominal_sweep
+        setupname = solution.split(" ")[0]
+        if setupname not in self.props["Sim. Setups"]:
+            self.props["Sim. Setups"].append(setupname)
+        sweepdefinition["Solution"] = solution
+        sweepdefinition["SimValueContext"] = OrderedDict({"Domain": domain})
+        sweepdefinition["Calculation"] = calculation
+        if goal_name:
+            sweepdefinition["Name"] = goal_name
         else:
-            vgroup = ["NAME:Group", "Value:=", name]
-            self._change_property(vgroup)
-            self._m_groupName = name
-
-    @property
-    def material_name(self):
-        """Material name of the object.
-
-        Returns
-        -------
-        str or None
-            Name of the material when successful, ``None`` and a warning message otherwise.
-
-        References
-        ----------
-
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
-
-        """
-        if self._material_name is not None:
-            return self._material_name
-        if "Material" in self.valid_properties and self.model:
-            mat = _retry_ntimes(10, self.m_Editor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Material")
-            self._material_name = ""
-            if mat:
-                self._material_name = mat.strip('"').lower()
-            return self._material_name
-        return ""
-
-    @material_name.setter
-    def material_name(self, mat):
-        matobj = self._primitives._materials.checkifmaterialexists(mat)
-        if matobj:
-            if not self.model:
-                self.model = True
-            vMaterial = ["NAME:Material", "Value:=", chr(34) + matobj.name + chr(34)]
-            self._change_property(vMaterial)
-            self._material_name = matobj.name.lower()
-            self._solve_inside = None
+            sweepdefinition["Name"] = generate_unique_name(calculation)
+        if domain == "Sweep":
+            var = "Freq"
         else:
-            self.logger.warning("Material %s does not exist.", mat)
-
-    @surface_material_name.setter
-    def surface_material_name(self, mat):
-        try:
-            if not self.model:
-                self.model = True
-            self._surface_material = mat
-            vMaterial = ["NAME:Surface Material", "Value:=", '"' + mat + '"']
-            self._change_property(vMaterial)
-            self._surface_material = mat
-        except:
-            self.logger.warning("Material %s does not exist", mat)
-
-    @property
-    def id(self):
-        """ID of the object.
-
-        Returns
-        -------
-        int or None
-            ID of the object when successful, ``None`` otherwise.
-
-        References
-        ----------
-
-        >>> oEditor.GetObjectIDByName
-
-        """
-        if not self._id:
-            try:
-                self._id = self._primitives.oeditor.GetObjectIDByName(self._m_name)
-            except:
-                return None
-        return self._id
-
-    @property
-    def object_type(self):
-        """Type of the object.
-
-        Options are:
-             * Solid
-             * Sheet
-             * Line
-
-        Returns
-        -------
-        str
-            Type of the object.
-
-        """
-        if self._object_type:
-            return self._object_type
-        if self._m_name in list(self.m_Editor.GetObjectsInGroup("Solids")):
-            self._object_type = "Solid"
-        elif self._m_name in list(self.m_Editor.GetObjectsInGroup("Sheets")):
-            self._object_type = "Sheet"
-        elif self._m_name in list(self.m_Editor.GetObjectsInGroup("Lines")):
-            self._object_type = "Line"
-        elif self._m_name in list(self.m_Editor.GetObjectsInGroup("Unclassified")):  # pragma: no cover
-            self._object_type = "Unclassified"  # pragma: no cover
-        return self._object_type
-
-    @property
-    def is3d(self):
-        """Check for if the object is 3D.
-
-        Returns
-        -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
-        """
-        if self.object_type == "Solid":
-            return True
+            var = "Time"
+        if calculation_type == "discrete":
+            if type(calc_val1) is list:
+                dr = ",".join(calc_val1)
+            else:
+                dr = calc_val1
+            sweepdefinition["Ranges"] = OrderedDict({"Range": ["Var:=", var, "Type:=", "d", "DiscreteValues:=", dr]})
+        elif calculation_type == "all":
+            sweepdefinition["Ranges"] = OrderedDict(
+                {
+                    "Range": [
+                        "Var:=",
+                        var,
+                        "Type:=",
+                        "a",
+                    ]
+                }
+            )
         else:
-            return False
-
-    @property
-    def mass(self):
-        """Object mass.
-
-        Returns
-        -------
-        float or None
-            Mass of the object when successful, 0.0 otherwise. Mass of the volume in kg since AEDT mass density is
-            always in kg/m^3
-
-        References
-        ----------
-
-        >>> oEditor.GetObjectVolume
-
-        """
-        if self.model and self.material_name:
-            volume = self._primitives.oeditor.GetObjectVolume(self._m_name)
-            units = self.object_units
-            mass_density = (
-                float(self._primitives._materials[self.material_name].mass_density.value)
-                * float(volume)
-                * float(AEDT_UNITS["Length"][str(units)]) ** 3
+            sweepdefinition["Ranges"] = OrderedDict(
+                {
+                    "Range": [
+                        "Var:=",
+                        var,
+                        "Type:=",
+                        calculation_type,
+                        "Start:=",
+                        calc_val1,
+                        "Stop:=",
+                        calc_val2,
+                        "DiscreteValues:=",
+                        "",
+                    ]
+                }
             )
-            self._mass = mass_density
+        sweepdefinition["Condition"] = condition
+        sweepdefinition["GoalValue"] = OrderedDict(
+            {"GoalValueType": "Independent", "Format": "Real/Imag", "bG": ["v:=", "[{};]".format(goal_value)]}
+        )
+        sweepdefinition["Weight"] = "[{};]".format(goal_weight)
+        if "Goal" in self.props[optigoalname]:
+            if type(self.props[optigoalname]["Goal"]) is not list:
+                self.props[optigoalname]["Goal"] = [self.props[optigoalname]["Goal"], sweepdefinition]
+            else:
+                self.props[optigoalname]["Goal"].append(sweepdefinition)
         else:
-            self._mass = 0.0
-        return self._mass
-
-    @property
-    def volume(self):
-        """Object volume.
-
-        Returns
-        -------
-        float
-            Volume of the object when successful, 0.0 otherwise.
+            self.props[optigoalname] = OrderedDict({})
+            self.props[optigoalname]["Goal"] = sweepdefinition
+        self.auto_update = True
+        return self.update()
+
+    @pyaedt_function_handler()
+    def _activate_variable(self, variable_name):
+        if self.soltype in ["OptiDesignExplorer", "OptiDXDOE", "OptiOptimization", "OptiSLang"]:
+            self._app.activate_variable_optimization(variable_name)
+        elif self.soltype == "OptiParametric":
+            self._app.activate_variable_tuning(variable_name)
+        elif self.soltype == "OptiSensitivity":
+            self._app.activate_variable_sensitivity(variable_name)
+        elif self.soltype == "OptiStatistical":
+            self._app.activate_variable_statistical(variable_name)
+
+    @pyaedt_function_handler()
+    def analyze(
+        self,
+        num_cores=1,
+        num_tasks=1,
+        num_gpu=0,
+        acf_file=None,
+        use_auto_settings=True,
+        solve_in_batch=False,
+        machine="localhost",
+        run_in_thread=False,
+        revert_to_initial_mesh=False,
+    ):
+        """Solve the active design.
 
-        References
+        Parameters
         ----------
-
-        >>> oEditor.GetObjectVolume
-
-        """
-        if self.object_type == "Solid":
-            self._volume = float(self._primitives.oeditor.GetObjectVolume(self._m_name))
-        else:
-            self._volume = 0.0
-        return self._volume
-
-    @property
-    def name(self):
-        """Name of the object as a string value.
+        num_cores : int, optional
+            Number of simulation cores. Default is ``1``.
+        num_tasks : int, optional
+            Number of simulation tasks. Default is ``1``.
+        num_gpu : int, optional
+            Number of simulation graphic processing units to use. Default is ``0``.
+        acf_file : str, optional
+            Full path to the custom ACF file.
+        use_auto_settings : bool, optional
+            Set ``True`` to use automatic settings for HPC. The option is only considered for setups
+            that support automatic settings.
+        solve_in_batch : bool, optional
+            Whether to solve the project in batch or not.
+            If ``True`` the project will be saved, closed, solved and repened.
+        machine : str, optional
+            Name of the machine if remote.  The default is ``"localhost"``.
+        run_in_thread : bool, optional
+            Whether to submit the batch command as a thread. The default is
+            ``False``.
+        revert_to_initial_mesh : bool, optional
+            Whether to revert to initial mesh before solving or not. Default is ``False``.
 
         Returns
         -------
-        str
-           Name of object as a string value.
-
-        References
-        ----------
-
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
-
-        """
-        return self._m_name
-
-    @name.setter
-    def name(self, obj_name):
-        if obj_name not in self._primitives.object_names:
-            if obj_name != self._m_name:
-                vName = []
-                vName.append("NAME:Name")
-                vName.append("Value:=")
-                vName.append(obj_name)
-                vChangedProps = ["NAME:ChangedProps", vName]
-                vPropServers = ["NAME:PropServers"]
-                vPropServers.append(self._m_name)
-                vGeo3d = ["NAME:Geometry3DAttributeTab", vPropServers, vChangedProps]
-                vOut = ["NAME:AllTabs", vGeo3d]
-                _retry_ntimes(10, self._primitives.oeditor.ChangeProperty, vOut)
-                self._m_name = obj_name
-                self._primitives.cleanup_objects()
-        else:
-            pass
-
-    @property
-    def valid_properties(self):
-        """Valid properties.
-
-        References
-        ----------
-
-        >>> oEditor.GetProperties
-        """
-        if not self._all_props:
-            self._all_props = _retry_ntimes(10, self.m_Editor.GetProperties, "Geometry3DAttributeTab", self._m_name)
-        return self._all_props
-
-    @property
-    def color(self):
-        """Part color as a tuple of integer values for `(Red, Green, Blue)` color values.
-
-        If the integer values are outside the range 0-255, then limit the values. Invalid inputs are ignored.
-
-        References
-        ----------
-
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
-
-        Examples
-        --------
-        >>> part.color = (255,255,0)
-
-        """
-        if self._color is not None:
-            return self._color
-        if "Color" in self.valid_properties:
-            color = _retry_ntimes(10, self.m_Editor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Color")
-            if color:
-                b = (int(color) >> 16) & 255
-                g = (int(color) >> 8) & 255
-                r = int(color) & 255
-                self._color = (r, g, b)
-            else:
-                self._color = (0, 195, 255)
-            return self._color
-
-    @property
-    def color_string(self):
-        """Color tuple as a string in the format '(Red, Green, Blue)'.
+        bool
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
+        >>> oDesign.Analyze
         """
-        return "({} {} {})".format(self.color[0], self.color[1], self.color[2])
+        self._app.analyze(
+            setup_name=self.name,
+            num_cores=num_cores,
+            num_tasks=num_tasks,
+            num_gpu=num_gpu,
+            acf_file=acf_file,
+            use_auto_settings=use_auto_settings,
+            solve_in_batch=solve_in_batch,
+            machine=machine,
+            run_in_thread=run_in_thread,
+            revert_to_initial_mesh=revert_to_initial_mesh,
+        )
 
-    @color.setter
-    def color(self, color_value):
-        color_tuple = None
-        if isinstance(color_value, str):
-            try:
-                color_tuple = rgb_color_codes[color_value]
-            except KeyError:
-                parse_string = color_value.replace(")", "").replace("(", "").split()
-                if len(parse_string) == 3:
-                    color_tuple = tuple([int(x) for x in parse_string])
-        else:
-            try:
-                color_tuple = tuple([int(x) for x in color_value])
-            except ValueError:
-                pass
 
-        if color_tuple:
-            try:
-                R = clamp(color_tuple[0], 0, 255)
-                G = clamp(color_tuple[1], 0, 255)
-                B = clamp(color_tuple[2], 0, 255)
-                vColor = ["NAME:Color", "R:=", str(R), "G:=", str(G), "B:=", str(B)]
-                self._change_property(vColor)
-                self._color = (R, G, B)
-            except TypeError:
-                color_tuple = None
-        else:
-            msg_text = "Invalid color input {} for object {}.".format(color_value, self._m_name)
-            self._primitives.logger.warning(msg_text)
+class SetupOpti(CommonOptimetrics, object):
+    """Sets up an optimization in Opimetrics."""
 
-    @property
-    def transparency(self):
-        """Part transparency as a value between 0.0 and 1.0.
+    def __init__(self, app, name, dictinputs=None, optim_type="OptiDesignExplorer"):
+        CommonOptimetrics.__init__(self, app, name, dictinputs=dictinputs, optimtype=optim_type)
 
-        If the value is outside the range, then apply a limit. If the value is not a valid number, set to ``0.0``.
+    @pyaedt_function_handler()
+    def delete(self):
+        """Delete a defined Optimetrics Setup.
 
-        References
+        Parameters
         ----------
-
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
-
-        """
-        if self._transparency is not None:
-            return self._transparency
-        if "Transparent" in self.valid_properties:
-            transp = _retry_ntimes(
-                10, self.m_Editor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Transparent"
-            )
-            try:
-                self._transparency = float(transp)
-            except:
-                self._transparency = 0.3
-            return self._transparency
-
-    @transparency.setter
-    def transparency(self, T):
-        try:
-            trans_float = float(T)
-            if trans_float < 0.0:
-                trans_float = 0.0
-            elif trans_float > 1.0:
-                trans_float = 1.0
-        except ValueError:
-            trans_float = 0.0
-        vTrans = ["NAME:Transparent", "Value:=", str(trans_float)]
-
-        self._change_property(vTrans)
-
-        self._transparency = trans_float
-
-    @property
-    def object_units(self):
-        """Object units."""
-        return self._primitives.model_units
-
-    @property
-    def part_coordinate_system(self):
-        """Part coordinate system.
+        setup_name : str
+            Name of optimetrics setup to delete.
 
         Returns
         -------
-        str
-            Name of the part coordinate system.
-
-        References
-        ----------
-
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
-
+        bool
+            `True` if setup is deleted. `False` if it failed.
         """
-        if self._part_coordinate_system is not None and not isinstance(self._part_coordinate_system, int):
-            return self._part_coordinate_system
-        if "Orientation" in self.valid_properties:
-            self._part_coordinate_system = _retry_ntimes(
-                10, self.m_Editor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Orientation"
-            )
-            return self._part_coordinate_system
 
-    @part_coordinate_system.setter
-    def part_coordinate_system(self, sCS):
-        pcs = ["NAME:Orientation", "Value:=", sCS]
-        self._change_property(pcs)
-        self._part_coordinate_system = sCS
+        self.omodule.DeleteSetups([self.name])
+        self._app.optimizations.setups.remove(self)
         return True
 
-    @property
-    def solve_inside(self):
-        """Part solve inside flag.
-
-        Returns
-        -------
-        bool
-            ``True`` when ``"solve-inside"`` is activated for the part, ``False`` otherwise.
+    @pyaedt_function_handler()
+    def add_calculation(
+        self,
+        calculation,
+        ranges=None,
+        variables=None,
+        solution=None,
+        context=None,
+        subdesign_id=None,
+        polyline_points=1001,
+        report_type=None,
+    ):
+        """Add a calculation to the setup.
 
-        References
+        Parameters
         ----------
-
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
-
-        """
-        if self._solve_inside is not None:
-            return self._solve_inside
-        if "Solve Inside" in self.valid_properties and self.model:
-            solveinside = _retry_ntimes(
-                10, self.m_Editor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Solve Inside"
-            )
-            if solveinside == "false" or solveinside == "False":
-                self._solve_inside = False
-            else:
-                self._solve_inside = True
-            return self._solve_inside
-        return None
-
-    @solve_inside.setter
-    def solve_inside(self, S):
-        if not self.model:
-            self.model = True
-        vSolveInside = []
-        # fS = self._to_boolean(S)
-        fs = S
-        vSolveInside.append("NAME:Solve Inside")
-        vSolveInside.append("Value:=")
-        vSolveInside.append(fs)
-        self._change_property(vSolveInside)
-        self._solve_inside = fs
-
-    @property
-    def display_wireframe(self):
-        """Wireframe property of the part.
+        calculation : str, optional
+            Name of the calculation.
+        ranges : dict, optional
+            Dictionary of ranges with respective values.
+            Values can be: `None` for all values, a List of Discrete Values, a tuple of start and stop range.
+            It includes intrinsics like "Freq", "Time", "Theta", "Distance".
+            The default is ``None``, to be used e.g. in "Eigenmode" design type.
+        solution : str, optional
+            Type of the solution. The default is ``None``, in which case the default
+            solution is used.
+        context : str, optional
+            Calculation contexts. It can be a sphere, a matrix or a polyline.
+        subdesign_id : int, optional
+            Subdesign id for Circuit and HFSS 3D Layout objects.
+        polyline_points : int, optional
+            Number of points for Polyline context.
+        report_type : str, optional
+            Override the auto computation of Calculation Type.
 
         Returns
         -------
         bool
-            ``True`` when wirefame is activated for the part, ``False`` otherwise.
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
-
+        >>> oModule.EditSetup
         """
-        if self._wireframe is not None:
-            return self._wireframe
-        if "Display Wireframe" in self.valid_properties:
-            wireframe = _retry_ntimes(
-                10, self.m_Editor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Display Wireframe"
-            )
-            if wireframe == "true" or wireframe == "True":
-                self._wireframe = True
-            else:
-                self._wireframe = False
-            return self._wireframe
-
-    @display_wireframe.setter
-    def display_wireframe(self, fWireframe):
-        vWireframe = ["NAME:Display Wireframe", "Value:=", fWireframe]
-        # fwf = self._to_boolean(wf)
-
-        self._change_property(vWireframe)
-        self._wireframe = fWireframe
-
-    @property
-    def history(self):
-        """Object history.
-
-        Returns
-        -------
-            :class:`pyaedt.modeler.cad.elements3d.BinaryTree` when successful,
-            ``False`` when failed.
+        return self._add_calculation(
+            calculation,
+            ranges,
+            variables,
+            solution,
+            context,
+            subdesign_id,
+            polyline_points,
+            report_type,
+            is_goal=False,
+        )
 
-        """
-        try:
-            child_object = self.m_Editor.GetChildObject(self.name)
-            parent = BinaryTreeNode(self.name, child_object, True)
-            return parent
-        except:
-            return False
+    @pyaedt_function_handler()
+    def add_goal(
+        self,
+        calculation,
+        ranges,
+        variables=None,
+        solution=None,
+        context=None,
+        subdesign_id=None,
+        polyline_points=1001,
+        report_type=None,
+        condition="<=",
+        goal_value=1,
+        goal_weight=1,
+    ):
+        """Add a goal to the setup.
 
-    @property
-    def model(self):
-        """Part model or non-model property.
+        Parameters
+        ----------
+        calculation : str, optional
+            Name of the calculation.
+        ranges : dict
+            Dictionary of ranges with respective values.
+            Values can be: `None` for all values, a List of Discrete Values, a tuple of start and stop range.
+            It includes intrinsics like "Freq", "Time", "Theta", "Distance".
+        variables : list, optional
+            List of variables to include in the optimization.
+        condition : string, optional
+            The default is ``"<="``.
+        goal_value : optional
+            Value for the goal. The default is ``1``.
+        goal_weight : optional
+            Value for the goal weight. The default is ``1``.
+        solution : str, optional
+            Type of the solution. The default is ``None``, in which case the default
+            solution is used.
+        context : str, optional
+            Calculation contexts. It can be a sphere, a matrix or a polyline.
+        subdesign_id : int, optional
+            Subdesign id for Circuit and HFSS 3D Layout objects.
+        polyline_points : int, optional
+            Number of points for Polyline context.
+        report_type : str, optional
+            Override the auto computation of Calculation Type.
 
         Returns
         -------
         bool
-            ``True`` when model, ``False`` otherwise.
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oEditor.GetPropertyValue
-        >>> oEditor.ChangeProperty
-
+        >>> oModule.EditSetup
         """
-        if self._model is not None:
-            return self._model
-        if "Model" in self.valid_properties:
-            mod = _retry_ntimes(10, self.m_Editor.GetPropertyValue, "Geometry3DAttributeTab", self._m_name, "Model")
-            if mod == "false" or mod == "False":
-                self._model = False
-            else:
-                self._model = True
-            return self._model
 
-    @model.setter
-    def model(self, fModel):
-        vArg1 = ["NAME:Model", "Value:=", fModel]
-        fModel = _to_boolean(fModel)
-        self._change_property(vArg1)
-        self._model = fModel
+        return self._add_calculation(
+            calculation,
+            ranges,
+            variables,
+            solution,
+            context,
+            subdesign_id,
+            polyline_points,
+            report_type,
+            True,
+            condition,
+            goal_value,
+            goal_weight,
+        )
 
     @pyaedt_function_handler()
-    def unite(self, object_list):
-        """Unite a list of objects with this object.
+    def add_variation(
+        self,
+        variable_name,
+        min_value,
+        max_value,
+        starting_point=None,
+        min_step=None,
+        max_step=None,
+        use_manufacturable=False,
+    ):
+        """Add a new variable as input for the optimization and defines its ranges.
 
         Parameters
         ----------
-        object_list : list of str or list of pyaedt.modeler.object3d.Object3d
-            List of objects.
+        variable_name : str
+            Name of the variable.
+        min_value : float
+            Minimum Optimization Value for variable_name.
+        max_value : float
+            Maximum Optimization Value for variable_name.
+        starting_point : float, optional
+            Starting point for optimization. If None, default will be used.
+        min_step : float
+            Minimum Step Size for optimization. If None, 1/100 of the range will be used.
+
+        max_step : float
+            Maximum Step Size for optimization. If None, 1/10 of the range will be used.
+        use_manufacturable : bool
+            Either if to use or not the Manufacturable values. Default is False.
+
 
         Returns
         -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-           Object 3D object.
-
-        References
-        ----------
-
-        >>> oEditor.Unite
-
+        bool
         """
-        unite_list = [self.name] + self._primitives.modeler.convert_to_selections(object_list, return_list=True)
-        self._primitives.modeler.unite(unite_list)
-        return self
+        if variable_name not in self._app.variable_manager.variables:
+            self._app.logger.error("Variable {} does not exists.".format(variable_name))
+            return False
+        self.auto_update = False
+        self._activate_variable(variable_name)
 
-    @pyaedt_function_handler()
-    def intersect(self, theList, keep_originals=False):
-        """Intersect the active object with a given list.
+        if not min_step:
+            min_step = (max_value - min_value) / 100
+        min_step = self._app.value_with_units(min_step, self._app.variable_manager[variable_name].units)
+
+        if not max_step:
+            max_step = (max_value - min_value) / 10
+        max_step = self._app.value_with_units(max_step, self._app.variable_manager[variable_name].units)
+        min_value = self._app.value_with_units(min_value, self._app.variable_manager[variable_name].units)
+        max_value = self._app.value_with_units(max_value, self._app.variable_manager[variable_name].units)
+        arg = [
+            "i:=",
+            True,
+            "int:=",
+            False,
+            "Min:=",
+            min_value,
+            "Max:=",
+            max_value,
+            "MinStep:=",
+            min_step,
+            "MaxStep:=",
+            max_step,
+            "MinFocus:=",
+            min_value,
+            "MaxFocus:=",
+            max_value,
+            "UseManufacturableValues:=",
+            use_manufacturable,
+        ]
+        if not self.props.get("Variables", None):
+            self.props["Variables"] = OrderedDict({})
+        self.props["Variables"][variable_name] = arg
+        if not self.props.get("StartingPoint", None):
+            self.props["StartingPoint"] = OrderedDict({})
+        if not starting_point:
+            starting_point = self._app[variable_name]
 
-        Parameters
-        ----------
-        theList : list
-            List of objects.
-        keep_originals : bool, optional
-            Whether to keep the original object. The default is ``False``.
+        self.props["StartingPoint"][variable_name] = self._app.value_with_units(
+            starting_point, self._app.variable_manager[variable_name].units
+        )
+        self.auto_update = True
+        self.update()
+        return True
 
-        Returns
-        -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-            Retrieve the resulting 3D Object when succeeded.
 
-        References
-        ----------
+class SetupParam(CommonOptimetrics, object):
+    """Sets up a parametric analysis in Optimetrics."""
 
-        >>> oEditor.Intersect
-        """
-        theList = [self.name] + self._primitives.modeler.convert_to_selections(theList, return_list=True)
-        self._primitives.modeler.intersect(theList, keep_originals)
-        return self
+    def __init__(self, p_app, name, dictinputs=None, optim_type="OptiParametric"):
+        CommonOptimetrics.__init__(self, p_app, name, dictinputs=dictinputs, optimtype=optim_type)
+        pass
 
     @pyaedt_function_handler()
-    def split(self, plane, sides="Both"):
-        """Split the active object.
+    def delete(self):
+        """Delete a defined Optimetrics Setup.
 
         Parameters
         ----------
-        plane : str
-            Coordinate plane of the cut or the Application.PLANE object.
-            Choices for the coordinate plane are ``"XY"``, ``"YZ"``, and ``"ZX"``.
-        sides : str, optional
-            Which side to keep. Options are ``"Both"``, ``"PositiveOnly"``,
-            and ``"NegativeOnly"``. The default is ``"Both"``, in which case
-            all objects are kept after the split.
+        setup_name : str
+            Name of optimetrics setup to delete.
 
         Returns
         -------
-        list of str
-            List of split objects.
-
-        References
-        ----------
-
-        >>> oEditor.Split
+        bool
+            ``True`` if setup is deleted. ``False`` if it failed.
         """
-        return self._primitives.modeler.split(self.name, plane, sides)
+
+        self.omodule.DeleteSetups([self.name])
+        self._app.parametrics.setups.remove(self)
+        return True
 
     @pyaedt_function_handler()
-    def mirror(self, position, vector, duplicate=False):
-        """Mirror a selection.
+    def add_variation(self, sweep_var, start_point, end_point=None, step=100, unit=None, variation_type="LinearCount"):
+        """Add a variation to an existing parametric setup.
 
         Parameters
         ----------
-        position : list of int or float
-            Cartesian ``[x, y, z]`` coordinates or
-            the ``Application.Position`` object of a point in the plane used for the mirror operation.
-        vector : list of float
-            Vector in Cartesian coordinates ``[x1, y1, z1]``  or
-            the ``Application.Position`` object for the vector normal to the plane used for the mirror operation.
+        sweep_var : str
+            Name of the variable.
+        start_point : float or int
+            Variation Start Point.
+        end_point : float or int, optional
+            Variation End Point. This parameter is optional if a Single Value is defined.
+        step : float or int, optional
+            Variation Step or Count depending on variation_type. Default is `100`.
+        unit : str, optional
+            Variation units. Default is `None`.
+        variation_type : float or int
+            Variation Type. Admitted values are `"LinearCount"`, `"LinearStep"`, `"LogScale"`, `"SingleValue"`.
 
         Returns
         -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-            3D object.
-            ``False`` when failed.
+        bool
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oEditor.Mirror
+        >>> oModule.EditSetup
         """
-        if self._primitives.modeler.mirror(self.id, position=position, vector=vector, duplicate=duplicate):
-            return self
-        return False
-
-    @pyaedt_function_handler()
-    def rotate(self, cs_axis, angle=90.0, unit="deg"):
-        """Rotate the selection.
-
-        Parameters
-        ----------
-        cs_axis : int
-            Coordinate system axis or the Application.CoordinateSystemAxis object.
-        angle : float, optional
-            Angle of rotation. The units, defined by ``unit``, can be either
-            degrees or radians. The default is ``90.0``.
-        unit : text, optional
-             Units for the angle. Options are ``"deg"`` or ``"rad"``.
-             The default is ``"deg"``.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-            3D object. ``False`` when failed.
+        if sweep_var not in self._app.variable_manager.variables:
+            self._app.logger.error("Variable {} does not exists.".format(sweep_var))
+            return False
+        sweep_range = ""
+        if not unit:
+            unit = self._app.variable_manager[sweep_var].units
+        start_point = self._app.value_with_units(start_point, unit)
+        end_point = self._app.value_with_units(end_point, unit)
+        if variation_type == "LinearCount":
+            sweep_range = "LINC {} {} {}".format(start_point, end_point, step)
+        elif variation_type == "LinearStep":
+            sweep_range = "LIN {} {} {}".format(start_point, end_point, self._app.value_with_units(step, unit))
+        elif variation_type == "LogScale":
+            sweep_range = "DEC {} {} {}".format(start_point, end_point, self._app.value_with_units(step, unit))
+        elif variation_type == "SingleValue":
+            sweep_range = "{}".format(self._app.value_with_units(start_point, unit))
+        if not sweep_range:
+            return False
+        self._activate_variable(sweep_var)
+        sweepdefinition = OrderedDict()
+        sweepdefinition["Variable"] = sweep_var
+        sweepdefinition["Data"] = sweep_range
+        sweepdefinition["OffsetF1"] = False
+        sweepdefinition["Synchronize"] = 0
+        if self.props["Sweeps"]["SweepDefinition"] is None:
+            self.props["Sweeps"]["SweepDefinition"] = sweepdefinition
+        elif type(self.props["Sweeps"]["SweepDefinition"]) is not list:
+            self.props["Sweeps"]["SweepDefinition"] = [self.props["Sweeps"]["SweepDefinition"]]
+            self._append_sweepdefinition(sweepdefinition)
+        else:
+            self._append_sweepdefinition(sweepdefinition)
 
-        References
-        ----------
+        return self.update()
 
-        >>> oEditor.Rotate
-        """
-        if self._primitives.modeler.rotate(self.id, cs_axis=cs_axis, angle=angle, unit=unit):
-            return self
-        return False
+    @pyaedt_function_handler()
+    def _append_sweepdefinition(self, sweepdefinition):
+        for sweep_def in self.props["Sweeps"]["SweepDefinition"]:
+            if sweepdefinition["Variable"] == sweep_def["Variable"]:
+                sweep_def["Data"] += " " + sweepdefinition["Data"]
+                return True
+        self.props["Sweeps"]["SweepDefinition"].append(sweepdefinition)
+        return True
 
     @pyaedt_function_handler()
-    def move(self, vector):
-        """Move objects from a list.
+    def sync_variables(self, variables, sync_n=1):
+        """Sync variable variations in an existing parametric setup.
+        Setting the sync number to `0` will effectively unsync the variables.
 
         Parameters
         ----------
-        objid : list, Position object
-            List of object IDs.
-        vector : list
-            Vector of the direction move. It can be a list of the ``[x, y, z]``
-            coordinates or a Position object.
+        variables : list
+            List of variables to sync.
+        sync_n : int, optional
+            Sync number. Sweep variables with the same Sync number will be synchronizad.
+            Default is `1`.
 
         Returns
         -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-            3D object.
-            ``False`` when failed.
+        bool
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
-        >>> oEditor.Move
+
+        >>> oModule.EditSetup
         """
-        if self._primitives.modeler.move(self.id, vector=vector):
-            return self
-        return False
+        if type(self.props["Sweeps"]["SweepDefinition"]) is not list:
+            self._app.logger.error("Not enough variables are defined in the Parametric setup")
+            return False
+        existing_variables = [s["Variable"] for s in self.props["Sweeps"]["SweepDefinition"]]
+        undo_vals = {}
+        for v in variables:
+            if v not in existing_variables:
+                self._app.logger.error("Variable {} is not defined in the Parametric setup".format(v))
+                return False
+        for v in variables:
+            for sweep_def in self.props["Sweeps"]["SweepDefinition"]:
+                if v == sweep_def["Variable"]:
+                    undo_vals[v] = sweep_def["Synchronize"]
+                    sweep_def["Synchronize"] = sync_n
+        try:
+            return self.update()
+        except Exception:  # pragma: no cover
+            # If it fails to sync (due to e.g. different number of variations), reverts to original values.
+            for v in variables:
+                for sweep_def in self.props["Sweeps"]["SweepDefinition"]:
+                    if v == sweep_def["Variable"]:
+                        sweep_def["Synchronize"] = undo_vals[v]
+            self._app.logger.error("Failed to sync the Parametric setup.")
+            return False
 
-    def duplicate_around_axis(self, cs_axis, angle=90, nclones=2, create_new_objects=True):
-        """Duplicate the object around the axis.
+    @pyaedt_function_handler()
+    def add_calculation(
+        self,
+        calculation,
+        ranges,
+        solution=None,
+        context=None,
+        subdesign_id=None,
+        polyline_points=1001,
+        report_type=None,
+    ):
+        """Add a calculation to the parametric setup.
 
         Parameters
         ----------
-        cs_axis : Application.CoordinateSystemAxis object
-            Coordinate system axis of the object.
-        angle : float
-            Angle of rotation in degrees. The default is ``90``.
-        nclones : int, optional
-            Number of clones. The default is ``2``.
-        create_new_objects : bool, optional
-            Whether to create copies as new objects. The default is ``True``.
+        calculation : str, optional
+            Name of the calculation.
+        ranges : dict
+            Dictionary of ranges with respective values.
+            Values can be: `None` for all values, a List of Discrete Values, a tuple of start and stop range.
+            It includes intrinsics like "Freq", "Time", "Theta", "Distance".
+        solution : str, optional
+            Type of the solution. The default is ``None``, in which case the default
+            solution is used.
+        context : str, optional
+            Calculation contexts. It can be a sphere, a matrix or a polyline.
+        subdesign_id : int, optional
+            Subdesign id for Circuit and HFSS 3D Layout objects.
+        polyline_points : int, optional
+            Number of points for Polyline context.
+        report_type : str, optional
+            Override the auto computation of Calculation Type.
 
         Returns
         -------
-        list of :class:`pyaedt.modeler.cad.object3d.Object3d`
-            List of names of the newly added objects.
+        bool
+            ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oEditor.DuplicateAroundAxis
-
+        >>> oModule.EditSetup
         """
-        ret, added_objects = self._primitives.modeler.duplicate_around_axis(
-            self, cs_axis, angle, nclones, create_new_objects
+        return self._add_calculation(
+            calculation, ranges, None, solution, context, subdesign_id, polyline_points, report_type, is_goal=False
         )
-        return added_objects
 
     @pyaedt_function_handler()
-    def duplicate_along_line(self, vector, nclones=2, attachObject=False):
-        """Duplicate the object along a line.
+    def export_to_csv(self, filename):
+        """Export the current Parametric Setup to csv.
 
         Parameters
         ----------
-        vector : list
-            List of ``[x1 ,y1, z1]`` coordinates for the vector or the Application.Position object.
-        nclones : int, optional
-            Number of clones. The default is ``2``.
-        attachObject : bool, optional
-            Whether to attach the object. The default is ``False``.
+        filename : str
+            Full Path to the csv file.
 
         Returns
         -------
-        list of :class:`pyaedt.modeler.cad.object3d.Object3d`
-            List of names of the newly added objects.
-
-        References
-        ----------
-
-        >>> oEditor.DuplicateAlongLine
-
+        bool
+            `True` if the export is correctly executed.
         """
-        ret, added_objects = self._primitives.modeler.duplicate_along_line(self, vector, nclones, attachObject)
-        return added_objects
-
-    @pyaedt_function_handler()
-    def translate(self, vector):
-        """Translate the object and return the 3D object.
-
-        .. deprecated:: 0.4.0
-           Use :func:`move` instead.
+        self.omodule.ExportParametricSetupTable(self.name, filename)
+        return True
 
-        Returns
-        -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-            3D object.
 
-        References
-        ----------
+class ParametricSetups(object):
+    """Sets up Parametrics analyses. It includes Parametrics, Sensitivity and Statistical Analysis.
 
-        >>> oEditor.Move
+    Examples
+    --------
+    >>> from pyaedt import Hfss
+    >>> app = Hfss()
+    >>> sensitivity_setups = app.parametrics
+    """
 
-        """
-        warnings.warn("`translate` is deprecated. Use `move` instead.", DeprecationWarning)
-        self.move(vector)
-        return self
+    def __init__(self, p_app):
+        self._app = p_app
+        self.setups = []
+        if self._app.design_properties:
+            try:
+                setups_data = self._app.design_properties["Optimetrics"]["OptimetricsSetups"]
+                for data in setups_data:
+                    if (
+                        isinstance(setups_data[data], (OrderedDict, dict))
+                        and setups_data[data]["SetupType"] == "OptiParametric"
+                    ):
+                        self.setups.append(SetupParam(p_app, data, setups_data[data], setups_data[data]["SetupType"]))
+            except:
+                pass
 
-    @pyaedt_function_handler()
-    def sweep_along_vector(self, sweep_vector, draft_angle=0, draft_type="Round"):
-        """Sweep the selection along a vector.
+    @property
+    def p_app(self):
+        """Parent."""
+        return self._app
 
-        Parameters
-        ----------
-        sweep_vector : list
-            Application.Position object.
-        draft_angle : float, optional
-            Angle of the draft in degrees. The default is ``0``.
-        draft_type : str, optional
-            Type of the draft. Options are ``"Extended"``, ``"Round"``,
-            and ``"Natural"``. The default value is ``"Round``.
+    @property
+    def optimodule(self):
+        """Optimetrics module.
 
         Returns
         -------
-        bool
-            ``True`` when model, ``False`` otherwise.
-
-        References
-        ----------
-
-        >>> oEditor.SweepAlongVector
+        :class:`Optimetrics`
 
         """
-        self._primitives.modeler.sweep_along_vector(self, sweep_vector, draft_angle, draft_type)
-        return self
+        return self._app.ooptimetrics
 
     @pyaedt_function_handler()
-    def sweep_along_path(
-        self, sweep_object, draft_angle=0, draft_type="Round", is_check_face_intersection=False, twist_angle=0
+    def add(
+        self,
+        sweep_var,
+        start_point,
+        end_point=None,
+        step=100,
+        variation_type="LinearCount",
+        solution=None,
+        parametricname=None,
     ):
-        """Sweep the selection along a vector.
+        """Add a basic sensitivity analysis.
+        You can customize all options after the analysis is added.
 
         Parameters
         ----------
-        sweep_object : :class:`pyaedt.modeler.object3d.Object3d`
-            Application.Position object.
-        draft_angle : float, optional
-            Angle of the draft in degrees. The default is ``0``.
-        draft_type : str
-            Type of the draft. Options are ``"Extended"``, ``"Round"``,
-            and ``"Natural"``. The default is ``"Round``.
-        is_check_face_intersection : bool, optional
-           The default value is ``False``.
-        twist_angle : float, optional
-            Angle at which to twist or rotate in degrees. The default value is ``0``.
+        sweep_var : str
+            Name of the variable.
+        start_point : float or int
+            Variation Start Point if a variation is defined or Single Value.
+        end_point : float or int, optional
+            Variation End Point. This parameter is optional if a Single Value is defined.
+        step : float or int
+            Variation Step or Count depending on variation_type. The default is ``100``.
+        variation_type : float or int
+            Variation Type. Admitted values are `"LinearCount"`, `"LinearStep"`, `"LogScale"`, `"SingleValue"`.
+        solution : str, optional
+            Type of the solution. The default is ``None``, in which case the default
+            solution is used.
+        parametricname : str, optional
+            Name of the sensitivity analysis. The default is ``None``, in which case
+            a default name is assigned.
 
         Returns
         -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-            Swept object.
+        :class:`pyaedt.modules.DesignXPloration.SetupParam`
+            Optimization Object.
 
         References
         ----------
 
-        >>> oEditor.SweepAlongPath
-
+        >>> oModule.InsertSetup
         """
-        self._primitives.modeler.sweep_along_path(
-            self, sweep_object, draft_angle, draft_type, is_check_face_intersection, twist_angle
-        )
-        return self
+        if sweep_var not in self._app.variable_manager.variables:
+            self._app.logger.error("Variable {} not found.".format(sweep_var))
+            return False
+        if not solution and not self._app.nominal_sweep:
+            self._app.logger.error("At least one setup is needed.")
+            return False
+        if not solution:
+            solution = self._app.nominal_sweep
+        setupname = solution.split(" ")[0]
+        if not parametricname:
+            parametricname = generate_unique_name("Parametric")
+        setup = SetupParam(self._app, parametricname, optim_type="OptiParametric")
+        setup.auto_update = False
+
+        setup.props["Sim. Setups"] = [setupname]
+        setup.props["Sweeps"] = OrderedDict({"SweepDefinition": None})
+        setup.create()
+        unit = self._app.variable_manager[sweep_var].units
+        setup.add_variation(sweep_var, start_point, end_point, step, unit, variation_type)
+        setup.auto_update = True
+        self.setups.append(setup)
+        return setup
 
     @pyaedt_function_handler()
-    def sweep_around_axis(self, cs_axis, sweep_angle=360, draft_angle=0):
-        """Sweep around an axis.
+    def delete(self, setup_name):
+        """Delete a defined Parametric Setup.
 
         Parameters
         ----------
-        cs_axis : :class:`pyaedt.generic.constants.CoordinateSystemAxis`
-            Coordinate system of the axis.
-        sweep_angle : float, optional
-             Sweep angle in degrees. The default is ``360``.
-        draft_angle : float, optional
-            Angle of the draft. The default is ``0``.
+        setup_name : str
+            Name of parametric setup to delete.
 
         Returns
         -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-            Swept object.
-
-        References
-        ----------
-
-        >>> oEditor.SweepAroundAxis
-
+        bool
+            ``True`` if setup is deleted. ``False`` if it failed.
         """
-        self._primitives.modeler.sweep_around_axis(self, cs_axis, sweep_angle, draft_angle)
-        return self
+        for el in self.setups:
+            if el.name == setup_name:
+                el.delete()
+                return True
+        return False
 
     @pyaedt_function_handler()
-    def section(self, plane, create_new=True, section_cross_object=False):
-        """Section the object.
+    def add_from_file(self, filename, parametricname=None):
+        """Add a Parametric Setup from a csv file.
 
         Parameters
         ----------
-        plane : pyaedt.generic.constants.PLANE
-            Coordinate system of the plane object. Application.PLANE object
-        create_new : bool, optional
-            Whether to create an object. The default is ``True``.
-        section_cross_object : bool, optional
-            The default is ``False``.
+        filename : str
+            Csv file path.
+        parametricname : str, option
+            Name of parameric setup.
 
         Returns
         -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-            3D object.
-
-        References
-        ----------
-
-        >>> oEditor.Section
-
+        bool
+            `True` if the import is executed correctly.
         """
-        self._primitives.modeler.section(self, plane, create_new, section_cross_object)
-        return self
+        if not parametricname:
+            parametricname = generate_unique_name("Parametric")
+        setup = SetupParam(self._app, parametricname, optim_type="OptiParametric")
+        setup.auto_update = False
+        setup.props["Sim. Setups"] = [setup_defined.name for setup_defined in self._app.setups]
+        with open(filename, "r") as csvfile:
+            csvreader = csv.DictReader(csvfile)
+            first_data_line = next(csvreader)
+            setup.props["Sweeps"] = {"SweepDefinition": OrderedDict()}
+            sweep_definition = []
+            for var_name in csvreader.fieldnames:
+                if var_name != "*":
+                    sweep_definition.append(
+                        OrderedDict(
+                            {
+                                "Variable": var_name,
+                                "Data": first_data_line[var_name],
+                                "OffsetF1": False,
+                                "Synchronize": 0,
+                            }
+                        )
+                    )
+            setup.props["Sweeps"]["SweepDefinition"] = sweep_definition
+
+            args = ["NAME:" + parametricname]
+            _dict2arg(setup.props, args)
+
+            setup.props["Sweep Operations"] = OrderedDict({"add": []})
+            table = []
+            for var_name in csvreader.fieldnames:
+                if var_name != "*":
+                    table.append(first_data_line[var_name])
+            table = [table]
+            for line in csvreader:
+                table_line = []
+                for var_name in csvreader.fieldnames:
+                    if var_name != "*":
+                        table_line.append(line[var_name])
+                table.append(table_line)
+
+            if len(table) > 1:
+                for point in table[1:]:
+                    setup.props["Sweep Operations"]["add"].append(point)
+
+        cont = 0
+        for data in args:
+            if isinstance(data, list) and "NAME:Sweep Operations" in data:
+                del args[cont]
+                args.append(["NAME:Sweep Operations"])
+                break
+            cont += 1
+
+        for variation in setup.props["Sweep Operations"].get("add", []):
+            args[-1].append("add:=")
+            args[-1].append(variation)
 
-    @pyaedt_function_handler()
-    def clone(self):
-        """Clone the object and return the new 3D object.
+        self.optimodule.InsertSetup("OptiParametric", args)
+        self.setups.append(setup)
+        return True
 
-        Returns
-        -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-            3D object that was added.
 
-        References
-        ----------
+class OptimizationSetups(object):
+    """Sets up optimizations. It includes Optimization, DOE and DesignXplorer Analysis.
 
-        >>> oEditor.Clone
+    Examples
+    --------
+    >>> from pyaedt import Hfss
+    >>> app = Hfss()
+    >>> optimization_setup = app.optimizations
+    """
 
-        """
-        new_obj_tuple = self._primitives.modeler.clone(self.id)
-        success = new_obj_tuple[0]
-        assert success, "Could not clone the object {}.".format(self.name)
-        new_name = new_obj_tuple[1][0]
-        return self._primitives[new_name]
+    def __init__(self, p_app):
+        self._app = p_app
+        self.setups = []
+        if self._app.design_properties:
+            try:
+                setups_data = self._app.design_properties["Optimetrics"]["OptimetricsSetups"]
+                for data in setups_data:
+                    if isinstance(setups_data[data], (OrderedDict, dict)) and setups_data[data]["SetupType"] in [
+                        "OptiOptimization",
+                        "OptiDXDOE",
+                        "OptiDesignExplorer",
+                        "OptiSLang",
+                        "OptiSensitivity",
+                        "OptiStatistical",
+                    ]:
+                        self.setups.append(SetupOpti(p_app, data, setups_data[data], setups_data[data]["SetupType"]))
+            except:
+                pass
 
-    @pyaedt_function_handler()
-    def subtract(self, tool_list, keep_originals=True):
-        """Subtract one or more parts from the object.
+    @property
+    def p_app(self):
+        """Parent."""
+        return self._app
 
-        Parameters
-        ----------
-        tool_list : str, Object3d, or list of str and Object3d.
-            List of parts to subtract from this part.
-        keep_originals : bool, optional
-            Whether to keep the tool parts after subtraction. The default
-            is ``True``. If ``False``, the parts are deleted.
+    @property
+    def optimodule(self):
+        """Optimetrics module.
 
         Returns
         -------
-        :class:`pyaedt.modeler.cad.object3d.Object3d`
-            Modified 3D object following the subtraction.
-
-        References
-        ----------
-
-        >>> oEditor.Subtract
+        :class:`Optimetrics`
 
         """
-        self._primitives.modeler.subtract(self.name, tool_list, keep_originals)
-        return self
+        return self._app.ooptimetrics
 
     @pyaedt_function_handler()
-    def wrap_sheet(self, object_name, imprinted=False):
-        """Execute the sheet wrapping around an object. This object can be either the sheet or the object.
-        If wrapping produces an unclassified operation it will be reverted.
+    def delete(self, setup_name):
+        """Delete a defined Optimetrics Setup.
 
         Parameters
         ----------
-        object_name : str, :class:`pyaedt.modeler.Object3d.Object3d`
-            Object name or solid object or sheet name.
-        imprinted : bool, optional
-            Either if imprint or not over the sheet. Default is `False`.
+        setup_name : str
+            Name of optimetrics setup to delete.
 
         Returns
         -------
         bool
-            Command execution status.
-        """
-        object_name = self._primitives.convert_to_selections(object_name, False)
-        if self.object_type == "Sheet" and object_name in self._primitives.solid_names:
-            return self._primitives.wrap_sheet(self.name, object_name, imprinted)
-        elif self.object_type == "Solid" and object_name in self._primitives.sheet_names:
-            return self._primitives.wrap_sheet(object_name, self.name, imprinted)
-        else:
-            msg = "Error in command execution."
-            msg += " Either one of the two objects has to be a sheet and the other an object."
-            self.logger.error(msg)
-            return False
-
-    @pyaedt_function_handler()
-    def delete(self):
-        """Delete the object.
-
-        References
-        ----------
-
-        >>> oEditor.Delete
+            ``True`` if setup is deleted. ``False`` if it failed.
         """
-        arg = ["NAME:Selections", "Selections:=", self._m_name]
-        self.m_Editor.Delete(arg)
-        self._primitives.cleanup_objects()
-        self.__dict__ = {}
+        for el in self.setups:
+            if el.name == setup_name:
+                el.delete()
+                return True
+        return False
 
     @pyaedt_function_handler()
-    def faces_by_area(self, area, area_filter="==", tolerance=1e-12):
-        """Filter faces by area.
+    def add(
+        self,
+        calculation=None,
+        ranges=None,
+        variables=None,
+        optim_type="Optimization",
+        condition="<=",
+        goal_value=1,
+        goal_weight=1,
+        solution=None,
+        parametricname=None,
+        context=None,
+        subdesign_id=None,
+        polyline_points=1001,
+        report_type=None,
+    ):
+        """Add a basic optimization analysis.
+        You can customize all options after the analysis is added.
 
         Parameters
         ----------
-        area : float
-            Value of the area to filter in model units.
-        area_filter : str, optional
-            Comparer symbol.
-            Default value is "==".
-        tolerance : float, optional
-            tolerance for comparison.
+        calculation : str, optional
+            Name of the calculation.
+        ranges : dict, optional
+            Dictionary of ranges with respective values.
+            Values can be: a list of discrete values, a dict with tuple args of start and stop range.
+            It includes intrinsics like "Freq", "Time", "Theta", "Distance".
+        variables : list, optional
+            List of variables to include in the optimization.
+        optim_type : strm optional
+            Optimization Type.
+            Possible values are `"Optimization"`, `"DXDOE"`,`"DesignExplorer"`,`"Sensitivity"`,`"Statistical"`
+            and `"optiSLang"`.
+        condition : string, optional
+            The default is ``"<="``.
+        goal_value : optional
+            Value for the goal. The default is ``1``.
+        goal_weight : optional
+            Value for the goal weight. The default is ``1``.
+        solution : str, optional
+            Type of the solution. The default is ``None``, in which case the default
+            solution is used.
+        parametricname : str, optional
+            Name of the analysis. The default is ``None``, in which case a
+            default name is assigned.
+        context : str, optional
+            Calculation contexts. It can be a sphere, a matrix or a polyline.
+        subdesign_id : int, optional
+            Subdesign id for Circuit and HFSS 3D Layout objects.
+        polyline_points : int, optional
+            Number of points for Polyline context.
+        report_type : str, optional
+            Override the auto computation of Calculation Type.
 
         Returns
         -------
-        list of :class:`pyaedt.modeler.elements3d.FacePrimitive`
-            List of face primitives.
-        """
-
-        filters = ["==", "<=", ">=", "<", ">"]
-        if area_filter not in filters:
-            raise ValueError('Symbol not valid, enter one of the following: "==", "<=", ">=", "<", ">"')
-
-        faces = []
-        for face in self.faces:
-            if area_filter == "==":
-                if abs(face.area - area) < tolerance:
-                    faces.append(face)
-            if area_filter == ">=":
-                if (face.area - area) >= -tolerance:
-                    faces.append(face)
-            if area_filter == "<=":
-                if (face.area - area) <= tolerance:
-                    faces.append(face)
-            if area_filter == ">":
-                if (face.area - area) > 0:
-                    faces.append(face)
-            if area_filter == "<":
-                if (face.area - area) < 0:
-                    faces.append(face)
-
-        return faces
-
-    @pyaedt_function_handler()
-    def edges_by_length(self, length, length_filter="==", tolerance=1e-12):
-        """Filter edges by length.
+        :class:`pyaedt.modules.DesignXPloration.SetupOpti`
+            Optimization object.
 
-        Parameters
+        References
         ----------
-        length : float
-            Value of the length to filter.
-        length_filter : str, optional
-            Comparer symbol.
-            Default value is "==".
-        tolerance : float, optional
-            tolerance for comparison.
 
-        Returns
-        -------
-        list of :class:`pyaedt.modeler.elements3d.EdgePrimitive`
-            List of edge primitives.
+        >>> oModule.InsertSetup
         """
-        filters = ["==", "<=", ">=", "<", ">"]
-        if length_filter not in filters:
-            raise ValueError('Symbol not valid, enter one of the following: "==", "<=", ">=", "<", ">"')
-
-        edges = []
-        for edge in self.edges:
-            if length_filter == "==":
-                if abs(edge.length - length) < tolerance:
-                    edges.append(edge)
-            if length_filter == ">=":
-                if (edge.length - length) >= -tolerance:
-                    edges.append(edge)
-            if length_filter == "<=":
-                if (edge.length - length) <= tolerance:
-                    edges.append(edge)
-            if length_filter == ">":
-                if (edge.length - length) > 0:
-                    edges.append(edge)
-            if length_filter == "<":
-                if (edge.length - length) < 0:
-                    edges.append(edge)
-
-        return edges
-
-    @pyaedt_function_handler()
-    def _change_property(self, vPropChange):
-        return self._primitives._change_geometry_property(vPropChange, self._m_name)
-
-    def _update(self):
-        # self._object3d._refresh_object_types()
-        self._primitives.cleanup_objects()
-
-    def __str__(self):
-        return """
-         {}
-         name: {}    id: {}    object_type: {}
-         --- read/write properties  ----
-         solve_inside: {}
-         model: {}
-         material_name: {}
-         color: {}
-         transparency: {}
-         display_wireframe {}
-         part_coordinate_system: {}
-         """.format(
-            type(self),
-            self.name,
-            self.id,
-            self.object_type,
-            self.solve_inside,
-            self.model,
-            self.material_name,
-            self.color,
-            self.transparency,
-            self.display_wireframe,
-            self.part_coordinate_system,
-        )
+        if not solution and not self._app.nominal_sweep:
+            self._app.logger.error("At least one setup is needed.")
+            return False
+        if not solution:
+            solution = self._app.nominal_sweep
+        setupname = solution.split(" ")[0]
+        if not parametricname:
+            parametricname = generate_unique_name(optim_type)
+        if optim_type != "optiSLang":
+            optim_type = "Opti" + optim_type
+        setup = SetupOpti(self._app, parametricname, optim_type=optim_type)
+        setup.auto_update = False
+        setup.props["Sim. Setups"] = [setupname]
+        if calculation:
+            domain = "Time"
+            if not ranges:
+                ranges = {}
+            if "Freq" in ranges or "Phase" in ranges or "Theta" in ranges:
+                domain = "Sweep"
+            if not report_type:
+                report_type = self._app.design_solutions.report_type
+                if context and context in self._app.modeler.sheet_names:
+                    report_type = "Fields"
+                elif self._app.solution_type in ["Q3D Extractor", "2D Extractor"]:
+                    report_type = "Matrix"
+                elif context:
+                    try:
+                        for f in self._app.field_setups:
+                            if context == f.name:
+                                report_type = "Far Fields"
+                    except:
+                        pass
+            sweepdefinition = setup._get_context(
+                calculation,
+                condition,
+                goal_weight,
+                goal_value,
+                solution,
+                domain,
+                ranges,
+                report_type,
+                context,
+                subdesign_id,
+                polyline_points,
+                is_goal=True,
+            )
+            setup.props["Goals"]["Goal"] = sweepdefinition
+
+        dx_variables = {}
+        if variables:
+            for el in variables:
+                try:
+                    dx_variables[el] = self._app[el]
+                except:
+                    pass
+        for v in list(dx_variables.keys()):
+            if optim_type in ["OptiOptimization", "OptiDXDOE", "OptiDesignExplorer"]:
+                self._app.activate_variable_optimization(v)
+            elif optim_type == "OptiSensitivity":
+                self._app.activate_variable_sensitivity(v)
+            elif optim_type == "OptiStatistical":
+                self._app.activate_variable_statistical(v)
+        if optim_type == "OptiDXDOE" and calculation:
+            setup.props["CostFunctionGoals"]["Goal"] = sweepdefinition
+        if optim_type in ["OptiDesignExplorer", "optiSLang"]:
+            setup.props["Sweeps"]["SweepDefinition"] = []
+            for l, k in dx_variables.items():
+                arg = OrderedDict({"Variable": l, "Data": k, "OffsetF1": False, "Synchronize": 0})
+                setup.props["Sweeps"]["SweepDefinition"].append(arg)
+        setup.create()
+        setup.auto_update = True
+        self.setups.append(setup)
+        return setup
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/cad/polylines.py` & `pyaedt-0.6.70/pyaedt/modeler/cad/polylines.py`

 * *Files 1% similar despite different names*

```diff
@@ -320,19 +320,17 @@
             varg1 = self._point_segment_string_array()
             if non_model:
                 flag = "NonModel#"
             else:
                 flag = ""
             varg2 = self._primitives._default_object_attributes(name=name, matname=matname, flags=flag)
 
-            new_object_name = _retry_ntimes(10, self.m_Editor.CreatePolyline, varg1, varg2)
-
+            new_object_name = _retry_ntimes(10, self._oeditor.CreatePolyline, varg1, varg2)
             Object3d.__init__(self, primitives, name=new_object_name)
-            self._primitives.objects[self.id] = self
-            self._primitives.object_id_dict[self.name] = self.id
+            self._primitives._create_object(self.name)
 
     @property
     def start_point(self):
         """List of the ``[x, y, z]`` coordinates for the starting point in the polyline
         object in the object's coordinate system.
 
         Returns
@@ -381,15 +379,15 @@
                 else:
                     p_out.append(unit_converter(v, unit_system="Length", input_units=u, output_units=dest_unit))
             return p_out
 
         segments = []
         points = []
         try:
-            history = self.history
+            history = self.history()
             h_segments = history.segments
         except:  # pragma: no cover
             history = None
             h_segments = None
         if h_segments:
             for i, c in enumerate(h_segments.values()):
                 # evaluate the number of points in the segment
@@ -718,17 +716,15 @@
     @pyaedt_function_handler()
     def _add_new_polyline(self):
         new_objects = self._primitives.find_new_objects()
         assert len(new_objects) == 1
         new_name = new_objects[0]
         new_polyline = Polyline(self._primitives, src_object=self, name=new_name)
         new_polyline._id = None
-        self._primitives.objects[new_polyline.id] = new_polyline
-        self._primitives.object_id_dict[new_name] = new_polyline.id
-        return new_polyline
+        return self._primitives._create_object(new_name)
 
     @pyaedt_function_handler()
     def remove_vertex(self, position, abstol=1e-9):
         """Remove a vertex from an existing polyline by position.
 
         .. deprecated:: 0.6.55
            Use :func:``remove_point`` method instead.
@@ -974,16 +970,15 @@
             arg3.append(["NAME:Number of Segments", "Value:=", num_seg])
         elif section_type == "Isosceles Trapezoid":
             arg3.append(["NAME:Top Width", "Value:=", _dim_arg(topwidth, model_units)])
             arg3.append(["NAME:Height", "Value:=", _dim_arg(height, model_units)])
         arg2.append(arg3)
         arg1.append(arg2)
         self._primitives.oeditor.ChangeProperty(arg1)
-        self._update()
-        return True
+        return self._primitives.update_object(self.name)
 
     @pyaedt_function_handler()
     def _get_point_slice_from_segment_id(self, segment_id, at_start=True):
         """Get the points belonging to the segment from the segment id.
         The points are returned as list slice by returning the indexes.
 
         Parameters
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/circuits/PrimitivesCircuit.py` & `pyaedt-0.6.70/pyaedt/modeler/circuits/PrimitivesCircuit.py`

 * *Files 2% similar despite different names*

```diff
@@ -228,24 +228,14 @@
         comp_id = "CompInst@" + name + ";" + str(id_num) + ";395"
         arg1 = ["Name:Selections", "Selections:=", [comp_id]]
         self.oeditor.AddPinIPorts(arg1)
 
         return True
 
     @pyaedt_function_handler()
-    def create_iport(self, name, posx=0.1, posy=0.1, angle=0):
-        """Create an interface port.
-
-        .. deprecated:: 0.4.0
-           Use :func:`Circuit.modeler.schematic.create_interface_port` instead.
-        """
-        warnings.warn("`create_iport` is deprecated. Use `create_interface_port` instead.", DeprecationWarning)
-        return self.create_interface_port(name, [posx, posy], angle)
-
-    @pyaedt_function_handler()
     def create_interface_port(self, name, location=[], angle=0):
         """Create an interface port.
 
         Parameters
         ----------
         name : str
             Name of the port.
@@ -606,44 +596,14 @@
             ]
         )
 
         self.o_component_manager.Add(arg)
         return model_name
 
     @pyaedt_function_handler()
-    def create_component_from_touchstonmodel(
-        self,
-        model_name,
-        location=[],
-        angle=0,
-    ):
-        """Create a component from a Touchstone model.
-
-        .. deprecated:: 0.4.14
-           Use :func:`create_touchsthone_component` instead.
-
-        Parameters
-        ----------
-        model_name : str
-            Name of the Touchstone model or full path to touchstone file.
-            If full touchstone is provided then, new model will be created.
-        location : list of float, optional
-            Position on the X  and Y axis.
-        angle : float, optional
-            Angle rotation in degrees. The default is ``0``.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.object3dcircuit.CircuitComponent`
-            Circuit Component Object.
-
-        """
-        return self.create_touchsthone_component(model_name, location, angle)
-
-    @pyaedt_function_handler()
     def create_touchsthone_component(
         self,
         model_name,
         location=[],
         angle=0,
     ):
         """Create a component from a Touchstone model.
@@ -953,14 +913,16 @@
         """Refresh all IDs and return the number of components.
 
         References
         ----------
 
         >>> oEditor.GetAllElements()"""
         obj = self.oeditor.GetAllElements()
+        if not obj:
+            obj = []
         obj = [i for i in obj if "Wire" not in i[:4]]
         for el in obj:
             if not self.get_obj_id(el):
                 name = el.split(";")
                 if len(name) > 1:
                     o = CircuitComponent(self, tabname=self.tab_name)
                     o.name = name[0]
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/circuits/PrimitivesEmit.py` & `pyaedt-0.6.70/pyaedt/modeler/circuits/PrimitivesEmit.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/circuits/PrimitivesMaxwellCircuit.py` & `pyaedt-0.6.70/pyaedt/modeler/circuits/PrimitivesMaxwellCircuit.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/circuits/PrimitivesNexxim.py` & `pyaedt-0.6.70/pyaedt/modeler/circuits/PrimitivesNexxim.py`

 * *Files 2% similar despite different names*

```diff
@@ -266,26 +266,14 @@
         comps[0].pins[0].connect_to_component([i.pins[0] for i in comps[1:]])
         terminal_to_connect = [cmp for cmp in comps if len(cmp.pins) >= 2]
         if len(terminal_to_connect) > 1:
             terminal_to_connect[0].pins[1].connect_to_component([i.pins[1] for i in terminal_to_connect[1:]])
         return True
 
     @pyaedt_function_handler()
-    def create_3dlayout_subcircuit(self, sourcename):
-        """Add a subcircuit from a HFSS 3DLayout.
-
-        .. deprecated:: 0.4.0
-           Use :func:`Circuit.modeler.schematic.add_subcircuit_3dlayout` instead.
-        """
-        warnings.warn(
-            "`create_3dlayout_subcircuit` is deprecated. Use `add_subcircuit_3dlayout` instead.", DeprecationWarning
-        )
-        return self.add_subcircuit_3dlayout(sourcename)
-
-    @pyaedt_function_handler()
     def add_subcircuit_3dlayout(self, sourcename):
         """Add a subcircuit from a HFSS 3DLayout.
 
         Parameters
         ----------
         sourcename : str
             Name of the source design.
@@ -1311,76 +1299,14 @@
             "DataType:=",
             data_type,
         ]
 
         return res
 
     @pyaedt_function_handler()
-    def add_subcircuit_hfss_link(
-        self,
-        comp_name,
-        pin_names,
-        source_project_path,
-        source_design_name,
-        solution_name="Setup1 : Sweep",
-        image_subcircuit_path=None,
-        variables=None,
-    ):
-        """Add a subcircuit HFSS link.
-
-        .. deprecated:: 0.4.27
-           Use :func:`pyaedt.modeler.circuits.PrimitivesNexxim.NexximComponents.add_subcircuit_dynamic_link.` instead.
-
-        Parameters
-        ----------
-        comp_name : str
-            Name of the subcircuit HFSS link.
-        pin_names : list
-            List of the pin names.
-        source_project_path : str
-            Path to the source project.
-        source_design_name : str
-            Name of the design.
-        solution_name : str, optional
-            Name of the solution and sweep. The
-            default is ``"Setup1 : Sweep"``.
-        image_subcircuit_path : str, optional
-            Path of the Picture used in Circuit.
-            Default is an HFSS Picture exported automatically.
-        variables : dict, optional.
-            Dictionary of design variables of linked object if any. Key is name, value is default value.
-
-        Returns
-        -------
-        :class:`pyaedt.modeler.object3dcircuit.CircuitComponent`
-            Circuit Component Object.
-
-        References
-        ----------
-
-        >>> oModelManager.Add
-        >>> oComponentManager.Add
-        >>> oDesign.AddCompInstance
-        """
-        warnings.warn(
-            "`add_subcircuit_hfss_link` is deprecated. Use `add_subcircuit_dynamic_link` instead.",
-            DeprecationWarning,
-        )
-        return self._add_subcircuit_link(
-            comp_name=comp_name,
-            pin_names=pin_names,
-            source_project_path=source_project_path,
-            source_design_name=source_design_name,
-            solution_name=solution_name,
-            image_subcircuit_path=image_subcircuit_path,
-            model_type="Hfss",
-            variables=variables,
-        )
-
-    @pyaedt_function_handler()
     def add_subcircuit_dynamic_link(
         self,
         pyaedt_app=None,
         solution_name=None,
         extrusion_length=None,
         enable_cable_modeling=True,
         default_matrix="Original",
@@ -1855,41 +1781,14 @@
         if "@" in component_name:
             component_name = component_name.split("@")[1]
         component_name = component_name.split(";")[0]
         self.o_component_manager.UpdateDynamicLink(component_name)
         return True
 
     @pyaedt_function_handler()
-    def push_excitations(self, instance_name, thevenin_calculation=False, setup_name="LinearFrequency"):
-        """Push excitations.
-
-        .. deprecated:: 0.4.0
-           Use :func:`Circuit.push_excitations` instead.
-        """
-        warnings.warn(
-            "`circuit.modeler.schematic.push_excitation` is deprecated. " "Use `circuit.push_excitation` instead.",
-            DeprecationWarning,
-        )
-        return self._app.push_excitations(instance_name, thevenin_calculation, setup_name)
-
-    @pyaedt_function_handler()
-    def assign_sin_excitation2ports(self, ports, settings):
-        """Assign a voltage sinusoidal excitation to circuit ports.
-
-        .. deprecated:: 0.4.0
-           Use :func:`Circuit.modeler.schematic.assign_voltage_sinusoidal_excitation_to_ports` instead.
-        """
-        warnings.warn(
-            "`assign_sin_excitation2ports` is deprecated. "
-            "Use `assign_voltage_sinusoidal_excitation_to_ports` instead.",
-            DeprecationWarning,
-        )
-        return self._app.assign_voltage_sinusoidal_excitation_to_ports(ports)
-
-    @pyaedt_function_handler()
     def _parse_spice_model(self, model_path):
         models = []
         with open_file(model_path, "r") as f:
             for line in f:
                 if ".subckt" in line.lower():
                     pinNames = [i.strip() for i in re.split(" |\t", line) if i]
                     models.append(pinNames[1])
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/circuits/PrimitivesTwinBuilder.py` & `pyaedt-0.6.70/pyaedt/modeler/circuits/PrimitivesTwinBuilder.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/circuits/object3dcircuit.py` & `pyaedt-0.6.70/pyaedt/modeler/circuits/object3dcircuit.py`

 * *Files 3% similar despite different names*

```diff
@@ -17,15 +17,15 @@
 
 class CircuitPins(object):
     """Manages circuit component pins."""
 
     def __init__(self, circuit_comp, pinname):
         self._circuit_comp = circuit_comp
         self.name = pinname
-        self.m_Editor = circuit_comp.m_Editor
+        self._oeditor = circuit_comp._oeditor
 
     @property
     def units(self):
         """Length units."""
         return self._circuit_comp.units
 
     @property
@@ -36,15 +36,15 @@
         ----------
 
         >>> oPadstackManager.GetComponentPinLocation
         """
         if "Port" in self._circuit_comp.composed_name:
             pos1 = _retry_ntimes(
                 30,
-                self.m_Editor.GetPropertyValue,
+                self._oeditor.GetPropertyValue,
                 "BaseElementTab",
                 self._circuit_comp.composed_name,
                 "Component Location",
             )
             if isinstance(pos1, str):
                 pos1 = pos1.split(", ")
                 pos1 = [float(i.strip()[:-3]) * 0.0000254 for i in pos1]
@@ -52,46 +52,46 @@
                     pos1[1] += 0.00254
                 pos1 = [round(i / AEDT_UNITS["Length"][self.units], 8) for i in pos1]
                 return pos1
             return []
         return [
             round(
                 _retry_ntimes(
-                    30, self.m_Editor.GetComponentPinLocation, self._circuit_comp.composed_name, self.name, True
+                    30, self._oeditor.GetComponentPinLocation, self._circuit_comp.composed_name, self.name, True
                 )
                 / AEDT_UNITS["Length"][self.units],
                 8,
             ),
             round(
                 _retry_ntimes(
-                    30, self.m_Editor.GetComponentPinLocation, self._circuit_comp.composed_name, self.name, False
+                    30, self._oeditor.GetComponentPinLocation, self._circuit_comp.composed_name, self.name, False
                 )
                 / AEDT_UNITS["Length"][self.units],
                 8,
             ),
         ]
 
     @property
     def net(self):
         """Get pin net."""
         if "PagePort@" in self.name:
             return self._circuit_comp.name.split("@")[1]
         for net in self._circuit_comp._circuit_components.nets:
-            conns = self.m_Editor.GetNetConnections(net)
+            conns = self._oeditor.GetNetConnections(net)
             for conn in conns:
                 if conn.endswith(self.name) and (
                     ";{};".format(self._circuit_comp.id) in conn or ";{} ".format(self._circuit_comp.id) in conn
                 ):
                     return net
         return ""
 
     @property
     def angle(self):
         """Pin angle."""
-        props = list(self.m_Editor.GetComponentPinInfo(self._circuit_comp.composed_name, self.name))
+        props = list(self._oeditor.GetComponentPinInfo(self._circuit_comp.composed_name, self.name))
         for i in props:
             if "Angle=" in i:
                 return round(float(i[6:]))
         return 0.0
 
     @staticmethod
     def _is_inside_point(plist, pa, pb):
@@ -307,15 +307,15 @@
         else:
             return False
 
 
 class ComponentParameters(dict):
     def __setitem__(self, key, value):
         try:
-            self._component.m_Editor.ChangeProperty(
+            self._component._oeditor.ChangeProperty(
                 [
                     "NAME:AllTabs",
                     [
                         "NAME:" + self._tab,
                         ["NAME:PropServers", self._component.composed_name],
                         ["NAME:ChangedProps", ["NAME:" + key, "Value:=", str(value)]],
                     ],
@@ -367,17 +367,17 @@
         else:
             return self.name + ";" + str(self.schematic_id)
 
     def __init__(self, circuit_components, tabname="PassedParameterTab", custom_editor=None):
         self.name = ""
         self._circuit_components = circuit_components
         if custom_editor:
-            self.m_Editor = custom_editor
+            self._oeditor = custom_editor
         else:
-            self.m_Editor = self._circuit_components.oeditor
+            self._oeditor = self._circuit_components.oeditor
         self._modelName = None
         self.status = "Active"
         self.component = None
         self.id = 0
         self.schematic_id = 0
         self.levels = 0.1
         self._angle = None
@@ -391,15 +391,15 @@
         self._component_info = {}
         self._model_data = {}
 
     @property
     def refdes(self):
         """Reference designator."""
         try:
-            return self.m_Editor.GetPropertyValue("Component", self.composed_name, "RefDes")
+            return self._oeditor.GetPropertyValue("Component", self.composed_name, "RefDes")
         except:
             return ""
 
     @property
     def units(self):
         """Length units."""
         return self._circuit_components.schematic_units
@@ -458,20 +458,20 @@
         if self._circuit_components._app.design_type == "Circuit Design":
             tab = "PassedParameterTab"
         elif self._circuit_components._app.design_type == "Maxwell Circuit":
             tab = "PassedParameterTab"
         else:
             tab = "Quantities"
         try:
-            proparray = self.m_Editor.GetProperties(tab, self.composed_name)
+            proparray = self._oeditor.GetProperties(tab, self.composed_name)
         except:
             proparray = []
 
         for j in proparray:
-            propval = _retry_ntimes(10, self.m_Editor.GetPropertyValue, tab, self.composed_name, j)
+            propval = _retry_ntimes(10, self._oeditor.GetPropertyValue, tab, self.composed_name, j)
             _parameters[j] = propval
         self._parameters = ComponentParameters(self, tab, _parameters)
         return self._parameters
 
     @property
     def component_info(self):
         """Component parameters.
@@ -482,26 +482,26 @@
         >>> oEditor.GetProperties
         >>> oEditor.GetPropertyValue
         """
         if self._component_info or self._circuit_components._app.design_type != "Circuit Design":
             return self._component_info
         _component_info = {}
         tab = "Component"
-        proparray = self.m_Editor.GetProperties(tab, self.composed_name)
+        proparray = self._oeditor.GetProperties(tab, self.composed_name)
 
         for j in proparray:
-            propval = _retry_ntimes(10, self.m_Editor.GetPropertyValue, tab, self.composed_name, j)
+            propval = _retry_ntimes(10, self._oeditor.GetPropertyValue, tab, self.composed_name, j)
             _component_info[j] = propval
         self._component_info = ComponentParameters(self, tab, _component_info)
         return self._component_info
 
     @property
     def bounding_box(self):
         """Component bounding box."""
-        comp_info = self.m_Editor.GetComponentInfo(self.composed_name)
+        comp_info = self._oeditor.GetComponentInfo(self.composed_name)
         if not comp_info:
             if len(self.pins) == 1:
                 return [
                     self.pins[0].location[0] - 0.00254 / AEDT_UNITS["Length"][self._circuit_components.schematic_units],
                     self.pins[0].location[-1]
                     + 0.00254 / AEDT_UNITS["Length"][self._circuit_components.schematic_units],
                     self.pins[0].location[0] + 0.00254 / AEDT_UNITS["Length"][self._circuit_components.schematic_units],
@@ -531,15 +531,15 @@
 
         """
         if self._pins:
             return self._pins
         self._pins = []
 
         try:
-            pins = _retry_ntimes(10, self.m_Editor.GetComponentPins, self.composed_name)
+            pins = _retry_ntimes(10, self._oeditor.GetComponentPins, self.composed_name)
 
             if not pins:
                 return []
             elif pins is True:
                 self._pins.append(CircuitPins(self, self.composed_name))
                 return self._pins
             for pin in pins:
@@ -560,15 +560,15 @@
 
         >>> oEditor.GetPropertyValue
         >>> oEditor.ChangeProperty
         """
         self._location = []
         try:
             loc = _retry_ntimes(
-                10, self.m_Editor.GetPropertyValue, "BaseElementTab", self.composed_name, "Component Location"
+                10, self._oeditor.GetPropertyValue, "BaseElementTab", self.composed_name, "Component Location"
             )
             loc = [loc.split(",")[0].strip(), loc.split(",")[1].strip()]
             loc = [decompose_variable_value(i) for i in loc]
 
             self._location = [
                 round(i[0] * AEDT_UNITS["Length"][i[1]] / AEDT_UNITS["Length"][self.units], 10) for i in loc
             ]
@@ -600,15 +600,15 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         >>> oEditor.ChangeProperty
         """
-        comp_info = self.m_Editor.GetComponentInfo(self.composed_name)
+        comp_info = self._oeditor.GetComponentInfo(self.composed_name)
         self._angle = 0.0
         if comp_info:
             for info in comp_info:
                 if "Angle=" in info:
                     self._angle = float(info[6:])
                     break
         return self._angle
@@ -639,15 +639,15 @@
         >>> oEditor.ChangeProperty
         """
         if self._mirror is not None:
             return self._mirror
         try:
             self._mirror = (
                 _retry_ntimes(
-                    10, self.m_Editor.GetPropertyValue, "BaseElementTab", self.composed_name, "Component Mirror"
+                    10, self._oeditor.GetPropertyValue, "BaseElementTab", self.composed_name, "Component Mirror"
                 )
                 == "true"
             )
         except:
             self._mirror = False
         return self._mirror
 
@@ -803,28 +803,28 @@
         if names_list:
             vPropServers = ["NAME:PropServers"]
             for el in names_list:
                 vPropServers.append(el)
         else:
             vPropServers = ["NAME:PropServers", self.composed_name]
         tabname = None
-        if vPropChange[0][5:] in _retry_ntimes(10, self.m_Editor.GetProperties, self.tabname, self.composed_name):
+        if vPropChange[0][5:] in _retry_ntimes(10, self._oeditor.GetProperties, self.tabname, self.composed_name):
             tabname = self.tabname
         elif vPropChange[0][5:] in _retry_ntimes(
-            10, self.m_Editor.GetProperties, "PassedParameterTab", self.composed_name
+            10, self._oeditor.GetProperties, "PassedParameterTab", self.composed_name
         ):
             tabname = "PassedParameterTab"
-        elif vPropChange[0][5:] in _retry_ntimes(10, self.m_Editor.GetProperties, "BaseElementTab", self.composed_name):
+        elif vPropChange[0][5:] in _retry_ntimes(10, self._oeditor.GetProperties, "BaseElementTab", self.composed_name):
             tabname = "BaseElementTab"
         if tabname:
             vGeo3dlayout = ["NAME:" + tabname, vPropServers, vChangedProps]
             vOut = ["NAME:AllTabs", vGeo3dlayout]
             if "NAME:Component Location" in str(vChangedProps) and "PagePort" not in self.composed_name:
-                _retry_ntimes(10, self.m_Editor.ChangeProperty, vOut)
-            return _retry_ntimes(10, self.m_Editor.ChangeProperty, vOut)
+                _retry_ntimes(10, self._oeditor.ChangeProperty, vOut)
+            return _retry_ntimes(10, self._oeditor.ChangeProperty, vOut)
         return False
 
 
 class Wire(object):
     """Creates and manipulates a wire."""
 
     def __init__(self, modeler):
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/geometry_operators.py` & `pyaedt-0.6.70/pyaedt/modeler/geometry_operators.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/modeler2d.py` & `pyaedt-0.6.70/pyaedt/modeler/modeler2d.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/modeler3d.py` & `pyaedt-0.6.70/pyaedt/modeler/modeler3d.py`

 * *Files 0% similar despite different names*

```diff
@@ -553,15 +553,15 @@
 
         Parameters
         ----------
         startingposition : list
             List of ``[x, y, z]`` coordinates for the starting position.
         axis : int
             Coordinate system AXIS (integer ``0`` for X, ``1`` for Y, ``2`` for Z) or
-            the :class:`Application.CoordinateSystemAxis` enumerator.
+            the :class:`Application.AXIS` enumerator.
         innerradius : float, optional
             Inner coax radius. The default is ``1``.
         outerradius : float, optional
             Outer coax radius. The default is ``2``.
         dielradius : float, optional
             Dielectric coax radius. The default is ``1.8``.
         length : float, optional
@@ -635,15 +635,15 @@
 
         Parameters
         ----------
         origin : list
             List of ``[x, y, z]`` coordinates for the original position.
         wg_direction_axis : int
             Coordinate system axis (integer ``0`` for X, ``1`` for Y, ``2`` for Z) or
-            the :class:`Application.CoordinateSystemAxis` enumerator.
+            the :class:`Application.AXIS` enumerator.
         wgmodel : str, optional
             Waveguide model. The default is ``"WG0"``.
         wg_length : float, optional
             Waveguide length. The default is ``100``.
         wg_thickness : float, optional
             Waveguide thickness. The default is ``None``, in which case the
             thickness is `wg_height/20`.
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/modelerpcb.py` & `pyaedt-0.6.70/pyaedt/modeler/modelerpcb.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/pcb/Primitives3DLayout.py` & `pyaedt-0.6.70/pyaedt/modeler/pcb/Primitives3DLayout.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modeler/pcb/object3dlayout.py` & `pyaedt-0.6.70/pyaedt/modeler/pcb/object3dlayout.py`

 * *Files 2% similar despite different names*

```diff
@@ -22,15 +22,15 @@
     Parameters
     -----------
     primitives : :class:`pyaedt.modeler.Model3DLayout.Modeler3dLayout`
     """
 
     def __init__(self, primitives, prim_type=None):
         self._primitives = primitives
-        self.m_Editor = self._primitives.oeditor
+        self._oeditor = self._primitives.oeditor
         self._n = 10
         self.prim_type = prim_type
         self._points = []
 
     @property
     def object_units(self):
         """Object units.
@@ -68,15 +68,15 @@
             for el in names_list:
                 vPropServers.append(el)
         else:
             vPropServers = ["NAME:PropServers", self.name]
         vGeo3dlayout = ["NAME:BaseElementTab", vPropServers, vChangedProps]
         vOut = ["NAME:AllTabs", vGeo3dlayout]
 
-        self.m_Editor.ChangeProperty(vOut)
+        self._oeditor.ChangeProperty(vOut)
         return True
 
     @pyaedt_function_handler()
     def set_property_value(self, property_name, property_value):
         """Set a property value.
 
         Parameters
@@ -110,15 +110,15 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if self.prim_type in ["component", "pin", "via"]:
-            return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Angle")
+            return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Angle")
 
     @angle.setter
     def angle(self, value):
         if self.prim_type in ["component", "pin", "via"]:
             vMaterial = ["NAME:Angle", "Value:=", value]
             self.change_property(vMaterial)
 
@@ -128,20 +128,20 @@
 
         Returns
         -------
         float
         """
         if self.prim_type != "component":
             return 0.0
-        comp_pins = self.m_Editor.GetComponentPins(self.name)
+        comp_pins = self._oeditor.GetComponentPins(self.name)
         if len(comp_pins) == 2:
             pin_1_name = comp_pins[0]
             pin_2_name = comp_pins[1]
-            pin1_info = self.m_Editor.GetComponentPinInfo(self.name, pin_1_name)
-            pin2_info = self.m_Editor.GetComponentPinInfo(self.name, pin_2_name)
+            pin1_info = self._oeditor.GetComponentPinInfo(self.name, pin_1_name)
+            pin2_info = self._oeditor.GetComponentPinInfo(self.name, pin_2_name)
             pin1_x = pin1_info[1].split("=")[1]
             pin1_y = pin1_info[2].split("=")[1]
             pin2_x = pin2_info[1].split("=")[1]
             pin2_y = pin2_info[2].split("=")[1]
             p1x = float(pin1_x)
             p1y = float(pin1_y)
             p2x = float(pin2_x)
@@ -167,15 +167,15 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if self.prim_type not in ["component"]:
-            return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Net")
+            return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Net")
 
     @net_name.setter
     def net_name(self, netname=""):
         if self.prim_type not in ["component"]:
             vMaterial = ["NAME:Net", "Value:=", netname]
             self.change_property(vMaterial)
 
@@ -190,15 +190,15 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if self.prim_type not in ["pin", "via"]:
-            return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "PlacementLayer")
+            return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "PlacementLayer")
 
     @placement_layer.setter
     def placement_layer(self, layer_name):
         if self.prim_type not in ["pin", "via"]:
             vMaterial = ["NAME:PlacementLayer", "Value:=", layer_name]
             self.change_property(vMaterial)
 
@@ -207,15 +207,15 @@
         """Get component bounding box.
 
         Returns
         -------
         list
             [BB_lower_left_X, BB_lower_left_Y, BB_upper_right_X, BB_upper_right_Y].
         """
-        info = self.m_Editor.GetComponentInfo(self.name)
+        info = self._oeditor.GetComponentInfo(self.name)
         bbllx = bblly = bburx = bbury = 0
         for i in info:
             if "BBoxLLx" in i:
                 bbllx = float(i.split("=")[1])
             elif "BBoxLLy" in i:
                 bblly = float(i.split("=")[1])
             elif "BBoxURx" in i:
@@ -284,15 +284,15 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if self.prim_type == "component":
-            info = self.m_Editor.GetComponentInfo(self.name)
+            info = self._oeditor.GetComponentInfo(self.name)
             bbllx = bblly = bburx = bbury = 0
             for i in info:
                 if "BBoxLLx" in i:
                     bbllx = float(i.split("=")[1])
                 elif "BBoxLLy" in i:
                     bblly = float(i.split("=")[1])
                 elif "BBoxURx" in i:
@@ -302,30 +302,30 @@
             loc_x = (bburx + bbllx) / 2
             loc_y = (bbury + bblly) / 2
             loc_x = round(unit_converter(loc_x, output_units=self._primitives.model_units), 9)
             loc_y = round(unit_converter(loc_y, output_units=self._primitives.model_units), 9)
             return [loc_x, loc_y]
         elif self.prim_type in ["pin", "via"]:
             location = _retry_ntimes(
-                self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Location"
+                self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Location"
             ).split(",")
             locs = []
             for i in location:
                 try:
                     locs.append(float(i))
                 except ValueError:  # pragma: no cover
                     locs.append(i)
             return locs
         else:
             return None
 
     @location.setter
     def location(self, position):
         if self.prim_type == "component":
-            info = self.m_Editor.GetComponentInfo(self.name)
+            info = self._oeditor.GetComponentInfo(self.name)
             bbllx = bblly = bburx = bbury = 0
             for i in info:
                 if "BBoxLLx" in i:
                     bbllx = float(i.split("=")[1])
                 elif "BBoxLLy" in i:
                     bblly = float(i.split("=")[1])
                 elif "BBoxURx" in i:
@@ -360,15 +360,15 @@
         References
         ----------
 
         >>> oEditor.ChangeProperty
         """
         return (
             True
-            if _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "LockPosition")
+            if _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "LockPosition")
             in [True, "true"]
             else False
         )
 
     @lock_position.setter
     def lock_position(self, lock_position=True):
         vMaterial = ["NAME:LockPosition", "Value:=", lock_position]
@@ -378,15 +378,15 @@
 class ModelInfoRlc(object):
     def __init__(self, component, name):
         self._comp = component
         self._name = name
 
     @property
     def rlc_model_type(self):
-        props = _retry_ntimes(self._comp._n, self._comp.m_Editor.GetComponentInfo, self._name)
+        props = _retry_ntimes(self._comp._n, self._comp._oeditor.GetComponentInfo, self._name)
         model = ""
         for p in props:
             if "ComponentProp=" in p:
                 model = p
                 break
         s = r".+rlc\(r='(.+?)', re=(.+?), l='(.+?)', le=(.+?), c='(.+?)', ce=(.+?), p=(.+?), lyr=(.+?)"
         m = re.search(s, model)
@@ -440,15 +440,15 @@
             Component part.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Part")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Part")
 
     @property
     def part_type(self):
         """Retrieve the component part type.
 
         Returns
         -------
@@ -456,15 +456,15 @@
             Component part type.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Part Type")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Part Type")
 
     @property
     def _part_type_id(self):
         parts = {"Other": 0, "Resistor": 1, "Inductor": 2, "Capacitor": 3, "IC": 4, "IO": 5}
         if self.part_type in parts:
             return parts[self.part_type]
         return -1
@@ -479,40 +479,40 @@
             Set the RLC Component to Enable or Disable state.
 
         Returns
         -------
         bool
             `True` if succeeded.
         """
-        comp_info = self.m_Editor.GetComponentInfo(self.name)
+        comp_info = self._oeditor.GetComponentInfo(self.name)
         for el in comp_info:
             if "ComponentProp=" in el and "CompPropEnabled=false" in el:
                 return False
             elif "ComponentProp=" in el and "CompPropEnabled=true" in el:
                 return True
         return True
 
     @enabled.setter
     def enabled(self, status):
         if self._part_type_id in [0, 4, 5]:
             return False
-        self.m_Editor.EnableComponents(["NAME:Components", self.name], status)
+        self._oeditor.EnableComponents(["NAME:Components", self.name], status)
 
     @property
     def solderball_enabled(self):
         """Check if solderball is enabled.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
         """
         if self._part_type_id not in [0, 4, 5]:
             return False
-        component_info = str(list(self.m_Editor.GetComponentInfo(self.name))).replace("'", "").replace('"', "")
+        component_info = str(list(self._oeditor.GetComponentInfo(self.name))).replace("'", "").replace('"', "")
         if "sbsh=Cyl" in component_info or "sbsh=Sph" in component_info:
             return True
         return False
 
     @property
     def die_enabled(self):
         """Check if the die is enabled. This method is valid for integrated circuits only.
@@ -520,30 +520,30 @@
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
         """
         if self._part_type_id not in [0, 4, 5]:
             return False
-        component_info = str(list(self.m_Editor.GetComponentInfo(self.name))).replace("'", "").replace('"', "")
+        component_info = str(list(self._oeditor.GetComponentInfo(self.name))).replace("'", "").replace('"', "")
         if "dt=1" in component_info or "dt=2" in component_info:
             return True
         return False
 
     @property
     def die_type(self):
         """Die type.
 
         Returns
         -------
         str
         """
         if self._part_type_id not in [0, 4, 5]:
             return False
-        component_info = str(list(self.m_Editor.GetComponentInfo(self.name))).replace("'", "").replace('"', "")
+        component_info = str(list(self._oeditor.GetComponentInfo(self.name))).replace("'", "").replace('"', "")
         if "dt=1" in component_info:
             return "FlipChip"
         elif "dt=2" in component_info:
             return "WireBond"
         return None
 
     @pyaedt_function_handler()
@@ -647,15 +647,15 @@
         """
         if self._part_type_id not in [0, 4, 5]:
             return False
         if self._part_type_id == 4:
             prop_name = "ICProp:="
             if not self.die_enabled:
                 self.set_die_type()
-            props = _retry_ntimes(10, self.m_Editor.GetComponentInfo, self.name)
+            props = _retry_ntimes(10, self._oeditor.GetComponentInfo, self.name)
             model = ""
             for p in props:
                 if "PortProp(" in p:
                     model = p
                     break
             s = r".+PortProp\(rh='(.+?)', rsa=(.+?), rsx='(.+?)', rsy='(.+?)'\)"
             m = re.search(s, model)
@@ -739,15 +739,15 @@
     def pins(self):
         """Component pins.
 
         Returns
         -------
         List of str
         """
-        return list(self.m_Editor.GetComponentPins(self.name))
+        return list(self._oeditor.GetComponentPins(self.name))
 
     @property
     def model(self):
         """RLC model if available.
 
         Returns
         -------
@@ -758,28 +758,28 @@
 
 
 class Nets3DLayout(object):
     """Contains Nets in HFSS 3D Layout."""
 
     def __init__(self, primitives, name=""):
         self._primitives = primitives
-        self.m_Editor = self._primitives.oeditor
+        self._oeditor = self._primitives.oeditor
         self._n = 10
         self.name = name
 
     @property
     def components(self):
         """Components that belongs to the Nets.
 
         Returns
         -------
         :class:`pyaedt.modeler.object3dlayout.Components3DLayout`
         """
         comps = {}
-        for c in self.m_Editor.FilterObjectList("Type", "component", self.m_Editor.FindObjects("Net", self.name)):
+        for c in self._oeditor.FilterObjectList("Type", "component", self._oeditor.FindObjects("Net", self.name)):
             comps[c] = self._primitives.components[c]
         return comps
 
 
 class Pins3DLayout(Objec3DLayout, object):
     """Contains the pins in HFSS 3D Layout."""
 
@@ -799,15 +799,15 @@
             Name of the starting layer of the pin.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Start Layer")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Start Layer")
 
     @property
     def stop_layer(self):
         """Retrieve the starting layer of the pin.
 
         Returns
         -------
@@ -815,15 +815,15 @@
             Name of the stopping layer of the pin.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Stop Layer")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Stop Layer")
 
     @property
     def holediam(self):
         """Retrieve the hole diameter of the pin.
 
         Returns
         -------
@@ -831,15 +831,15 @@
            Hole diameter of the pin.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "HoleDiameter")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "HoleDiameter")
 
 
 class Geometries3DLayout(Objec3DLayout, object):
     """Contains geometries in HFSS 3D Layout."""
 
     def __init__(self, primitives, name, prim_type="poly", is_void=False):
         Objec3DLayout.__init__(self, primitives, prim_type)
@@ -863,28 +863,28 @@
         Returns
         -------
         List of :class:`pyaedt.modeler.object3dlayout.Points3dLayout`
         """
         if self._points:
             return self._points
         self._points = []
-        obj = self.m_Editor.GetPolygon(self.name)
+        obj = self._oeditor.GetPolygon(self.name)
         for oo in obj.GetPoints():
             self._points.append(Points3dLayout(self._primitives, oo))
         return self._points
 
     @property
     def edges(self):
         """Edges list.
 
         Returns
         -------
         List
         """
-        info = self.m_Editor.GetPolygonInfo(self.name)
+        info = self._oeditor.GetPolygonInfo(self.name)
         points = []
         for i in info:
             if i == "Poly:=":
                 for k in info[info.index(i) + 1]:
                     if k == "pt:=":
                         source = info[info.index(i) + 1]
                         points = source[source.index(k) + 1][2:]
@@ -1001,15 +1001,15 @@
             Value of the property.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, propertyname)
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, propertyname)
 
     @property
     def negative(self):
         """Get/Set the negative.
 
         Parameters
         ----------
@@ -1024,15 +1024,15 @@
 
         >>> oEditor.ChangeProperty
         """
         if self.is_void:
             return False
         return (
             True
-            if _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Negative")
+            if _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Negative")
             in [True, "true"]
             else False
         )
 
     @negative.setter
     def negative(self, negative=False):
         if not self.is_void:
@@ -1052,15 +1052,15 @@
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if self.is_void:
             return None
         if self.prim_type not in ["component"]:
-            return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Net")
+            return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Net")
 
     @net_name.setter
     def net_name(self, netname=""):
         if not self.is_void and self.prim_type not in ["component"]:
             vMaterial = ["NAME:Net", "Value:=", netname]
             self.change_property(vMaterial)
 
@@ -1076,27 +1076,27 @@
     def is_closed(self):
         """Either if the Geometry is closed or not.
 
         Returns
         -------
         bool
         """
-        obj = self.m_Editor.GetPolygon(self.name)
+        obj = self._oeditor.GetPolygon(self.name)
         return obj.IsClosed()
 
     @property
     def polygon_voids(self):
         """All Polygon Voids.
 
         Returns
         -------
         dict
             Dictionary of polygon voids.
         """
-        voids = list(self.m_Editor.GetPolygonVoids(self.name))
+        voids = list(self._oeditor.GetPolygonVoids(self.name))
         pvoids = {}
         for void in voids:
             pvoids[void] = Polygons3DLayout(self._primitives, void, "poly", True)
         return pvoids
 
 
 class Circle3dLayout(Geometries3DLayout, object):
@@ -1115,15 +1115,15 @@
             placement layer.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        cent = _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Center")
+        cent = _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Center")
         if cent:
             return cent.split(",")
 
     @center.setter
     def center(self, position):
         vMaterial = ["NAME:Center", "Value:=", position]
         self.change_property(vMaterial)
@@ -1138,15 +1138,15 @@
             placement layer.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Radius")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Radius")
 
     @radius.setter
     def radius(self, value):
         vMaterial = ["NAME:Radius", "Value:=", value]
         self.change_property(vMaterial)
 
 
@@ -1166,15 +1166,15 @@
             placement layer.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "CornerRadius")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "CornerRadius")
 
     @corner_radius.setter
     def corner_radius(self, value):
         vMaterial = ["NAME:CornerRadius", "Value:=", value]
         self.change_property(vMaterial)
 
     @property
@@ -1189,15 +1189,15 @@
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         return (
             True
-            if _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "2 pt Description")
+            if _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "2 pt Description")
             in [True, "true"]
             else False
         )
 
     @two_point_description.setter
     def two_point_description(self, value):
         vMaterial = ["NAME:2 pt Description", "Value:=", value]
@@ -1214,15 +1214,15 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if not self.two_point_description:
-            cent = _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Center")
+            cent = _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Center")
             if cent:
                 return cent.split(",")
 
     @center.setter
     def center(self, value):
         if not self.two_point_description:
             vMaterial = ["NAME:Center", "X:=", value[0], "Y:=", value[1]]
@@ -1239,15 +1239,15 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if not self.two_point_description:
-            return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Width")
+            return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Width")
 
     @width.setter
     def width(self, value):
         if not self.two_point_description:
             vMaterial = ["NAME:Width", "Value:=", value]
             self.change_property(vMaterial)
 
@@ -1262,15 +1262,15 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if not self.two_point_description:
-            return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Height")
+            return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Height")
 
     @height.setter
     def height(self, value):
         if not self.two_point_description:
             vMaterial = ["NAME:Height", "Value:=", value]
             self.change_property(vMaterial)
 
@@ -1285,15 +1285,15 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if self.two_point_description:
-            pa = _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Pt A")
+            pa = _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Pt A")
             if pa:
                 return pa.split(",")
 
     @point_a.setter
     def point_a(self, value):
         if self.two_point_description:
             vMaterial = ["NAME:Pt A", "X:=", value[0], "Y:=", value[1]]
@@ -1310,15 +1310,15 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if self.two_point_description:
-            pa = _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "Pt B")
+            pa = _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "Pt B")
             if pa:
                 return pa.split(",")
 
     @point_b.setter
     def point_b(self, value):
         if self.two_point_description:
             vMaterial = ["NAME:Pt B", "X:=", value[0], "Y:=", value[1]]
@@ -1327,14 +1327,15 @@
 
 class Line3dLayout(Geometries3DLayout, object):
     """Manages Hfss 3D Layout lines."""
 
     def __init__(self, primitives, name, is_void=False):
         Geometries3DLayout.__init__(self, primitives, name, "line", is_void)
         self._points = []
+        self._center_line = {}
 
     @property
     def bend_type(self):
         """Get/Set the line bend type.
 
         Returns
         -------
@@ -1342,15 +1343,15 @@
             Bend Type.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "BendType")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "BendType")
 
     @bend_type.setter
     def bend_type(self, value):
         vMaterial = ["NAME:BendType", "Value:=", value]
         self.change_property(vMaterial)
 
     @property
@@ -1363,15 +1364,15 @@
             Start Cap Type.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "StartCapType")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "StartCapType")
 
     @start_cap_type.setter
     def start_cap_type(self, value):
         vMaterial = ["NAME:StartCap Type", "Value:=", value]
         self.change_property(vMaterial)
 
     @property
@@ -1384,15 +1385,15 @@
             End Cap Type.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "EndCapType")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "EndCapType")
 
     @end_cap_type.setter
     def end_cap_type(self, value):
         vMaterial = ["NAME:EndCap Type", "Value:=", value]
         self.change_property(vMaterial)
 
     @property
@@ -1405,15 +1406,15 @@
             Line Width.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "LineWidth")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "LineWidth")
 
     @width.setter
     def width(self, value):
         vMaterial = ["NAME:LineWidth", "Value:=", value]
         self.change_property(vMaterial)
 
     @property
@@ -1426,19 +1427,47 @@
             Line length.
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
-        return _retry_ntimes(self._n, self.m_Editor.GetPropertyValue, "BaseElementTab", self.name, "TotalLength")
+        return _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, "TotalLength")
+
+    @property
+    def center_line(self):
+        """Get the center line points.
+
+        Returns
+        -------
+        dict
+            Points.
+        """
+        props = [i for i in list(self._oeditor.GetProperties("BaseElementTab", self.name)) if i.startswith("Pt")]
+        self._center_line = {}
+        for i in props:
+            self._center_line[i] = [
+                i.strip()
+                for i in _retry_ntimes(self._n, self._oeditor.GetPropertyValue, "BaseElementTab", self.name, i).split(
+                    ","
+                )
+            ]
+        return self._center_line
+
+    @center_line.setter
+    def center_line(self, points):
+        u = self._primitives.model_units
+        for point_name, value in points.items():
+            vpoint = ["NAME:{}".format(point_name), "X:=", _dim_arg(value[0], u), "Y:=", _dim_arg(value[1], u)]
+            self.change_property(vpoint)
+        self._center_line = {}
 
 
 class Points3dLayout(object):
-    """Manages Hfss 3D Layout Points."""
+    """Manages HFSS 3D Layout points."""
 
     def __init__(self, primitives, point):
         self._primitives = primitives
         self.point = point
 
     @property
     def is_arc(self):
@@ -1495,15 +1524,15 @@
     def __init__(self, primitives, name=""):
         Objec3DLayout.__init__(self, primitives, "component")
         self.name = name
 
     @property
     def component_info(self):
         """Retrieve all component info."""
-        return self.m_Editor.GetComponentInfo(self.name)
+        return self._oeditor.GetComponentInfo(self.name)
 
     @property
     def component_name(self):
         """Retrieve the component name."""
         try:
             return self.component_info[0].split("=")[1]
         except IndexError:
@@ -1520,17 +1549,17 @@
 
         References
         ----------
 
         >>> oEditor.GetPropertyValue
         """
         if self.is_3d_placement:
-            ang = self.m_Editor.GetPropertyValue("BaseElementTab", self.name, "Rotation Angle")
+            ang = self._oeditor.GetPropertyValue("BaseElementTab", self.name, "Rotation Angle")
         else:
-            ang = self.m_Editor.GetPropertyValue("BaseElementTab", self.name, "Angle")
+            ang = self._oeditor.GetPropertyValue("BaseElementTab", self.name, "Angle")
         try:
             return float(ang)
         except ValueError:
             return ang
 
     @angle.setter
     def angle(self, angle_val):
@@ -1542,15 +1571,15 @@
         else:
             props = ["NAME:Rotation Angle", "Value:=", angle_val]
         self.change_property(props)
 
     @property
     def is_3d_placement(self):
         """Retrieve if the component has 3d placement."""
-        if self.m_Editor.GetPropertyValue("BaseElementTab", self.name, "3D Placement") in ["true", "True"]:
+        if self._oeditor.GetPropertyValue("BaseElementTab", self.name, "3D Placement") in ["true", "True"]:
             return True
         else:
             return False
 
 
 class Padstack(object):
     """Manages properties of a padstack.
```

### Comparing `pyaedt-0.6.61/pyaedt/modeler/schematic.py` & `pyaedt-0.6.70/pyaedt/modeler/schematic.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/AdvancedPostProcessing.py` & `pyaedt-0.6.70/pyaedt/modules/AdvancedPostProcessing.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/Boundary.py` & `pyaedt-0.6.70/pyaedt/modules/Boundary.py`

 * *Files 1% similar despite different names*

```diff
@@ -642,14 +642,16 @@
             self._app.oboundary.SetSBRTxRxSettings(self._get_args())  # pragma: no cover
         elif self.type == "Floquet Port":
             self._app.oboundary.EditFloquetPort(self._boundary_name, self._get_args())  # pragma: no cover
         elif self.type == "End Connection":
             self._app.oboundary.EditEndConnection(self._boundary_name, self._get_args())
         elif self.type == "Hybrid":
             self._app.oboundary.EditHybridRegion(self._boundary_name, self._get_args())
+        elif self.type == "Terminal":
+            self._app.oboundary.EditTerminal(self._boundary_name, self._get_args())
         else:
             return False  # pragma: no cover
         self._boundary_name = self.name
         return True
 
     @pyaedt_function_handler()
     def update_assignment(self):
```

### Comparing `pyaedt-0.6.61/pyaedt/modules/CableModeling.py` & `pyaedt-0.6.70/pyaedt/modules/CableModeling.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/CircuitTemplates.py` & `pyaedt-0.6.70/pyaedt/modules/CircuitTemplates.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/DesignXPloration.py` & `pyaedt-0.6.70/pyaedt/modules/Mesh.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,1407 +1,1447 @@
+"""
+This module contains the `Mesh` class.
+"""
+from __future__ import absolute_import  # noreorder
+
 from collections import OrderedDict
-import copy
-import csv
+import os
+import shutil
 
-from pyaedt.generic.DataHandlers import _arg2dict
+from pyaedt.application.design_solutions import model_names
 from pyaedt.generic.DataHandlers import _dict2arg
-from pyaedt.generic.general_methods import PropsManager
+from pyaedt.generic.LoadAEDTFile import load_entire_aedt_file
+from pyaedt.generic.general_methods import MethodNotSupportedError
+from pyaedt.generic.general_methods import _retry_ntimes
 from pyaedt.generic.general_methods import generate_unique_name
 from pyaedt.generic.general_methods import pyaedt_function_handler
-from pyaedt.modules.OptimetricsTemplates import defaultdoeSetup
-from pyaedt.modules.OptimetricsTemplates import defaultdxSetup
-from pyaedt.modules.OptimetricsTemplates import defaultoptiSetup
-from pyaedt.modules.OptimetricsTemplates import defaultparametricSetup
-from pyaedt.modules.OptimetricsTemplates import defaultsensitivitySetup
-from pyaedt.modules.OptimetricsTemplates import defaultstatisticalSetup
-from pyaedt.modules.SolveSweeps import SetupProps
+from pyaedt.generic.general_methods import settings
+from pyaedt.modeler.cad.elements3d import EdgePrimitive
+from pyaedt.modeler.cad.elements3d import FacePrimitive
+from pyaedt.modeler.cad.elements3d import VertexPrimitive
+
+meshers = {
+    "HFSS": "MeshSetup",
+    "Icepak": "MeshRegion",
+    "HFSS3DLayout": "MeshSetup",
+    "Maxwell 2D": "MeshSetup",
+    "Maxwell 3D": "MeshSetup",
+    "Q3D Extractor": "MeshSetup",
+    "Mechanical": "MeshSetup",
+    "2D Extractor": "MeshSetup",
+}
+
+mesh_props = {
+    "CurvedSurfaceApproxChoice": "Curved Mesh Approximation Type",
+    "SliderMeshSettings": "Curved Surface Mesh Resolution",
+    "SurfDevChoice": "Surface Deviation Choice",
+    "SurfDev": "Surface Deviation",
+    "NormalDevChoice": "Normal Deviation Choice",
+    "NormalDev": "Normal Deviation",
+    "AspectRatioChoice": "Aspect Ratio Choice",
+    "AspectRatio": "Aspect Ratio",
+    "UseAutoLength": "Use Auto Simplify",
+    "DefeatureLength": "Model Resolution Length",
+    "SurfaceRepPriority": "Surface Representation Priority for TAU",
+    "RestrictLength": "Restrict Length",
+    "MaxLength": "Max Length",
+    "RestrictElem": "Restrict Max Elems",
+    "SkinDepth": "Skin Depth",
+    "NumLayers": "Num Layers",
+    "SurfTriMaxLength": "Max Elem Length",
+    "NumMaxElem": "Max Elems",
+    "Apply": "Apply Curvilinear Elements",
+    "DisableForFacetedSurfaces": "Disable for Faceted Surface",
+    "RestrictMaxElemLength": "Restrict Max Element Length",
+    "MaxElemLength": "Max Element Length",
+    "RestrictLayersNum": "Restrict Layers Number",
+    "LayersNum": "Number of layers",
+}
+
+
+class MeshProps(OrderedDict):
+    """AEDT Mesh Component Internal Parameters."""
+
+    def __setitem__(self, key, value):
+        OrderedDict.__setitem__(self, key, value)
+        if self._pyaedt_mesh.auto_update:
+            if key in ["Edges", "Faces", "Objects"]:
+                res = self._pyaedt_mesh.update_assignment()
+            else:
+                res = self._pyaedt_mesh.update(key, value)
+            if not res:
+                self._pyaedt_mesh._app.logger.warning("Update of %s Failed. Check needed arguments", key)
+
+    def __init__(self, mesh_object, props):
+        OrderedDict.__init__(self)
+        if props:
+            for key, value in props.items():
+                if isinstance(value, (OrderedDict, OrderedDict)):
+                    OrderedDict.__setitem__(self, key, MeshProps(mesh_object, value))
+                else:
+                    OrderedDict.__setitem__(self, key, value)
+        self._pyaedt_mesh = mesh_object
 
+    def _setitem_without_update(self, key, value):
+        OrderedDict.__setitem__(self, key, value)
 
-class CommonOptimetrics(PropsManager, object):
-    """Creates and sets up optimizations.
+
+class MeshOperation(object):
+    """MeshOperation class.
 
     Parameters
     ----------
-    p_app :
-
-    name :
-
-    dictinputs
-
-    optimtype : str
-        Type of the optimization.
+    mesh : class:`pyaedt.modules.Mesh.Mesh or :class:`pyaedt.modules.MeshIcepak.MeshIcepak`
 
     """
 
-    def __init__(self, p_app, name, dictinputs, optimtype):
-        self.auto_update = False
-        self._app = p_app
-        self.omodule = self._app.ooptimetrics
-        self.name = name
-        self.soltype = optimtype
-
-        inputd = copy.deepcopy(dictinputs)
-
-        if optimtype == "OptiParametric":
-            self.props = SetupProps(self, inputd or copy.deepcopy(defaultparametricSetup))
-            if not inputd and self._app.design_type == "Icepak":
-                self.props["ProdOptiSetupDataV2"] = OrderedDict(
-                    {"SaveFields": False, "FastOptimetrics": False, "SolveWithCopiedMeshOnly": True}
-                )
-        if optimtype == "OptiDesignExplorer":
-            self.props = SetupProps(self, inputd or copy.deepcopy(defaultdxSetup))
-        if optimtype == "OptiOptimization":
-            self.props = SetupProps(self, inputd or copy.deepcopy(defaultoptiSetup))
-        if optimtype == "OptiSensitivity":
-            self.props = SetupProps(self, inputd or copy.deepcopy(defaultsensitivitySetup))
-        if optimtype == "OptiStatistical":
-            self.props = SetupProps(self, inputd or copy.deepcopy(defaultstatisticalSetup))
-        if optimtype == "OptiDXDOE":
-            self.props = SetupProps(self, inputd or copy.deepcopy(defaultdoeSetup))
-        if optimtype == "optiSLang":
-            self.props = SetupProps(self, inputd or copy.deepcopy(defaultdxSetup))
-        if inputd:
-            self.props.pop("ID", None)
-            self.props.pop("NextUniqueID", None)
-            self.props.pop("MoveBackwards", None)
-            self.props.pop("GoalSetupVersion", None)
-            self.props.pop("Version", None)
-            self.props.pop("SetupType", None)
-            if inputd.get("Sim. Setups"):
-                setups = inputd["Sim. Setups"]
-                for el in setups:
-                    if type(self._app.design_properties["SolutionManager"]["ID Map"]["Setup"]) is list:
-                        for setup in self._app.design_properties["SolutionManager"]["ID Map"]["Setup"]:
-                            if setup["I"] == el:
-                                setups[setups.index(el)] = setup["I"]
-                                break
-                    else:
-                        if self._app.design_properties["SolutionManager"]["ID Map"]["Setup"]["I"] == el:
-                            setups[setups.index(el)] = self._app.design_properties["SolutionManager"]["ID Map"][
-                                "Setup"
-                            ]["N"]
-                            break
-            if inputd.get("Goals", None):
-                if self._app._is_object_oriented_enabled():
-                    oparams = self.omodule.GetChildObject(self.name).GetCalculationInfo()
-                    oparam = [i for i in oparams[0]]
-                    calculation = ["NAME:Goal"]
-                    calculation.extend(oparam)
-                    arg1 = OrderedDict()
-                    _arg2dict(calculation, arg1)
-                    self.props["Goals"] = arg1
+    def __init__(self, mesh, name, props, meshoptype):
+        self._mesh = mesh
+        self._app = self._mesh._app
+        self.props = MeshProps(self, props)
+        self.type = meshoptype
+        self._name = name
         self.auto_update = True
 
     @pyaedt_function_handler()
-    def _get_context(
-        self,
-        expressions,
-        condition,
-        goal_weight,
-        goal_value,
-        setup_sweep_name=None,
-        domain="Sweep",
-        intrinsics=None,
-        report_category=None,
-        context=None,
-        subdesign_id=None,
-        polyline_points=0,
-        is_goal=False,
-    ):
-        did = 3
-        if domain != "Sweep":
-            did = 1
-        sweepdefinition = OrderedDict()
-        sweepdefinition["ReportType"] = report_category
-        if not setup_sweep_name:
-            setup_sweep_name = self._app.nominal_sweep
-        sweepdefinition["Solution"] = setup_sweep_name
-        ctxt = OrderedDict({})
-
-        if self._app.solution_type in ["TR", "AC", "DC"]:
-            ctxt["SimValueContext"] = [did, 0, 2, 0, False, False, -1, 1, 0, 1, 1, "", 0, 0]
-            setup_sweep_name = self._app.solution_type
-            sweepdefinition["Solution"] = setup_sweep_name
-
-        elif self._app.solution_type in ["HFSS3DLayout"]:
-            if context == "Differential Pairs":
-                ctxt["SimValueContext"] = [
-                    did,
-                    0,
-                    2,
-                    0,
-                    False,
-                    False,
-                    -1,
-                    1,
-                    0,
-                    1,
-                    1,
-                    "",
-                    0,
-                    0,
-                    "EnsDiffPairKey",
-                    False,
-                    "1",
-                    "IDIID",
-                    False,
-                    "1",
-                ]
-            else:
-                ctxt["SimValueContext"] = [did, 0, 2, 0, False, False, -1, 1, 0, 1, 1, "", 0, 0, "IDIID", False, "1"]
+    def _get_args(self):
+        """Retrieve arguments."""
+        props = self.props
+        arg = ["NAME:" + self.name]
+        _dict2arg(props, arg)
+        return arg
 
-        elif self._app.solution_type in ["NexximLNA", "NexximTransient"]:
-            ctxt["SimValueContext"] = [did, 0, 2, 0, False, False, -1, 1, 0, 1, 1, "", 0, 0]
-            if subdesign_id:
-                ctxt_temp = ["NUMLEVELS", False, "1", "SUBDESIGNID", False, str(subdesign_id)]
-                ctxt["SimValueContext"].extend(ctxt_temp)
-            if context == "Differential Pairs":
-                ctxt_temp = ["USE_DIFF_PAIRS", False, "1"]
-                ctxt["SimValueContext"].extend(ctxt_temp)
-        elif context == "Differential Pairs":
-            ctxt["SimValueContext"] = ["Diff:=", "Differential Pairs", "Domain:=", domain]
-        elif self._app.solution_type in ["Q3D Extractor", "2D Extractor"]:
-            if not context:
-                ctxt["Context"] = "Original"
-            else:
-                ctxt["Context"] = context
-        elif context:
-            ctxt["Context"] = context
-            if context in self._app.modeler.line_names:
-                ctxt["PointCount"] = polyline_points
-        else:
-            ctxt = OrderedDict({"Domain": domain})
-        sweepdefinition["SimValueContext"] = ctxt
-        sweepdefinition["Calculation"] = expressions
-        sweepdefinition["Name"] = expressions
-        sweepdefinition["Ranges"] = OrderedDict({})
-        if context and context in self._app.modeler.line_names and intrinsics and "Distance" not in intrinsics:
-            sweepdefinition["Ranges"]["Range"] = ("Var:=", "Distance", "Type:=", "a")
-        if not setup_sweep_name:
-            setup_sweep_name = self._app.nominal_sweep
-            if not setup_sweep_name:
-                self._app.logger.error("Sweep not Available.")
-                return False
-        elif setup_sweep_name not in self._app.existing_analysis_sweeps:
-            self._app.logger.error("Sweep not Available.")
-            return False
-        if intrinsics:
-            for v, k in intrinsics.items():
-                if not k:
-                    r = ["Var:=", v, "Type:=", "a"]
-                elif isinstance(k, tuple):
-                    r = ["Var:=", v, "Type:=", "rd"]
-                    r.append("Start:=")
-                    r.append(k[0])
-                    r.append("Stop:=")
-                    r.append(k[1])
-                    r.append("DiscreteValues:=")
-                    r.append("")
-                elif isinstance(k, (list, str)):
-                    r = ["Var:=", v, "Type:=", "d"]
-                    r.append("DiscreteValues:=")
-                    if isinstance(k, list):
-                        r.append(",".join(k))
-                    else:
-                        r.append(k)
-
-                if not sweepdefinition["Ranges"]:
-                    sweepdefinition["Ranges"]["Range"] = tuple(r)
-                elif isinstance(sweepdefinition["Ranges"]["Range"], list):
-                    sweepdefinition["Ranges"]["Range"].append(tuple(r))
-                else:
-                    sweepdefinition["Ranges"]["Range"] = [sweepdefinition["Ranges"]["Range"]]
-                    sweepdefinition["Ranges"]["Range"].append(tuple(r))
-        if is_goal:
-            sweepdefinition["Condition"] = condition
-            sweepdefinition["GoalValue"] = OrderedDict(
-                {"GoalValueType": "Independent", "Format": "Real/Imag", "bG": ["v:=", "[{};]".format(goal_value)]}
-            )
-            sweepdefinition["Weight"] = "[{};]".format(goal_weight)
-        return sweepdefinition
+    @property
+    def name(self):
+        """Name of the mesh operation.
 
-    @pyaedt_function_handler()
-    def update(self, update_dictionary=None):
-        """Update the setup based on stored properties.
+        Returns
+        -------
+        str
+           Name of the mesh operation.
 
-        Parameters
-        ----------
-        update_dictionary : dict, optional
-            Dictionary to use. The  default is ``None``.
+        """
+        return self._name
+
+    @name.setter
+    def name(self, meshop_name):
+        if meshop_name not in self._mesh._app.odesign.GetChildObject("Mesh").GetChildNames():
+            self._mesh._app.odesign.GetChildObject("Mesh").GetChildObject(self.name).SetPropValue("Name", meshop_name)
+            self._name = meshop_name
+        else:
+            self._mesh.logger.warning("Name %s already assigned in the design", meshop_name)
+
+    @pyaedt_function_handler()
+    def create(self):
+        """Create a mesh.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
-        References
-        ----------
-
-        >>> oModule.EditSetup
         """
-        if update_dictionary:
-            for el in update_dictionary:
-                self.props._setitem_without_update(el, update_dictionary[el])
-
-        arg = ["NAME:" + self.name]
-        _dict2arg(self.props, arg)
-
-        if self.soltype == "OptiParametric" and len(arg[8]) == 3:
-            arg[8] = ["NAME:Sweep Operations"]
-            for variation in self.props["Sweep Operations"].get("add", []):
-                arg[8].append("add:=")
-                arg[8].append(variation)
-
-        self.omodule.EditSetup(self.name, arg)
+        if self.type == "SurfApproxBased":
+            self._mesh.omeshmodule.AssignTrueSurfOp(self._get_args())
+        elif self.type == "DefeatureBased":
+            self._mesh.omeshmodule.AssignModelResolutionOp(self._get_args())
+        elif self.type == "SurfaceRepPriority":
+            self._mesh.omeshmodule.AssignSurfPriorityForTauOp(self._get_args())
+        elif self.type == "LengthBased":
+            self._mesh.omeshmodule.AssignLengthOp(self._get_args())
+        elif self.type == "SkinDepthBased":
+            self._mesh.omeshmodule.AssignSkinDepthOp(self._get_args())
+        elif self.type == "Curvilinear":
+            self._mesh.omeshmodule.AssignApplyCurvlinearElementsOp(self._get_args())
+        elif self.type == "RotationalLayerMesh":
+            self._mesh.omeshmodule.AssignRotationalLayerOp(self._get_args())
+        elif self.type == "EdgeCutLayerMesh":
+            self._mesh.omeshmodule.AssignEdgeCutLayerOp(self._get_args())
+        elif self.type == "DensityControlBased":
+            self._mesh.omeshmodule.AssignDensityControlOp(self._get_args())
+        elif self.type == "Icepak":
+            self._mesh.omeshmodule.AssignMeshOperation(self._get_args())
+        elif self.type == "CurvatureExtraction":
+            self._mesh.omeshmodule.AssignCurvatureExtractionOp(self._get_args())
+        elif self.type == "CylindricalGap":
+            self._mesh.omeshmodule.AssignCylindricalGapOp(self._get_args())
+        else:
+            return False
         return True
 
     @pyaedt_function_handler()
-    def create(self):
-        """Create a setup.
-
+    def update(self, key_name=None, value=None):
+        """Update the mesh.
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
-
         References
         ----------
-
-        >>> oModule.InsertSetup
+        >>> oModule.EditTrueSurfOp
+        >>> oModule.EditModelResolutionOp
+        >>> oModule.EditSurfPriorityForTauOp
+        >>> oModule.EditLengthOp
+        >>> oModule.EditApplyCurvlinearElementsOp
+        >>> oModule.EditRotationalLayerOp
+        >>> oModule.EditDensityControlOp
+        >>> oModule.EditMeshOperation
+        >>> oModule.EditSBRCurvatureExtractionOp
         """
-        arg = ["NAME:" + self.name]
-        _dict2arg(self.props, arg)
-        self.omodule.InsertSetup(self.soltype, arg)
+        if key_name and settings.aedt_version > "2022.2":
+            mesh_obj = self._mesh._app.odesign.GetChildObject("Mesh").GetChildObject(self.name)
+            if key_name in mesh_props.keys():
+                if key_name == "SurfaceRepPriority":
+                    value = "Normal" if value == 0 else "High"
+                key_name = mesh_props[key_name]
+            mesh_obj.SetPropValue(key_name, value)
+            return True
+
+        if self.type == "SurfApproxBased":
+            self._mesh.omeshmodule.EditTrueSurfOp(self.name, self._get_args())
+        elif self.type == "DefeatureBased":
+            self._mesh.omeshmodule.EditModelResolutionOp(self.name, self._get_args())
+        elif self.type == "SurfaceRepPriority":
+            self._mesh.omeshmodule.EditSurfPriorityForTauOp(self.name, self._get_args())
+        elif self.type == "LengthBased":
+            self._mesh.omeshmodule.EditLengthOp(self.name, self._get_args())
+        elif self.type == "SkinDepthBased":
+            self._mesh.omeshmodule.EditSkinDepthOp(self.name, self._get_args())
+        elif self.type == "Curvilinear":
+            self._mesh.omeshmodule.EditApplyCurvlinearElementsOp(self.name, self._get_args())
+        elif self.type == "RotationalLayerMesh":
+            self._mesh.omeshmodule.EditRotationalLayerOp(self.name, self._get_args())
+        elif self.type == "DensityControlBased":
+            self._mesh.omeshmodule.EditDensityControlOp(self.name, self._get_args())
+        elif self.type == "Icepak":
+            self._mesh.omeshmodule.EditMeshOperation(self.name, self._get_args())
+        elif self.type == "CurvatureExtraction":
+            self._mesh.omeshmodule.EditSBRCurvatureExtractionOp(self.name, self._get_args())
+        elif self.type == "InitialMeshSettings":
+            self._mesh.omeshmodule.InitialMeshSettings(self._get_args())
+        elif self.type == "CylindricalGap":
+            self._mesh.omeshmodule.EditCylindricalGapOp(self.name, self._get_args())
+        else:
+            return False
         return True
 
     @pyaedt_function_handler()
-    def _add_calculation(
-        self,
-        calculation,
-        ranges=None,
-        variables=None,
-        solution=None,
-        context=None,
-        subdesign_id=None,
-        polyline_points=1001,
-        report_type=None,
-        is_goal=False,
-        condition="<=",
-        goal_value=1,
-        goal_weight=1,
-    ):
-        self.auto_update = False
-        if not solution:
-            solution = self._app.nominal_sweep
-        setupname = solution.split(" ")[0]
-        if setupname not in self.props["Sim. Setups"]:
-            self.props["Sim. Setups"].append(setupname)
-        domain = "Time"
-        if (ranges and ("Freq" in ranges or "Phase" in ranges or "Theta" in ranges)) or self._app.solution_type in [
-            "Magnetostatic",
-            "Electrostatic",
-            "EddyCurrent",
-            "DCConduction",
-            "Eigenmode",
-        ]:
-            domain = "Sweep"
-        if not report_type:
-            report_type = self._app.design_solutions.report_type
-            if context and context in self._app.modeler.sheet_names:
-                report_type = "Fields"
-            elif self._app.solution_type in ["Q3D Extractor", "2D Extractor"]:
-                report_type = "Matrix"
-            elif context:
-                try:
-                    for f in self._app.field_setups:
-                        if context == f.name:
-                            report_type = "Far Fields"
-                except:
-                    pass
-        sweepdefinition = self._get_context(
-            calculation,
-            condition,
-            goal_weight,
-            goal_value,
-            solution,
-            domain,
-            ranges,
-            report_type,
-            context,
-            subdesign_id,
-            polyline_points,
-            is_goal,
-        )
-        dx_variables = {}
-        if variables:
-            for el in list(variables):
+    def update_assignment(self):
+        """Update the boundary assignment.
+
+        Returns
+        -------
+        bool
+            ``True`` when successful, ``False`` when failed.
+
+        """
+
+        out = []
+
+        if "Faces" in self.props:
+            faces = self.props["Faces"]
+            faces_out = []
+            if type(faces) is not list:
+                faces = [faces]
+            for f in faces:
+                if type(f) is EdgePrimitive or type(f) is FacePrimitive or type(f) is VertexPrimitive:
+                    faces_out.append(f.id)
+                else:
+                    faces_out.append(f)
+            out += ["Faces:=", faces_out]
+
+        if "Objects" in self.props:
+            pr = []
+            for el in self.props["Objects"]:
                 try:
-                    dx_variables[el] = self._app[el]
-                except:
+                    pr.append(self._app.modeler[el].name)
+                except (KeyError, AttributeError):
                     pass
-        for v in list(dx_variables.keys()):
-            self._activate_variable(v)
-        if self.soltype in ["OptiDesignExplorer", "OptiDXDOE"] and is_goal:
-            optigoalname = "CostFunctionGoals"
-        else:
-            optigoalname = "Goals"
-        if "Goal" in self.props[optigoalname]:
-            if type(self.props[optigoalname]["Goal"]) is not list:
-                self.props[optigoalname]["Goal"] = [self.props[optigoalname]["Goal"], sweepdefinition]
-            else:
-                self.props[optigoalname]["Goal"].append(sweepdefinition)
-        else:
-            self.props[optigoalname] = OrderedDict({})
-            self.props[optigoalname]["Goal"] = sweepdefinition
-        self.auto_update = True
-        return self.update()
+            out += ["Objects:=", pr]
+
+        if len(out) == 1:
+            return False
+
+        self._app.omeshmodule.ReassignOp(self.name, out)
+
+        return True
 
     @pyaedt_function_handler()
-    def _add_goal(
-        self,
-        optigoalname,
-        reporttype,
-        solution=None,
-        domain="Sweep",
-        calculation="",
-        calculation_type="discrete",
-        calc_val1="",
-        calc_val2="",
-        condition="==",
-        goal_value=1,
-        goal_weight=1,
-        goal_name=None,
-    ):
-        """Add an optimization goal to the setup.
+    def _change_property(self, name, arg):
+        """Update properties of the mesh operation.
 
         Parameters
         ----------
-        optigoalname : str
-            Name of the optimization goal.
-        reporttype : str, optional
-            Type of the report.
-        solution : str, optional
-            Type of the solution. The default is ``None``.
-        domain : str, optional
-            Type of the domain. The default is ``"Sweep"''.
-        calculation : str, optional
-            Name of the calculation. The default is ``""``.
-        calculation_type : str, optional
-            Type of the calculation. The default is ``"discrete"``.
-        calc_val1 : str, optional
-            First value for the calculation. The default is ``""``.
-        calc_val2 : str, optional
-            Second value for the calculation. The default is ``""``.
-        condition : str, optional
-            The condition for the calculation. The default is ``"=="``.
-        goal_value : optional
-            Value for the optimization goal. The default is ``1``.
-        goal_weight : optional
-            Weight for the optimization goal. The default is ``1``.
-        goal_name : str, optional
-            Name of the goal. The default is ``None``.
+        name : str
+            Name of the mesh operation.
+        arg : list
+            List of the properties to update. For example,
+            ``["NAME:ChangedProps", ["NAME:Max Length", "Value:=", "2mm"]]``.
 
         Returns
         -------
+        list
+            List of changed properties of the mesh operation.
 
         """
-        self.auto_update = False
-        sweepdefinition = OrderedDict()
-        sweepdefinition["ReportType"] = reporttype
-        if not solution:
-            solution = self._app.nominal_sweep
-        setupname = solution.split(" ")[0]
-        if setupname not in self.props["Sim. Setups"]:
-            self.props["Sim. Setups"].append(setupname)
-        sweepdefinition["Solution"] = solution
-        sweepdefinition["SimValueContext"] = OrderedDict({"Domain": domain})
-        sweepdefinition["Calculation"] = calculation
-        if goal_name:
-            sweepdefinition["Name"] = goal_name
-        else:
-            sweepdefinition["Name"] = generate_unique_name(calculation)
-        if domain == "Sweep":
-            var = "Freq"
-        else:
-            var = "Time"
-        if calculation_type == "discrete":
-            if type(calc_val1) is list:
-                dr = ",".join(calc_val1)
-            else:
-                dr = calc_val1
-            sweepdefinition["Ranges"] = OrderedDict({"Range": ["Var:=", var, "Type:=", "d", "DiscreteValues:=", dr]})
-        elif calculation_type == "all":
-            sweepdefinition["Ranges"] = OrderedDict(
-                {
-                    "Range": [
-                        "Var:=",
-                        var,
-                        "Type:=",
-                        "a",
-                    ]
-                }
-            )
-        else:
-            sweepdefinition["Ranges"] = OrderedDict(
-                {
-                    "Range": [
-                        "Var:=",
-                        var,
-                        "Type:=",
-                        calculation_type,
-                        "Start:=",
-                        calc_val1,
-                        "Stop:=",
-                        calc_val2,
-                        "DiscreteValues:=",
-                        "",
-                    ]
-                }
-            )
-        sweepdefinition["Condition"] = condition
-        sweepdefinition["GoalValue"] = OrderedDict(
-            {"GoalValueType": "Independent", "Format": "Real/Imag", "bG": ["v:=", "[{};]".format(goal_value)]}
-        )
-        sweepdefinition["Weight"] = "[{};]".format(goal_weight)
-        if "Goal" in self.props[optigoalname]:
-            if type(self.props[optigoalname]["Goal"]) is not list:
-                self.props[optigoalname]["Goal"] = [self.props[optigoalname]["Goal"], sweepdefinition]
-            else:
-                self.props[optigoalname]["Goal"].append(sweepdefinition)
-        else:
-            self.props[optigoalname] = OrderedDict({})
-            self.props[optigoalname]["Goal"] = sweepdefinition
-        self.auto_update = True
-        return self.update()
-
-    @pyaedt_function_handler()
-    def _activate_variable(self, variable_name):
-        if self.soltype in ["OptiDesignExplorer", "OptiDXDOE", "OptiOptimization", "OptiSLang"]:
-            self._app.activate_variable_optimization(variable_name)
-        elif self.soltype == "OptiParametric":
-            self._app.activate_variable_tuning(variable_name)
-        elif self.soltype == "OptiSensitivity":
-            self._app.activate_variable_sensitivity(variable_name)
-        elif self.soltype == "OptiStatistical":
-            self._app.activate_variable_statistical(variable_name)
+        arguments = ["NAME:AllTabs", ["NAME:MeshSetupTab", ["NAME:PropServers", "MeshSetup:{}".format(name)], arg]]
+        _retry_ntimes(5, self._mesh._app.odesign.ChangeProperty, arguments)
 
     @pyaedt_function_handler()
-    def analyze(
-        self,
-        num_cores=1,
-        num_tasks=1,
-        num_gpu=0,
-        acf_file=None,
-        use_auto_settings=True,
-        solve_in_batch=False,
-        machine="localhost",
-        run_in_thread=False,
-        revert_to_initial_mesh=False,
-    ):
-        """Solve the active design.
-
-        Parameters
-        ----------
-        num_cores : int, optional
-            Number of simulation cores. Default is ``1``.
-        num_tasks : int, optional
-            Number of simulation tasks. Default is ``1``.
-        num_gpu : int, optional
-            Number of simulation graphic processing units to use. Default is ``0``.
-        acf_file : str, optional
-            Full path to the custom ACF file.
-        use_auto_settings : bool, optional
-            Set ``True`` to use automatic settings for HPC. The option is only considered for setups
-            that support automatic settings.
-        solve_in_batch : bool, optional
-            Whether to solve the project in batch or not.
-            If ``True`` the project will be saved, closed, solved and repened.
-        machine : str, optional
-            Name of the machine if remote.  The default is ``"localhost"``.
-        run_in_thread : bool, optional
-            Whether to submit the batch command as a thread. The default is
-            ``False``.
-        revert_to_initial_mesh : bool, optional
-            Whether to revert to initial mesh before solving or not. Default is ``False``.
+    def delete(self):
+        """Delete the mesh.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oDesign.Analyze
+        >>> oModule.DeleteOp
         """
-        self._app.analyze(
-            setup_name=self.name,
-            num_cores=num_cores,
-            num_tasks=num_tasks,
-            num_gpu=num_gpu,
-            acf_file=acf_file,
-            use_auto_settings=use_auto_settings,
-            solve_in_batch=solve_in_batch,
-            machine=machine,
-            run_in_thread=run_in_thread,
-            revert_to_initial_mesh=revert_to_initial_mesh,
-        )
+        self._mesh.omeshmodule.DeleteOp([self.name])
+        for el in self._mesh.meshoperations[:]:
+            if el.name == self.name:
+                self._mesh.meshoperations.remove(el)
+        return True
 
 
-class SetupOpti(CommonOptimetrics, object):
-    """Sets up an optimization in Opimetrics."""
+class Mesh(object):
+    """Manages AEDT mesh functions for 2D and 3D solvers (HFSS, Maxwell, and Q3D).
 
-    def __init__(self, app, name, dictinputs=None, optim_type="OptiDesignExplorer"):
-        CommonOptimetrics.__init__(self, app, name, dictinputs=dictinputs, optimtype=optim_type)
+    Parameters
+    ----------
+    app : :class:`pyaedt.application.Analysis3D.FieldAnalysis3D`
+
+    Examples
+    --------
+    Basic usage demonstrated with an HFSS design:
+
+    >>> from pyaedt import Hfss
+    >>> aedtapp = Hfss()
+    >>> cylinder = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+    >>> model_resolution = aedtapp.mesh.assign_model_resolution(cylinder, 1e-4, "ModelRes1")
+    """
+
+    def __init__(self, app):
+        self._app = app
+        self._odesign = self._app.odesign
+        self.modeler = self._app.modeler
+        self.logger = self._app.logger
+        self.id = 0
+        self._meshoperations = None
+        self._globalmesh = None
 
     @pyaedt_function_handler()
-    def delete(self):
-        """Delete a defined Optimetrics Setup.
+    def __getitem__(self, part_id):
+        """Get the object ``Mesh`` for a given mesh operation name.
 
         Parameters
         ----------
-        setup_name : str
-            Name of optimetrics setup to delete.
+        part_id : str
+            Mesh operation name.
 
         Returns
         -------
-        bool
-            `True` if setup is deleted. `False` if it failed.
+        :class:`pyaedt.mesh.meshoperations`
+            Returns None if the part ID or the object name is not found.
+
+        Examples
+        --------
+        Basic usage demonstrated with an HFSS design:
+
+        >>> from pyaedt import Hfss
+        >>> aedtapp = Hfss()
+        >>> cylinder = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> mr1 = aedtapp.mesh.assign_model_resolution(cylinder, 1e-4, "ModelRes1")
+        >>> mr2 = aedtapp.mesh[mr1.name]
         """
 
-        self.omodule.DeleteSetups([self.name])
-        self._app.optimizations.setups.remove(self)
-        return True
+        if part_id in self.meshoperation_names:
+            mesh_op_selected = [mesh_op for mesh_op in self.meshoperations if mesh_op.name == part_id]
+            return mesh_op_selected[0]
+        return None
+
+    @property
+    def meshoperations(self):
+        """Return the available mesh operations.
+
+        Returns
+        -------
+        List
+            List of :class:`pyaedt.modules.Mesh.MeshOperation`
+                        List of mesh operation object.
+
+        Examples
+        --------
+        Basic usage demonstrated with an HFSS design:
+
+        >>> from pyaedt import Hfss
+        >>> aedtapp = Hfss()
+        >>> o = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> mr1 = aedtapp.mesh.assign_model_resolution(o, 1e-4, "ModelRes1")
+        >>> mesh_operations_list = aedtapp.mesh.meshoperations
+        """
+        if self._meshoperations is None:
+            self._meshoperations = self._get_design_mesh_operations()
+        return self._meshoperations
 
     @pyaedt_function_handler()
-    def add_calculation(
-        self,
-        calculation,
-        ranges=None,
-        variables=None,
-        solution=None,
-        context=None,
-        subdesign_id=None,
-        polyline_points=1001,
-        report_type=None,
-    ):
-        """Add a calculation to the setup.
+    def _refresh_mesh_operations(self):
+        """Refresh all mesh operations."""
 
-        Parameters
-        ----------
-        calculation : str, optional
-            Name of the calculation.
-        ranges : dict, optional
-            Dictionary of ranges with respective values.
-            Values can be: `None` for all values, a List of Discrete Values, a tuple of start and stop range.
-            It includes intrinsics like "Freq", "Time", "Theta", "Distance".
-            The default is ``None``, to be used e.g. in "Eigenmode" design type.
-        solution : str, optional
-            Type of the solution. The default is ``None``, in which case the default
-            solution is used.
-        context : str, optional
-            Calculation contexts. It can be a sphere, a matrix or a polyline.
-        subdesign_id : int, optional
-            Subdesign id for Circuit and HFSS 3D Layout objects.
-        polyline_points : int, optional
-            Number of points for Polyline context.
-        report_type : str, optional
-            Override the auto computation of Calculation Type.
+        self._meshoperations = self._get_design_mesh_operations()
+        return len(self.meshoperations)
+
+    @property
+    def meshoperation_names(self):
+        """Return the available mesh operation names.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
+        List
+            List of mesh operation names.
+
+        Examples
+        --------
+        Basic usage demonstrated with an HFSS design:
+
+        >>> from pyaedt import Hfss
+        >>> aedtapp = Hfss()
+        >>> o = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> mr1 = aedtapp.mesh.assign_model_resolution(o, 1e-4, "ModelRes1")
+        >>> mr2 = aedtapp.mesh.assign_model_resolution(o, 1e-2, "ModelRes2")
+        >>> mesh_operations_names = aedtapp.mesh.meshoperation_names
+        """
+        if self._app._is_object_oriented_enabled():
+            return list(self._app.odesign.GetChildObject("Mesh").GetChildNames())
+        return []
+
+    @property
+    def initial_mesh_settings(self):
+        """Return the global mesh object.
+
+        Returns
+        -------
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
 
         References
         ----------
 
-        >>> oModule.EditSetup
+        >>> oModule.InitialMeshSettings
         """
-        return self._add_calculation(
-            calculation,
-            ranges,
-            variables,
-            solution,
-            context,
-            subdesign_id,
-            polyline_points,
-            report_type,
-            is_goal=False,
-        )
+        if not self._globalmesh:
+            self._globalmesh = self._get_design_global_mesh()
+        return self._globalmesh
+
+    @property
+    def omeshmodule(self):
+        """Aedt Mesh Module.
+
+        References
+        ----------
+
+        >>> oDesign.GetModule("MeshSetup")
+        """
+        return self._app.omeshmodule
 
     @pyaedt_function_handler()
-    def add_goal(
-        self,
-        calculation,
-        ranges,
-        variables=None,
-        solution=None,
-        context=None,
-        subdesign_id=None,
-        polyline_points=1001,
-        report_type=None,
-        condition="<=",
-        goal_value=1,
-        goal_weight=1,
-    ):
-        """Add a goal to the setup.
+    def _get_design_global_mesh(self):
+        """ """
+        props = None
+        try:
+            props = self._app.design_properties["MeshSetup"]["MeshSettings"]
+        except:
+            temp_name = generate_unique_name("temp_prj")
+            temp_proj = os.path.join(self._app.working_directory, temp_name + ".aedt")
+            oproject_target = self._app.odesktop.NewProject(temp_name)
+            if self._app.solution_type == "Modal":
+                sol = "HFSS Modal Network"
+            elif self._app.solution_type == "Terminal":
+                sol = "HFSS Terminal Network"
+            else:
+                sol = self._app.solution_type
+            oproject_target.InsertDesign(self._app.design_type, temp_name, sol, "")
+            oproject_target.SaveAs(temp_proj, True)
+            self._app.odesktop.CloseProject(temp_name)
+            _project_dictionary = load_entire_aedt_file(temp_proj)
+            try:
+                props = _project_dictionary["AnsoftProject"][model_names[self._app.design_type]]["MeshSetup"][
+                    "MeshSettings"
+                ]
+            except:
+                pass
+            if os.path.exists(temp_proj):
+                os.remove(temp_proj)
+            if os.path.exists(temp_proj + "results"):
+                shutil.rmtree(temp_proj + "results", True)
+        if props:
+            bound = MeshOperation(self, "MeshSettings", props, "InitialMeshSettings")
+            return bound
+        return OrderedDict()
+
+    @pyaedt_function_handler()
+    def _get_design_mesh_operations(self):
+        """ """
+        meshops = []
+        try:
+            for ds in self.meshoperation_names:
+                props = {}
+                design_mesh = self._app.odesign.GetChildObject("Mesh")
+                for i in design_mesh.GetChildObject(ds).GetPropNames():
+                    props[i] = design_mesh.GetChildObject(ds).GetPropValue(i)
+                if self._app._desktop.GetVersion()[0:6] < "2023.1":
+                    if self._app.design_properties:
+                        props_parsed = self._app.design_properties["MeshSetup"]["MeshOperations"][ds]
+                        if "Edges" in props_parsed.keys():
+                            props["Edges"] = props_parsed["Edges"]
+                        if "Faces" in props_parsed.keys():
+                            props["Faces"] = props_parsed["Faces"]
+                        if "Objects" in props_parsed.keys():
+                            props["Objects"] = []
+                            for comp in props_parsed["Objects"]:
+                                props["Objects"].append(comp)
+                else:
+                    props["Objects"] = []
+                    props["Faces"] = []
+                    props["Edges"] = []
+                    assigned_id = self.omeshmodule.GetMeshOpAssignment(ds)
+                    for comp_id in assigned_id:
+                        if int(comp_id) in self._app.modeler.objects.keys():
+                            props["Objects"].append(self._app.modeler.oeditor.GetObjectNameByID(comp_id))
+                            continue
+                        for comp in self._app.modeler.object_list:
+                            faces = comp.faces
+                            face_ids = [face.id for face in faces]
+                            if int(comp_id) in face_ids:
+                                props["Faces"].append(int(comp_id))
+                                continue
+                            edges = comp.edges
+                            edge_ids = [edge.id for edge in edges]
+                            if int(comp_id) in edge_ids:
+                                props["Edges"].append(int(comp_id))
+                                continue
+
+                meshops.append(MeshOperation(self, ds, props, props["Type"]))
+        except:
+            pass
+        return meshops
+
+    @pyaedt_function_handler()
+    def assign_surface_mesh(self, names, level, meshop_name=None):
+        """Assign a surface mesh level to one or more objects.
 
         Parameters
         ----------
-        calculation : str, optional
-            Name of the calculation.
-        ranges : dict
-            Dictionary of ranges with respective values.
-            Values can be: `None` for all values, a List of Discrete Values, a tuple of start and stop range.
-            It includes intrinsics like "Freq", "Time", "Theta", "Distance".
-        variables : list, optional
-            List of variables to include in the optimization.
-        condition : string, optional
-            The default is ``"<="``.
-        goal_value : optional
-            Value for the goal. The default is ``1``.
-        goal_weight : optional
-            Value for the goal weight. The default is ``1``.
-        solution : str, optional
-            Type of the solution. The default is ``None``, in which case the default
-            solution is used.
-        context : str, optional
-            Calculation contexts. It can be a sphere, a matrix or a polyline.
-        subdesign_id : int, optional
-            Subdesign id for Circuit and HFSS 3D Layout objects.
-        polyline_points : int, optional
-            Number of points for Polyline context.
-        report_type : str, optional
-            Override the auto computation of Calculation Type.
+        names : list
+            One or more names of the objects.
+        level : int
+            Level of the surface mesh. Options are ``1`` through ``10``
+        meshop_name : str, optional
+            Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
 
         References
         ----------
 
-        >>> oModule.EditSetup
+        >>> oModule.AssignTrueSurfOp
+
+        Examples
+        --------
+        Basic usage demonstrated with an HFSS design:
+
+        >>> from pyaedt import Hfss
+        >>> aedtapp = Hfss()
+        >>> o = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> surface = aedtapp.mesh.assign_surface_mesh(o.id, 3, "Surface")
         """
+        names = self.modeler.convert_to_selections(names, True)
+        if meshop_name:
+            for m in self.meshoperations:
+                if meshop_name == m.name:
+                    meshop_name = generate_unique_name(meshop_name)
+        else:
+            meshop_name = generate_unique_name("SurfApprox")
+        self.logger.info("Assigning Mesh Level " + str(level) + " to " + str(names))
+        names = self._app.modeler.convert_to_selections(names, True)
 
-        return self._add_calculation(
-            calculation,
-            ranges,
-            variables,
-            solution,
-            context,
-            subdesign_id,
-            polyline_points,
-            report_type,
-            True,
-            condition,
-            goal_value,
-            goal_weight,
+        if isinstance(names[0], int):
+            seltype = "Faces"
+        else:
+            seltype = "Objects"
+        props = OrderedDict(
+            {
+                "Type": "SurfApproxBased",
+                "CurvedSurfaceApproxChoice": "UseSlider",
+                seltype: names,
+                "SliderMeshSettings": level,
+            }
         )
+        mop = MeshOperation(self, meshop_name, props, "SurfApproxBased")
+        mop.create()
+        self.meshoperations.append(mop)
+        return mop
 
     @pyaedt_function_handler()
-    def add_variation(
-        self,
-        variable_name,
-        min_value,
-        max_value,
-        starting_point=None,
-        min_step=None,
-        max_step=None,
-        use_manufacturable=False,
-    ):
-        """Add a new variable as input for the optimization and defines its ranges.
+    def assign_surface_mesh_manual(self, names, surf_dev=None, normal_dev=None, aspect_ratio=None, meshop_name=None):
+        """Assign a surface mesh to a list of faces.
 
         Parameters
         ----------
-        variable_name : str
-            Name of the variable.
-        min_value : float
-            Minimum Optimization Value for variable_name.
-        max_value : float
-            Maximum Optimization Value for variable_name.
-        starting_point : float, optional
-            Starting point for optimization. If None, default will be used.
-        min_step : float
-            Minimum Step Size for optimization. If None, 1/100 of the range will be used.
-
-        max_step : float
-            Maximum Step Size for optimization. If None, 1/10 of the range will be used.
-        use_manufacturable : bool
-            Either if to use or not the Manufacturable values. Default is False.
-
+        names : list or str or :class:`pyaedt.modeler.elements3d.FacePrimitive`
+            List of faces to apply the surface mesh to.
+        surf_dev : float or str, optional
+            Surface deviation. The default is ``None``. Allowed values are float, number with units or `"inf"`.
+        normal_dev : float or str, optional
+            Normal deviation. The default is ``None``.
+        aspect_ratio : int, optional
+            Aspect ratio. The default is ``None``.
+        meshop_name : str, optional
+            Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
-        bool
-        """
-        if variable_name not in self._app.variable_manager.variables:
-            self._app.logger.error("Variable {} does not exists.".format(variable_name))
-            return False
-        self.auto_update = False
-        self._activate_variable(variable_name)
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
 
-        if not min_step:
-            min_step = (max_value - min_value) / 100
-        min_step = self._app.value_with_units(min_step, self._app.variable_manager[variable_name].units)
-
-        if not max_step:
-            max_step = (max_value - min_value) / 10
-        max_step = self._app.value_with_units(max_step, self._app.variable_manager[variable_name].units)
-        min_value = self._app.value_with_units(min_value, self._app.variable_manager[variable_name].units)
-        max_value = self._app.value_with_units(max_value, self._app.variable_manager[variable_name].units)
-        arg = [
-            "i:=",
-            True,
-            "int:=",
-            False,
-            "Min:=",
-            min_value,
-            "Max:=",
-            max_value,
-            "MinStep:=",
-            min_step,
-            "MaxStep:=",
-            max_step,
-            "MinFocus:=",
-            min_value,
-            "MaxFocus:=",
-            max_value,
-            "UseManufacturableValues:=",
-            use_manufacturable,
-        ]
-        if not self.props.get("Variables", None):
-            self.props["Variables"] = OrderedDict({})
-        self.props["Variables"][variable_name] = arg
-        if not self.props.get("StartingPoint", None):
-            self.props["StartingPoint"] = OrderedDict({})
-        if not starting_point:
-            starting_point = self._app[variable_name]
+        References
+        ----------
 
-        self.props["StartingPoint"][variable_name] = self._app.value_with_units(
-            starting_point, self._app.variable_manager[variable_name].units
-        )
-        self.auto_update = True
-        self.update()
-        return True
+        >>> oModule.AssignTrueSurfOp
 
+        Examples
+        --------
+        Basic usage demonstrated with an HFSS design:
+
+        >>> from pyaedt import Hfss
+        >>> aedtapp = Hfss()
+        >>> o = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> surface = self.aedtapp.mesh.assign_surface_mesh_manual(o.id, 1e-6, aspect_ratio=3,
+        ... meshop_name="Surface_Manual")
+        """
+        names = self.modeler.convert_to_selections(names, True)
+        if meshop_name:
+            for m in self.meshoperations:
+                if meshop_name == m.name:
+                    meshop_name = generate_unique_name(meshop_name)
+        else:
+            meshop_name = generate_unique_name("ModelResolution")
 
-class SetupParam(CommonOptimetrics, object):
-    """Sets up a parametric analysis in Optimetrics."""
+        surf_dev_enable = 2
+        normal_dev_enable = 2
+        aspect_ratio_enable = 2
+
+        if not surf_dev:
+            surf_dev_enable = 0
+            surf_dev = "0.0001mm"
+        elif surf_dev == "inf":
+            surf_dev_enable = 1
+        if not normal_dev:
+            normal_dev_enable = 1
+            normal_dev = "1"
+
+        if not aspect_ratio:
+            aspect_ratio_enable = 1
+            aspect_ratio = "10"
+
+        props = OrderedDict(
+            {
+                "Type": "SurfApproxBased",
+                "Objects": names,
+                "CurvedSurfaceApproxChoice": "ManualSettings",
+                "SurfDevChoice": surf_dev_enable,
+                "SurfDev": surf_dev,
+                "NormalDevChoice": normal_dev_enable,
+                "NormalDev": normal_dev,
+                "AspectRatioChoice": aspect_ratio_enable,
+                "AspectRatio": aspect_ratio,
+            }
+        )
 
-    def __init__(self, p_app, name, dictinputs=None, optim_type="OptiParametric"):
-        CommonOptimetrics.__init__(self, p_app, name, dictinputs=dictinputs, optimtype=optim_type)
-        pass
+        mop = MeshOperation(self, meshop_name, props, "SurfApproxBased")
+        mop.create()
+        self.meshoperations.append(mop)
+        return mop
 
     @pyaedt_function_handler()
-    def delete(self):
-        """Delete a defined Optimetrics Setup.
+    def assign_model_resolution(self, names, defeature_length=None, meshop_name=None):
+        """Assign the model resolution.
 
         Parameters
         ----------
-        setup_name : str
-            Name of optimetrics setup to delete.
+        names : list
+            List of objects to defeature.
+        defeature_length : float, optional
+            Defeaturing length in millimeters. The default is ``None``, in which case
+            automatic defeaturing is used.
+        meshop_name : str, optional
+            Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
-        bool
-            ``True`` if setup is deleted. ``False`` if it failed.
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
+
+        References
+        ----------
+
+        >>> oModule.AssignModelResolutionOp
+
+        Examples
+        --------
+        Basic usage demonstrated with an HFSS design:
+
+        >>> from pyaedt import Hfss
+        >>> aedtapp = Hfss()
+        >>> o = aedtapp.modeler.create_cylinder(0, [0, 0, 0], 3, 20, 0)
+        >>> surface = aedtapp.mesh.assign_model_resolution(o, 1e-4, "ModelRes1")
         """
+        names = self.modeler.convert_to_selections(names, True)
+        if meshop_name:
+            for m in self.meshoperations:
+                if meshop_name == m.name:
+                    meshop_name = generate_unique_name(meshop_name)
+        else:
+            meshop_name = generate_unique_name("ModelResolution")
+        for name in names:
+            if isinstance(name, int):
+                self.logger.error("Mesh Operation Applies to Objects only")
+                return False
+        if defeature_length is None:
+            props = OrderedDict({"Objects": names, "UseAutoLength": True})
+        else:
+            props = OrderedDict(
+                {
+                    "Type": "DefeatureBased",
+                    "Objects": names,
+                    "UseAutoLength": False,
+                    "DefeatureLength": str(defeature_length) + "mm",
+                }
+            )
 
-        self.omodule.DeleteSetups([self.name])
-        self._app.parametrics.setups.remove(self)
-        return True
+        mop = MeshOperation(self, meshop_name, props, "DefeatureBased")
+        mop.create()
+        self.meshoperations.append(mop)
+        return mop
 
     @pyaedt_function_handler()
-    def add_variation(self, sweep_var, start_point, end_point=None, step=100, unit=None, variation_type="LinearCount"):
-        """Add a variation to an existing parametric setup.
+    def assign_initial_mesh_from_slider(
+        self,
+        level=5,
+        method="Auto",
+        usedynamicsurface=True,
+        useflexmesh=False,
+        applycurvilinear=False,
+        usefallback=True,
+        usephi=True,
+        automodelresolution=True,
+        modelresolutionlength="0.0001mm",
+    ):
+        """Assign a surface mesh level to an object.
 
         Parameters
         ----------
-        sweep_var : str
-            Name of the variable.
-        start_point : float or int
-            Variation Start Point.
-        end_point : float or int, optional
-            Variation End Point. This parameter is optional if a Single Value is defined.
-        step : float or int, optional
-            Variation Step or Count depending on variation_type. Default is `100`.
-        unit : str, optional
-            Variation units. Default is `None`.
-        variation_type : float or int
-            Variation Type. Admitted values are `"LinearCount"`, `"LinearStep"`, `"LogScale"`, `"SingleValue"`.
+        level : int, optional
+            Level of the surface mesh. Options are ``1`` through ``10``. The default is ``5.``
+        method : str, optional
+            Meshing method. Options are ``"Auto"``, ``"AnsoftTAU"``, and ``"AnsoftClassic"``
+            The default is ``"Auto"``.
+        usedynamicsurface : bool, optional
+            Whether to use a dynamic surface. The default is ``True``.
+        useflexmesh : bool, optional
+            Whether to use a flexible mesh. The default is ``False``.
+        applycurvilinear : bool, optional
+            Whether to apply curvilinear elements. The default is ``False``.
+        usefallback : bool, optional
+            Whether to retain as a fallback. The default is ``True``.
+        usephi : bool, optional
+            Whether to use the Phi mesher for layered geometry.
+            The default is ``True``.
+        automodelresolution : bool, optional
+            Whether to automatically calculate the resolution length
+            based on each object's effective thickness. The default is ``True``.
+        modelresolutionlength : float, optional
+             Resolution thickness with units if ``automodelresolution=False``.
+             The default ``"0.0001mm"``.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oModule.EditSetup
+        >>> oModule.InitialMeshSettings
         """
-        if sweep_var not in self._app.variable_manager.variables:
-            self._app.logger.error("Variable {} does not exists.".format(sweep_var))
-            return False
-        sweep_range = ""
-        if not unit:
-            unit = self._app.variable_manager[sweep_var].units
-        start_point = self._app.value_with_units(start_point, unit)
-        end_point = self._app.value_with_units(end_point, unit)
-        if variation_type == "LinearCount":
-            sweep_range = "LINC {} {} {}".format(start_point, end_point, step)
-        elif variation_type == "LinearStep":
-            sweep_range = "LIN {} {} {}".format(start_point, end_point, self._app.value_with_units(step, unit))
-        elif variation_type == "LogScale":
-            sweep_range = "DEC {} {} {}".format(start_point, end_point, self._app.value_with_units(step, unit))
-        elif variation_type == "SingleValue":
-            sweep_range = "{}".format(self._app.value_with_units(start_point, unit))
-        if not sweep_range:
-            return False
-        self._activate_variable(sweep_var)
-        sweepdefinition = OrderedDict()
-        sweepdefinition["Variable"] = sweep_var
-        sweepdefinition["Data"] = sweep_range
-        sweepdefinition["OffsetF1"] = False
-        sweepdefinition["Synchronize"] = 0
-        if self.props["Sweeps"]["SweepDefinition"] is None:
-            self.props["Sweeps"]["SweepDefinition"] = sweepdefinition
-        elif type(self.props["Sweeps"]["SweepDefinition"]) is not list:
-            self.props["Sweeps"]["SweepDefinition"] = [self.props["Sweeps"]["SweepDefinition"]]
-            self._append_sweepdefinition(sweepdefinition)
-        else:
-            self._append_sweepdefinition(sweepdefinition)
-
-        return self.update()
-
-    @pyaedt_function_handler()
-    def _append_sweepdefinition(self, sweepdefinition):
-        for sweep_def in self.props["Sweeps"]["SweepDefinition"]:
-            if sweepdefinition["Variable"] == sweep_def["Variable"]:
-                sweep_def["Data"] += " " + sweepdefinition["Data"]
-                return True
-        self.props["Sweeps"]["SweepDefinition"].append(sweepdefinition)
+        if self._app.design_type == "2D Extractor" or self._app.design_type == "Maxwell 2D":
+            mesh_methods = ["Auto", "AnsoftClassic"]
+        else:
+            mesh_methods = ["Auto", "AnsoftTAU", "AnsoftClassic"]
+        assert method in mesh_methods
+
+        modelres = ["NAME:GlobalModelRes", "UseAutoLength:=", automodelresolution]
+        if not automodelresolution:
+            modelres.append("DefeatureLength:=")
+            modelres.append(modelresolutionlength)
+        surface_appr = [
+            "NAME:GlobalSurfApproximation",
+            "CurvedSurfaceApproxChoice:=",
+            "UseSlider",
+            "SliderMeshSettings:=",
+            level,
+        ]
+        if self._app.design_type == "2D Extractor" or self._app.design_type == "Maxwell 2D":
+            args = ["NAME:MeshSettings", surface_appr, modelres, "MeshMethod:=", method]
+        else:
+            args = [
+                "NAME:MeshSettings",
+                surface_appr,
+                ["NAME:GlobalCurvilinear", "Apply:=", applycurvilinear],
+                modelres,
+                "MeshMethod:=",
+                method,
+                "UseLegacyFaceterForTauVolumeMesh:=",
+                False,
+                "DynamicSurfaceResolution:=",
+                usedynamicsurface,
+                "UseFlexMeshingForTAUvolumeMesh:=",
+                useflexmesh,
+            ]
+        if self._app.design_type == "HFSS":
+            args.append("UseAlternativeMeshMethodsAsFallBack:=")
+            args.append(usefallback)
+            args.append("AllowPhiForLayeredGeometry:=")
+            args.append(usephi)
+        self.omeshmodule.InitialMeshSettings(args)
         return True
 
     @pyaedt_function_handler()
-    def sync_variables(self, variables, sync_n=1):
-        """Sync variable variations in an existing parametric setup.
-        Setting the sync number to `0` will effectively unsync the variables.
+    def assign_surf_priority_for_tau(self, object_lists, surfpriority=0):
+        """Assign a surface representation priority for the TAU mesh.
 
         Parameters
         ----------
-        variables : list
-            List of variables to sync.
-        sync_n : int, optional
-            Sync number. Sweep variables with the same Sync number will be synchronizad.
-            Default is `1`.
+        object_lists : list
+            List of objects to apply a surface representation
+            priority to.
+        surfpriority : int, optional
+            Surface representation priority. The default is ``0``.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
 
         References
         ----------
 
-        >>> oModule.EditSetup
+        >>> oModule.AssignSurfPriorityForTauOp
         """
-        if type(self.props["Sweeps"]["SweepDefinition"]) is not list:
-            self._app.logger.error("Not enough variables are defined in the Parametric setup")
-            return False
-        existing_variables = [s["Variable"] for s in self.props["Sweeps"]["SweepDefinition"]]
-        undo_vals = {}
-        for v in variables:
-            if v not in existing_variables:
-                self._app.logger.error("Variable {} is not defined in the Parametric setup".format(v))
-                return False
-        for v in variables:
-            for sweep_def in self.props["Sweeps"]["SweepDefinition"]:
-                if v == sweep_def["Variable"]:
-                    undo_vals[v] = sweep_def["Synchronize"]
-                    sweep_def["Synchronize"] = sync_n
-        try:
-            return self.update()
-        except Exception:  # pragma: no cover
-            # If it fails to sync (due to e.g. different number of variations), reverts to original values.
-            for v in variables:
-                for sweep_def in self.props["Sweeps"]["SweepDefinition"]:
-                    if v == sweep_def["Variable"]:
-                        sweep_def["Synchronize"] = undo_vals[v]
-            self._app.logger.error("Failed to sync the Parametric setup.")
-            return False
+        meshop_name = generate_unique_name("SurfaceRepPriority")
+        props = OrderedDict({"Type": "SurfaceRepPriority", "Objects": object_lists, "SurfaceRepPriority": surfpriority})
+        mop = MeshOperation(self, meshop_name, props, "SurfaceRepPriority")
+        mop.create()
+        self.meshoperations.append(mop)
+        return mop
 
     @pyaedt_function_handler()
-    def add_calculation(
-        self,
-        calculation,
-        ranges,
-        solution=None,
-        context=None,
-        subdesign_id=None,
-        polyline_points=1001,
-        report_type=None,
-    ):
-        """Add a calculation to the parametric setup.
+    def generate_mesh(self, name):
+        """Generate the mesh for a design.
 
         Parameters
         ----------
-        calculation : str, optional
-            Name of the calculation.
-        ranges : dict
-            Dictionary of ranges with respective values.
-            Values can be: `None` for all values, a List of Discrete Values, a tuple of start and stop range.
-            It includes intrinsics like "Freq", "Time", "Theta", "Distance".
-        solution : str, optional
-            Type of the solution. The default is ``None``, in which case the default
-            solution is used.
-        context : str, optional
-            Calculation contexts. It can be a sphere, a matrix or a polyline.
-        subdesign_id : int, optional
-            Subdesign id for Circuit and HFSS 3D Layout objects.
-        polyline_points : int, optional
-            Number of points for Polyline context.
-        report_type : str, optional
-            Override the auto computation of Calculation Type.
+        name : str
+            Name of the design.
 
         Returns
         -------
         bool
             ``True`` when successful, ``False`` when failed.
 
         References
         ----------
 
-        >>> oModule.EditSetup
+        >>> oDesign.GenerateMesh
         """
-        return self._add_calculation(
-            calculation, ranges, None, solution, context, subdesign_id, polyline_points, report_type, is_goal=False
-        )
+        return self._odesign.GenerateMesh(name) == 0
 
     @pyaedt_function_handler()
-    def export_to_csv(self, filename):
-        """Export the current Parametric Setup to csv.
+    def delete_mesh_operations(self, mesh_type=None):
+        """Remove mesh operations from a design.
 
         Parameters
         ----------
-        filename : str
-            Full Path to the csv file.
+        mesh_type : optional
+           Type of the mesh operation to delete. The default is ``None``, in which
+           case all mesh operations are deleted.
 
         Returns
         -------
         bool
-            `True` if the export is correctly executed.
-        """
-        self.omodule.ExportParametricSetupTable(self.name, filename)
-        return True
+            ``True`` when successful, ``False`` when failed.
 
+        References
+        ----------
 
-class ParametricSetups(object):
-    """Sets up Parametrics analyses. It includes Parametrics, Sensitivity and Statistical Analysis.
+        >>> oModule.DeleteOp
+        """
 
-    Examples
-    --------
-    >>> from pyaedt import Hfss
-    >>> app = Hfss()
-    >>> sensitivity_setups = app.parametrics
-    """
+        mesh_op_types = ["Length Based", "Surface Approximation Based"]
 
-    def __init__(self, p_app):
-        self._app = p_app
-        self.setups = []
-        if self._app.design_properties:
-            try:
-                setups_data = self._app.design_properties["Optimetrics"]["OptimetricsSetups"]
-                for data in setups_data:
-                    if (
-                        isinstance(setups_data[data], (OrderedDict, dict))
-                        and setups_data[data]["SetupType"] == "OptiParametric"
-                    ):
-                        self.setups.append(SetupParam(p_app, data, setups_data[data], setups_data[data]["SetupType"]))
-            except:
-                pass
+        if mesh_type:
+            if mesh_type in mesh_op_types:
+                mesh_op_types = [mesh_type]
+
+        for mesh_op_type in mesh_op_types:
+            opnames = self.omeshmodule.GetOperationNames(mesh_op_type)
+            if opnames:
+                self.omeshmodule.DeleteOp(opnames)
+            for el in self.meshoperations[:]:
+                if el.name in opnames:
+                    self.meshoperations.remove(el)
 
-    @property
-    def p_app(self):
-        """Parent."""
-        return self._app
+        return True
 
-    @property
-    def optimodule(self):
-        """Optimetrics module.
+    @pyaedt_function_handler()
+    def assign_length_mesh(self, names, isinside=True, maxlength=1, maxel=1000, meshop_name=None):
+        """Assign a length for the model resolution.
+
+        Parameters
+        ----------
+        names : list
+            List of object names or face IDs.
+        isinside : bool, optional
+            Whether the length mesh is inside the selection. The default is ``True``.
+        maxlength : str, float, optional
+            Maximum element length. The default is ``1``. When ``None``,
+            this parameter is disabled.
+        maxel : int, optional
+            Maximum number of elements. The default is ``1000``. When ``None``, this parameter
+            is disabled.
+        meshop_name : str, optional
+            Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
-        :class:`Optimetrics`
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
 
+        References
+        ----------
+
+        >>> oModule.AssignLengthOp
         """
-        return self._app.ooptimetrics
+        names = self.modeler.convert_to_selections(names, True)
+        if meshop_name:
+            for m in self.meshoperations:
+                if meshop_name == m.name:
+                    meshop_name = generate_unique_name(meshop_name)
+        else:
+            meshop_name = generate_unique_name("length")
+
+        if maxlength is None:
+            restrictlength = False
+        else:
+            restrictlength = True
+        length = self.modeler.modeler_variable(maxlength)
+
+        if maxel is None:
+            restrictel = False
+            numel = "1000"
+        else:
+            restrictel = True
+            numel = str(maxel)
+        if maxlength is None and maxel is None:
+            self.logger.error("mesh not assigned due to incorrect settings")
+            return
+        names = self._app.modeler.convert_to_selections(names, True)
+
+        if isinstance(names[0], int) and not isinside:
+            seltype = "Faces"
+        elif isinstance(names[0], str):
+            seltype = "Objects"
+        else:
+            seltype = None
+        if seltype is None:
+            self.logger.error("Error in Assignment")
+            return
+        props = OrderedDict(
+            {
+                "Type": "LengthBased",
+                "RefineInside": isinside,
+                "Enabled": True,
+                seltype: names,
+                "RestrictElem": restrictel,
+                "NumMaxElem": numel,
+                "RestrictLength": restrictlength,
+                "MaxLength": length,
+            }
+        )
+
+        mop = MeshOperation(self, meshop_name, props, "LengthBased")
+        for meshop in self.meshoperations[:]:
+            if meshop.name == mop.name:
+                meshop.delete()
+                break
+        mop.create()
+        self.meshoperations.append(mop)
+        return mop
 
     @pyaedt_function_handler()
-    def add(
-        self,
-        sweep_var,
-        start_point,
-        end_point=None,
-        step=100,
-        variation_type="LinearCount",
-        solution=None,
-        parametricname=None,
+    def assign_skin_depth(
+        self, names, skindepth, maxelements=None, triangulation_max_length="0.1mm", numlayers="2", meshop_name=None
     ):
-        """Add a basic sensitivity analysis.
-        You can customize all options after the analysis is added.
+        """Assign a skin depth for the mesh refinement.
 
         Parameters
         ----------
-        sweep_var : str
-            Name of the variable.
-        start_point : float or int
-            Variation Start Point if a variation is defined or Single Value.
-        end_point : float or int, optional
-            Variation End Point. This parameter is optional if a Single Value is defined.
-        step : float or int
-            Variation Step or Count depending on variation_type. The default is ``100``.
-        variation_type : float or int
-            Variation Type. Admitted values are `"LinearCount"`, `"LinearStep"`, `"LogScale"`, `"SingleValue"`.
-        solution : str, optional
-            Type of the solution. The default is ``None``, in which case the default
-            solution is used.
-        parametricname : str, optional
-            Name of the sensitivity analysis. The default is ``None``, in which case
-            a default name is assigned.
+        names : list
+           List of the object names or face IDs.
+        skindepth : bool
+            Whether the length mesh is inside the selection. The default is ``True``.
+        maxelements : int, optional
+            Maximum number of elements. The default is ``None``, which means this parameter is disabled.
+        triangulation_max_length : str, optional
+            Maximum surface triangulation length with units. The default is ``"0.1mm"``.
+        numlayers : str, optional
+            Number of layers. The default is ``"2"``.
+        meshop_name : str, optional
+            Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
-        :class:`pyaedt.modules.DesignXPloration.SetupParam`
-            Optimization Object.
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
 
         References
         ----------
 
-        >>> oModule.InsertSetup
+        >>> oModule.AssignSkinDepthOp
         """
-        if sweep_var not in self._app.variable_manager.variables:
-            self._app.logger.error("Variable {} not found.".format(sweep_var))
-            return False
-        if not solution and not self._app.nominal_sweep:
-            self._app.logger.error("At least one setup is needed.")
-            return False
-        if not solution:
-            solution = self._app.nominal_sweep
-        setupname = solution.split(" ")[0]
-        if not parametricname:
-            parametricname = generate_unique_name("Parametric")
-        setup = SetupParam(self._app, parametricname, optim_type="OptiParametric")
-        setup.auto_update = False
-
-        setup.props["Sim. Setups"] = [setupname]
-        setup.props["Sweeps"] = OrderedDict({"SweepDefinition": None})
-        setup.create()
-        unit = self._app.variable_manager[sweep_var].units
-        setup.add_variation(sweep_var, start_point, end_point, step, unit, variation_type)
-        setup.auto_update = True
-        self.setups.append(setup)
-        return setup
+        names = self.modeler.convert_to_selections(names, True)
+
+        if self._app.design_type != "HFSS" and self._app.design_type != "Maxwell 3D":
+            raise MethodNotSupportedError
+        if meshop_name:
+            for m in self.meshoperations:
+                if meshop_name == m.name:
+                    meshop_name = generate_unique_name(meshop_name)
+        else:
+            meshop_name = generate_unique_name("SkinDepth")
+
+        if maxelements is None:
+            restrictlength = False
+            maxelements = "1000"
+        else:
+            restrictlength = True
+        names = self._app.modeler.convert_to_selections(names, True)
+
+        if isinstance(names[0], int):
+            seltype = "Faces"
+        elif isinstance(names[0], str):
+            seltype = "Objects"
+        else:
+            seltype = None
+        if seltype is None:
+            self.logger.error("Error in Assignment")
+            return
+
+        props = OrderedDict(
+            {
+                "Type": "SkinDepthBased",
+                "Enabled": True,
+                seltype: names,
+                "RestrictElem": restrictlength,
+                "NumMaxElem": str(maxelements),
+                "SkinDepth": skindepth,
+                "SurfTriMaxLength": triangulation_max_length,
+                "NumLayers": numlayers,
+            }
+        )
+
+        mop = MeshOperation(self, meshop_name, props, "SkinDepthBased")
+        mop.create()
+        self.meshoperations.append(mop)
+        return mop
 
     @pyaedt_function_handler()
-    def delete(self, setup_name):
-        """Delete a defined Parametric Setup.
+    def assign_curvilinear_elements(self, names, enable=True, meshop_name=None):
+        """Assign curvilinear elements.
 
         Parameters
         ----------
-        setup_name : str
-            Name of parametric setup to delete.
+        names : list
+            List of objects or faces.
+        enable : bool, optional
+            Whether to apply curvilinear elements. The default is ``True``.
+        meshop_name : str, optional
+            Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
-        bool
-            ``True`` if setup is deleted. ``False`` if it failed.
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
+
+        References
+        ----------
+
+        >>> oModule.AssignApplyCurvlinearElementsOp
         """
-        for el in self.setups:
-            if el.name == setup_name:
-                el.delete()
-                return True
-        return False
+        names = self.modeler.convert_to_selections(names, True)
+
+        if self._app.design_type != "HFSS" and self._app.design_type != "Maxwell 3D":
+            raise MethodNotSupportedError
+        if meshop_name:
+            for m in self.meshoperations:
+                if meshop_name == m.name:
+                    meshop_name = generate_unique_name(meshop_name)
+        else:
+            meshop_name = generate_unique_name("CurvilinearElements")
+        names = self._app.modeler.convert_to_selections(names, True)
+
+        if isinstance(names[0], int):
+            seltype = "Faces"
+        elif isinstance(names[0], str):
+            seltype = "Objects"
+        else:
+            seltype = None
+        if seltype is None:
+            self.logger.error("Error in Assignment")
+            return
+        props = OrderedDict({"Type": "Curvilinear", seltype: names, "Apply": enable})
+        mop = MeshOperation(self, meshop_name, props, "Curvilinear")
+        mop.create()
+        self.meshoperations.append(mop)
+        return mop
+
+    @pyaedt_function_handler()
+    def assign_curvature_extraction(self, names, disable_for_faceted_surf=True, meshop_name=None):
+        """Assign curvature extraction.
+
+         Parameters
+         ----------
+         names : list
+            List of objects or faces.
+         disable_for_faceted_surf : bool, optional
+            Whether curvature extraction is enabled for faceted surfaces.
+            The default is ``True``.
+         meshop_name : str, optional
+            Name of the mesh operation. The default is ``None``.
+
+         Returns
+         -------
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
+
+        References
+        ----------
+
+        >>> oModule.AssignCurvatureExtractionOp
+        """
+        names = self.modeler.convert_to_selections(names, True)
+
+        if self._app.solution_type != "SBR+":
+            raise MethodNotSupportedError
+        if meshop_name:
+            for m in self.meshoperations:
+                if meshop_name == m.name:
+                    meshop_name = generate_unique_name(meshop_name)
+        else:
+            meshop_name = generate_unique_name("CurvilinearElements")
+        names = self._app.modeler.convert_to_selections(names, True)
+        if isinstance(names[0], int):
+            seltype = "Faces"
+        elif isinstance(names[0], str):
+            seltype = "Objects"
+        else:
+            seltype = None
+        if seltype is None:
+            self.logger.error("Error in Assignment")
+            return
+        props = OrderedDict(
+            {"Type": "CurvatureExtraction", seltype: names, "DisableForFacetedSurfaces": disable_for_faceted_surf}
+        )
+        mop = MeshOperation(self, meshop_name, props, "CurvatureExtraction")
+        mop.create()
+        self.meshoperations.append(mop)
+        return mop
 
     @pyaedt_function_handler()
-    def add_from_file(self, filename, parametricname=None):
-        """Add a Parametric Setup from a csv file.
+    def assign_rotational_layer(self, names, num_layers=3, total_thickness="1mm", meshop_name=None):
+        """Assign a rotational layer mesh.
 
         Parameters
         ----------
-        filename : str
-            Csv file path.
-        parametricname : str, option
-            Name of parameric setup.
+        names : list
+            List of objects.
+        num_layers : int, optional
+            Number of layers to create in the radial direction, starting from
+            the faces most adjacent to the band. The default is ``3``, which is the maximum.
+        total_thickness : str, optional
+            Total thickness of all layers with units. The default is ``"1mm"``.
+        meshop_name : str, optional
+            Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
-        bool
-            `True` if the import is executed correctly.
-        """
-        if not parametricname:
-            parametricname = generate_unique_name("Parametric")
-        setup = SetupParam(self._app, parametricname, optim_type="OptiParametric")
-        setup.auto_update = False
-        setup.props["Sim. Setups"] = [setup_defined.name for setup_defined in self._app.setups]
-        with open(filename, "r") as csvfile:
-            csvreader = csv.DictReader(csvfile)
-            first_data_line = next(csvreader)
-            setup.props["Sweeps"] = {"SweepDefinition": OrderedDict()}
-            sweep_definition = []
-            for var_name in csvreader.fieldnames:
-                if var_name != "*":
-                    sweep_definition.append(
-                        OrderedDict(
-                            {
-                                "Variable": var_name,
-                                "Data": first_data_line[var_name],
-                                "OffsetF1": False,
-                                "Synchronize": 0,
-                            }
-                        )
-                    )
-            setup.props["Sweeps"]["SweepDefinition"] = sweep_definition
-
-            args = ["NAME:" + parametricname]
-            _dict2arg(setup.props, args)
-
-            setup.props["Sweep Operations"] = OrderedDict({"add": []})
-            table = []
-            for var_name in csvreader.fieldnames:
-                if var_name != "*":
-                    table.append(first_data_line[var_name])
-            table = [table]
-            for line in csvreader:
-                table_line = []
-                for var_name in csvreader.fieldnames:
-                    if var_name != "*":
-                        table_line.append(line[var_name])
-                table.append(table_line)
-
-            if len(table) > 1:
-                for point in table[1:]:
-                    setup.props["Sweep Operations"]["add"].append(point)
-
-        cont = 0
-        for data in args:
-            if isinstance(data, list) and "NAME:Sweep Operations" in data:
-                del args[cont]
-                args.append(["NAME:Sweep Operations"])
-                break
-            cont += 1
-
-        for variation in setup.props["Sweep Operations"].get("add", []):
-            args[-1].append("add:=")
-            args[-1].append(variation)
-
-        self.optimodule.InsertSetup("OptiParametric", args)
-        self.setups.append(setup)
-        return True
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
 
+        References
+        ----------
 
-class OptimizationSetups(object):
-    """Sets up optimizations. It includes Optimization, DOE and DesignXplorer Analysis.
+        >>> oModule.AssignRotationalLayerOp
+        """
+        names = self.modeler.convert_to_selections(names, True)
 
-    Examples
-    --------
-    >>> from pyaedt import Hfss
-    >>> app = Hfss()
-    >>> optimization_setup = app.optimizations
-    """
+        if self._app.design_type != "Maxwell 3D":
+            raise MethodNotSupportedError
+        if meshop_name:
+            for m in self.meshoperations:
+                if meshop_name == m.name:
+                    meshop_name = generate_unique_name(meshop_name)
+        else:
+            meshop_name = generate_unique_name("RotationalLayer")
+        seltype = "Objects"
+        props = OrderedDict(
+            {
+                "Type": "RotationalLayerMesh",
+                seltype: names,
+                "Number of Layers": str(num_layers),
+                "Total Layer Thickness": total_thickness,
+            }
+        )
 
-    def __init__(self, p_app):
-        self._app = p_app
-        self.setups = []
-        if self._app.design_properties:
-            try:
-                setups_data = self._app.design_properties["Optimetrics"]["OptimetricsSetups"]
-                for data in setups_data:
-                    if isinstance(setups_data[data], (OrderedDict, dict)) and setups_data[data]["SetupType"] in [
-                        "OptiOptimization",
-                        "OptiDXDOE",
-                        "OptiDesignExplorer",
-                        "OptiSLang",
-                        "OptiSensitivity",
-                        "OptiStatistical",
-                    ]:
-                        self.setups.append(SetupOpti(p_app, data, setups_data[data], setups_data[data]["SetupType"]))
-            except:
-                pass
+        mop = MeshOperation(self, meshop_name, props, "RotationalLayerMesh")
+        mop.create()
+        mop.props["Total Layer Thickness"] = total_thickness
+        self.meshoperations.append(mop)
+        return mop
 
-    @property
-    def p_app(self):
-        """Parent."""
-        return self._app
+    @pyaedt_function_handler()
+    def assign_edge_cut(self, names, layer_thickness="1mm", meshop_name=None):
+        """Assign an edge cut layer mesh.
 
-    @property
-    def optimodule(self):
-        """Optimetrics module.
+        Parameters
+        ----------
+        names : list
+            List of objects.
+        layer_thickness :
+            Thickness of the layer with units. The default is ``"1mm"``.
+        meshop_name : str, optional
+            Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
-        :class:`Optimetrics`
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
 
+        References
+        ----------
+
+        >>> oModule.AssignRotationalLayerOp
         """
-        return self._app.ooptimetrics
+        names = self.modeler.convert_to_selections(names, True)
+
+        if self._app.design_type != "Maxwell 3D":
+            raise MethodNotSupportedError
+        if meshop_name:
+            for m in self.meshoperations:
+                if meshop_name == m.name:
+                    meshop_name = generate_unique_name(meshop_name)
+        else:
+            meshop_name = generate_unique_name("EdgeCut")
+        seltype = "Objects"
+        props = OrderedDict({"Type": "EdgeCutLayerMesh", seltype: names, "Layer Thickness": layer_thickness})
+
+        mop = MeshOperation(self, meshop_name, props, "EdgeCutLayerMesh")
+        mop.create()
+        mop.props["Layer Thickness"] = layer_thickness
+        self.meshoperations.append(mop)
+        return mop
 
     @pyaedt_function_handler()
-    def delete(self, setup_name):
-        """Delete a defined Optimetrics Setup.
+    def assign_density_control(self, names, refine_inside=True, maxelementlength=None, layerNum=None, meshop_name=None):
+        """Assign density control.
 
         Parameters
         ----------
-        setup_name : str
-            Name of optimetrics setup to delete.
+        names : list
+            List of objects.
+        refine_inside : bool, optional
+            Whether to refine inside objects. The default is ``True``.
+        maxelementlength : str, optional
+            Maximum element length with units. The default is ``None``,
+            which disables this parameter.
+        layerNum : int, optional
+            Number of layers. The default is ``None``, which disables
+            this parameter.
+        meshop_name : str, optional
+            Name of the mesh operation. The default is ``None``.
 
         Returns
         -------
-        bool
-            ``True`` if setup is deleted. ``False`` if it failed.
+        :class:`pyaedt.modules.Mesh.MeshOperation`
+            Mesh operation object.
+
+        References
+        ----------
+
+        >>> oModule.AssignDensityControlOp
         """
-        for el in self.setups:
-            if el.name == setup_name:
-                el.delete()
-                return True
-        return False
+        names = self.modeler.convert_to_selections(names, True)
+
+        if self._app.design_type != "Maxwell 3D":
+            raise MethodNotSupportedError
+        if meshop_name:
+            for m in self.meshoperations:
+                if meshop_name == m.name:
+                    meshop_name = generate_unique_name(meshop_name)
+        else:
+            meshop_name = generate_unique_name("CloneMeshDensity")
+        seltype = "Objects"
+        if not maxelementlength:
+            restr = False
+            restrval = "0mm"
+        else:
+            restr = True
+            restrval = maxelementlength
+        if not layerNum:
+            restrlay = False
+            restrlaynum = "1"
+        else:
+            restrlay = True
+            restrlaynum = str(layerNum)
+        props = OrderedDict(
+            {
+                "Type": "DensityControlBased",
+                "RefineInside": refine_inside,
+                seltype: names,
+                "RestrictMaxElemLength": restr,
+                "MaxElemLength": restrval,
+                "RestrictLayersNum": restrlay,
+                "LayersNum": restrlaynum,
+            }
+        )
+        mop = MeshOperation(self, meshop_name, props, "DensityControlBased")
+        mop.create()
+        self.meshoperations.append(mop)
+        return mop
 
     @pyaedt_function_handler()
-    def add(
+    def assign_cylindrical_gap(
         self,
-        calculation=None,
-        ranges=None,
-        variables=None,
-        optim_type="Optimization",
-        condition="<=",
-        goal_value=1,
-        goal_weight=1,
-        solution=None,
-        parametricname=None,
-        context=None,
-        subdesign_id=None,
-        polyline_points=1001,
-        report_type=None,
+        obj,
+        meshop_name=None,
+        band_mapping_angle=None,
+        clone_mesh=False,
+        moving_side_layers=1,
+        static_side_layers=1,
     ):
-        """Add a basic optimization analysis.
-        You can customize all options after the analysis is added.
+        """Assign a cylindrical gap for a 2D or 3D design to enable a clone mesh and associated band mapping angle.
 
         Parameters
         ----------
-        calculation : str, optional
-            Name of the calculation.
-        ranges : dict, optional
-            Dictionary of ranges with respective values.
-            Values can be: a list of discrete values, a dict with tuple args of start and stop range.
-            It includes intrinsics like "Freq", "Time", "Theta", "Distance".
-        variables : list, optional
-            List of variables to include in the optimization.
-        optim_type : strm optional
-            Optimization Type.
-            Possible values are `"Optimization"`, `"DXDOE"`,`"DesignExplorer"`,`"Sensitivity"`,`"Statistical"`
-            and `"optiSLang"`.
-        condition : string, optional
-            The default is ``"<="``.
-        goal_value : optional
-            Value for the goal. The default is ``1``.
-        goal_weight : optional
-            Value for the goal weight. The default is ``1``.
-        solution : str, optional
-            Type of the solution. The default is ``None``, in which case the default
-            solution is used.
-        parametricname : str, optional
-            Name of the analysis. The default is ``None``, in which case a
-            default name is assigned.
-        context : str, optional
-            Calculation contexts. It can be a sphere, a matrix or a polyline.
-        subdesign_id : int, optional
-            Subdesign id for Circuit and HFSS 3D Layout objects.
-        polyline_points : int, optional
-            Number of points for Polyline context.
-        report_type : str, optional
-            Override the auto computation of Calculation Type.
+        obj : int or str or :class:`pyaedt.modeler.object3d.Object3d`
+            Object to assign cylindrical gap to.
+        meshop_name : str, optional
+            Name of the mesh. The default is ``None``, in which
+            case the default name is used.
+        clone_mesh : bool, optional
+            Whether to clone the mesh. This parameter is valid only for 3D design.
+            The default is ``False``. If ``True``, the solid bodies adjacent to the band
+            are detected to identify the clone object.
+        band_mapping_angle : int, optional
+            Band mapping angle in degrees.
+            The recommended band mapping angle (the angle the rotor rotates in one time step) typically
+            equals the rotational speed multiplied by the time step.
+            The band mapping angle must be between 0.0005 and 3 degrees.
+            The default is ``None``.
+
+            - For a 2D design, if a value is provided, the option ``Use band mapping angle``
+              is automatically enabled.
+            - For a 3D design, the ``Clone Mesh`` option has to be enabled first.
+        moving_side_layers : int, optional
+            Number of mesh layers on the moving side.
+            The valid ranges are integers greater or equal to 1.
+            This parameter is valid only for a 3D design.
+            The default is ``1``.
+        static_side_layers : int, optional
+            Number of mesh layers on the static side.
+            The valid ranges are integers greater than or equal to 1.
+            This parameter is valid only for a 3D design.
+            The default is ``1``.
 
         Returns
         -------
-        :class:`pyaedt.modules.DesignXPloration.SetupOpti`
-            Optimization object.
+        :class:`pyaedt.modules.Mesh.MeshOperation` or bool
+            Mesh operation object or ``False`` if it fails.
 
         References
         ----------
 
-        >>> oModule.InsertSetup
+        >>> oModule.AssignCylindricalGapOp
         """
-        if not solution and not self._app.nominal_sweep:
-            self._app.logger.error("At least one setup is needed.")
-            return False
-        if not solution:
-            solution = self._app.nominal_sweep
-        setupname = solution.split(" ")[0]
-        if not parametricname:
-            parametricname = generate_unique_name(optim_type)
-        if optim_type != "optiSLang":
-            optim_type = "Opti" + optim_type
-        setup = SetupOpti(self._app, parametricname, optim_type=optim_type)
-        setup.auto_update = False
-        setup.props["Sim. Setups"] = [setupname]
-        if calculation:
-            domain = "Time"
-            if not ranges:
-                ranges = {}
-            if "Freq" in ranges or "Phase" in ranges or "Theta" in ranges:
-                domain = "Sweep"
-            if not report_type:
-                report_type = self._app.design_solutions.report_type
-                if context and context in self._app.modeler.sheet_names:
-                    report_type = "Fields"
-                elif self._app.solution_type in ["Q3D Extractor", "2D Extractor"]:
-                    report_type = "Matrix"
-                elif context:
-                    try:
-                        for f in self._app.field_setups:
-                            if context == f.name:
-                                report_type = "Far Fields"
-                    except:
-                        pass
-            sweepdefinition = setup._get_context(
-                calculation,
-                condition,
-                goal_weight,
-                goal_value,
-                solution,
-                domain,
-                ranges,
-                report_type,
-                context,
-                subdesign_id,
-                polyline_points,
-                is_goal=True,
-            )
-            setup.props["Goals"]["Goal"] = sweepdefinition
+        try:
+            if self._app.design_type != "Maxwell 2D" and self._app.design_type != "Maxwell 3D":
+                raise MethodNotSupportedError
 
-        dx_variables = {}
-        if variables:
-            for el in variables:
-                try:
-                    dx_variables[el] = self._app[el]
-                except:
-                    pass
-        for v in list(dx_variables.keys()):
-            if optim_type in ["OptiOptimization", "OptiDXDOE", "OptiDesignExplorer"]:
-                self._app.activate_variable_optimization(v)
-            elif optim_type == "OptiSensitivity":
-                self._app.activate_variable_sensitivity(v)
-            elif optim_type == "OptiStatistical":
-                self._app.activate_variable_statistical(v)
-        if optim_type == "OptiDXDOE" and calculation:
-            setup.props["CostFunctionGoals"]["Goal"] = sweepdefinition
-        if optim_type in ["OptiDesignExplorer", "optiSLang"]:
-            setup.props["Sweeps"]["SweepDefinition"] = []
-            for l, k in dx_variables.items():
-                arg = OrderedDict({"Variable": l, "Data": k, "OffsetF1": False, "Synchronize": 0})
-                setup.props["Sweeps"]["SweepDefinition"].append(arg)
-        setup.create()
-        setup.auto_update = True
-        self.setups.append(setup)
-        return setup
+            obj = self.modeler.convert_to_selections(obj, True)
+            if len(obj) > 1:
+                self.logger.error("Cylindrical gap treatment cannot be assigned to multiple objects.")
+                raise ValueError
+            if [x for x in self.meshoperations if x.type == "Cylindrical Gap Based" or x.type == "CylindricalGap"]:
+                self.logger.error("Cylindrical gap treatment cannot be assigned to multiple objects.")
+                raise ValueError
+            if band_mapping_angle and band_mapping_angle > 3:
+                self.logger.error("Band mapping angle must be between 0.0005 and 3 deg.")
+                raise ValueError
+            if not meshop_name:
+                meshop_name = generate_unique_name("CylindricalGap")
+
+            if self._app.design_type == "Maxwell 3D":
+                if moving_side_layers < 1:
+                    self.logger.error("Moving side layers must be an integer greater or equal to 1.")
+                    raise ValueError
+                if static_side_layers < 1:
+                    self.logger.error("Static side layers must be an integer greater or equal to 1.")
+                    raise ValueError
+                if clone_mesh and not band_mapping_angle:
+                    band_mapping_angle = 3
+                props = OrderedDict(
+                    {
+                        "Name": meshop_name,
+                        "Objects": obj,
+                        "CloneMesh": clone_mesh,
+                        "BandMappingAngle": str(band_mapping_angle) + "deg",
+                        "MovingSideLayers": moving_side_layers,
+                        "StaticSideLayers": static_side_layers,
+                    }
+                )
+            elif self._app.design_type == "Maxwell 2D":
+                if band_mapping_angle:
+                    use_band_mapping_angle = True
+                else:
+                    use_band_mapping_angle = False
+                    band_mapping_angle = 3
+                props = OrderedDict(
+                    {
+                        "Name": meshop_name,
+                        "Objects": obj,
+                        "UseBandMappingAngle": use_band_mapping_angle,
+                        "BandMappingAngle": str(band_mapping_angle) + "deg",
+                    }
+                )
+            mesh_operation = MeshOperation(self, meshop_name, props, "CylindricalGap")
+            mesh_operation.create()
+            self.meshoperations.append(mesh_operation)
+            return mesh_operation
+        except:
+            return False
```

### Comparing `pyaedt-0.6.61/pyaedt/modules/LayerStackup.py` & `pyaedt-0.6.70/pyaedt/modules/LayerStackup.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/Material.py` & `pyaedt-0.6.70/pyaedt/modules/Material.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/MaterialLib.py` & `pyaedt-0.6.70/pyaedt/modules/MaterialLib.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/Mesh3DLayout.py` & `pyaedt-0.6.70/pyaedt/modules/Mesh3DLayout.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/MeshIcepak.py` & `pyaedt-0.6.70/pyaedt/modules/MeshIcepak.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/OptimetricsTemplates.py` & `pyaedt-0.6.70/pyaedt/modules/OptimetricsTemplates.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/PostProcessor.py` & `pyaedt-0.6.70/pyaedt/modules/PostProcessor.py`

 * *Files 1% similar despite different names*

```diff
@@ -7,15 +7,14 @@
 from __future__ import absolute_import  # noreorder
 
 import ast
 from collections import OrderedDict
 import os
 import random
 import string
-import warnings
 
 from pyaedt import is_ironpython
 from pyaedt import settings
 from pyaedt.application.Variables import decompose_variable_value
 from pyaedt.generic.DataHandlers import json_to_dict
 from pyaedt.generic.constants import unit_converter
 from pyaedt.generic.general_methods import _retry_ntimes
@@ -1036,218 +1035,14 @@
                 if plot.plot_name == plot_name:
                     plot.plot_name = self.oreportsetup.GetChildObject(new_name).GetPropValue("Name")
             return True
         except:
             return False
 
     @pyaedt_function_handler()
-    def get_report_data(
-        self, expression="dB(S(1,1))", setup_sweep_name="", domain="Sweep", families_dict=None, report_input_type=None
-    ):
-        """Generate report data.
-        This method returns the data object and the arrays ``solData`` and
-        ``FreqVals``.
-
-        .. deprecated:: 0.4.41
-           Use :func:`get_solution_data` method instead.
-
-        Parameters
-        ----------
-        expression : str or list
-            One or more formulas to add to the report. The default is
-            ``"dB(S(1,1))"``.
-        setup_sweep_name : str, optional
-            Name of the setup for computing the report. The
-            default is ``""``, in which case the nominal sweep is
-            used.
-        domain : str or list, optional
-            Context type. The options are ``"Sweep"`` or
-            ``"Time"``. The default is ``"Sweep".``
-        families_dict : dict, optional
-            Dictionary of all families including the primary
-            sweep. The default is ``{"Freq": ["All"]}``.
-        report_input_type :  str
-            Type of input data for the report.
-
-        Returns
-        -------
-        pyaedt.modules.solutions.SolutionData
-
-        References
-        ----------
-
-        >>> oModule.GetSolutionDataPerVariation
-
-        Examples
-        --------
-        Generate a report with the default sweep and default variation.
-
-        >>> hfss = HFSS()
-        >>> hfss.post.get_report_data("S(1,1)")
-
-        >>> m3d = Maxwell3D()
-        >>> m3d.post.get_report_data("SurfaceLoss")   # Eddy Current examples
-        >>> m3d.post.get_report_data("Wind(LoadA,LaodA)")    # TransientAnalsysis
-
-        """
-        warnings.warn("`get_report_data` is deprecated. Use `get_solution_data` property instead.", DeprecationWarning)
-        if self.post_solution_type in ["HFSS3DLayout", "NexximLNA", "NexximTransient", "TR", "AC", "DC"]:
-            if domain == "Sweep":
-                did = 3
-            else:
-                did = 1
-            ctxt = [
-                "NAME:Context",
-                "SimValueContext:=",
-                [did, 0, 2, 0, False, False, -1, 1, 0, 1, 1, "", 0, 0, "IDIID", False, "1"],
-            ]
-        elif isinstance(domain, list):
-            ctxt = domain
-        else:
-            ctxt = ["Domain:=", domain]
-        if self.post_solution_type in ["TR", "AC", "DC"]:
-            ctxt[2] = ctxt[2][:-3]
-            setup_sweep_name = self.post_solution_type
-        if not isinstance(expression, list):
-            expression = [expression]
-        if not setup_sweep_name:
-            setup_sweep_name = self._app.nominal_sweep
-
-        if not report_input_type:
-            report_input_type = self._app.design_solutions.report_type
-
-        if families_dict is None:
-            if domain == "Time":
-                families_dict = {"Time": ["All"]}
-            else:
-                families_dict = {"Freq": ["All"]}
-
-        solution_data = self.get_solution_data_per_variation(
-            report_input_type, setup_sweep_name, ctxt, families_dict, expression
-        )
-
-        if not solution_data:
-            warnings.warn("No Data Available. Check inputs")
-            return False
-        return solution_data
-
-    @pyaedt_function_handler()
-    def create_rectangular_plot(
-        self,
-        expression="dB(S(1,1))",
-        setup_sweep_name="",
-        families_dict=None,
-        primary_sweep_variable="Freq",
-        context=None,
-        plotname=None,
-        report_category=None,
-        plot_type="Rectangular Plot",
-    ):
-        """Create a 2D rectangular plot in AEDT.
-
-        .. deprecated:: 0.4.41
-            Method deprecated. use `create_report` instead.
-
-        Parameters
-        ----------
-        expression : str or list, optional
-            One or more formulas to add to the report. The default is value = ``"dB(S(1,1))"``.
-        setup_sweep_name : str, optional
-            Setup name with the sweep. The default is ``""``.
-        families_dict : dict, optional
-            Dictionary of all families including the primary sweep. The default is ``{"Freq": ["All"]}``.
-        primary_sweep_variable : str, optional
-            Name of the primary sweep. The default is ``"Freq"``.
-        context : str, optional
-            The default is ``None``.
-        plotname : str, optional
-            Name of the plot. The default is ``None``.
-        report_category : str, optional
-            Type of the Report to be created. If `None` default data Report will be used
-        plot_type : str, optional
-            The format of Data Visualization. Default is ``Rectangular Plot``
-        Returns
-        -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
-        References
-        ----------
-
-        >>> oModule.CreateReport
-        """
-        if families_dict is None:
-            families_dict = {"Freq": ["All"]}
-
-        warnings.warn(
-            "`create_rectangular_plot` is deprecated. Use `create_report` property instead.", DeprecationWarning
-        )
-
-        ctxt = []
-        if not setup_sweep_name:
-            setup_sweep_name = self._app.nominal_sweep
-        if self.post_solution_type in ["HFSS3DLayout", "NexximLNA", "NexximTransient", "TR", "AC", "DC"]:
-            if "Freq" == primary_sweep_variable or "Freq" in list(families_dict.keys()):
-                did = 3
-            else:
-                did = 1
-            ctxt = [
-                "NAME:Context",
-                "SimValueContext:=",
-                [did, 0, 2, 0, False, False, -1, 1, 0, 1, 1, "", 0, 0, "IDIID", False, "1"],
-            ]
-        elif context:
-            if type(context) is list:
-                ctxt = context
-            else:
-                ctxt = ["Context:=", context]
-        if self.post_solution_type in ["TR", "AC", "DC"]:
-            ctxt[2] = ctxt[2][:-3]
-            setup_sweep_name = self.post_solution_type
-        if not isinstance(expression, list):
-            expression = [expression]
-        if not setup_sweep_name:
-            setup_sweep_name = self._app.nominal_sweep
-        if not report_category and not self._app.design_solutions.report_type:
-            self.logger.info("Solution not supported")
-            return False
-        if not report_category:
-            modal_data = self._app.design_solutions.report_type
-        else:
-            modal_data = report_category
-        if not plotname:
-            plotname = generate_unique_name("Plot")
-        families_input = [primary_sweep_variable + ":="]
-        if primary_sweep_variable not in families_dict:
-            families_input.append(["All"])
-        elif isinstance(families_dict[primary_sweep_variable], list):
-            families_input.append(families_dict[primary_sweep_variable])
-        else:
-            families_input.append([families_dict[primary_sweep_variable]])
-        for el in families_dict:
-            if el == primary_sweep_variable:
-                continue
-            families_input.append(el + ":=")
-            if isinstance(families_dict[el], list):
-                families_input.append(families_dict[el])
-            else:
-                families_input.append([families_dict[el]])
-        self.oreportsetup.CreateReport(
-            plotname,
-            modal_data,
-            plot_type,
-            setup_sweep_name,
-            ctxt,
-            families_input,
-            ["X Component:=", primary_sweep_variable, "Y Component:=", expression],
-        )
-        self.logger.info("Report %s correctly created.", plotname)
-        return True
-
-    @pyaedt_function_handler()
     def get_solution_data_per_variation(
         self, soltype="Far Fields", setup_sweep_name="", ctxt=None, sweeps=None, expression=""
     ):
         """Retrieve solution data for each variation.
 
         Parameters
         ----------
@@ -3231,58 +3026,14 @@
         else:
             self.ofieldsreporter.ExportPlotImageWithViewToFile(
                 fileName, foldername, plotName, width, height, orientation
             )
         return True
 
     @pyaedt_function_handler()
-    def export_field_image_with_view(self, plotName, foldername, exportFilePath, view="isometric", wireframe=True):
-        """Export a field plot image with a view.
-
-        .. deprecated:: 0.5.0
-           Use :func:`export_field_jpg` method instead.
-
-        .. note::
-           For AEDT 2019 R3, this method works only on the ISO view due to a bug in the API.
-           This method works properly in 2021 R1.
-
-        Parameters
-        ----------
-        plotName : str
-            Name of the plot.
-        foldername : str
-            Path to folder.
-        exportFilePath :
-            Path for exporting the image file.
-        view : str, optional
-           View to export. Options are ``"isometric"``, ``"xy"``, ``"xz"``, ``"yz"``.
-            The default is ``"isometric"``.
-        wireframe : bool, optional
-            Whether to put the objects in the wireframe mode. The default is ``True``.
-
-        Returns
-        -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
-        References
-        ----------
-
-        >>> oModule.ExportPlotImageToFile
-        >>> oModule.ExportModelImageToFile
-        """
-        warnings.warn(
-            "`export_field_image_with_view` is deprecated. Use `export_field_jpg` property instead.", DeprecationWarning
-        )
-
-        return self.export_field_jpg(
-            exportFilePath, plotName, foldername, orientation=view, display_wireframe=wireframe
-        )
-
-    @pyaedt_function_handler()
     def delete_field_plot(self, name):
         """Delete a field plot.
 
         Parameters
         ----------
         name : str
             Name of the field plot.
@@ -3560,20 +3311,17 @@
         project_path = self._app.working_directory
 
         if not setup_name:
             setup_name = self._app.nominal_adaptive
         face_lists = []
         obj_list = self._app.modeler.object_names
         for el in obj_list:
-            obj_id = self._app.modeler.get_obj_id(el)
-            if not self._app.modeler.objects[obj_id].is3d or (
-                self._app.modeler.objects[obj_id].material_name != "vacuum"
-                and self._app.modeler.objects[obj_id].material_name != "air"
-            ):
-                face_lists += self._app.modeler.get_object_faces(obj_id)
+            object3d = self._app.modeler[el]
+            if not object3d.is3d or object3d.material_name not in ["vacuum", "air"]:
+                face_lists += [i.id for i in object3d.faces]
         plot = self.create_fieldplot_surface(face_lists, "Mesh", setup_name, intrinsic_dict)
         if plot:
             file_to_add = self.export_field_plot(plot.name, project_path)
             plot.delete()
             return file_to_add
         return None
```

### Comparing `pyaedt-0.6.61/pyaedt/modules/SetupTemplates.py` & `pyaedt-0.6.70/pyaedt/modules/SetupTemplates.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/SolveSetup.py` & `pyaedt-0.6.70/pyaedt/modules/SolveSetup.py`

 * *Files 0% similar despite different names*

```diff
@@ -1400,50 +1400,50 @@
         for net, primitives in primitives_3d_pts_per_nets.items():
             obj_dict = {}
             for position in primitives_3d_pts_per_nets[net]:
                 aedtapp_objs = [p for p in aedtapp.modeler.get_bodynames_from_position(position) if p in metal_object]
                 if aedtapp_objs:
                     for p in aedtapp.modeler.get_bodynames_from_position(position, None, False):
                         if p in metal_object:
-                            obj_ind = aedtapp.modeler.object_id_dict[p]
+                            obj_ind = aedtapp.modeler._object_names_to_ids[p]
                             if obj_ind not in obj_dict:
                                 obj_dict[obj_ind] = aedtapp.modeler.objects[obj_ind]
             if net in via_per_nets:
                 for via_pos in via_per_nets[net]:
                     for p in aedtapp.modeler.get_bodynames_from_position(via_pos, None, False):
                         if p in metal_object:
-                            obj_ind = aedtapp.modeler.object_id_dict[p]
+                            obj_ind = aedtapp.modeler._object_names_to_ids[p]
                             if obj_ind not in obj_dict:
                                 obj_dict[obj_ind] = aedtapp.modeler.objects[obj_ind]
                         for lay_el in list(layers_elevation.values()):
                             pad_pos = via_pos[:2]
                             pad_pos.append(lay_el)
                             pad_objs = aedtapp.modeler.get_bodynames_from_position(pad_pos, None, False)
                             for pad_obj in pad_objs:
                                 if pad_obj in metal_object:
-                                    pad_ind = aedtapp.modeler.object_id_dict[pad_obj]
+                                    pad_ind = aedtapp.modeler._object_names_to_ids[pad_obj]
                                     if pad_ind not in obj_dict:
                                         obj_dict[pad_ind] = aedtapp.modeler.objects[pad_ind]
             obj_list = list(obj_dict.values())
             if len(obj_list) == 1:
                 obj_list[0].name = net
                 obj_list[0].color = [randrange(255), randrange(255), randrange(255)]
             elif len(obj_list) > 1:
                 united_object = aedtapp.modeler.unite(obj_list, purge=True)
-                obj_ind = aedtapp.modeler.object_id_dict[united_object]
+                obj_ind = aedtapp.modeler._object_names_to_ids[united_object]
                 aedtapp.modeler.objects[obj_ind].name = net
                 aedtapp.modeler.objects[obj_ind].color = [randrange(255), randrange(255), randrange(255)]
         if aedtapp.design_type == "Q3D Extractor":
             aedtapp.auto_identify_nets()
         aedtapp.close_project(save_project=True)
 
     @pyaedt_function_handler()
     def _get_primitives_points_per_net(self):
         edb = self.p_app.modeler.edb
-        net_primitives = edb.core_primitives.primitives_by_net
+        net_primitives = edb.modeler.primitives_by_net
         primitive_dict = {}
         for net, primitives in net_primitives.items():
             primitive_dict[net] = []
             if primitives:
                 for prim in primitives:
                     layer = edb.stackup.signal_layers[prim.layer_name]
                     z = layer.lower_elevation + layer.thickness / 2
@@ -1469,17 +1469,17 @@
                 for pt in v:
                     new_pts.append([round(coord / output_unit, 5) for coord in pt])
                 input_dict[k] = new_pts
 
     @pyaedt_function_handler()
     def _get_via_position_per_net(self):
         via_dict = {}
-        via_list = list(self.p_app.modeler.edb.core_padstack.instances.values())
+        via_list = list(self.p_app.modeler.edb.padstacks.instances.values())
         if via_list:
-            for net in list(self.p_app.modeler.edb.core_nets.nets.keys()):
+            for net in list(self.p_app.modeler.edb.nets.nets.keys()):
                 vias = [via for via in via_list if via.net_name == net and via.start_layer != via.stop_layer]
                 if vias:
                     via_dict[net] = []
                     for via in vias:
                         via_pos = via.position
                         z1 = self.p_app.modeler.edb.stackup.signal_layers[via.start_layer].lower_elevation
                         z2 = self.p_app.modeler.edb.stackup.signal_layers[via.stop_layer].upper_elevation
```

### Comparing `pyaedt-0.6.61/pyaedt/modules/SolveSweeps.py` & `pyaedt-0.6.70/pyaedt/modules/SolveSweeps.py`

 * *Files 0% similar despite different names*

```diff
@@ -457,15 +457,15 @@
         rangetype : str
             Type of the subrange. Options are ``"LinearCount"``, ``"SinglePoint"``,
             ``"LinearStep"``, and ``"LogScale"``.
         start : float
             Starting frequency.
         end : float, optional
             Stopping frequency. The default is ``None``. A value is
-           required for these subranges: ``"LinearCount"``, ``"LinearStep"``, and ``"LogScale"``.
+            required for these subranges: ``"LinearCount"``, ``"LinearStep"``, and ``"LogScale"``.
         count : int or float, optional
             Frequency count or frequency step. The default is ``None``.
             A value is required for these subranges: ``"LinearCount"``, ``"LinearStep"``,
             and ``"LogScale"``.
         unit : str
             Unit of the frequency. For example, ``"MHz`` or ``"GHz"``. The default is ``"GHz"``.
```

### Comparing `pyaedt-0.6.61/pyaedt/modules/monitor_icepak.py` & `pyaedt-0.6.70/pyaedt/modules/monitor_icepak.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/report_templates.py` & `pyaedt-0.6.70/pyaedt/modules/report_templates.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/modules/solutions.py` & `pyaedt-0.6.70/pyaedt/edb.py`

 * *Files 24% similar despite different names*

```diff
@@ -1,3439 +1,3264 @@
-from collections import OrderedDict
-import itertools
-import math
+"""This module contains the ``Edb`` class.
+
+This module is implicitily loaded in HFSS 3D Layout when launched.
+
+"""
+import gc
 import os
+import re
+import shutil
 import sys
 import time
+import traceback
+import warnings
 
-from pyaedt import get_pyaedt_app
-from pyaedt import is_ironpython
-from pyaedt import pyaedt_function_handler
+from pyaedt import __version__
+from pyaedt import pyaedt_logger
 from pyaedt import settings
+from pyaedt.application.Variables import decompose_variable_value
+from pyaedt.edb_core import Components
+from pyaedt.edb_core import EdbHfss
+from pyaedt.edb_core import EdbLayout
+from pyaedt.edb_core import EdbNets
+from pyaedt.edb_core import EdbSiwave
+from pyaedt.edb_core.edb_data.design_options import EdbDesignOptions
+from pyaedt.edb_core.edb_data.edb_builder import EdbBuilder
+from pyaedt.edb_core.edb_data.edbvalue import EdbValue
+from pyaedt.edb_core.edb_data.hfss_simulation_setup_data import HfssSimulationSetup
+from pyaedt.edb_core.edb_data.simulation_configuration import SimulationConfiguration
+from pyaedt.edb_core.edb_data.siwave_simulation_setup_data import SiwaveDCSimulationSetup
+from pyaedt.edb_core.edb_data.siwave_simulation_setup_data import SiwaveSYZSimulationSetup
+from pyaedt.edb_core.edb_data.sources import ExcitationDifferential
+from pyaedt.edb_core.edb_data.sources import ExcitationPorts
+from pyaedt.edb_core.edb_data.sources import ExcitationProbes
+from pyaedt.edb_core.edb_data.sources import ExcitationSources
+from pyaedt.edb_core.edb_data.sources import SourceType
+from pyaedt.edb_core.edb_data.variables import Variable
+import pyaedt.edb_core.general
+from pyaedt.edb_core.general import convert_py_list_to_net_list
+from pyaedt.edb_core.ipc2581.ipc2581 import Ipc2581
+from pyaedt.edb_core.materials import Materials
+from pyaedt.edb_core.padstack import EdbPadstacks
+from pyaedt.edb_core.stackup import Stackup
+from pyaedt.generic.clr_module import Convert
+from pyaedt.generic.clr_module import List
+from pyaedt.generic.clr_module import Tuple
+from pyaedt.generic.clr_module import _clr
+from pyaedt.generic.clr_module import edb_initialized
 from pyaedt.generic.constants import AEDT_UNITS
-from pyaedt.generic.constants import db10
-from pyaedt.generic.constants import db20
-from pyaedt.generic.constants import unit_converter
-from pyaedt.generic.general_methods import check_and_download_folder
-from pyaedt.generic.general_methods import open_file
-from pyaedt.generic.general_methods import write_csv
-from pyaedt.generic.plot import get_structured_mesh
-from pyaedt.generic.plot import is_notebook
-from pyaedt.generic.plot import plot_2d_chart
-from pyaedt.generic.plot import plot_3d_chart
-from pyaedt.generic.plot import plot_contour
-from pyaedt.generic.plot import plot_polar_chart
-from pyaedt.modeler.cad.elements3d import FacePrimitive
-
-np = None
-pd = None
-pv = None
-if not is_ironpython:
-    try:
-        import numpy as np
-    except ImportError:
-        np = None
-    try:
-        import pandas as pd
-    except ImportError:
-        pd = None
-    try:
-        import pyvista as pv
-    except ImportError:
-        pv = None
-
-
-class SolutionData(object):
-    """Contains information from the :func:`GetSolutionDataPerVariation` method."""
-
-    def __init__(self, aedtdata):
-        self._original_data = aedtdata
-        self.number_of_variations = len(aedtdata)
-        self._enable_pandas_output = True if settings.enable_pandas_output and pd else False
-        self._expressions = None
-        self._intrinsics = None
-        self._nominal_variation = None
-        self._nominal_variation = self._original_data[0]
-        self.active_expression = self.expressions[0]
-        self._sweeps_names = []
-        self.update_sweeps()
-        self.variations = self._get_variations()
-        self.active_intrinsic = OrderedDict({})
-        for k, v in self.intrinsics.items():
-            self.active_intrinsic[k] = v[0]
-        if len(self.intrinsics) > 0:
-            self._primary_sweep = list(self.intrinsics.keys())[0]
-        else:
-            self._primary_sweep = self._sweeps_names[0]
-        self.active_variation = self.variations[0]
-        self.units_sweeps = {}
-        for intrinsic in self.intrinsics:
-            try:
-                self.units_sweeps[intrinsic] = self.nominal_variation.GetSweepUnits(intrinsic)
-            except:
-                self.units_sweeps[intrinsic] = None
-        self.init_solutions_data()
-        self._ifft = None
+from pyaedt.generic.constants import SolverType
+from pyaedt.generic.general_methods import env_path
+from pyaedt.generic.general_methods import env_path_student
+from pyaedt.generic.general_methods import env_value
+from pyaedt.generic.general_methods import generate_unique_name
+from pyaedt.generic.general_methods import inside_desktop
+from pyaedt.generic.general_methods import is_ironpython
+from pyaedt.generic.general_methods import is_linux
+from pyaedt.generic.general_methods import is_windows
+from pyaedt.generic.general_methods import pyaedt_function_handler
+from pyaedt.generic.process import SiwaveSolve
+from pyaedt.misc.misc import list_installed_ansysem
+
+if is_linux and is_ironpython:
+    import subprocessdotnet as subprocess
+else:
+    import subprocess
 
-    @property
-    def enable_pandas_output(self):
-        """Set/Get a flag to use Pandas to export dict and lists. This applies to Solution data output.
-        If ``True`` the property or method will return a pandas object in CPython environment.
-        Default is ``False``.
 
-        Returns
-        -------
-        bool
-        """
-        return True if self._enable_pandas_output and pd else False
+class Edb(object):
+    """Provides the EDB application interface.
+
+    This module inherits all objects that belong to EDB.
+
+    Parameters
+    ----------
+    edbpath : str, optional
+        Full path to the ``aedb`` folder. The variable can also contain
+        the path to a layout to import. Allowed formats are BRD,
+        XML (IPC2581), GDS, and DXF. The default is ``None``.
+        For GDS import, the Ansys control file (also XML) should have the same
+        name as the GDS file. Only the file extension differs.
+    cellname : str, optional
+        Name of the cell to select. The default is ``None``.
+    isreadonly : bool, optional
+        Whether to open EBD in read-only mode when it is
+        owned by HFSS 3D Layout. The default is ``False``.
+    edbversion : str, optional
+        Version of EDB to use. The default is ``"2021.2"``.
+    isaedtowned : bool, optional
+        Whether to launch EDB from HFSS 3D Layout. The
+        default is ``False``.
+    oproject : optional
+        Reference to the AEDT project object.
+    student_version : bool, optional
+        Whether to open the AEDT student version. The default is ``False.``
+
+    Examples
+    --------
+    Create an ``Edb`` object and a new EDB cell.
+
+    >>> from pyaedt import Edb
+    >>> app = Edb()
+
+    Add a new variable named "s1" to the ``Edb`` instance.
+
+    >>> app['s1'] = "0.25 mm"
+    >>> app['s1'].tofloat
+    >>> 0.00025
+    >>> app['s1'].tostring
+    >>> "0.25mm"
+
+    or add a new parameter with description:
+
+    >>> app['s2'] = ["20um", "Spacing between traces"]
+    >>> app['s2'].value
+    >>> 1.9999999999999998e-05
+    >>> app['s2'].description
+    >>> 'Spacing between traces'
+
+
+    Create an ``Edb`` object and open the specified project.
+
+    >>> app = Edb("myfile.aedb")
+
+    Create an ``Edb`` object from GDS and control files.
+    The XML control file resides in the same directory as the GDS file: (myfile.xml).
+
+    >>> app = Edb("/path/to/file/myfile.gds")
+
+    """
+
+    def __init__(
+        self,
+        edbpath=None,
+        cellname=None,
+        isreadonly=False,
+        edbversion=None,
+        isaedtowned=False,
+        oproject=None,
+        student_version=False,
+        use_ppe=False,
+    ):
+        self._clean_variables()
+        if inside_desktop:
+            self.standalone = False
+        else:
+            self.standalone = True
+        if edb_initialized:
+            self.oproject = oproject
+            self._main = sys.modules["__main__"]
+            self._global_logger = pyaedt_logger
+            self._logger = pyaedt_logger
+            self.student_version = student_version
+            self.logger.info("Logger is initialized in EDB.")
+            self.logger.info("pyaedt v%s", __version__)
+            self.logger.info("Python version %s", sys.version)
+            if not edbversion:
+                try:
+                    edbversion = "20{}.{}".format(list_installed_ansysem()[0][-3:-1], list_installed_ansysem()[0][-1:])
+                    self._logger.info("Edb version " + edbversion)
+                except IndexError:
+                    raise Exception("No ANSYSEM_ROOTxxx is found.")
+            self.edbversion = edbversion
+            self.isaedtowned = isaedtowned
+            self._init_dlls()
+            self._db = None
+            # self._edb.Database.SetRunAsStandAlone(not isaedtowned)
+            self.isreadonly = isreadonly
+            self.cellname = cellname
+            if not edbpath:
+                if is_windows:
+                    edbpath = os.getenv("USERPROFILE")
+                    if not edbpath:
+                        edbpath = os.path.expanduser("~")
+                    edbpath = os.path.join(edbpath, "Documents", generate_unique_name("layout") + ".aedb")
+                else:
+                    edbpath = os.getenv("HOME")
+                    if not edbpath:
+                        edbpath = os.path.expanduser("~")
+                    edbpath = os.path.join(edbpath, generate_unique_name("layout") + ".aedb")
+                self.logger.info("No EDB is provided. Creating a new EDB {}.".format(edbpath))
+            self.edbpath = edbpath
+            self.log_name = None
+            if edbpath:
+                self.log_name = os.path.join(
+                    os.path.dirname(edbpath), "pyaedt_" + os.path.splitext(os.path.split(edbpath)[-1])[0] + ".log"
+                )
 
-    @enable_pandas_output.setter
-    def enable_pandas_output(self, val):
-        if val != self._enable_pandas_output and pd:
-            self._enable_pandas_output = val
-            self.init_solutions_data()
+            if isaedtowned and (inside_desktop or settings.remote_api):
+                self.open_edb_inside_aedt()
+            elif edbpath[-3:] in ["brd", "gds", "xml", "dxf", "tgz"]:
+                self.edbpath = edbpath[:-4] + ".aedb"
+                working_dir = os.path.dirname(edbpath)
+                self.import_layout_pcb(edbpath, working_dir, use_ppe=use_ppe)
+                if settings.enable_local_log_file and self.log_name:
+                    self._logger = self._global_logger.add_file_logger(self.log_name, "Edb")
+                self.logger.info("EDB %s was created correctly from %s file.", self.edbpath, edbpath[-2:])
+            elif edbpath.endswith("edb.def"):
+                self.edbpath = os.path.dirname(edbpath)
+                if settings.enable_local_log_file and self.log_name:
+                    self._logger = self._global_logger.add_file_logger(self.log_name, "Edb")
+                self.open_edb()
+            elif not os.path.exists(os.path.join(self.edbpath, "edb.def")):
+                self.create_edb()
+                if settings.enable_local_log_file and self.log_name:
+                    self._logger = self._global_logger.add_file_logger(self.log_name, "Edb")
+                self.logger.info("EDB %s was created correctly.", self.edbpath)
+            elif ".aedb" in edbpath:
+                self.edbpath = edbpath
+                if settings.enable_local_log_file and self.log_name:
+                    self._logger = self._global_logger.add_file_logger(self.log_name, "Edb")
+                self.open_edb()
+            if self.builder:
+                self.logger.info("EDB was initialized.")
+            else:
+                self.logger.info("Failed to initialize DLLs.")
+        else:
+            warnings.warn("Failed to initialize DLLs.")
+
+    def __enter__(self):
+        return self
+
+    def __exit__(self, ex_type, ex_value, ex_traceback):
+        if ex_type:
+            self.edb_exception(ex_value, ex_traceback)
 
     @pyaedt_function_handler()
-    def set_active_variation(self, var_id=0):
-        """Set the active variations to one of available variations in self.variations.
+    def __getitem__(self, variable_name):
+        """Get or Set a variable to the Edb project. The variable can be project using ``$`` prefix or
+        it can be a design variable, in which case the ``$`` is omitted.
 
         Parameters
         ----------
-        var_id : int
-            Index of Variations to assign.
+        variable_name : str
 
         Returns
         -------
-        bool
+        :class:`pyaedt.edb_core.edb_data.variables.Variable`
+
         """
-        if var_id < len(self.variations):
-            self.active_variation = self.variations[var_id]
-            self.nominal_variation = var_id
-            self._expressions = None
-            self._intrinsics = None
-            return True
-        return False
+        if self.variable_exists(variable_name)[0]:
+            return self.variables[variable_name]
+        return
 
     @pyaedt_function_handler()
-    def _get_variations(self):
-        variations_lists = []
-        for data in self._original_data:
-            variations = OrderedDict({})
-            for v in data.GetDesignVariableNames():
-                variations[v] = data.GetDesignVariableValue(v)
-            variations_lists.append(variations)
-        return variations_lists
+    def __setitem__(self, variable_name, variable_value):
+        type_error_message = "Allowed values are str, numeric or two-item list with variable description."
+        if type(variable_value) in [list, tuple]:  # Two-item list or tuple. 2nd argument is a str description.
+            if len(variable_value) == 2:
+                if type(variable_value[1]) is str:
+                    description = variable_value[1] if len(variable_value[1]) > 0 else None
+                else:
+                    description = None
+                    pyaedt.edb_core.general.logger.warning("Invalid type for Edb variable desciprtion is ignored.")
+                val = variable_value[0]
+            else:
+                raise TypeError(type_error_message)
+        else:
+            description = None
+            val = variable_value
+        if self.variable_exists(variable_name)[0]:
+            self.change_design_variable_value(variable_name, val)
+        else:
+            self.add_design_variable(variable_name, val)
+        if description:  # Add the variable description if a two-item list is passed for variable_value.
+            self.__getitem__(variable_name).description = description
+
+    def _clean_variables(self):
+        """Initialize internal variables and perform garbage collection."""
+
+        self._components = None
+        self._core_primitives = None
+        self._stackup = None
+        self._padstack = None
+        self._siwave = None
+        self._hfss = None
+        self._nets = None
+        self._db = None
+        self._edb = None
+        self.builder = None
+        self.edbutils = None
+        self.simSetup = None
+        self.simsetupdata = None
+        self._setups = {}
+        self._layout_instance = None
+        self._variables = None
+        # time.sleep(2)
+        # gc.collect()
+
+    @pyaedt_function_handler()
+    def _init_objects(self):
+        time.sleep(1)
+        self._components = Components(self)
+        self._stackup = Stackup(self)
+        self._padstack = EdbPadstacks(self)
+        self._siwave = EdbSiwave(self)
+        self._hfss = EdbHfss(self)
+        self._nets = EdbNets(self)
+        self._core_primitives = EdbLayout(self)
+        self._stackup2 = self._stackup
+        self._materials = Materials(self)
 
-    @pyaedt_function_handler()
-    def variation_values(self, variation_name):
-        """Get the list of the specific variation available values.
+        self.logger.info("Objects Initialized")
 
-        Parameters
-        ----------
-        variation_name : str
-            Name of variation to return.
+    @property
+    def logger(self):
+        """Logger for EDB.
 
         Returns
         -------
-        list
+        :class:`pyaedt.aedt_logger.AedtLogger`
         """
-        if variation_name in self.intrinsics:
-            return self.intrinsics[variation_name]
-        else:
-            vars_vals = []
-            for el in self.variations:
-                if variation_name in el and el[variation_name] not in vars_vals:
-                    vars_vals.append(el[variation_name])
-            return vars_vals
-
-    @property
-    def intrinsics(self):
-        """Get intrinsics dictionary on active variation."""
-        if not self._intrinsics:
-            self._intrinsics = OrderedDict({})
-            intrinsics = [i for i in self._sweeps_names if i not in self.nominal_variation.GetDesignVariableNames()]
-            for el in intrinsics:
-                values = list(self.nominal_variation.GetSweepValues(el, False))
-                self._intrinsics[el] = [i for i in values]
-                self._intrinsics[el] = list(OrderedDict.fromkeys(self._intrinsics[el]))
-        return self._intrinsics
+        return self._logger
 
     @property
-    def nominal_variation(self):
-        """Nominal variation."""
-        return self._nominal_variation
+    def cell_names(self):
+        """Cell name container.
+        Returns
+        -------
+        list of str, cell names.
+        """
+        names = []
+        for cell in list(self._db.TopCircuitCells):
+            names.append(cell.GetName())
+        return names
 
-    @nominal_variation.setter
-    def nominal_variation(self, val):
-        if 0 <= val <= self.number_of_variations:
-            self._nominal_variation = self._original_data[val]
-        else:
-            print(str(val) + " not in Variations")
+    @pyaedt_function_handler()
+    def _init_dlls(self):
+        """Initialize DLLs."""
+        if is_linux:
+            if env_value(self.edbversion) in os.environ or settings.edb_dll_path:
+                if settings.edb_dll_path:
+                    self.base_path = settings.edb_dll_path
+                else:
+                    self.base_path = env_path(self.edbversion)
+                sys.path.append(self.base_path)
+            else:
+                main = sys.modules["__main__"]
+                if "oDesktop" in dir(main):
+                    self.base_path = main.oDesktop.GetExeDir()
+                    sys.path.append(main.oDesktop.GetExeDir())
+                    os.environ[env_value(self.edbversion)] = self.base_path
+                else:
+                    edb_path = os.getenv("PYAEDT_SERVER_AEDT_PATH")
+                    if edb_path:
+                        self.base_path = edb_path
+                        sys.path.append(edb_path)
+                        os.environ[env_value(self.edbversion)] = self.base_path
+            if is_ironpython:
+                _clr.AddReferenceToFile("Ansys.Ansoft.Edb.dll")
+                _clr.AddReferenceToFile("Ansys.Ansoft.EdbBuilderUtils.dll")
+                _clr.AddReferenceToFileAndPath(os.path.join(self.base_path, "Ansys.Ansoft.SimSetupData.dll"))
+            else:
+                _clr.AddReference("Ansys.Ansoft.Edb")
+                _clr.AddReference("Ansys.Ansoft.EdbBuilderUtils")
+                _clr.AddReference("Ansys.Ansoft.SimSetupData")
+        else:
+            if settings.edb_dll_path:
+                self.base_path = settings.edb_dll_path
+            elif self.student_version:
+                self.base_path = env_path_student(self.edbversion)
+            else:
+                self.base_path = env_path(self.edbversion)
+            sys.path.append(self.base_path)
+            _clr.AddReference("Ansys.Ansoft.Edb")
+            _clr.AddReference("Ansys.Ansoft.EdbBuilderUtils")
+            _clr.AddReference("Ansys.Ansoft.SimSetupData")
+        os.environ["ECAD_TRANSLATORS_INSTALL_DIR"] = self.base_path
+        oaDirectory = os.path.join(self.base_path, "common", "oa")
+        os.environ["ANSYS_OADIR"] = oaDirectory
+        os.environ["PATH"] = "{};{}".format(os.environ["PATH"], self.base_path)
+        edb = __import__("Ansys.Ansoft.Edb")
+        self.edb = edb.Ansoft.Edb
+        edbbuilder = __import__("Ansys.Ansoft.EdbBuilderUtils")
+        self.edbutils = edbbuilder.Ansoft.EdbBuilderUtils
+        self.simSetup = __import__("Ansys.Ansoft.SimSetupData")
+        self.simsetupdata = self.simSetup.Ansoft.SimSetupData.Data
 
     @property
-    def primary_sweep(self):
-        """Primary sweep.
+    def design_variables(self):
+        """Get all edb design variables.
 
-        Parameters
-        ----------
-        ps : float
-            Perimeter of the source.
+        Returns
+        -------
+        Dict[str, :class:`pyaedt.edb_core.edb_data.variables.Variable`]
         """
-        return self._primary_sweep
-
-    @primary_sweep.setter
-    def primary_sweep(self, ps):
-        if ps in self._sweeps_names:
-            self._primary_sweep = ps
+        d_var = dict()
+        for i in self.active_cell.GetVariableServer().GetAllVariableNames():
+            d_var[i] = Variable(self, i)
+        return d_var
 
     @property
-    def expressions(self):
-        """Expressions."""
-        if not self._expressions:
-            mydata = [i for i in self._nominal_variation.GetDataExpressions()]
-            self._expressions = list(dict.fromkeys(mydata))
-        return self._expressions
-
-    @pyaedt_function_handler()
-    def update_sweeps(self):
-        """Update sweeps.
+    def project_variables(self):
+        """Get all project variables.
 
         Returns
         -------
-        dict
-            Updated sweeps.
-        """
-
-        names = list(self.nominal_variation.GetSweepNames())
-        for data in self._original_data:
-            for v in data.GetDesignVariableNames():
-                if v not in self._sweeps_names:
-                    self._sweeps_names.append(v)
-        self._sweeps_names.extend((reversed(names)))
+        Dict[str, :class:`pyaedt.edb_core.edb_data.variables.Variable`]
 
-    @staticmethod
-    @pyaedt_function_handler()
-    def _quantity(unit):
         """
+        p_var = dict()
+        for i in self.db.GetVariableServer().GetAllVariableNames():
+            p_var[i] = Variable(self, i)
+        return p_var
 
-        Parameters
-        ----------
-        unit :
-
+    @property
+    def variables(self):
+        """Get all Edb variables.
 
         Returns
         -------
+        Dict[str, :class:`pyaedt.edb_core.edb_data.variables.Variable`]
 
         """
-        for el in AEDT_UNITS:
-            keys_units = [i.lower() for i in list(AEDT_UNITS[el].keys())]
-            if unit.lower() in keys_units:
-                return el
-        return None
+        all_vars = dict()
+        for i, j in self.project_variables.items():
+            all_vars[i] = j
+        for i, j in self.design_variables.items():
+            all_vars[i] = j
+        return all_vars
 
-    @pyaedt_function_handler()
-    def init_solutions_data(self):
-        "Initialize the database and store info in variables."
-        self._solutions_real = self._init_solution_data_real()
-        self._solutions_imag = self._init_solution_data_imag()
-        self._solutions_mag = self._init_solution_data_mag()
-        self._solutions_phase = self._init_solution_data_phase()
-
-    @pyaedt_function_handler()
-    def _init_solution_data_mag(self):
-        _solutions_mag = {}
-        self.units_data = {}
-
-        for expr in self.expressions:
-            _solutions_mag[expr] = {}
-            self.units_data[expr] = self.nominal_variation.GetDataUnits(expr)
-            if self.enable_pandas_output:
-                _solutions_mag[expr] = np.sqrt(
-                    self._solutions_real[expr]
-                    .mul(self._solutions_real[expr])
-                    .add(self._solutions_imag[expr].mul(self._solutions_imag[expr]))
-                )
-            else:
-                for i in self._solutions_real[expr]:
-                    _solutions_mag[expr][i] = abs(complex(self._solutions_real[expr][i], self._solutions_imag[expr][i]))
-        if self.enable_pandas_output:
-            return pd.DataFrame.from_dict(_solutions_mag)
-        else:
-            return _solutions_mag
-
-    @pyaedt_function_handler()
-    def _init_solution_data_real(self):
-        """ """
-        sols_data = {}
-
-        for expression in self.expressions:
-            solution_Data = {}
-
-            for data, comb in zip(self._original_data, self.variations):
-                solution = list(data.GetRealDataValues(expression, False))
-                values = []
-                for el in list(self.intrinsics.keys()):
-                    values.append(list(OrderedDict.fromkeys(data.GetSweepValues(el, False))))
-
-                i = 0
-                c = [comb[v] for v in list(comb.keys())]
-                for t in itertools.product(*values):
-                    solution_Data[tuple(c + list(t))] = solution[i]
-                    i += 1
-            sols_data[expression] = solution_Data
-        if self.enable_pandas_output:
-            return pd.DataFrame.from_dict(sols_data)
-        else:
-            return sols_data
-
-    @pyaedt_function_handler()
-    def _init_solution_data_imag(self):
-        """ """
-        sols_data = {}
-
-        for expression in self.expressions:
-            solution_Data = {}
-            for data, comb in zip(self._original_data, self.variations):
-                if data.IsDataComplex(expression):
-                    solution = list(data.GetImagDataValues(expression, False))
-                else:
-                    l = len(list(data.GetRealDataValues(expression, False)))
-                    solution = [0] * l
-                values = []
-                for el in list(self.intrinsics.keys()):
-                    values.append(list(OrderedDict.fromkeys(data.GetSweepValues(el, False))))
-                i = 0
-                c = [comb[v] for v in list(comb.keys())]
-                for t in itertools.product(*values):
-                    solution_Data[tuple(c + list(t))] = solution[i]
-                    i += 1
-            sols_data[expression] = solution_Data
-        if self.enable_pandas_output:
-            return pd.DataFrame.from_dict(sols_data)
-        else:
-            return sols_data
-
-    @pyaedt_function_handler()
-    def _init_solution_data_phase(self):
-        data_phase = {}
-        for expr in self.expressions:
-            data_phase[expr] = {}
-            if self.enable_pandas_output:
-                data_phase[expr] = np.arctan2(self._solutions_imag[expr], self._solutions_real[expr])
+    @property
+    def excitations(self):
+        """Get all layout excitations."""
+        terms = [term for term in list(self._active_layout.Terminals) if int(term.GetBoundaryType()) == 0]
+        terms = [i for i in terms if not i.IsReferenceTerminal()]
+        temp = {}
+        for ter in terms:
+            if "BundleTerminal" in ter.GetType().ToString():
+                temp[ter.GetName()] = ExcitationDifferential(self, ter)
             else:
-                for i in self._solutions_real[expr]:
-                    data_phase[expr][i] = math.atan2(self._solutions_imag[expr][i], self._solutions_real[expr][i])
-        if self.enable_pandas_output:
-            return pd.DataFrame.from_dict(data_phase)
-        else:
-            return data_phase
+                temp[ter.GetName()] = ExcitationPorts(self, ter)
+        return temp
 
     @property
-    def full_matrix_real_imag(self):
-        """Get the full available solution data in Real and Imaginary parts.
+    def excitations_nets(self):
+        """Get all excitations net names."""
+        return list(set([i.GetNet().GetName() for i in list(self._active_layout.Terminals)]))
 
-        Returns
-        -------
-        tuple of dicts
-            (Real Dict, Imag Dict)
-        """
-        return self._solutions_real, self._solutions_imag
+    @property
+    def sources(self):
+        """Get all layout sources."""
+        terms = [term for term in list(self._active_layout.Terminals) if int(term.GetBoundaryType()) in [3, 4, 7]]
+        return {ter.GetName(): ExcitationSources(self, ter) for ter in terms}
 
     @property
-    def full_matrix_mag_phase(self):
-        """Get the full available solution data magnitude and phase in radians.
+    def probes(self):
+        """Get all layout sources."""
+        terms = [term for term in list(self._active_layout.Terminals) if int(term.GetBoundaryType()) in [8]]
+        return {ter.GetName(): ExcitationProbes(self, ter) for ter in terms}
+
+    @pyaedt_function_handler()
+    def open_edb(self, init_dlls=False):
+        """Open EDB.
+
+        Parameters
+        ----------
+        init_dlls : bool, optional
+            Whether to initialize DLLs. The default is ``False``.
 
         Returns
         -------
-        tuple of dicts
-            (Mag Dict, Phase Dict).
-        """
-        return self._solutions_mag, self._solutions_phase
 
-    @staticmethod
-    @pyaedt_function_handler()
-    def to_degrees(input_list):
-        """Convert an input list from radians to degrees.
+        """
+        if init_dlls:
+            self._init_dlls()
+        self.logger.info("EDB Path %s", self.edbpath)
+        self.logger.info("EDB Version %s", self.edbversion)
+        self.edb.Database.SetRunAsStandAlone(self.standalone)
+        self.logger.info("EDB Standalone %s", self.standalone)
+        try:
+            db = self.edb.Database.Open(self.edbpath, self.isreadonly)
+        except Exception as e:
+            db = None
+            self.logger.error("Builder is not Initialized.")
+        if not db:
+            self.logger.warning("Error Opening db")
+            self._db = None
+            self._active_cell = None
+            self.builder = None
+            return None
+        self._db = db
+        self.logger.info("Database Opened")
+
+        self._active_cell = None
+        if self.cellname:
+            for cell in list(self._db.TopCircuitCells):
+                if cell.GetName() == self.cellname:
+                    self._active_cell = cell
+        # if self._active_cell is still None, set it to default cell
+        if self._active_cell is None:
+            self._active_cell = list(self._db.TopCircuitCells)[0]
+        self.logger.info("Cell %s Opened", self._active_cell.GetName())
+        if self._db and self._active_cell:
+            self.builder = EdbBuilder(self.edbutils, self._db, self._active_cell)
+            self._init_objects()
+            self.logger.info("Builder was initialized.")
+        else:
+            self.builder = None
+            self.logger.error("Builder was not initialized.")
+
+        return self.builder
+
+    @pyaedt_function_handler()
+    def open_edb_inside_aedt(self, init_dlls=False):
+        """Open EDB inside of AEDT.
 
         Parameters
         ----------
-        input_list : list
-            List of inputs in radians.
+        init_dlls : bool, optional
+            Whether to initialize DLLs. The default is ``False``.
 
         Returns
         -------
-        list
-            List of inputs in degrees.
 
         """
-        if isinstance(input_list, (tuple, list)):
-            return [i * 360 / (2 * math.pi) for i in input_list]
-        else:
-            return input_list * 360 / (2 * math.pi)
+        if init_dlls:
+            self._init_dlls()
+        self.logger.info("Opening EDB from HDL")
+        self.edb.Database.SetRunAsStandAlone(False)
+        if self.oproject.GetEDBHandle():
+            hdl = Convert.ToUInt64(self.oproject.GetEDBHandle())
+            db = self.edb.Database.Attach(hdl)
+            if not db:
+                self.logger.warning("Error getting the database.")
+                self._db = None
+                self._active_cell = None
+                self.builder = None
+                return None
+            self._db = db
+            self._active_cell = self.edb.Cell.Cell.FindByName(
+                self.db, self.edb.Cell.CellType.CircuitCell, self.cellname
+            )
+            if self._active_cell is None:
+                self._active_cell = list(self._db.TopCircuitCells)[0]
+            if self._db and self._active_cell:
+                if not os.path.exists(self.edbpath):
+                    os.makedirs(self.edbpath)
+                time.sleep(3)
+                self.builder = EdbBuilder(self.edbutils, self._db, self._active_cell)
+                self._init_objects()
+                return self.builder
+            else:
+                self.builder = None
+                return None
+        else:
+            self._db = None
+            self._active_cell = None
+            self.builder = None
+            return None
+
+    @pyaedt_function_handler()
+    def create_edb(self, init_dlls=False):
+        """Create EDB.
+
+        Parameters
+        ----------
+        init_dlls : bool, optional
+            Whether to initialize DLLs. The default is ``False``.
+
+        """
+        if init_dlls:
+            self._init_dlls()
+        self.edb.Database.SetRunAsStandAlone(self.standalone)
+        db = self.edb.Database.Create(self.edbpath)
+        if not db:
+            self.logger.warning("Error creating the database.")
+            self._db = None
+            self._active_cell = None
+            self.builder = None
+            return None
+        self._db = db
+        if not self.cellname:
+            self.cellname = generate_unique_name("Cell")
+        self._active_cell = self.edb.Cell.Cell.Create(self._db, self.edb.Cell.CellType.CircuitCell, self.cellname)
+        if self._db and self._active_cell:
+            self.builder = EdbBuilder(self.edbutils, self._db, self._active_cell)
+            self._init_objects()
+            return self.builder
+        self.builder = None
+        return None
 
-    @staticmethod
     @pyaedt_function_handler()
-    def to_radians(input_list):
-        """Convert an input list from degrees to radians.
+    def import_layout_pcb(
+        self, input_file, working_dir, init_dlls=False, anstranslator_full_path="", use_ppe=False, control_file=None
+    ):
+        """Import a board file and generate an ``edb.def`` file in the working directory.
+
+        This function supports all AEDT formats, including DXF, GDS, SML (IPC2581), BRD, and TGZ.
 
         Parameters
         ----------
-        input_list : list
-            List of inputs in degrees.
+        input_file : str
+            Full path to the board file.
+        working_dir : str
+            Directory in which to create the ``aedb`` folder. The name given to the AEDB file
+            is the same as the name of the board file.
+        init_dlls : bool
+            Whether to initialize DLLs. The default is ``False``.
+        anstranslator_full_path : str, optional
+            Full path to the Ansys translator. The default is ``""``.
+        use_ppe : bool
+            Whether to use the PPE License. The default is ``False``.
+        control_file : str, optional
+            Path to the XML file. The default is ``None``, in which case an attempt is made to find
+            the XML file in the same directory as the board file. To succeed, the XML file and board file
+            must have the same name. Only the extension differs.
 
         Returns
         -------
-        type
-            List of inputs in radians.
-
+        str
+            Full path to the AEDB file.
         """
-        if isinstance(input_list, (tuple, list)):
-            return [i * 2 * math.pi / 360 for i in input_list]
-        else:
-            return input_list * 2 * math.pi / 360
+        self._components = None
+        self._core_primitives = None
+        self._stackup = None
+        self._padstack = None
+        self._siwave = None
+        self._hfss = None
+        self._nets = None
+        self._db = None
+        if init_dlls:
+            self._init_dlls()
+        aedb_name = os.path.splitext(os.path.basename(input_file))[0] + ".aedb"
+        if anstranslator_full_path and os.path.exists(anstranslator_full_path):
+            command = anstranslator_full_path
+        else:
+            command = os.path.join(self.base_path, "anstranslator")
+            if is_windows:
+                command += ".exe"
+
+        if not working_dir:
+            working_dir = os.path.dirname(input_file)
+        cmd_translator = [
+            command,
+            input_file,
+            os.path.join(working_dir, aedb_name),
+            "-l={}".format(os.path.join(working_dir, "Translator.log")),
+        ]
+        if not use_ppe:
+            cmd_translator.append("-ppe=false")
+        if control_file and input_file[-3:] not in ["brd"]:
+            if is_linux:
+                cmd_translator.append("-c={}".format(control_file))
+            else:
+                cmd_translator.append('-c="{}"'.format(control_file))
+        p = subprocess.Popen(cmd_translator)
+        p.wait()
+        if not os.path.exists(os.path.join(working_dir, aedb_name)):
+            self.logger.error("Translator failed to translate.")
+            return False
+        self.edbpath = os.path.join(working_dir, aedb_name)
+        self.open_edb()
 
     @pyaedt_function_handler()
-    def _variation_tuple(self):
-        temp = []
-        for it in self._sweeps_names:
-            try:
-                temp.append(self.active_variation[it])
-            except KeyError:
-                temp.append(self.active_intrinsic[it])
-        return temp
+    def export_to_ipc2581(self, ipc_path=None, units="MILLIMETER"):
+        """Create an XML IPC2581 file from the active EDB.
 
-    @pyaedt_function_handler()
-    def data_magnitude(self, expression=None, convert_to_SI=False):
-        """Retrieve the data magnitude of an expression.
+        .. note::
+           The method works only in CPython because of some limitations on Ironpython in XML parsing and
+           because it's time-consuming.
+           This method is still being tested and may need further debugging.
+           Any feedback is welcome. Backdrills and custom pads are not supported yet.
 
         Parameters
         ----------
-        expression : str, optional
-            Name of the expression. The default is ``None``, in which case the
-            active expression is used.
-        convert_to_SI : bool, optional
-            Whether to convert the data to the SI unit system.
-            The default is ``False``.
+        ipc_path : str, optional
+            Path to the XML IPC2581 file. The default is ``None``, in which case
+            an attempt is made to find the XML IPC2581 file in the same directory
+            as the active EDB. To succeed, the XML IPC2581 file and the active
+            EDT must have the same name. Only the extension differs.
+        units : str, optional
+            Units of the XML IPC2581 file. Options are ``"millimeter"``,
+            ``"inch"``, and ``"micron"``. The default is ``"millimeter"``.
 
         Returns
         -------
-        list
-            List of data.
-
+        bool
+            ``True`` if successful, ``False`` if failed.
         """
-        if not expression:
-            expression = self.active_expression
-        elif expression not in self.expressions:
+        if is_ironpython:  # pragma no cover
+            self.logger.error("This method is not supported in Ironpython")
             return False
-        temp = self._variation_tuple()
-        solution_Data = self._solutions_mag[expression]
-        sol = []
-        position = list(self._sweeps_names).index(self.primary_sweep)
-        sw = self.variation_values(self.primary_sweep)
-        for el in sw:
-            temp[position] = el
-            try:
-                sol.append(solution_Data[tuple(temp)])
-            except KeyError:
-                sol.append(None)
-        if convert_to_SI and self._quantity(self.units_data[expression]):
-            sol = self._convert_list_to_SI(
-                sol, self._quantity(self.units_data[expression]), self.units_data[expression]
-            )
-        if self.enable_pandas_output:
-            return pd.Series(sol)
-        return sol
+        if units.lower() not in ["millimeter", "inch", "micron"]:  # pragma no cover
+            self.logger.warning("The wrong unit is entered. Setting to the default, millimeter.")
+            units = "millimeter"
+
+        if not ipc_path:
+            ipc_path = self.edbpath[:-4] + "xml"
+        self.logger.info("Export IPC 2581 is starting. This operation can take a while.")
+        start = time.time()
+        ipc = Ipc2581(self, units)
+        ipc.load_ipc_model()
+        ipc.file_path = ipc_path
+        result = ipc.write_xml()
+
+        if result:  # pragma no cover
+            self.logger.info_timer("Export IPC 2581 completed.", start)
+            self.logger.info("File saved as %s", ipc_path)
+            return ipc_path
+        self.logger.info("Error exporting IPC 2581.")
+        return False
 
-    @staticmethod
-    @pyaedt_function_handler()
-    def _convert_list_to_SI(datalist, dataunits, units):
-        """Convert a data list to the SI unit system.
+    def edb_exception(self, ex_value, tb_data):
+        """Write the trace stack to AEDT when a Python error occurs.
 
         Parameters
         ----------
-        datalist : list
-           List of data to convert.
-        dataunits :
+        ex_value :
 
-        units :
+        tb_data :
 
 
         Returns
         -------
-        list
-           List of the data converted to the SI unit system.
 
         """
-        sol = datalist
-        if dataunits in AEDT_UNITS and units in AEDT_UNITS[dataunits]:
-            sol = [i * AEDT_UNITS[dataunits][units] for i in datalist]
-        return sol
+        tb_trace = traceback.format_tb(tb_data)
+        tblist = tb_trace[0].split("\n")
+        self.logger.error(str(ex_value))
+        for el in tblist:
+            self.logger.error(el)
 
-    @pyaedt_function_handler()
-    def data_db(self, expression=None, convert_to_SI=False):
-        """Retrieve the data in the database for an expression and convert in db10.
+    @property
+    def db(self):
+        """Database object."""
+        return self._db
 
-        .. deprecated:: 0.4.8
-           Use :func:`data_db10` instead.
+    @property
+    def active_cell(self):
+        """Active cell."""
+        return self._active_cell
 
-        Parameters
-        ----------
-        expression : str, optional
-            Name of the expression. The default is ``None``,
-            in which case the active expression is used.
-        convert_to_SI : bool, optional
-            Whether to convert the data to the SI unit system.
-            The default is ``False``.
+    @property
+    def core_components(self):  # pragma: no cover
+        """Edb Components methods and properties.
+
+        .. deprecated:: 0.6.62
+           Use new property :func:`components` instead.
 
         Returns
         -------
-        list
-            List of the data in the database for the expression.
+        Instance of :class:`pyaedt.edb_core.Components.Components`
 
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> comp = self.edbapp.components.get_component_by_name("J1")
         """
-        if not expression:
-            expression = self.active_expression
-        if self.enable_pandas_output:
-            return 10 * np.log10(self.data_magnitude(expression, convert_to_SI))
-        return [db10(i) for i in self.data_magnitude(expression, convert_to_SI)]
-
-    @pyaedt_function_handler()
-    def data_db10(self, expression=None, convert_to_SI=False):
-        """Retrieve the data in the database for an expression and convert in db10.
+        warnings.warn("Use new property :func:`components` instead.", DeprecationWarning)
+        return self.components
 
-        Parameters
-        ----------
-        expression : str, optional
-            Name of the expression. The default is ``None``,
-            in which case the active expression is used.
-        convert_to_SI : bool, optional
-            Whether to convert the data to the SI unit system.
-            The default is ``False``.
+    @property
+    def components(self):
+        """Edb Components methods and properties.
 
         Returns
         -------
-        list
-            List of the data in the database for the expression.
+        :class:`pyaedt.edb_core.Components.Components`
 
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> comp = self.edbapp.components.get_component_by_name("J1")
         """
-        if not expression:
-            expression = self.active_expression
-        if self.enable_pandas_output:
-            return 10 * np.log10(self.data_magnitude(expression, convert_to_SI))
-        return [db10(i) for i in self.data_magnitude(expression, convert_to_SI)]
+        if not self._components and self.builder:
+            self._components = Components(self)
+        return self._components
 
-    @pyaedt_function_handler()
-    def data_db20(self, expression=None, convert_to_SI=False):
-        """Retrieve the data in the database for an expression and convert in db20.
+    @property
+    def core_stackup(self):
+        """Core stackup.
 
-        Parameters
-        ----------
-        expression : str, optional
-            Name of the expression. The default is ``None``,
-            in which case the active expression is used.
-        convert_to_SI : bool, optional
-            Whether to convert the data to the SI unit system.
-            The default is ``False``.
+        .. deprecated:: 0.6.5
+            There is no need to use the ``core_stackup`` property anymore.
+            You can instantiate a new ``stackup`` class directly from the ``Edb`` class.
+        """
+        mess = "`core_stackup` is deprecated.\n"
+        mess += " Use `app.stackup` directly to instantiate new stackup methods."
+        warnings.warn(mess, DeprecationWarning)
+        if not self._stackup and self.builder:
+            self._stackup = Stackup(self)
+        return self._stackup
+
+    @property
+    def design_options(self):
+        """Edb Design Settings and Options.
 
         Returns
         -------
-        list
-            List of the data in the database for the expression.
-
+        Instance of :class:`pyaedt.edb_core.edb_data.design_options.EdbDesignOptions`
         """
-        if not expression:
-            expression = self.active_expression
-        if self.enable_pandas_output:
-            return 20 * np.log10(self.data_magnitude(expression, convert_to_SI))
-        return [db20(i) for i in self.data_magnitude(expression, convert_to_SI)]
-
-    @pyaedt_function_handler()
-    def data_phase(self, expression=None, radians=True):
-        """Retrieve the phase part of the data for an expression.
+        return EdbDesignOptions(self.active_cell)
 
-        Parameters
-        ----------
-        expression : str, None
-            Name of the expression. The default is ``None``,
-            in which case the active expression is used.
-        radians : bool, optional
-            Whether to convert the data into radians or degree.
-            The default is ``True`` for radians.
+    @property
+    def stackup(self):
+        """Stackup manager.
 
         Returns
         -------
-        list
-            Phase data for the expression.
+        Instance of :class: 'pyaedt.edb_core.Stackup`
 
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> edbapp.stackup.layers["TOP"].thickness = 4e-5
+        >>> edbapp.stackup.layers["TOP"].thickness == 4e-05
+        >>> edbapp.stackup.add_layer("Diel", "GND", layer_type="dielectric", thickness="0.1mm", material="FR4_epoxy")
         """
-        if not expression:
-            expression = self.active_expression
-        coefficient = 1
-        if not radians:
-            coefficient = 180 / math.pi
-        if self.enable_pandas_output:
-            return coefficient * np.arctan2(self.data_imag(expression), self.data_real(expression))
-        return [coefficient * math.atan2(k, i) for i, k in zip(self.data_real(expression), self.data_imag(expression))]
+        if not self._stackup2 and self.builder:
+            self._stackup2 = Stackup(self)
+        return self._stackup2
 
     @property
-    def primary_sweep_values(self):
-        """Retrieve the primary sweep for a given data and primary variable.
+    def materials(self):
+        """Material Database.
 
         Returns
         -------
-        list
-            List of the primary sweep valid points for the expression.
+        Instance of :class: `pyaedt.edb_core.Materials`
 
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> edbapp.materials["FR4_epoxy"].conductivity = 1
+        >>> edbapp.materials.add_debye_material("My_Debye2", 5, 3, 0.02, 0.05, 1e5, 1e9)
+        >>> edbapp.materials.add_djordjevicsarkar_material("MyDjord2", 3.3, 0.02, 3.3)
         """
-        if self.enable_pandas_output:
-            return pd.Series(self.variation_values(self.primary_sweep))
-        return self.variation_values(self.primary_sweep)
+
+        if not self._materials and self.builder:
+            self._materials = Materials(self)
+        return self._materials
 
     @property
-    def primary_sweep_variations(self):
-        """Retrieve the variations lists for a given primary variable.
+    def core_padstack(self):  # pragma: no cover
+        """Core padstack.
+
+
+        .. deprecated:: 0.6.62
+           Use new property :func:`padstacks` instead.
 
         Returns
         -------
-        list
-            List of the primary sweep valid points for the expression.
+        Instance of :class: `pyaedt.edb_core.padstack.EdbPadstack`
 
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> p = edbapp.padstacks.create(padstackname="myVia_bullet", antipad_shape="Bullet")
+        >>> edbapp.padstacks.get_pad_parameters(
+        >>> ... p, "TOP", self.edbapp.padstacks.pad_type.RegularPad
+        >>> ... )
         """
-        expression = self.active_expression
-        temp = self._variation_tuple()
 
-        solution_Data = list(self._solutions_real[expression].keys())
-        sol = []
-        position = list(self._sweeps_names).index(self.primary_sweep)
-
-        for el in self.primary_sweep_values:
-            temp[position] = el
-            if tuple(temp) in solution_Data:
-                sol_dict = OrderedDict({})
-                i = 0
-                for sn in self._sweeps_names:
-                    sol_dict[sn] = temp[i]
-                    i += 1
-                sol.append(sol_dict)
-            else:
-                sol.append(None)
-        if self.enable_pandas_output:
-            return pd.Series(sol)
-        return sol
+        warnings.warn("Use new property :func:`padstacks` instead.", DeprecationWarning)
+        return self.padstacks
 
-    @pyaedt_function_handler()
-    def data_real(self, expression=None, convert_to_SI=False):
-        """Retrieve the real part of the data for an expression.
+    @property
+    def padstacks(self):
+        """Core padstack.
 
-        Parameters
-        ----------
-        expression : str, None
-            Name of the expression. The default is ``None``,
-            in which case the active expression is used.
-        convert_to_SI : bool, optional
-            Whether to convert the data to the SI unit system.
-            The default is ``False``.
 
         Returns
         -------
-        list
-            List of the real data for the expression.
+        Instance of :class: `pyaedt.edb_core.padstack.EdbPadstack`
 
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> p = edbapp.padstacks.create(padstackname="myVia_bullet", antipad_shape="Bullet")
+        >>> edbapp.padstacks.get_pad_parameters(
+        >>> ... p, "TOP", self.edbapp.padstacks.pad_type.RegularPad
+        >>> ... )
         """
-        if not expression:
-            expression = self.active_expression
-        temp = self._variation_tuple()
 
-        solution_Data = self._solutions_real[expression]
-        sol = []
-        position = list(self._sweeps_names).index(self.primary_sweep)
+        if not self._padstack and self.builder:
+            self._padstack = EdbPadstacks(self)
+        return self._padstack
 
-        for el in self.primary_sweep_values:
-            temp[position] = el
-            try:
-                sol.append(solution_Data[tuple(temp)])
-            except KeyError:
-                sol.append(None)
-
-        if convert_to_SI and self._quantity(self.units_data[expression]):
-            sol = self._convert_list_to_SI(
-                sol, self._quantity(self.units_data[expression]), self.units_data[expression]
-            )
-        if self.enable_pandas_output:
-            return pd.Series(sol)
-        return sol
+    @property
+    def core_siwave(self):  # pragma: no cover
+        """Core SIWave methods and properties.
 
-    @pyaedt_function_handler()
-    def data_imag(self, expression=None, convert_to_SI=False):
-        """Retrieve the imaginary part of the data for an expression.
+        .. deprecated:: 0.6.62
+           Use new property :func:`siwave` instead.
 
-        Parameters
-        ----------
-        expression : str, optional
-            Name of the expression. The default is ``None``,
-            in which case the active expression is used.
-        convert_to_SI : bool, optional
-            Whether to convert the data to the SI unit system.
-            The default is ``False``.
+        Returns
+        -------
+        Instance of :class: `pyaedt.edb_core.siwave.EdbSiwave`
+
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> p2 = edbapp.siwave.create_circuit_port_on_net("U2A5", "V3P3_S0", "U2A5", "GND", 50, "test")
+        """
+        warnings.warn("Use new property :func:`siwave` instead.", DeprecationWarning)
+        return self.siwave
+
+    @property
+    def siwave(self):
+        """Core SIWave methods and properties.
 
         Returns
         -------
-        list
-            List of the imaginary data for the expression.
+        Instance of :class: `pyaedt.edb_core.siwave.EdbSiwave`
 
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> p2 = edbapp.siwave.create_circuit_port_on_net("U2A5", "V3P3_S0", "U2A5", "GND", 50, "test")
         """
-        if not expression:
-            expression = self.active_expression
-        temp = self._variation_tuple()
-
-        solution_Data = self._solutions_imag[expression]
-        sol = []
-        position = list(self._sweeps_names).index(self.primary_sweep)
-        for el in self.primary_sweep_values:
-            temp[position] = el
-            try:
-                sol.append(solution_Data[tuple(temp)])
-            except KeyError:
-                sol.append(None)
-        if convert_to_SI and self._quantity(self.units_data[expression]):
-            sol = self._convert_list_to_SI(
-                sol, self._quantity(self.units_data[expression]), self.units_data[expression]
-            )
-        if self.enable_pandas_output:
-            return pd.Series(sol)
-        return sol
+        if not self._siwave and self.builder:
+            self._siwave = EdbSiwave(self)
+        return self._siwave
 
-    @pyaedt_function_handler()
-    def is_real_only(self, expression=None):
-        """Check if the expression has only real values or not.
+    @property
+    def core_hfss(self):  # pragma: no cover
+        """Core HFSS methods and properties.
 
-        Parameters
-        ----------
-        expression : str, optional
-            Name of the expression. The default is ``None``,
-            in which case the active expression is used.
+        .. deprecated:: 0.6.62
+           Use new property :func:`hfss` instead.
 
         Returns
         -------
-        bool
-            ``True`` if the Solution Data for specific expression contains only real values.
-        """
-        if not expression:
-            expression = self.active_expression
-        if self.enable_pandas_output:
-            return True if self._solutions_imag[expression].abs().sum() > 0.0 else False
-        for v in list(self._solutions_imag[expression].values()):
-            if float(v) != 0.0:
-                return False
-        return True
+        Instance of :class:`pyaedt.edb_core.hfss.EdbHfss`
 
-    @pyaedt_function_handler()
-    def export_data_to_csv(self, output, delimiter=";"):
-        """Save to output csv file the Solution Data.
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> edbapp.hfss.configure_hfss_analysis_setup(sim_config)
+        """
+        warnings.warn("Use new property :func:`hfss` instead.", DeprecationWarning)
+        return self.hfss
 
-        Parameters
-        ----------
-        output : str,
-            Full path to csv file.
-        delimiter : str,
-            CSV Delimiter. Default is ``";"``.
+    @property
+    def hfss(self):
+        """Core HFSS methods and properties.
 
         Returns
         -------
-        bool
+        :class:`pyaedt.edb_core.hfss.EdbHfss`
+
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> edbapp.hfss.configure_hfss_analysis_setup(sim_config)
         """
-        header = [el for el in self._sweeps_names]
-        for el in self.expressions:
-            if not self.is_real_only(el):
-                header.append(el + " (Real)")
-                header.append(el + " (Imag)")
-            else:
-                header.append(el)
-
-        list_full = [header]
-        for e, v in self._solutions_real[self.active_expression].items():
-            list_full.append(list(e))
-        for el in self.expressions:
-            i = 1
-            for e, v in self._solutions_real[el].items():
-                list_full[i].extend([v])
-                i += 1
-            i = 1
-            if not self.is_real_only(el):
-                for e, v in self._solutions_imag[el].items():
-                    list_full[i].extend([v])
-                    i += 1
+        if not self._hfss and self.builder:
+            self._hfss = EdbHfss(self)
+        return self._hfss
 
-        return write_csv(output, list_full, delimiter=delimiter)
+    @property
+    def core_nets(self):  # pragma: no cover
+        """Core nets.
 
-    @pyaedt_function_handler()
-    def plot(
-        self,
-        curves=None,
-        math_formula=None,
-        size=(2000, 1000),
-        show_legend=True,
-        xlabel="",
-        ylabel="",
-        title="",
-        snapshot_path=None,
-        is_polar=False,
-    ):
-        """Create a matplotlib plot based on a list of data.
+        .. deprecated:: 0.6.62
+           Use new property :func:`nets` instead.
 
-        Parameters
-        ----------
-        curves : list
-            Curves to be plotted. If None, the first curve will be plotted.
-        math_formula : str , optional
-            Mathematical formula to apply to the plot curve.
-            Valid values are `"re"`, `"im"`, `"db20"`, `"db10"`, `"abs"`, `"mag"`, `"phasedeg"`, `"phaserad"`.
-            `None` value will plot only real value of the data stored in solution data.
-        size : tuple, optional
-            Image size in pixel (width, height).
-        show_legend : bool
-            Either to show legend or not. Flag will be ignored if number of curves to plot is greater than 15.
-        xlabel : str
-            Plot X label.
-        ylabel : str
-            Plot Y label.
-        title : str
-            Plot Title label.
-        snapshot_path : str
-            Full path to image file if a snapshot is needed.
-        is_polar : bool, optional
-            Set to `True` if this is a polar plot.
-
-        Returns
-        -------
-        :class:`matplotlib.plt`
-            Matplotlib fig object.
-        """
-        if is_ironpython:
-            return False  # pragma: no cover
-        if not curves:
-            curves = [self.active_expression]
-        if isinstance(curves, str):
-            curves = [curves]
-        data_plot = []
-        sweep_name = self.primary_sweep
-        if is_polar:
-            sw = self.to_radians(self.primary_sweep_values)
-        else:
-            sw = self.primary_sweep_values
-        for curve in curves:
-            if not math_formula:
-                data_plot.append([sw, self.data_real(curve), curve])
-            elif math_formula == "re":
-                data_plot.append([sw, self.data_real(curve), "{}({})".format(math_formula, curve)])
-            elif math_formula == "im":
-                data_plot.append([sw, self.data_imag(curve), "{}({})".format(math_formula, curve)])
-            elif math_formula == "db20":
-                data_plot.append([sw, self.data_db20(curve), "{}({})".format(math_formula, curve)])
-            elif math_formula == "db10":
-                data_plot.append([sw, self.data_db10(curve), "{}({})".format(math_formula, curve)])
-            elif math_formula == "mag":
-                data_plot.append([sw, self.data_magnitude(curve), "{}({})".format(math_formula, curve)])
-            elif math_formula == "phasedeg":
-                data_plot.append([sw, self.data_phase(curve, False), "{}({})".format(math_formula, curve)])
-            elif math_formula == "phaserad":
-                data_plot.append([sw, self.data_phase(curve, True), "{}({})".format(math_formula, curve)])
-        if not xlabel:
-            xlabel = sweep_name
-        if not ylabel:
-            ylabel = math_formula
-        if not title:
-            title = "Simulation Results Plot"
-        if len(data_plot) > 15:
-            show_legend = False
-        if is_polar:
-            return plot_polar_chart(data_plot, size, show_legend, xlabel, ylabel, title, snapshot_path)
-        else:
-            return plot_2d_chart(data_plot, size, show_legend, xlabel, ylabel, title, snapshot_path)
+        Returns
+        -------
+        :class:`pyaedt.edb_core.nets.EdbNets`
 
-    @pyaedt_function_handler()
-    def plot_3d(
-        self,
-        curve=None,
-        x_axis="Theta",
-        y_axis="Phi",
-        xlabel="",
-        ylabel="",
-        title="",
-        math_formula=None,
-        size=(2000, 1000),
-        snapshot_path=None,
-    ):
-        """Create a matplotlib 3d plot based on a list of data.
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> edbapp.nets.find_or_create_net("GND")
+        >>> edbapp.nets.find_and_fix_disjoint_nets("GND", keep_only_main_net=True)
+        """
+        warnings.warn("Use new property :func:`nets` instead.", DeprecationWarning)
+        return self.nets
 
-        Parameters
-        ----------
-        curve : str
-            Curve to be plotted. If None, the first curve will be plotted.
-        x_axis : str, optional
-            X Axis sweep. Default is `"Theta"`.
-        y_axis : str, optional
-            Y Axis sweep. Default is `"Phi"`.
-        math_formula : str , optional
-            Mathematical formula to apply to the plot curve.
-            Valid values are `"re"`, `"im"`, `"db20"`, `"db10"`, `"abs"`, `"mag"`, `"phasedeg"`, `"phaserad"`.
-        size : tuple, optional
-            Image size in pixel (width, height).
-        snapshot_path : str
-            Full path to image file if a snapshot is needed.
-        is_polar : bool, optional
-            Set to `True` if this is a polar plot.
-
-        Returns
-        -------
-        :class:`matplotlib.plt`
-            Matplotlib fig object.
-        """
-        if is_ironpython:
-            return False  # pragma: no cover
-        if not curve:
-            curve = self.active_expression
-
-        if not math_formula:
-            math_formula = "mag"
-        theta = self.variation_values(x_axis)
-        y_axis_val = self.variation_values(y_axis)
-
-        phi = []
-        r = []
-        for el in y_axis_val:
-            self.active_variation[y_axis] = el
-            phi.append(el * math.pi / 180)
-
-            if math_formula == "re":
-                r.append(self.data_real(curve))
-            elif math_formula == "im":
-                r.append(self.data_imag(curve))
-            elif math_formula == "db20":
-                r.append(self.data_db20(curve))
-            elif math_formula == "db10":
-                r.append(self.data_db10(curve))
-            elif math_formula == "mag":
-                r.append(self.data_magnitude(curve))
-            elif math_formula == "phasedeg":
-                r.append(self.data_phase(curve, False))
-            elif math_formula == "phaserad":
-                r.append(self.data_phase(curve, True))
-        active_sweep = self.active_intrinsic[self.primary_sweep]
-        position = self.variation_values(self.primary_sweep).index(active_sweep)
-        if len(self.variation_values(self.primary_sweep)) > 1:
-            new_r = []
-            for el in r:
-                new_r.append([el[position]])
-            r = new_r
-        data_plot = [theta, phi, r]
-        if not xlabel:
-            xlabel = x_axis
-        if not ylabel:
-            ylabel = y_axis
-        if not title:
-            title = "Simulation Results Plot"
-        return plot_3d_chart(data_plot, size, xlabel, ylabel, title, snapshot_path)
-
-    @pyaedt_function_handler()
-    def ifft(self, curve_header="NearE", u_axis="_u", v_axis="_v", window=False):
-        """Create IFFT of given complex data.
-
-        Parameters
-        ----------
-        curve_header : curve header. Solution data must contain 3 curves with X, Y and Z components of curve header.
-        u_axis : str, optional
-            U Axis name. Default is Hfss name "_u"
-        v_axis : str, optional
-            V Axis name. Default is Hfss name "_v"
-        window : bool, optional
-            Either if Hanning windowing has to be applied.
+    @property
+    def nets(self):
+        """Core nets.
 
         Returns
         -------
-        List
-            IFFT Matrix.
+        :class:`pyaedt.edb_core.nets.EdbNets`
+
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> edbapp.nets.find_or_create_net("GND")
+        >>> edbapp.nets.find_and_fix_disjoint_nets("GND", keep_only_main_net=True)
         """
-        if is_ironpython:
-            return False
-        u = self.variation_values(u_axis)
-        v = self.variation_values(v_axis)
 
-        freq = self.variation_values("Freq")
-        if self.enable_pandas_output:
-            E_realx = np.reshape(self._solutions_real[curve_header + "X"].copy().values, (len(freq), len(v), len(u)))
-            E_imagx = np.reshape(self._solutions_imag[curve_header + "X"].copy().values, (len(freq), len(v), len(u)))
-            E_realy = np.reshape(self._solutions_real[curve_header + "Y"].copy().values, (len(freq), len(v), len(u)))
-            E_imagy = np.reshape(self._solutions_imag[curve_header + "Y"].copy().values, (len(freq), len(v), len(u)))
-            E_realz = np.reshape(self._solutions_real[curve_header + "Z"].copy().values, (len(freq), len(v), len(u)))
-            E_imagz = np.reshape(self._solutions_imag[curve_header + "Z"].copy().values, (len(freq), len(v), len(u)))
-        else:
-            vals_real_Ex = [j for j in self._solutions_real[curve_header + "X"].values()]
-            vals_imag_Ex = [j for j in self._solutions_imag[curve_header + "X"].values()]
-            vals_real_Ey = [j for j in self._solutions_real[curve_header + "Y"].values()]
-            vals_imag_Ey = [j for j in self._solutions_imag[curve_header + "Y"].values()]
-            vals_real_Ez = [j for j in self._solutions_real[curve_header + "Z"].values()]
-            vals_imag_Ez = [j for j in self._solutions_imag[curve_header + "Z"].values()]
-
-            E_realx = np.reshape(vals_real_Ex, (len(freq), len(v), len(u)))
-            E_imagx = np.reshape(vals_imag_Ex, (len(freq), len(v), len(u)))
-            E_realy = np.reshape(vals_real_Ey, (len(freq), len(v), len(u)))
-            E_imagy = np.reshape(vals_imag_Ey, (len(freq), len(v), len(u)))
-            E_realz = np.reshape(vals_real_Ez, (len(freq), len(v), len(u)))
-            E_imagz = np.reshape(vals_imag_Ez, (len(freq), len(v), len(u)))
-
-        Temp_E_compx = E_realx + 1j * E_imagx  # Here is the complex FD data matrix, ready for transforming
-        Temp_E_compy = E_realy + 1j * E_imagy
-        Temp_E_compz = E_realz + 1j * E_imagz
-
-        E_compx = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
-        E_compy = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
-        E_compz = np.zeros((len(freq), len(v), len(u)), dtype="complex_")
-        if window:
-            timewin = np.hanning(len(freq))
-
-            for row in range(0, len(v)):
-                for col in range(0, len(u)):
-                    E_compx[:, row, col] = np.multiply(Temp_E_compx[:, row, col], timewin)
-                    E_compy[:, row, col] = np.multiply(Temp_E_compy[:, row, col], timewin)
-                    E_compz[:, row, col] = np.multiply(Temp_E_compz[:, row, col], timewin)
-        else:
-            E_compx = Temp_E_compx
-            E_compy = Temp_E_compy
-            E_compz = Temp_E_compz
-
-        E_time_x = np.fft.ifft(np.fft.fftshift(E_compx, 0), len(freq), 0, None)
-        E_time_y = np.fft.ifft(np.fft.fftshift(E_compy, 0), len(freq), 0, None)
-        E_time_z = np.fft.ifft(np.fft.fftshift(E_compz, 0), len(freq), 0, None)
-        E_time = np.zeros((np.size(freq), np.size(v), np.size(u)))
-        for i in range(0, len(freq)):
-            E_time[i, :, :] = np.abs(
-                np.sqrt(np.square(E_time_x[i, :, :]) + np.square(E_time_y[i, :, :]) + np.square(E_time_z[i, :, :]))
-            )
-        self._ifft = E_time
+        if not self._nets and self.builder:
+            self._nets = EdbNets(self)
+        return self._nets
 
-        return self._ifft
+    @property
+    def core_primitives(self):  # pragma: no cover
+        """Core primitives.
 
-    @pyaedt_function_handler()
-    def ifft_to_file(
-        self,
-        u_axis="_u",
-        v_axis="_v",
-        coord_system_center=None,
-        db_val=False,
-        num_frames=None,
-        csv_dir=None,
-        name_str="res_",
-    ):
-        """Save IFFT Matrix to a list of csv files (one per time step).
 
-        Parameters
-        ----------
-        u_axis : str, optional
-            U Axis name. Default is Hfss name "_u"
-        v_axis : str, optional
-            V Axis name. Default is Hfss name "_v"
-        coord_system_center : list, optional
-            List of UV GlobalCS Center.
-        db_val : bool, optional
-            Either if data has to be exported in db or not.
-        num_frames : int, optional
-            Number of frames to export.
-        csv_dir : str
-            Output path
-        name_str : str, optional
-            csv file header.
+        .. deprecated:: 0.6.62
+           Use new property :func:`modeler` instead.
 
         Returns
         -------
-        str
-            Path to file containing the list of csv files.
+        Instance of :class: `pyaedt.edb_core.layout.EdbLayout`
+
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> top_prims = edbapp.modeler.primitives_by_layer["TOP"]
         """
-        if not coord_system_center:
-            coord_system_center = [0, 0, 0]
-        t_matrix = self._ifft
-        x_c_list = self.variation_values(u_axis)
-        y_c_list = self.variation_values(v_axis)
-
-        adj_x = coord_system_center[0]
-        adj_y = coord_system_center[1]
-        adj_z = coord_system_center[2]
-        if num_frames:
-            frames = num_frames
-        else:
-            frames = t_matrix.shape[0]
-        csv_list = []
-        if os.path.exists(csv_dir):
-            files = [os.path.join(csv_dir, f) for f in os.listdir(csv_dir) if name_str in f and ".csv" in f]
-            for file in files:
-                os.remove(file)
-        else:
-            os.mkdir(csv_dir)
-
-        for frame in range(frames):
-            output = os.path.join(csv_dir, name_str + str(frame) + ".csv")
-            list_full = [["x", "y", "z", "val"]]
-            for i, y in enumerate(y_c_list):
-                for j, x in enumerate(x_c_list):
-                    y_coord = y + adj_y
-                    x_coord = x + adj_x
-                    z_coord = adj_z
-                    if db_val:
-                        val = 10.0 * np.log10(np.abs(t_matrix[frame, i, j]))
-                    else:
-                        val = t_matrix[frame, i, j]
-                    row_lst = [x_coord, y_coord, z_coord, val]
-                    list_full.append(row_lst)
-            write_csv(output, list_full, delimiter=",")
-            csv_list.append(output)
-
-        txt_file_name = csv_dir + "fft_list.txt"
-        textfile = open_file(txt_file_name, "w")
-
-        for element in csv_list:
-            textfile.write(element + "\n")
-        textfile.close()
-        return txt_file_name
+        warnings.warn("Use new property :func:`modeler` instead.", DeprecationWarning)
+        return self.modeler
 
+    @property
+    def modeler(self):
+        """Core primitives modeler.
 
-class FfdSolutionData(object):
-    """Contains Hfss Far Field Solution Data (ffd)."""
+        Returns
+        -------
+        Instance of :class: `pyaedt.edb_core.layout.EdbLayout`
 
-    def __init__(
-        self,
-        app,
-        sphere_name,
-        setup_name,
-        frequencies,
-        variations=None,
-        overwrite=True,
-        taper="flat",
-        sbr_3d_comp_name=None,
-    ):
-        self._app = app
-        self.levels = 64
-        self._native_indexes = []
-        self._port_indexes = {}
-        self.all_max = 1
-        self.sphere_name = sphere_name
-        self.setup_name = setup_name
-        self.sbr_comp = sbr_3d_comp_name
-        if not isinstance(frequencies, list):
-            self.frequencies = [frequencies]
-        else:
-            self.frequencies = frequencies
-        self._frequency = self.frequencies[0]
-        self.variations = variations
-        self.overwrite = overwrite
-        self._all_solutions = self._export_all_ffd()
-        self.ffd_dict = self._all_solutions[0]
-        self.lattice_vectors = self.get_lattice_vectors()
-        self.taper = taper
-        self.data_dict = {}
-        self._init_ffd()
-        self._phase_offset = [0] * len(self.all_port_names)
-
-    @pyaedt_function_handler()
-    def _init_ffd(self):
-        all_ports = list(self.ffd_dict.keys())
-        valid_ffd = True
-
-        if os.path.exists(self.ffd_dict[all_ports[0]]):
-            with open(self.ffd_dict[all_ports[0]], "r") as reader:
-                theta = [int(i) for i in reader.readline().split()]
-                phi = [int(i) for i in reader.readline().split()]
-            reader.close()
-            for port in self.ffd_dict.keys():
-                if ":" in port:
-                    port = port.split(":")[0]
-                temp_dict = {}
-                theta_range = np.linspace(*theta)
-                phi_range = np.linspace(*phi)
-                if os.path.exists(self.ffd_dict[port]):
-                    eep_txt = np.loadtxt(self.ffd_dict[port], skiprows=4)
-                    Etheta = np.vectorize(complex)(eep_txt[:, 0], eep_txt[:, 1])
-                    Ephi = np.vectorize(complex)(eep_txt[:, 2], eep_txt[:, 3])
-                    # eep=np.column_stack((etheta, ephi))
-                    temp_dict["Theta"] = theta_range
-                    temp_dict["Phi"] = phi_range
-                    temp_dict["rETheta"] = Etheta
-                    temp_dict["rEPhi"] = Ephi
-                    self.data_dict[port] = temp_dict
-                else:
-                    valid_ffd = False
-            if valid_ffd:
-                # differential area of sphere, based on observation angle
-                self.d_theta = np.abs(theta_range[1] - theta_range[0])
-                self.d_phi = np.abs(phi_range[1] - phi_range[0])
-                self.diff_area = np.radians(self.d_theta) * np.radians(self.d_phi) * np.sin(np.radians(theta_range))
-                self.num_samples = len(temp_dict["rETheta"])
-                self.all_port_names = list(self.data_dict.keys())
-                if self._native_indexes:
-                    i = 0
-                    for p in self.all_port_names:
-                        self._port_indexes[p] = self._native_indexes[i]
-                        i += 1
-                else:
-                    for p in self.all_port_names:
-                        self._port_indexes[p] = self.get_array_index(p)
-                self.solution_type = "DrivenModal"
-                self.unique_beams = None
-                self.renormalize = False
-                self.renormalize_dB = True
-                self.renorm_value = 1
-        else:
-            valid_ffd = False
-            self._app.logger.info("ERROR: Far Field Files are Missing")
-        self.valid_ffd = valid_ffd
-        self.Ax = float(self.lattice_vectors[0])
-        self.Ay = float(self.lattice_vectors[1])
-        self.Bx = float(self.lattice_vectors[3])
-        self.By = float(self.lattice_vectors[4])
-        self._phase_offset = [0] * len(self.all_port_names)
-        self._mag_offset = [1] * len(self.all_port_names)
-        self.beamform()
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> top_prims = edbapp.modeler.primitives_by_layer["TOP"]
+        """
+        if not self._core_primitives and self.builder:
+            self._core_primitives = EdbLayout(self)
+        return self._core_primitives
 
     @property
-    def frequency(self):
-        """Get/set the Active Frequency.
+    def active_layout(self):
+        """Active layout.
 
         Returns
         -------
-        float
+        Instance of :class: `pyaedt.`
         """
-        return self._frequency
+        self._active_layout = None
+        if self._active_cell:
+            self._active_layout = self.active_cell.GetLayout()
+        return self._active_layout
 
-    @frequency.setter
-    def frequency(self, val):
-        if val in self.frequencies:
-            self._frequency = val
-            self.ffd_dict = self._all_solutions[self.frequencies.index(val)]
-            self._init_ffd()
+    @property
+    def layout_instance(self):
+        """Edb Layout Instance."""
+        if not self._layout_instance:
+            self._layout_instance = self.active_layout.GetLayoutInstance()
+        return self._layout_instance
 
     @property
-    def phase_offset(self):
-        """Additional phase offset in degrees on each port. Useful when element has more than one port.
+    def pins(self):
+        """EDBPadstackInstance of Component.
+
+        .. deprecated:: 0.6.62
+           Use new method :func:`edb.padstacks.pins` instead.
 
         Returns
         -------
-        list
-        """
-        return self._phase_offset
+        dic[str, :class:`pyaedt.edb_core.edb_data.definitions.EDBPadstackInstance`]
+            Dictionary of EDBPadstackInstance Components.
 
-    @phase_offset.setter
-    def phase_offset(self, phases):
-        if len(phases) != len(self.all_port_names):
-            self._app.logger.error("Number of phases must be equal to number of ports")
-        else:
-            phases_to_rad = []
-            for phase in phases:
-                phases_to_rad.append(math.radians(phase))
-            self._phase_offset = phases_to_rad
-            self.beamform()
 
-    @property
-    def mag_offset(self):
-        """Additional magnitude on each port. Useful when element has more than one port.
+        Examples
+        --------
+        >>> edbapp = pyaedt.Edb("myproject.aedb")
+        >>> pin_net_name = edbapp.pins[424968329].netname
+        """
+        warnings.warn("Use new method :func:`edb.padstacks.pins` instead.", DeprecationWarning)
+        return self.padstacks.pins
+
+    class Boundaries:
+        """Boundaries Enumerator.
 
         Returns
         -------
-        list
+        int
         """
-        return self._mag_offset
 
-    @mag_offset.setter
-    def mag_offset(self, mags):
-        if len(mags) != len(self.all_port_names):
-            self._app.logger.error("Number of magnitude must be equal to number of ports")
-        else:
-            self._mag_offset = mags
-            self.beamform()
+        (Port, Pec, RLC, CurrentSource, VoltageSource, NexximGround, NexximPort, DcTerminal, VoltageProbe) = range(0, 9)
 
     @pyaedt_function_handler()
-    def get_array_index(self, port_name):
-        """Get index of a given port.
+    def edb_value(self, val):
+        """Convert a value to an EDB value. Value can be a string, float or integer. Mainly used in internal calls.
 
         Parameters
         ----------
-        port_name : str
+        val : str, float, int
+
 
         Returns
         -------
-        list of int
+        Instance of `Edb.Utility.Value`
+
         """
-        if self._port_indexes and port_name in self._port_indexes:
-            return self._port_indexes[port_name]
-        try:
-            str1 = port_name.split("[", 1)[1].split("]", 1)[0]
-            index_str = [int(i) for i in str1.split(",")]
-        except:
-            return [1, 1]
-        return index_str
+        if isinstance(val, (int, float)):
+            return self.edb.Utility.Value(val)
+        m1 = re.findall(r"(?<=[/+-/*//^/(/[])([a-z_A-Z/$]\w*)", str(val).replace(" ", ""))
+        m2 = re.findall(r"^([a-z_A-Z/$]\w*)", str(val).replace(" ", ""))
+        val_decomposed = list(set(m1).union(m2))
+        if not val_decomposed:
+            return self.edb.Utility.Value(val)
+        var_server_db = self.db.GetVariableServer()
+        var_names = var_server_db.GetAllVariableNames()
+        var_server_cell = self.active_cell.GetVariableServer()
+        var_names_cell = var_server_cell.GetAllVariableNames()
+        if set(val_decomposed).intersection(var_names_cell):
+            return self.edb.Utility.Value(val, var_server_cell)
+        if set(val_decomposed).intersection(var_names):
+            return self.edb.Utility.Value(val, var_server_db)
+        return self.edb.Utility.Value(val)
 
     @pyaedt_function_handler()
-    def array_min_max_values(self):
-        """Array bounding box.
+    def _is_file_existing_and_released(self, filename):
+        if os.path.exists(filename):
+            try:
+                os.rename(filename, filename + "_")
+                os.rename(filename + "_", filename)
+                return True
+            except OSError as e:
+                return False
+        else:
+            return False
+
+    @pyaedt_function_handler()
+    def _is_file_existing(self, filename):
+        if os.path.exists(filename):
+            return True
+        else:
+            return False
+
+    @pyaedt_function_handler()
+    def _wait_for_file_release(self, timeout=30, file_to_release=None):
+        if not file_to_release:
+            file_to_release = os.path.join(self.edbpath)
+        tstart = time.time()
+        while True:
+            if self._is_file_existing_and_released(file_to_release):
+                return True
+            elif time.time() - tstart > timeout:
+                return False
+            else:
+                time.sleep(0.250)
+
+    @pyaedt_function_handler()
+    def _wait_for_file_exists(self, timeout=30, file_to_release=None, wait_count=4):
+        if not file_to_release:
+            file_to_release = os.path.join(self.edbpath)
+        tstart = time.time()
+        times = 0
+        while True:
+            if self._is_file_existing(file_to_release):
+                # print 'File is released'
+                times += 1
+                if times == wait_count:
+                    return True
+            elif time.time() - tstart > timeout:
+                # print 'Timeout reached'
+                return False
+            else:
+                times = 0
+                time.sleep(0.250)
+
+    @pyaedt_function_handler()
+    def close_edb(self):
+        """Close EDB and cleanup variables.
 
         Returns
         -------
-        list of float
-        """
-        row_min = 1
-        row_max = 1
-        col_min = 1
-        col_max = 1
-        rows = []
-        cols = []
-        for portstring in self.all_port_names:
-            index_str = self.get_array_index(portstring)
-            rows.append(index_str[1])
-            cols.append(index_str[0])
+        bool
+            ``True`` when successful, ``False`` when failed.
 
-        row_min = np.min(rows)
-        row_max = np.max(rows)
-        col_min = np.min(cols)
-        col_max = np.max(cols)
-        return [col_min, col_max, row_min, row_max]
+        """
+        self._db.Close()
+        if self.log_name and settings.enable_local_log_file:
+            self._global_logger.remove_file_logger(os.path.splitext(os.path.split(self.log_name)[-1])[0])
+            self._logger = self._global_logger
+        time.sleep(2)
+        start_time = time.time()
+        self._wait_for_file_release()
+        elapsed_time = time.time() - start_time
+        self.logger.info("EDB file release time: {0:.2f}ms".format(elapsed_time * 1000.0))
+        self._clean_variables()
+        timeout = 4
+        time.sleep(2)
+        while gc.collect() != 0 and timeout > 0:
+            time.sleep(1)
+            timeout -= 1
+        return True
 
     @pyaedt_function_handler()
-    def array_center_and_edge(self):
-        """Find the center and edge of our array, assumes all ports in far field
-        mapping file are active ports.
+    def save_edb(self):
+        """Save the EDB file.
 
         Returns
         -------
         bool
+            ``True`` when successful, ``False`` when failed.
+
         """
-        AMax = 0
-        BMax = 0
-        RMax = 0
-        XMax = 0
-        YMax = 0
-        CenterA = 0
-        CenterB = 0
-        CenterX = 0
-        CenterY = 0
-
-        # collecting all active cells inside the specified region
-        activeCells = []
-
-        for i in range(0, len(self.all_port_names)):
-            index_str = self.get_array_index(self.all_port_names[i])
-            row = index_str[1]
-            col = index_str[0]
-            a = row
-            b = col
-
-            activeCells.append((a, b))  # because ffd is assuming all ffd files are active
-        if len(activeCells) == 0:
-            return
-
-        [a_min, a_max, b_min, b_max] = self.array_min_max_values()
-
-        CenterA = (a_min + a_max) / 2
-        CenterB = (b_min + b_max) / 2
-        CenterX = (CenterA + 0.5) * self.Ax + (CenterB + 0.5) * self.Bx
-        CenterY = (CenterA + 0.5) * self.Ay + (CenterB + 0.5) * self.By
-
-        self.CenterA = CenterA
-        self.CenterB = CenterB
-        self.CenterX = CenterX
-        self.CenterY = CenterY
-        # find the distance from the edge to the center
-        AMax = a_max - a_min
-        BMax = b_max - b_min
-
-        self.AMax = AMax
-        self.BMax = BMax
-        for a, b in activeCells:
-            x = (a + 0.5) * self.Ax + (b + 0.5) * self.Bx
-            y = (a + 0.5) * self.Ay + (b + 0.5) * self.By
-            x_dis = abs(x - CenterX)
-            y_dis = abs(y - CenterY)
-            distance = math.sqrt(x_dis**2 + y_dis**2)
-            XMax = max(XMax, x_dis)
-            YMax = max(YMax, y_dis)
-            RMax = max(RMax, distance)
-
-        self.RMax = RMax
-        self.XMax = XMax
-        self.YMax = YMax
-        self.RMax *= 2
-        self.XMax *= 2
-        self.YMax *= 2
+        self._db.Save()
         return True
 
     @pyaedt_function_handler()
-    def element_location(self, a, b):
-        """Element location in the array.
+    def save_edb_as(self, fname):
+        """Save the EDB file as another file.
 
         Parameters
         ----------
-        a : int
-        b : int
+        fname : str
+            Name of the new file to save to.
 
         Returns
         -------
-        list of float
-        """
-        a = int(a)
-        b = int(b)
+        bool
+            ``True`` when successful, ``False`` when failed.
 
-        x = (a + 0.5) * self.Ax + (b + 0.5) * self.Bx
-        y = (a + 0.5) * self.Ay + (b + 0.5) * self.By
-        x_dis = x - self.CenterX
-        y_dis = y - self.CenterY
+        """
+        self._db.SaveAs(fname)
+        self.edbpath = self._db.GetDirectory()
+        if self.log_name:
+            self._global_logger.remove_file_logger(os.path.splitext(os.path.split(self.log_name)[-1])[0])
+            self._logger = self._global_logger
 
-        return np.array([x_dis, y_dis, 0])
+        self.log_name = os.path.join(
+            os.path.dirname(fname), "pyaedt_" + os.path.splitext(os.path.split(fname)[-1])[0] + ".log"
+        )
+        if settings.enable_local_log_file:
+            self._logger = self._global_logger.add_file_logger(self.log_name, "Edb")
+        return True
 
     @pyaedt_function_handler()
-    def assign_weight(self, a, b, taper="flat", port_cont=0):
-        """Assign weight to array.
+    def execute(self, func):
+        """Execute a function.
 
         Parameters
         ----------
-        a : int
-            Inndex of array, column.
-        b : int
-            Inndex of array, row.
-        taper : string, optional
-            This is the type of taper we want to apply. The default is 'flat'.
-            It can be ``"cosine"``, ``"triangular"``, ``"hamming"`` or ``"flat"``.
+        func : str
+            Function to execute.
+
 
         Returns
         -------
-        float
-            Weight to applied to specific index of array.
-        """
-
-        a = int(a)
-        b = int(b)
-        if taper.lower() == "flat":  # Flat
-            return self.mag_offset[port_cont]
+        bool
+            ``True`` when successful, ``False`` when failed.
 
-        cosinePow = 1
-        edgeTaper_dB = -200
+        """
+        return self.edb.Utility.Command.Execute(func)
 
-        edgeTaper = 10 ** ((float(edgeTaper_dB)) / 20)
+    @pyaedt_function_handler()
+    def import_cadence_file(self, inputBrd, WorkDir=None, anstranslator_full_path="", use_ppe=False):
+        """Import a board file and generate an ``edb.def`` file in the working directory.
 
-        threshold = 1e-10
-        length_in_direction1 = 0
-        max_length_in_dir1 = 0
-        length_in_direction2 = 0
-        max_length_in_dir2 = 0
-        w1 = w2 = None
+        Parameters
+        ----------
+        inputBrd : str
+            Full path to the board file.
+        WorkDir : str, optional
+            Directory in which to create the ``aedb`` folder. The default value is ``None``,
+            in which case the AEDB file is given the same name as the board file. Only
+            the extension differs.
+        anstranslator_full_path : str, optional
+            Full path to the Ansys translator.
+        use_ppe : bool, optional
+            Whether to use the PPE License. The default is ``False``.
 
-        # find the distance between current cell and array center in terms of index
-        length_in_direction1 = a - self.CenterA
-        length_in_direction2 = b - self.CenterB
-        max_length_in_dir1 = self.AMax
-        max_length_in_dir2 = self.BMax
+        Returns
+        -------
+        bool
+            ``True`` when successful, ``False`` when failed.
 
-        if taper.lower() == "cosine":  # Cosine
-            if max_length_in_dir1 < threshold:
-                w1 = 1
-            else:
-                w1 = (1 - edgeTaper) * (
-                    math.cos(math.pi * length_in_direction1 / max_length_in_dir1)
-                ) ** cosinePow + edgeTaper
-            if max_length_in_dir2 < threshold:
-                w2 = 1
-            else:
-                w2 = (1 - edgeTaper) * (
-                    math.cos(math.pi * length_in_direction2 / max_length_in_dir2)
-                ) ** cosinePow + edgeTaper
-        elif taper.lower() == "triangular":  # Triangular
-            if max_length_in_dir1 < threshold:
-                w1 = 1
-            else:
-                w1 = (1 - edgeTaper) * (1 - (math.fabs(length_in_direction1) / (max_length_in_dir1 / 2))) + edgeTaper
-            if max_length_in_dir2 < threshold:
-                w2 = 1
-            else:
-                w2 = (1 - edgeTaper) * (1 - (math.fabs(length_in_direction2) / (max_length_in_dir2 / 2))) + edgeTaper
-        elif taper.lower() == "hamming":  # Hamming Window
-            if max_length_in_dir1 < threshold:
-                w1 = 1
-            else:
-                w1 = 0.54 - 0.46 * math.cos(2 * math.pi * (length_in_direction1 / max_length_in_dir1 - 0.5))
-            if max_length_in_dir2 < threshold:
-                w2 = 1
-            else:
-                w2 = 0.54 - 0.46 * math.cos(2 * math.pi * (length_in_direction2 / max_length_in_dir2 - 0.5))
+        """
+        if self.import_layout_pcb(
+            inputBrd, working_dir=WorkDir, anstranslator_full_path=anstranslator_full_path, use_ppe=use_ppe
+        ):
+            return True
         else:
-            return 0
-
-        return w1 * w2 * self.mag_offset[port_cont]
+            return False
 
     @pyaedt_function_handler()
-    def beamform(self, phi_scan=0, theta_scan=0):
-        """Compute the far field pattern calculated for a specific phi/scan angle requested.
-        This is calculated based on the lattice vector spacing and the embedded element
-        patterns of a ca-ddm or fa-ddm array in HFSS.
-        Calculates phase shifts between array elements in A and B directions,
-        PhaseShiftA and PhaseShiftB, given Wave Vector (k), lattice vectors
-        (Ax, Ay, Bx, By), Scan angles (theta, phi) using formula below
-        Phase Shift A = - (Ax*k*sin(theta)*cos(phi) + Ay*k*sin(theta)*sin(phi))
-        Phase Shift B = - (Bx*k*sin(theta)*cos(phi) + By*k*sin(theta)*sin(phi)).
+    def import_gds_file(self, inputGDS, WorkDir=None, anstranslator_full_path="", use_ppe=False, control_file=None):
+        """Import a GDS file and generate an ``edb.def`` file in the working directory.
 
         Parameters
         ----------
-        phi_scan : int, float
-            Spherical cs for desired scan angle of beam.
-        theta_scan: : int, float
-            Spherical cs for desired scan angle of beam.
+        inputGDS : str
+            Full path to the GDS file.
+        WorkDir : str, optional
+            Directory in which to create the ``aedb`` folder. The default value is ``None``,
+            in which case the AEDB file is given the same name as the GDS file. Only the extension
+            differs.
+        anstranslator_full_path : str, optional
+            Full path to the Ansys translator.
+        use_ppe : bool, optional
+            Whether to use the PPE License. The default is ``False``.
+        control_file : str, optional
+            Path to the XML file. The default is ``None``, in which case an attempt is made to find
+            the XML file in the same directory as the GDS file. To succeed, the XML file and GDS file must
+            have the same name. Only the extension differs.
 
         Returns
         -------
-        dict
-            Updated quantities dictionary.
+        bool
+            ``True`` when successful, ``False`` when failed.
+
         """
-        num_ports = len(self.all_port_names)
-        self.array_center_and_edge()
+        if self.import_layout_pcb(
+            inputGDS,
+            working_dir=WorkDir,
+            anstranslator_full_path=anstranslator_full_path,
+            use_ppe=use_ppe,
+            control_file=control_file,
+        ):
+            return True
+        else:
+            return False
 
-        c = 299792458
-        k = (2 * math.pi * self.frequency) / c
+    @pyaedt_function_handler()
+    def _create_extent(
+        self,
+        net_signals,
+        extent_type,
+        expansion_size,
+        use_round_corner,
+        use_pyaedt_extent=False,
+        smart_cut=False,
+        reference_list=[],
+        include_pingroups=True,
+    ):
+        if extent_type in ["Conforming", self.edb.Geometry.ExtentType.Conforming, 1]:
+            if use_pyaedt_extent:
+                _poly = self._create_conformal(
+                    net_signals,
+                    expansion_size,
+                    1e-12,
+                    use_round_corner,
+                    expansion_size,
+                    smart_cut,
+                    reference_list,
+                    include_pingroups,
+                )
+            else:
+                _poly = self.active_layout.GetExpandedExtentFromNets(
+                    net_signals, self.edb.Geometry.ExtentType.Conforming, expansion_size, False, use_round_corner, 1
+                )
+        elif extent_type in ["Bounding", self.edb.Geometry.ExtentType.BoundingBox, 0]:
+            _poly = self.active_layout.GetExpandedExtentFromNets(
+                net_signals, self.edb.Geometry.ExtentType.BoundingBox, expansion_size, False, use_round_corner, 1
+            )
+        else:
+            if use_pyaedt_extent:
+                _poly = self._create_convex_hull(
+                    net_signals,
+                    expansion_size,
+                    1e-12,
+                    use_round_corner,
+                    expansion_size,
+                    smart_cut,
+                    reference_list,
+                    include_pingroups,
+                )
+            else:
+                _poly = self.active_layout.GetExpandedExtentFromNets(
+                    net_signals, self.edb.Geometry.ExtentType.Conforming, expansion_size, False, use_round_corner, 1
+                )
+                _poly_list = convert_py_list_to_net_list([_poly])
+                _poly = self.edb.Geometry.PolygonData.GetConvexHullOfPolygons(_poly_list)
+        return _poly
 
-        theta_scan = math.radians(theta_scan)
-        phi_scan = math.radians(phi_scan)
+    @pyaedt_function_handler()
+    def _create_conformal(
+        self,
+        net_signals,
+        expansion_size,
+        tolerance,
+        round_corner,
+        round_extension,
+        smart_cutout=False,
+        reference_list=[],
+        include_pingroups=True,
+    ):
+        names = []
+        _polys = []
+        for net in net_signals:
+            names.append(net.GetName())
+        for prim in self.modeler.primitives:
+            if prim.net_name in names:
+                obj_data = prim.primitive_object.GetPolygonData().Expand(
+                    expansion_size, tolerance, round_corner, round_extension
+                )
+                if obj_data:
+                    _polys.extend(list(obj_data))
+        if smart_cutout:
+            _polys.extend(self._smart_cut(net_signals, reference_list, include_pingroups))
+        _poly = self.edb.Geometry.PolygonData.Unite(convert_py_list_to_net_list(_polys))[0]
+        return _poly
+
+    @pyaedt_function_handler()
+    def _smart_cut(self, net_signals, reference_list=[], include_pingroups=True):
+        _polys = []
+        terms = [term for term in list(self.active_layout.Terminals) if int(term.GetBoundaryType()) in [0, 3, 4, 7, 8]]
+        locations = []
+        for term in terms:
+            if term.GetTerminalType().ToString() == "PadstackInstanceTerminal":
+                if term.GetParameters()[1].GetNet().GetName() in reference_list:
+                    locations.append(self.padstacks.instances[term.GetParameters()[1].GetId()].position)
+            elif term.GetTerminalType().ToString() == "PointTerminal" and term.GetNet().GetName() in reference_list:
+                pd = term.GetParameters()[1]
+                locations.append([pd.X.ToDouble(), pd.Y.ToDouble()])
+        if include_pingroups:
+            for reference in reference_list:
+                for pin in self.nets.nets[reference].padstack_instances:
+                    if pin.pingroups:
+                        locations.append(pin.position)
+        for point in locations:
+            pointA = self.edb.Geometry.PointData(self.edb_value(point[0] - 1e-12), self.edb_value(point[1] - 1e-12))
+            pointB = self.edb.Geometry.PointData(self.edb_value(point[0] + 1e-12), self.edb_value(point[1] + 1e-12))
+            points = Tuple[self.edb.Geometry.PointData, self.edb.Geometry.PointData](pointA, pointB)
+            _polys.append(self.edb.Geometry.PolygonData.CreateFromBBox(points))
+        for cname, c in self.components.instances.items():
+            if (
+                set(net_signals).intersection(c.nets)
+                and c.is_enabled
+                and c.model_type in ["SParameterModel", "SpiceModel", "NetlistModel"]
+            ):
+                for pin in c.pins:
+                    locations.append(pin.position)
+        return _polys
 
-        phase_shift_A_rad = -1 * (
-            (self.Ax * k * math.sin(theta_scan) * math.cos(phi_scan))
-            + (self.Ay * k * math.sin(theta_scan) * math.sin(phi_scan))
-        )
-        phase_shift_B_rad = -1 * (
-            (self.Bx * k * math.sin(theta_scan) * math.cos(phi_scan))
-            + (self.By * k * math.sin(theta_scan) * math.sin(phi_scan))
-        )
+    @pyaedt_function_handler()
+    def _create_convex_hull(
+        self,
+        net_signals,
+        expansion_size,
+        tolerance,
+        round_corner,
+        round_extension,
+        smart_cut=False,
+        reference_list=[],
+        include_pingroups=True,
+    ):
+        names = []
+        _polys = []
+        for net in net_signals:
+            names.append(net.GetName())
+        for prim in self.modeler.primitives:
+            if prim.net_name in names:
+                _polys.append(prim.primitive_object.GetPolygonData())
+        if smart_cut:
+            _polys.extend(self._smart_cut(net_signals, reference_list, include_pingroups))
+        _poly = self.edb.Geometry.PolygonData.GetConvexHullOfPolygons(convert_py_list_to_net_list(_polys))
+        _poly = _poly.Expand(expansion_size, tolerance, round_corner, round_extension)[0]
+        return _poly
 
-        w_dict = {}
-        w_dict_ang = {}
-        w_dict_mag = {}
-        array_positions = {}
-        port_cont = 0
-        for port_name in self.all_port_names:
-            index_str = self.get_array_index(port_name)
-            a = index_str[0] - 1
-            b = index_str[1] - 1
-            w_mag = np.round(np.abs(self.assign_weight(a, b, taper=self.taper, port_cont=port_cont)), 3)
-            w_ang = self.phase_offset[port_cont] + (a * phase_shift_A_rad + b * phase_shift_B_rad)
-            w_dict[port_name] = np.sqrt(w_mag) * np.exp(1j * w_ang)
-            w_dict_ang[port_name] = w_ang
-            w_dict_mag[port_name] = w_mag
-            array_positions[port_name] = self.element_location(a, b)
-            port_cont += 1
-
-        length_of_ff_data = len(self.data_dict[self.all_port_names[0]]["rETheta"])
-
-        rEtheta_fields = np.zeros((num_ports, length_of_ff_data), dtype=complex)
-        rEphi_fields = np.zeros((num_ports, length_of_ff_data), dtype=complex)
-        w = np.zeros((1, num_ports), dtype=complex)
-        # create port mapping
-        for n, port in enumerate(self.all_port_names):
-            re_theta = self.data_dict[port]["rETheta"]  # this is re_theta index of loaded data
-            re_phi = self.data_dict[port]["rEPhi"]  # this is re_ohi index of loaded data
-
-            w[0][n] = w_dict[port]  # build 1xNumPorts array of weights
-
-            rEtheta_fields[n] = re_theta
-            rEphi_fields[n] = re_phi
-
-            theta_range = self.data_dict[port]["Theta"]
-            phi_range = self.data_dict[port]["Phi"]
-            Ntheta = len(theta_range)
-            Nphi = len(phi_range)
-
-        rEtheta_fields_sum = np.dot(w, rEtheta_fields)
-        rEtheta_fields_sum = np.reshape(rEtheta_fields_sum, (Ntheta, Nphi))
-
-        rEphi_fields_sum = np.dot(w, rEphi_fields)
-        rEphi_fields_sum = np.reshape(rEphi_fields_sum, (Ntheta, Nphi))
-
-        self.all_qtys = {}
-        self.all_qtys["rEPhi"] = rEphi_fields_sum
-        self.all_qtys["rETheta"] = rEtheta_fields_sum
-        self.all_qtys["rETotal"] = np.sqrt(
-            np.power(np.abs(rEphi_fields_sum), 2) + np.power(np.abs(rEtheta_fields_sum), 2)
-        )
-        self.all_qtys["Theta"] = theta_range
-        self.all_qtys["Phi"] = phi_range
-        self.all_qtys["nPhi"] = Nphi
-        self.all_qtys["nTheta"] = Ntheta
-        pin = np.sum(np.power(np.abs(w), 2))
-        self.all_qtys["Pincident"] = pin
-        self._app.logger.info("Incident Power: %s", pin)
-        real_gain = 2 * np.pi * np.abs(np.power(self.all_qtys["rETotal"], 2)) / pin / 377
-        self.all_qtys["RealizedGain"] = real_gain
-        self.all_qtys["RealizedGain_dB"] = 10 * np.log10(real_gain)
-        self.max_gain = np.max(10 * np.log10(real_gain))
-        self.min_gain = np.min(10 * np.log10(real_gain))
-        self._app.logger.info("Peak Realized Gain: %s dB", self.max_gain)
-        self.all_qtys["Element_Location"] = array_positions
-
-        return self.all_qtys
-
-    @pyaedt_function_handler()
-    def beamform_2beams(self, phi_scan1=0, theta_scan1=0, phi_scan2=0, theta_scan2=0):
-        """Compute the far field pattern calculated for a specific phi/scan angle requested.
-        This is calculated based on the lattice vector spacing and the embedded element
-        patterns of a ca-ddm or fa-ddm array in HFSS.
+    @pyaedt_function_handler()
+    def cutout(
+        self,
+        signal_list=None,
+        reference_list=None,
+        extent_type="ConvexHull",
+        expansion_size=0.002,
+        use_round_corner=False,
+        output_aedb_path=None,
+        open_cutout_at_end=True,
+        use_pyaedt_cutout=True,
+        number_of_threads=4,
+        use_pyaedt_extent_computing=True,
+        extent_defeature=0,
+        remove_single_pin_components=False,
+        custom_extent=None,
+        custom_extent_units="mm",
+        include_partial_instances=False,
+        keep_voids=True,
+        check_terminals=False,
+        include_pingroups=False,
+        expansion_factor=0,
+        maximum_iterations=10,
+    ):
+        """Create a cutout using an approach entirely based on pyaedt.
+        This new method replaces all legacy cutout methods in pyaedt.
+        It does in sequence:
+        - delete all nets not in list,
+        - create a extent of the nets,
+        - check and delete all vias not in the extent,
+        - check and delete all the primitives not in extent,
+        - check and intersect all the primitives that intersect the extent.
 
         Parameters
         ----------
-        phi_scan1 : int, float
-            Spherical cs for desired scan angle of beam.
-        theta_scan1: : int, float
-            Spherical cs for desired scan angle of beam.
-        phi_scan2 : int, float
-            Spherical cs for desired scan angle of second beam.
-        theta_scan2 : int, float
-            Spherical cs for desired scan angle of second beam.
+         signal_list : list
+            List of signal strings.
+        reference_list : list, optional
+            List of references to add. The default is ``["GND"]``.
+        extent_type : str, optional
+            Type of the extension. Options are ``"Conforming"``, ``"ConvexHull"``, and
+            ``"Bounding"``. The default is ``"Conforming"``.
+        expansion_size : float, str, optional
+            Expansion size ratio in meters. The default is ``0.002``.
+        use_round_corner : bool, optional
+            Whether to use round corners. The default is ``False``.
+        output_aedb_path : str, optional
+            Full path and name for the new AEDB file. If None, then current aedb will be cutout.
+        open_cutout_at_end : bool, optional
+            Whether to open the cutout at the end. The default is ``True``.
+        use_pyaedt_cutout : bool, optional
+            Whether to use new PyAEDT cutout method or EDB API method.
+            New method is faster than native API method since it benefits of multithread.
+        number_of_threads : int, optional
+            Number of thread to use. Default is 4. Valid only if ``use_pyaedt_cutout`` is set to ``True``.
+        use_pyaedt_extent_computing : bool, optional
+            Whether to use pyaedt extent computing (experimental) or EDB API.
+        extent_defeature : float, optional
+            Defeature the cutout before applying it to produce simpler geometry for mesh (Experimental).
+            It applies only to Conforming bounding box. Default value is ``0`` which disable it.
+        remove_single_pin_components : bool, optional
+            Remove all Single Pin RLC after the cutout is completed. Default is `False`.
+        custom_extent : list
+            Points list defining the cutout shape. This setting will override `extent_type` field.
+        custom_extent_units : str
+            Units of the point list. The default is ``"mm"``. Valid only if `custom_extend` is provided.
+        include_partial_instances : bool, optional
+            Whether to include padstack instances that have bounding boxes intersecting with point list polygons.
+            This operation may slow down the cutout export.Valid only if `custom_extend` and
+            `use_pyaedt_cutout` is provided.
+        keep_voids : bool
+            Boolean used for keep or not the voids intersecting the polygon used for clipping the layout.
+            Default value is ``True``, ``False`` will remove the voids.Valid only if `custom_extend` is provided.
+        check_terminals : bool, optional
+            Whether to check for all reference terminals and increase extent to include them into the cutout.
+            This applies to components which have a model (spice, touchstone or netlist) associated.
+        include_pingroups : bool, optional
+            Whether to check for all pingroups terminals and increase extent to include them into the cutout.
+            It requires ``check_terminals``.
+        expansion_factor : int, optional
+            The method computes a float representing the largest number between
+            the dielectric thickness or trace width multiplied by the expansion_factor factor.
+            The trace width search is limited to nets with ports attached. Works only if `use_pyaedt_cutout`.
+            Default is `0` to disable the search.
+        maximum_iterations : int, optional
+            Maximum number of iterations before stopping in searching for a cutout with an error.
+            Default is `10`.
 
         Returns
         -------
-        dict
-            Updated quantities dictionary.
-        """
-        num_ports = len(self.all_port_names)
-        self.array_center_and_edge()
-
-        c = 299792458
-        k = (2 * math.pi * self.frequency) / c
-
-        # ---------------------- METHOD : CalculatePhaseShifts -------------------
-        # Calculates phase shifts between array elements in A and B directions,
-        # PhaseShiftA and PhaseShiftB, given Wave Vector (k), lattice vectors
-        # (Ax, Ay, Bx, By), Scan angles (theta, phi) using formula below
-        # Phase Shift A = - (Ax*k*sin(theta)*cos(phi) + Ay*k*sin(theta)*sin(phi))
-        # Phase Shift B = - (Bx*k*sin(theta)*cos(phi) + By*k*sin(theta)*sin(phi))
-        # ------------------------------------------------------------------------
-
-        theta_scan1 = math.radians(theta_scan1)
-        phi_scan1 = math.radians(phi_scan1)
-
-        theta_scan2 = math.radians(theta_scan2)
-        phi_scan2 = math.radians(phi_scan2)
-
-        phase_shift_A_rad1 = -1 * (
-            (self.Ax * k * math.sin(theta_scan1) * math.cos(phi_scan1))
-            + (self.Ay * k * math.sin(theta_scan1) * math.sin(phi_scan1))
-        )
-        phase_shift_B_rad1 = -1 * (
-            (self.Bx * k * math.sin(theta_scan1) * math.cos(phi_scan1))
-            + (self.By * k * math.sin(theta_scan1) * math.sin(phi_scan1))
-        )
+        bool
+            ``True`` when successful, ``False`` when failed.
+
+        Examples
+        --------
+        >>> edb = Edb(r'C:\\test.aedb', edbversion="2022.2")
+        >>> edb.logger.info_timer("Edb Opening")
+        >>> edb.logger.reset_timer()
+        >>> start = time.time()
+        >>> signal_list = []
+        >>> for net in edb.nets.netlist:
+        >>>      if "3V3" in net:
+        >>>           signal_list.append(net)
+        >>> power_list = ["PGND"]
+        >>> edb.cutout(signal_list=signal_list, reference_list=power_list, extent_type="Conforming")
+        >>> end_time = str((time.time() - start)/60)
+        >>> edb.logger.info("Total pyaedt cutout time in min %s", end_time)
+        >>> edb.nets.plot(signal_list, None, color_by_net=True)
+        >>> edb.nets.plot(power_list, None, color_by_net=True)
+        >>> edb.save_edb()
+        >>> edb.close_edb()
+
 
-        phase_shift_A_rad2 = -1 * (
-            (self.Ax * k * math.sin(theta_scan2) * math.cos(phi_scan2))
-            + (self.Ay * k * math.sin(theta_scan2) * math.sin(phi_scan2))
+        """
+        if expansion_factor > 0:
+            expansion_size = self.calculate_initial_extent(expansion_factor)
+        if signal_list is None:
+            signal_list = []
+        if isinstance(reference_list, str):
+            reference_list = [reference_list]
+        elif reference_list is None:
+            reference_list = []
+        if not use_pyaedt_cutout and custom_extent:
+            return self._create_cutout_on_point_list(
+                custom_extent,
+                units=custom_extent_units,
+                output_aedb_path=output_aedb_path,
+                open_cutout_at_end=open_cutout_at_end,
+                nets_to_include=signal_list + reference_list,
+                include_partial_instances=include_partial_instances,
+                keep_voids=keep_voids,
+            )
+        elif not use_pyaedt_cutout:
+            return self._create_cutout_legacy(
+                signal_list=signal_list,
+                reference_list=reference_list,
+                extent_type=extent_type,
+                expansion_size=expansion_size,
+                use_round_corner=use_round_corner,
+                output_aedb_path=output_aedb_path,
+                open_cutout_at_end=open_cutout_at_end,
+                use_pyaedt_extent_computing=use_pyaedt_extent_computing,
+                check_terminals=check_terminals,
+                include_pingroups=include_pingroups,
+            )
+        else:
+            legacy_path = self.edbpath
+            if expansion_factor > 0 and not custom_extent:
+                start = time.time()
+                self.save_edb()
+                dummy_path = self.edbpath.replace(".aedb", "_smart_cutout_temp.aedb")
+                working_cutout = False
+                i = 1
+                expansion = expansion_size
+                while i <= maximum_iterations:
+                    self.logger.info("-----------------------------------------")
+                    self.logger.info("Trying cutout with {}mm expansion size".format(expansion * 1e3))
+                    self.logger.info("-----------------------------------------")
+                    result = self._create_cutout_multithread(
+                        signal_list=signal_list,
+                        reference_list=reference_list,
+                        extent_type=extent_type,
+                        expansion_size=expansion,
+                        use_round_corner=use_round_corner,
+                        number_of_threads=number_of_threads,
+                        custom_extent=custom_extent,
+                        output_aedb_path=dummy_path,
+                        remove_single_pin_components=remove_single_pin_components,
+                        use_pyaedt_extent_computing=use_pyaedt_extent_computing,
+                        extent_defeature=extent_defeature,
+                        custom_extent_units=custom_extent_units,
+                        check_terminals=check_terminals,
+                        include_pingroups=include_pingroups,
+                    )
+                    if self.are_port_reference_terminals_connected():
+                        if output_aedb_path:
+                            self.save_edb_as(output_aedb_path)
+                        else:
+                            self.save_edb_as(legacy_path)
+                        working_cutout = True
+                        break
+                    self.close_edb()
+                    self.edbpath = legacy_path
+                    self.open_edb(True)
+                    i += 1
+                    expansion = expansion_size * i
+                if working_cutout:
+                    msg = "Cutout completed in {} iterations with expansion size of {}mm".format(i, expansion * 1e3)
+                    self.logger.info_timer(msg, start)
+                else:
+                    msg = "Cutout failed after {} iterations and expansion size of {}mm".format(i, expansion * 1e3)
+                    self.logger.info_timer(msg, start)
+                    return False
+            else:
+                result = self._create_cutout_multithread(
+                    signal_list=signal_list,
+                    reference_list=reference_list,
+                    extent_type=extent_type,
+                    expansion_size=expansion_size,
+                    use_round_corner=use_round_corner,
+                    number_of_threads=number_of_threads,
+                    custom_extent=custom_extent,
+                    output_aedb_path=output_aedb_path,
+                    remove_single_pin_components=remove_single_pin_components,
+                    use_pyaedt_extent_computing=use_pyaedt_extent_computing,
+                    extent_defeature=extent_defeature,
+                    custom_extent_units=custom_extent_units,
+                    check_terminals=check_terminals,
+                    include_pingroups=include_pingroups,
+                )
+            if result and not open_cutout_at_end and self.edbpath != legacy_path:
+                self.save_edb()
+                self.close_edb()
+                self.edbpath = legacy_path
+                self.open_edb(init_dlls=True)
+            return result
+
+    @pyaedt_function_handler()
+    def _create_cutout_legacy(
+        self,
+        signal_list=[],
+        reference_list=["GND"],
+        extent_type="Conforming",
+        expansion_size=0.002,
+        use_round_corner=False,
+        output_aedb_path=None,
+        open_cutout_at_end=True,
+        use_pyaedt_extent_computing=False,
+        remove_single_pin_components=False,
+        check_terminals=False,
+        include_pingroups=True,
+    ):
+        expansion_size = self.edb_value(expansion_size).ToDouble()
+
+        # validate nets in layout
+        net_signals = convert_py_list_to_net_list(
+            [net for net in list(self.active_layout.Nets) if net.GetName() in signal_list]
         )
-        phase_shift_B_rad2 = -1 * (
-            (self.Bx * k * math.sin(theta_scan2) * math.cos(phi_scan2))
-            + (self.By * k * math.sin(theta_scan2) * math.sin(phi_scan2))
+        # validate references in layout
+        _netsClip = convert_py_list_to_net_list(
+            [net for net in list(self.active_layout.Nets) if net.GetName() in reference_list]
         )
 
-        w_dict = {}
-        w_dict_ang = {}
-        w_dict_mag = {}
-        array_positions = {}
-        port_count = 0
-        for port_name in self.all_port_names:
-            index_str = self.get_array_index(port_name)
-            a = index_str[0]
-            b = index_str[1]
-            w_mag1 = np.round(np.abs(self.assign_weight(a, b, taper=self.taper, port_cont=port_count)), 3)
-            w_ang1 = a * phase_shift_A_rad1 + b * phase_shift_B_rad1
-
-            w_mag2 = np.round(np.abs(self.assign_weight(a, b, taper=self.taper, port_cont=port_count)), 3)
-            w_ang2 = a * phase_shift_A_rad2 + b * phase_shift_B_rad2
-
-            w_dict[port_name] = np.sqrt(w_mag1) * np.exp(1j * w_ang1) + np.sqrt(w_mag2) * np.exp(1j * w_ang2)
-            w_dict_ang[port_name] = np.angle(w_dict[port_name])
-            w_dict_mag[port_name] = np.abs(w_dict[port_name])
-
-            array_positions[port_name] = self.element_location(a, b)
-            port_count += 1
-
-        length_of_ff_data = len(self.data_dict[self.all_port_names[0]]["rETheta"])
-        rEtheta_fields = np.zeros((num_ports, length_of_ff_data), dtype=complex)
-        rEphi_fields = np.zeros((num_ports, length_of_ff_data), dtype=complex)
-        w = np.zeros((1, num_ports), dtype=complex)
-        # create port mapping
-        for n, port in enumerate(self.all_port_names):
-            re_theta = self.data_dict[port]["rETheta"]  # this is re_theta index of loaded data
-            re_phi = self.data_dict[port]["rEPhi"]  # this is re_ohi index of loaded data
-
-            w[0][n] = w_dict[port]  # build 1xNumPorts array of weights
-
-            rEtheta_fields[n] = re_theta
-            rEphi_fields[n] = re_phi
-
-            theta_range = self.data_dict[port]["Theta"]
-            phi_range = self.data_dict[port]["Phi"]
-            Ntheta = len(theta_range)
-            Nphi = len(phi_range)
-
-        rEtheta_fields_sum = np.dot(w, rEtheta_fields)
-        rEtheta_fields_sum = np.reshape(rEtheta_fields_sum, (Ntheta, Nphi))
-
-        rEphi_fields_sum = np.dot(w, rEphi_fields)
-        rEphi_fields_sum = np.reshape(rEphi_fields_sum, (Ntheta, Nphi))
-
-        self.all_qtys = {}
-        self.all_qtys["rEPhi"] = rEphi_fields_sum
-        self.all_qtys["rETheta"] = rEtheta_fields_sum
-        self.all_qtys["rETotal"] = np.sqrt(
-            np.power(np.abs(rEphi_fields_sum), 2) + np.power(np.abs(rEtheta_fields_sum), 2)
+        _poly = self._create_extent(
+            net_signals,
+            extent_type,
+            expansion_size,
+            use_round_corner,
+            use_pyaedt_extent_computing,
+            smart_cut=check_terminals,
+            reference_list=reference_list,
+            include_pingroups=include_pingroups,
         )
-        self.all_qtys["Theta"] = theta_range
-        self.all_qtys["Phi"] = phi_range
-        self.all_qtys["nPhi"] = Nphi
-        self.all_qtys["nTheta"] = Ntheta
-        pin = np.sum(np.power(np.abs(w), 2))
-        self.all_qtys["Pincident"] = pin
-        self._app.logger.info("Incident Power: %s", pin)
-        real_gain = 2 * np.pi * np.abs(np.power(self.all_qtys["rETotal"], 2)) / pin / 377
-        self.all_qtys["RealizedGain"] = real_gain
-        self.all_qtys["RealizedGain_dB"] = 10 * np.log10(real_gain)
-        self.max_gain = np.max(10 * np.log10(real_gain))
-        self.min_gain = np.min(10 * np.log10(real_gain))
-        self._app.logger.info("Peak Realized Gain: %s dB", self.max_gain)
-        self.all_qtys["Element_Location"] = array_positions
-
-        return self.all_qtys
-
-    @pyaedt_function_handler()
-    def _get_far_field_mesh(self, qty_str="RealizedGain", convert_to_db=True):
-        if convert_to_db:
-            ff_data = 10 * np.log10(self.all_qtys[qty_str])
-
-        else:
-            ff_data = self.all_qtys[qty_str]
-        theta = np.deg2rad(np.array(self.all_qtys["Theta"]))
-        phi = np.deg2rad(np.array(self.all_qtys["Phi"]))
-        self.mesh = get_structured_mesh(theta=theta, phi=phi, ff_data=ff_data)
-
-    @pyaedt_function_handler()
-    def get_lattice_vectors(self):
-        """Compute Lattice vectors for Antenna Arrays or return default array in case of simple antenna analysis.
 
-        Returns
-        -------
-        list of float
-        """
-        if self.sbr_comp and self.sbr_comp in self._app.modeler.user_defined_components:
-            component_props = "NativeComponentDefinitionProvider"
-            comp_obj = self._app.modeler.user_defined_components[self.sbr_comp]
-            if "Project" in list(comp_obj.native_properties.keys()):
-                # Project opened
-                project = comp_obj.native_properties["Project"]
-                proj_name = os.path.splitext(os.path.split(project)[-1])[0]
-                close = False
-                if proj_name not in self._app.project_list:
-                    close = True
-                    self._app.odesktop.OpenProject(project)
-                comp = get_pyaedt_app(proj_name, comp_obj.native_properties["Design"])
-                comp_units = comp.modeler.model_units
-                lattice_vectors = comp.omodelsetup.GetLatticeVectors()
-                source_names = [i[5:-1] for i in comp.post.available_report_quantities(quantities_category="VSWR")]
-                for port in source_names:
+        # Create new cutout cell/design
+        included_nets_list = signal_list + reference_list
+        included_nets = convert_py_list_to_net_list(
+            [net for net in list(self.active_layout.Nets) if net.GetName() in included_nets_list]
+        )
+        _cutout = self.active_cell.CutOut(included_nets, _netsClip, _poly, True)
+        # Analysis setups do not come over with the clipped design copy,
+        # so add the analysis setups from the original here.
+        id = 1
+        for _setup in self.active_cell.SimulationSetups:
+            # Empty string '' if coming from setup copy and don't set explicitly.
+            _setup_name = _setup.GetName()
+            if "GetSimSetupInfo" in dir(_setup):
+                # setup is an Ansys.Ansoft.Edb.Utility.HFSSSimulationSetup object
+                _hfssSimSetupInfo = _setup.GetSimSetupInfo()
+                _hfssSimSetupInfo.Name = "HFSS Setup " + str(id)  # Set name of analysis setup
+                # Write the simulation setup info into the cell/design setup
+                _setup.SetSimSetupInfo(_hfssSimSetupInfo)
+                _cutout.AddSimulationSetup(_setup)  # Add simulation setup to the cutout design
+                id += 1
+            else:
+                _cutout.AddSimulationSetup(_setup)  # Add simulation setup to the cutout design
+
+        _dbCells = [_cutout]
+
+        if output_aedb_path:
+            db2 = self.edb.Database.Create(output_aedb_path)
+            _success = db2.Save()
+            _dbCells = convert_py_list_to_net_list(_dbCells)
+            db2.CopyCells(_dbCells)  # Copies cutout cell/design to db2 project
+            if len(list(db2.CircuitCells)) > 0:
+                for net in list(list(db2.CircuitCells)[0].GetLayout().Nets):
+                    if not net.GetName() in included_nets_list:
+                        net.Delete()
+                _success = db2.Save()
+            for c in list(self.db.TopCircuitCells):
+                if c.GetName() == _cutout.GetName():
+                    c.Delete()
+            if open_cutout_at_end:  # pragma: no cover
+                self._db = db2
+                self.edbpath = output_aedb_path
+                self._active_cell = list(self._db.TopCircuitCells)[0]
+                self.builder = EdbBuilder(self.edbutils, self._db, self._active_cell)
+                self.edbpath = self._db.GetDirectory()
+                self._init_objects()
+                if remove_single_pin_components:
+                    self.components.delete_single_pin_rlc()
+                    self.logger.info_timer("Single Pins components deleted")
+                    self.components.refresh_components()
+            else:
+                if remove_single_pin_components:
                     try:
-                        str1 = port.split("[", 1)[1].split("]", 1)[0]
-                        self._native_indexes.append([int(i) for i in str1.split(",")])
+                        layout = list(db2.CircuitCells)[0].GetLayout()
+                        _cmps = [
+                            l
+                            for l in layout.Groups
+                            if l.ToString() == "Ansys.Ansoft.Edb.Cell.Hierarchy.Component" and l.GetNumberOfPins() < 2
+                        ]
+                        for _cmp in _cmps:
+                            _cmp.Delete()
                     except:
-                        self._native_indexes.append([1, 1])
-                if close:
-                    comp.close_project()
-            else:
-                # Project not opened
-                project = comp_obj.native_properties[component_props]["Project"]
-                proj_name = os.path.splitext(os.path.split(project)[-1])[0]
-                close = False
-                if proj_name not in self._app.project_list:
-                    close = True
-                    self._app.odesktop.OpenProject(project)
-                comp = get_pyaedt_app(proj_name, comp_obj.native_properties[component_props]["Design"])
-                lattice_vectors = comp.omodelsetup.GetLatticeVectors()
-                comp_units = comp.modeler.model_units
-                source_names = [i[5:-1] for i in comp.post.available_report_quantities(quantities_category="VSWR")]
-                for port in source_names:
+                        self._logger.error("Failed to remove single pin components.")
+                db2.Close()
+                source = os.path.join(output_aedb_path, "edb.def.tmp")
+                target = os.path.join(output_aedb_path, "edb.def")
+                self._wait_for_file_release(file_to_release=output_aedb_path)
+                if os.path.exists(source) and not os.path.exists(target):
                     try:
-                        str1 = port.split("[", 1)[1].split("]", 1)[0]
-                        self._native_indexes.append([int(i) for i in str1.split(",")])
+                        shutil.copy(source, target)
                     except:
-                        self._native_indexes.append([1, 1])
-                if close:
-                    comp.close_project(save_project=False)
-
-            lattice_vectors = [
-                str(x)
-                for x in unit_converter(
-                    values=[float(i) for i in lattice_vectors],
-                    unit_system="Length",
-                    input_units=comp_units,
-                    output_units=self._app.modeler.model_units,
-                )
-            ]
-        else:
-            try:
-                lattice_vectors = self._app.omodelsetup.GetLatticeVectors()
-                lattice_vectors = [
-                    float(vec) * AEDT_UNITS["Length"][self._app.modeler.model_units] for vec in lattice_vectors
-                ]
-            except:
-                lattice_vectors = [0, 0, 0, 0, 1, 0]
-        return lattice_vectors
-
-    @pyaedt_function_handler()
-    def _export_all_ffd(self):
-        exported_name_base = "eep"
-        exported_name_map = exported_name_base + ".txt"
-        sol_setup_name_str = self.setup_name.replace(":", "_").replace(" ", "")
-        path_dict = []
-        for frequency in self.frequencies:
-            full_setup_str = "{}-{}-{}".format(sol_setup_name_str, self.sphere_name, frequency)
-            export_path = "{}/{}/eep/".format(self._app.working_directory, full_setup_str)
-            if settings.remote_rpc_session:
-                settings.remote_rpc_session.filemanager.makedirs(export_path)
-                file_exists = settings.remote_rpc_session.filemanager.pathexists(
-                    export_path + exported_name_base + ".txt"
-                )
-            elif not os.path.exists(export_path):
-                os.makedirs(export_path)
-                file_exists = os.path.exists(export_path + exported_name_base + ".txt")
-            else:
-                file_exists = os.path.exists(export_path + exported_name_base + ".txt")
-            path_dict.append({})
-            time_before = time.time()
-            if self.overwrite or not file_exists:
-                self._app.logger.info("Exporting Embedded Element Patterns...")
-                var = []
-                if self.variations:
-                    for k, v in self.variations.items():
-                        var.append("{}='{}'".format(k, v))
-                variation = " ".join(var)
-                try:
-                    self._app.oradfield.ExportElementPatternToFile(
-                        [
-                            "ExportFileName:=",
-                            export_path + exported_name_base + ".ffd",
-                            "SetupName:=",
-                            self.sphere_name,
-                            "IntrinsicVariationKey:=",
-                            "Freq='" + str(frequency) + "'",
-                            "DesignVariationKey:=",
-                            variation,
-                            "SolutionName:=",
-                            self.setup_name,
-                        ]
-                    )
-                except:
-                    self._app.logger.error("Failed to export one Element Pattern.")
-                    self._app.logger.error(export_path + exported_name_base + ".ffd")
-
-            else:
-                self._app.logger.info("Using Existing Embedded Element Patterns")
-            local_path = "{}/{}/eep/".format(settings.remote_rpc_session_temp_folder, full_setup_str)
-            export_path = check_and_download_folder(local_path, export_path)
-            if os.path.exists(export_path + "/" + exported_name_map):
-                with open(export_path + "/" + exported_name_map, "r") as reader:
-                    lines = [line.split(None) for line in reader]
-                lines = lines[1:]  # remove header
-                for pattern in lines:
-                    if len(pattern) >= 2:
-                        port = pattern[0]
-                        if ":" in port:
-                            port = port.split(":")[0]
-                        path_dict[-1][port] = export_path + "/" + pattern[1] + ".ffd"
-        elapsed_time = time.time() - time_before
-        self._app.logger.info("Exporting Embedded Element Patterns...Done: %s seconds", elapsed_time)
-        return path_dict
+                        pass
+        elif open_cutout_at_end:
+            self._active_cell = _cutout
+            self._init_objects()
+            if remove_single_pin_components:
+                self.components.delete_single_pin_rlc()
+                self.logger.info_timer("Single Pins components deleted")
+                self.components.refresh_components()
+        return True
 
     @pyaedt_function_handler()
-    def plot_farfield_contour(
+    def create_cutout(
         self,
-        qty_str="RealizedGain",
-        phi_scan=0,
-        theta_scan=0,
-        title="RectangularPlot",
-        convert_to_db=True,
-        export_image_path=None,
+        signal_list=[],
+        reference_list=["GND"],
+        extent_type="Conforming",
+        expansion_size=0.002,
+        use_round_corner=False,
+        output_aedb_path=None,
+        open_cutout_at_end=True,
+        use_pyaedt_extent_computing=False,
     ):
-        """Create a Contour plot of specified quantity.
+        """Create a cutout using an approach entirely based on pyaedt.
+        It does in sequence:
+        - delete all nets not in list,
+        - create an extent of the nets,
+        - check and delete all vias not in the extent,
+        - check and delete all the primitives not in extent,
+        - check and intersect all the primitives that intersect the extent.
+
+        .. deprecated:: 0.6.58
+           Use new method :func:`cutout` instead.
 
         Parameters
         ----------
-        qty_str : str, optional
-            Quantity to plot. Default `"RealizedGain"`.
-        phi_scan : float, int, optional
-            Phi Scan Angle in degree. Default `0`.
-        theta_scan : float, int, optional
-            Theta Scan Angle in degree. Default `0`.
-        title : str, optional
-            Plot title. Default `"RectangularPlot"`.
-        convert_to_db : bool, optional
-            Either if the quantity has to be converted in db or not. Default is `True`.
-        export_image_path : str, optional
-            Full path to image file. Default is None to not export.
+        signal_list : list
+            List of signal strings.
+        reference_list : list, optional
+            List of references to add. The default is ``["GND"]``.
+        extent_type : str, optional
+            Type of the extension. Options are ``"Conforming"``, ``"ConvexHull"``, and
+            ``"Bounding"``. The default is ``"Conforming"``.
+        expansion_size : float, str, optional
+            Expansion size ratio in meters. The default is ``0.002``.
+        use_round_corner : bool, optional
+            Whether to use round corners. The default is ``False``.
+        output_aedb_path : str, optional
+            Full path and name for the new AEDB file.
+        open_cutout_at_end : bool, optional
+            Whether to open the cutout at the end. The default
+            is ``True``.
+        use_pyaedt_extent_computing : bool, optional
+            Whether to use pyaedt extent computing (experimental).
 
         Returns
         -------
-        :class:`matplotlib.plt`
-            Matplotlib fig object.
-        """
-        data = self.beamform(phi_scan, theta_scan)
-        if qty_str == "":
-            qty_to_plot = data
-            qty_str = "Data"
-        else:
-            qty_to_plot = data[qty_str]
-        qty_to_plot = np.reshape(qty_to_plot, (data["nTheta"], data["nPhi"]))
-        th, ph = np.meshgrid(data["Theta"], data["Phi"])
-
-        if convert_to_db:
-            factor = 20
-            if "Gain" in qty_str:
-                factor = 10
-            qty_to_plot = factor * np.log10(np.abs(qty_to_plot))
-
-        return plot_contour(
-            x=th,
-            y=ph,
-            qty_to_plot=qty_to_plot,
-            xlabel="Theta (degree)",
-            ylabel="Phi (degree)",
-            title=title,
-            levels=self.levels,
-            snapshot_path=export_image_path,
+        bool
+            ``True`` when successful, ``False`` when failed.
+
+        """
+        warnings.warn("Use new method `cutout` instead.", DeprecationWarning)
+        return self._create_cutout_legacy(
+            signal_list=signal_list,
+            reference_list=reference_list,
+            extent_type=extent_type,
+            expansion_size=expansion_size,
+            use_round_corner=use_round_corner,
+            output_aedb_path=output_aedb_path,
+            open_cutout_at_end=open_cutout_at_end,
+            use_pyaedt_extent_computing=use_pyaedt_extent_computing,
         )
 
     @pyaedt_function_handler()
-    def plot_2d_cut(
+    def _create_cutout_multithread(
         self,
-        qty_str="RealizedGain",
-        primary_sweep="phi",
-        secondary_sweep_value=0,
-        phi_scan=0,
-        theta_scan=0,
-        title="Far Field Cut",
-        convert_to_db=True,
-        export_image_path=None,
+        signal_list=[],
+        reference_list=["GND"],
+        extent_type="Conforming",
+        expansion_size=0.002,
+        use_round_corner=False,
+        number_of_threads=4,
+        custom_extent=None,
+        output_aedb_path=None,
+        remove_single_pin_components=False,
+        use_pyaedt_extent_computing=False,
+        extent_defeature=0.0,
+        custom_extent_units="mm",
+        check_terminals=False,
+        include_pingroups=True,
     ):
-        """Create a 2D plot of specified quantity in matplotlib.
+        if is_ironpython:  # pragma: no cover
+            self.logger.error("Method working only in Cpython")
+            return False
+        from concurrent.futures import ThreadPoolExecutor
+
+        if output_aedb_path:
+            self.save_edb_as(output_aedb_path)
+        self.logger.info("Cutout Multithread started.")
+        expansion_size = self.edb_value(expansion_size).ToDouble()
+
+        timer_start = self.logger.reset_timer()
+        if custom_extent:
+            if not reference_list and not signal_list:
+                reference_list = self.nets.netlist[::]
+                all_list = reference_list
+            else:
+                reference_list = reference_list + signal_list
+                all_list = reference_list
+        else:
+            all_list = signal_list + reference_list
+        for i in self.nets.nets.values():
+            if i.name not in all_list:
+                i.net_object.Delete()
+        reference_pinsts = []
+        reference_prims = []
+        for i in self.padstacks.instances.values():
+            net_name = i.net_name
+            if net_name not in all_list:
+                i.delete()
+            elif net_name in reference_list:
+                reference_pinsts.append(i)
+        for i in self.modeler.primitives:
+            net_name = i.net_name
+            if net_name not in all_list:
+                i.delete()
+            elif net_name in reference_list and not i.is_void:
+                reference_prims.append(i)
+        self.logger.info_timer("Net clean up")
+        self.logger.reset_timer()
+
+        if custom_extent and isinstance(custom_extent, list):
+            if custom_extent[0] != custom_extent[-1]:
+                custom_extent.append(custom_extent[0])
+            custom_extent = [
+                [self.number_with_units(i[0], custom_extent_units), self.number_with_units(i[1], custom_extent_units)]
+                for i in custom_extent
+            ]
+            plane = self.modeler.Shape("polygon", points=custom_extent)
+            _poly = self.modeler.shape_to_polygon_data(plane)
+        elif custom_extent:
+            _poly = custom_extent
+        else:
+            net_signals = convert_py_list_to_net_list(
+                [net for net in list(self.active_layout.Nets) if net.GetName() in signal_list]
+            )
+            _poly = self._create_extent(
+                net_signals,
+                extent_type,
+                expansion_size,
+                use_round_corner,
+                use_pyaedt_extent_computing,
+                smart_cut=check_terminals,
+                reference_list=reference_list,
+                include_pingroups=include_pingroups,
+            )
+            if extent_type in ["Conforming", self.edb.Geometry.ExtentType.Conforming, 1] and extent_defeature > 0:
+                _poly = _poly.Defeature(extent_defeature)
+
+        if not _poly or _poly.IsNull():
+            self._logger.error("Failed to create Extent.")
+            return False
+        self.logger.info_timer("Expanded Net Polygon Creation")
+        self.logger.reset_timer()
+        _poly_list = convert_py_list_to_net_list([_poly])
+        prims_to_delete = []
+        poly_to_create = []
+        pins_to_delete = []
+
+        def get_polygon_data(prim):
+            return prim.primitive_object.GetPolygonData()
+
+        def intersect(poly1, poly2):
+            if not isinstance(poly2, list):
+                poly2 = [poly2]
+            return list(poly1.Intersect(convert_py_list_to_net_list(poly1), convert_py_list_to_net_list(poly2)))
+
+        def subtract(poly, voids):
+            return poly.Subtract(convert_py_list_to_net_list(poly), convert_py_list_to_net_list(voids))
+
+        def clean_prim(prim_1):  # pragma: no cover
+            pdata = get_polygon_data(prim_1)
+            int_data = _poly.GetIntersectionType(pdata)
+            if int_data == 2:
+                return
+            elif int_data == 0:
+                prims_to_delete.append(prim_1)
+            else:
+                list_poly = intersect(_poly, pdata)
+                if list_poly:
+                    net = prim_1.net_name
+                    voids = prim_1.voids
+                    for p in list_poly:
+                        if p.IsNull():
+                            continue
+                        points = list(p.Points)
+                        list_void = []
+                        if voids:
+                            voids_data = [get_polygon_data(void) for void in voids]
+                            list_prims = subtract(p, voids_data)
+                            for prim in list_prims:
+                                if not prim.IsNull():
+                                    poly_to_create.append([prim, prim_1.layer_name, net, list_void])
+                            #
+                            # list_voids = intersect(p, voids_data)
+                            # for void_intersected in list_voids:
+                            #     if not void_intersected.IsNull():
+                            #         int_data_2 = p.GetIntersectionType(void_intersected)
+                            #         if int_data_2 == 2:
+                            #             list_void.append(void_intersected)
+                            #         elif int_data == 1 or int_data_2 > 2:
+                            #             p = subtract(p, void_intersected)[0]
+                            # poly_to_create.append([p, prim_1.layer_name, net, list_void])
+                        else:
+                            poly_to_create.append([p, prim_1.layer_name, net, list_void])
+
+                prims_to_delete.append(prim_1)
+
+        def pins_clean(pinst):
+            if not pinst.in_polygon(_poly, simple_check=True):
+                pins_to_delete.append(pinst)
+
+        with ThreadPoolExecutor(number_of_threads) as pool:
+            pool.map(lambda item: pins_clean(item), reference_pinsts)
+
+        for pin in pins_to_delete:
+            pin.delete()
+
+        self.logger.info_timer("Padstack Instances removal completed")
+        self.logger.reset_timer()
+
+        with ThreadPoolExecutor(number_of_threads) as pool:
+            pool.map(lambda item: clean_prim(item), reference_prims)
+
+        for el in poly_to_create:
+            self.modeler.create_polygon(el[0], el[1], net_name=el[2], voids=el[3])
+
+        for prim in prims_to_delete:
+            prim.delete()
+        self.logger.info_timer("Primitives cleanup completed")
+        self.logger.reset_timer()
+
+        i = 0
+        for _, val in self.components.components.items():
+            if val.numpins == 0:
+                val.edbcomponent.Delete()
+                i += 1
+        self.logger.info("Deleted {} additional components".format(i))
+        if remove_single_pin_components:
+            self.components.delete_single_pin_rlc()
+            self.logger.info_timer("Single Pins components deleted")
+
+        self.components.refresh_components()
+
+        self.logger.info_timer("Cutout completed.", timer_start)
+        self.logger.reset_timer()
+        return True
+
+    @pyaedt_function_handler()
+    def create_cutout_multithread(
+        self,
+        signal_list=[],
+        reference_list=["GND"],
+        extent_type="Conforming",
+        expansion_size=0.002,
+        use_round_corner=False,
+        number_of_threads=4,
+        custom_extent=None,
+        output_aedb_path=None,
+        remove_single_pin_components=False,
+        use_pyaedt_extent_computing=False,
+        extent_defeature=0,
+    ):
+        """Create a cutout using an approach entirely based on pyaedt.
+        It does in sequence:
+        - delete all nets not in list,
+        - create a extent of the nets,
+        - check and delete all vias not in the extent,
+        - check and delete all the primitives not in extent,
+        - check and intersect all the primitives that intersect the extent.
+
+
+        .. deprecated:: 0.6.58
+           Use new method :func:`cutout` instead.
 
         Parameters
         ----------
-        qty_str : str, optional
-            Quantity to plot. Default `"RealizedGain"`.
-        primary_sweep : str, optional.
-            X Axis variable. Default is `"phi"`. Option is  `"theta"`.
-        secondary_sweep_value : float, list, string, optional
-            List of cuts on secondary sweep to plot. Options are `"all"`, single value float or list of float.
-        phi_scan : float, int, optional
-            Phi Scan Angle in degree. Default `0`.
-        theta_scan : float, int, optional
-            Theta Scan Angle in degree. Default `0`.
-        title : str, optional
-            Plot title. Default `"RectangularPlot"`.
-        convert_to_db : bool, optional
-            Either if the quantity has to be converted in db or not. Default is `True`.
-        export_image_path : str, optional
-            Full path to image file. Default is None to not export.
-
+        signal_list : list
+            List of signal strings.
+        reference_list : list, optional
+            List of references to add. The default is ``["GND"]``.
+        extent_type : str, optional
+            Type of the extension. Options are ``"Conforming"``, ``"ConvexHull"``, and
+            ``"Bounding"``. The default is ``"Conforming"``.
+        expansion_size : float, str, optional
+            Expansion size ratio in meters. The default is ``0.002``.
+        use_round_corner : bool, optional
+            Whether to use round corners. The default is ``False``.
+        number_of_threads : int, optional
+            Number of thread to use. Default is 4
+        custom_extent : list, optional
+            Custom extent to use for the cutout. It has to be a list of points [[x1,y1],[x2,y2]....] or
+            Edb PolygonData object. In this case, both signal_list and reference_list will be cut.
+        output_aedb_path : str, optional
+            Full path and name for the new AEDB file. If None, then current aedb will be cutout.
+        remove_single_pin_components : bool, optional
+            Remove all Single Pin RLC after the cutout is completed. Default is `False`.
+        use_pyaedt_extent_computing : bool, optional
+            Whether to use pyaedt extent computing (experimental).
+        extent_defeature : float, optional
+            Defeature the cutout before applying it to produce simpler geometry for mesh (Experimental).
+            It applies only to Conforming bounding box. Default value is ``0`` which disable it.
 
         Returns
         -------
-        :class:`matplotlib.plt`
-            Matplotlib fig object.
-        """
-        data = self.beamform(phi_scan, theta_scan)
-
-        data_to_plot = data[qty_str]
-        curves = []
-        if primary_sweep == "phi":
-            x_key = "Phi"
-            y_key = "Theta"
-        else:
-            y_key = "Phi"
-            x_key = "Theta"
-        x = data[x_key]
-        xlabel = x_key
-        if x_key == "Phi":
-            temp = data_to_plot
-        else:
-            temp = data_to_plot.T
-        if secondary_sweep_value == "all":
-            for el in data[y_key]:
-                idx = self._find_nearest(data[y_key], el)
-                y = temp[idx]
-                if convert_to_db:
-                    if "Gain" in qty_str or "Dir" in qty_str:
-                        y = 10 * np.log10(y)
-                    else:
-                        y = 20 * np.log10(y)
-                curves.append([x, y, "{}={}".format(y_key, el)])
-        elif isinstance(secondary_sweep_value, list):
-            list_inserted = []
-            for el in secondary_sweep_value:
-                theta_idx = self._find_nearest(data[y_key], el)
-                if theta_idx not in list_inserted:
-                    y = temp[theta_idx]
-                    if convert_to_db:
-                        if "Gain" in qty_str or "Dir" in qty_str:
-                            y = 10 * np.log10(y)
-                        else:
-                            y = 20 * np.log10(y)
-                    curves.append([x, y, "{}={}".format(y_key, el)])
-                    list_inserted.append(theta_idx)
-        else:
-            theta_idx = self._find_nearest(data[y_key], secondary_sweep_value)
-            y = temp[theta_idx]
-            if convert_to_db:
-                if "Gain" in qty_str or "Dir" in qty_str:
-                    y = 10 * np.log10(y)
-                else:
-                    y = 20 * np.log10(y)
-            curves.append([x, y, "{}={}".format(y_key, data[y_key][theta_idx])])
-        show_legend = True
-        if len(curves) > 15:
-            show_legend = False
-        return plot_2d_chart(
-            curves, xlabel=xlabel, ylabel=qty_str, title=title, snapshot_path=export_image_path, show_legend=show_legend
+        bool
+            ``True`` when successful, ``False`` when failed.
+
+        Examples
+        --------
+        >>> edb = Edb(r'C:\\test.aedb', edbversion="2022.2")
+        >>> edb.logger.info_timer("Edb Opening")
+        >>> edb.logger.reset_timer()
+        >>> start = time.time()
+        >>> signal_list = []
+        >>> for net in edb.nets.nets.keys():
+        >>>      if "3V3" in net:
+        >>>           signal_list.append(net)
+        >>> power_list = ["PGND"]
+        >>> edb.create_cutout_multithread(signal_list=signal_list, reference_list=power_list, extent_type="Conforming")
+        >>> end_time = str((time.time() - start)/60)
+        >>> edb.logger.info("Total pyaedt cutout time in min %s", end_time)
+        >>> edb.nets.plot(signal_list, None, color_by_net=True)
+        >>> edb.nets.plot(power_list, None, color_by_net=True)
+        >>> edb.save_edb()
+        >>> edb.close_edb()
+
+        """
+        warnings.warn("Use new method `cutout` instead.", DeprecationWarning)
+        return self._create_cutout_multithread(
+            signal_list=signal_list,
+            reference_list=reference_list,
+            extent_type=extent_type,
+            expansion_size=expansion_size,
+            use_round_corner=use_round_corner,
+            number_of_threads=number_of_threads,
+            custom_extent=custom_extent,
+            output_aedb_path=output_aedb_path,
+            remove_single_pin_components=remove_single_pin_components,
+            use_pyaedt_extent_computing=use_pyaedt_extent_computing,
+            extent_defeature=extent_defeature,
         )
 
     @pyaedt_function_handler()
-    def polar_plot_3d(
-        self,
-        qty_str="RealizedGain",
-        phi_scan=0,
-        theta_scan=0,
-        title="3D Plot",
-        convert_to_db=True,
-        export_image_path=None,
-    ):
-        """Create a 3d plot of specified quantity.
+    def get_conformal_polygon_from_netlist(self, netlist=None):
+        """Return an EDB conformal polygon based on a netlist.
 
         Parameters
         ----------
-        qty_str : str, optional
-            Quantity to plot. Default `"RealizedGain"`.
-        phi_scan : float, int, optional
-            Phi Scan Angle in degree. Default `0`.
-        theta_scan : float, int, optional
-            Theta Scan Angle in degree. Default `0`.
-        title : str, optional
-            Plot title. Default `"3D Plot"`.
-        convert_to_db : bool, optional
-            Either if the quantity has to be converted in db or not. Default is `True`.
-        export_image_path : str, optional
-            Full path to image file. Default is None to not export.
 
+        netlist : List of net names.
+            list[str]
 
         Returns
         -------
+        :class:`Edb.Cell.Primitive.Polygon`
+            Edb polygon object.
 
         """
-        data = self.beamform(phi_scan, theta_scan)
-
-        if convert_to_db:
-            ff_data = 10 * np.log10(data[qty_str])
-            # renormalize to 0 and 1
-            ff_max_dB = np.max(ff_data)
-            ff_min_dB = np.min(ff_data)
-            ff_data_renorm = (ff_data - ff_min_dB) / (ff_max_dB - ff_min_dB)
-        else:
-            ff_data = data[qty_str]
-            # renormalize to 0 and 1
-            ff_max = np.max(ff_data)
-            ff_min = np.min(ff_data)
-            ff_data_renorm = (ff_data - ff_max) / (ff_max - ff_min)
-
-        theta = np.deg2rad(np.array(data["Theta"]))
-        phi = np.deg2rad(np.array(data["Phi"]))
-        phi_grid, theta_grid = np.meshgrid(phi, theta)
-        r = np.reshape(ff_data_renorm, (len(data["Theta"]), len(data["Phi"])))
-
-        x = r * np.sin(theta_grid) * np.cos(phi_grid)
-        y = r * np.sin(theta_grid) * np.sin(phi_grid)
-        z = r * np.cos(theta_grid)
-        plot_3d_chart([x, y, z], xlabel="Theta", ylabel="Phi", title=title, snapshot_path=export_image_path)
-
-    @pyaedt_function_handler()
-    def _get_geometry(self, is_antenna_array=True):
-        data = self.beamform(0, 0)
-        time_before = time.time()
-        self._app.logger.info("Exporting Geometry...")
-
-        # obj is being exported as model units, scaling factor needed for display
-        sf = AEDT_UNITS["Length"][self._app.modeler.model_units]
-
-        bounding_box = self._app.modeler.obounding_box
-        xmax = float(bounding_box[3]) - float(bounding_box[0])
-        ymax = float(bounding_box[4]) - float(bounding_box[1])
-        zmax = float(bounding_box[5]) - float(bounding_box[2])
-
-        geo_path = "{}\\geo\\".format(self._app.working_directory)
-        if not os.path.exists(geo_path):
-            os.makedirs(geo_path)
-
-        model_pv = self._app.post.get_model_plotter_geometries(plot_air_objects=False)
-
-        obj_meshes = []
-        center = []
-        if is_antenna_array:
-            i = 0
-            for obj in model_pv.objects:
-                for each in data["Element_Location"]:
-                    mesh = obj._cached_polydata
-                    translated_mesh = mesh.copy()
-                    offset_xyz = data["Element_Location"][each] / sf
-                    if np.abs(2 * offset_xyz[0]) > xmax:  # assume array is centere, factor of 2
-                        xmax = offset_xyz[0] * 2
-                    if np.abs(2 * offset_xyz[1]) > ymax:  # assume array is centere, factor of 2
-                        ymax = offset_xyz[1] * 2
-                    translated_mesh.position = offset_xyz
-                    translated_mesh.translate(offset_xyz, inplace=True)
-                    color_cad = [i / 255 for i in obj.color]
-
-                    if len(obj_meshes) > i:
-                        obj_meshes[i][0] += translated_mesh
-                    else:
-                        obj_meshes.append([translated_mesh, color_cad, obj.opacity])
-                i += 1
-                if not center:
-                    center = obj_meshes[-1][0].center
+        temp_edb_path = self.edbpath[:-5] + "_temp_aedb.aedb"
+        shutil.copytree(self.edbpath, temp_edb_path)
+        temp_edb = Edb(temp_edb_path)
+        for via in list(temp_edb.padstacks.instances.values()):
+            via.pin.Delete()
+        if netlist:
+            nets = convert_py_list_to_net_list(
+                [net for net in list(self.active_layout.Nets) if net.GetName() in netlist]
+            )
+            _poly = temp_edb.active_layout.GetExpandedExtentFromNets(
+                nets, self.edb.Geometry.ExtentType.Conforming, 0.0, True, True, 1
+            )
+        else:
+            nets = convert_py_list_to_net_list(
+                [net for net in list(temp_edb.active_layout.Nets) if "gnd" in net.GetName().lower()]
+            )
+            _poly = temp_edb.active_layout.GetExpandedExtentFromNets(
+                nets, self.edb.Geometry.ExtentType.Conforming, 0.0, True, True, 1
+            )
+            temp_edb.close_edb()
+        if _poly:
+            return _poly
+        else:
+            return False
+
+    @pyaedt_function_handler()
+    def number_with_units(self, value, units=None):
+        """Convert a number to a string with units. If value is a string, it's returned as is.
+
+        Parameters
+        ----------
+        value : float, int, str
+            Input number or string.
+        units : optional
+            Units for formatting. The default is ``None``, which uses ``"meter"``.
+
+        Returns
+        -------
+        str
+           String concatenating the value and unit.
+
+        """
+        if units is None:
+            units = "meter"
+        if isinstance(value, str):
+            return value
+        else:
+            return "{0}{1}".format(value, units)
+
+    @pyaedt_function_handler()
+    def arg_with_dim(self, Value, sUnits):
+        """Convert a number to a string with units. If value is a string, it's returned as is.
+
+        .. deprecated:: 0.6.56
+           Use :func:`number_with_units` property instead.
+
+        Parameters
+        ----------
+        Value : float, int, str
+            Input  number or string.
+        sUnits : optional
+            Units for formatting. The default is ``None``, which uses ``"meter"``.
+
+        Returns
+        -------
+        str
+           String concatenating the value and unit.
+
+        """
+        warnings.warn("Use :func:`number_with_units` instead.", DeprecationWarning)
+        return self.number_with_units(Value, sUnits)
+
+    def _decompose_variable_value(self, value, unit_system=None):
+        val, units = decompose_variable_value(value)
+        if units and unit_system and units in AEDT_UNITS[unit_system]:
+            return AEDT_UNITS[unit_system][units] * val
+        else:
+            return val
+
+    @pyaedt_function_handler()
+    def _create_cutout_on_point_list(
+        self,
+        point_list,
+        units="mm",
+        output_aedb_path=None,
+        open_cutout_at_end=True,
+        nets_to_include=None,
+        include_partial_instances=False,
+        keep_voids=True,
+    ):
+        if point_list[0] != point_list[-1]:
+            point_list.append(point_list[0])
+        point_list = [[self.number_with_units(i[0], units), self.number_with_units(i[1], units)] for i in point_list]
+        plane = self.modeler.Shape("polygon", points=point_list)
+        polygonData = self.modeler.shape_to_polygon_data(plane)
+        _ref_nets = []
+        if nets_to_include:
+            self.logger.info("Creating cutout on {} nets.".format(len(nets_to_include)))
+        else:
+            self.logger.info("Creating cutout on all nets.")  # pragma: no cover
+
+        # Check Padstack Instances overlapping the cutout
+        pinstance_to_add = []
+        if include_partial_instances:
+            if nets_to_include:
+                pinst = [i for i in list(self.padstacks.instances.values()) if i.net_name in nets_to_include]
+            else:
+                pinst = [i for i in list(self.padstacks.instances.values())]
+            for p in pinst:
+                if p.in_polygon(polygonData):
+                    pinstance_to_add.append(p)
+        # validate references in layout
+        for _ref in self.nets.nets:
+            if nets_to_include:
+                if _ref in nets_to_include:
+                    _ref_nets.append(self.nets.nets[_ref].net_object)
+            else:
+                _ref_nets.append(self.nets.nets[_ref].net_object)  # pragma: no cover
+        if keep_voids:
+            voids = [p for p in self.modeler.circles if p.is_void]
+            voids2 = [p for p in self.modeler.polygons if p.is_void]
+            voids.extend(voids2)
+        else:
+            voids = []
+        voids_to_add = []
+        for circle in voids:
+            if polygonData.GetIntersectionType(circle.primitive_object.GetPolygonData()) >= 3:
+                voids_to_add.append(circle)
+
+        _netsClip = convert_py_list_to_net_list(_ref_nets)
+        net_signals = List[type(_ref_nets[0])]()  # pragma: no cover
+        # Create new cutout cell/design
+        _cutout = self.active_cell.CutOut(net_signals, _netsClip, polygonData)
+        layout = _cutout.GetLayout()
+        cutout_obj_coll = list(layout.PadstackInstances)
+        ids = []
+        for lobj in cutout_obj_coll:
+            ids.append(lobj.GetId())
+
+        if include_partial_instances:
+            p_missing = [i for i in pinstance_to_add if i.id not in ids]
+            self.logger.info("Added {} padstack instances after cutout".format(len(p_missing)))
+            for p in p_missing:
+                position = self.edb.Geometry.PointData(self.edb_value(p.position[0]), self.edb_value(p.position[1]))
+                net = self.nets.find_or_create_net(p.net_name)
+                rotation = self.edb_value(p.rotation)
+                sign_layers = list(self.stackup.signal_layers.keys())
+                if not p.start_layer:  # pragma: no cover
+                    fromlayer = self.stackup.signal_layers[sign_layers[0]]._edb_layer
+                else:
+                    fromlayer = self.stackup.signal_layers[p.start_layer]._edb_layer
+
+                if not p.stop_layer:  # pragma: no cover
+                    tolayer = self.stackup.signal_layers[sign_layers[-1]]._edb_layer
                 else:
-                    center = [i + j for i, j in zip(obj_meshes[-1][0].center, center)]
-        center = [-k / i for k in center]
-        self.all_max = np.max(np.array([xmax, ymax, zmax]))
-        elapsed_time = time.time() - time_before
-        self._app.logger.info("Exporting Geometry...Done: %s seconds", elapsed_time)
-        for mesh in obj_meshes:
-            mesh[0].translate(center, inplace=True)
-        return obj_meshes
+                    tolayer = self.stackup.signal_layers[p.stop_layer]._edb_layer
+                padstack = None
+                for pad in list(self.padstacks.definitions.keys()):
+                    if pad == p.padstack_definition:
+                        padstack = self.padstacks.definitions[pad].edb_padstack
+                        padstack_instance = self.edb.Cell.Primitive.PadstackInstance.Create(
+                            _cutout.GetLayout(),
+                            net,
+                            p.name,
+                            padstack,
+                            position,
+                            rotation,
+                            fromlayer,
+                            tolayer,
+                            None,
+                            None,
+                        )
+                        padstack_instance.SetIsLayoutPin(p.is_pin)
+                        break
+
+        for void_circle in voids_to_add:
+            if void_circle.type == "Circle":
+                if is_ironpython:  # pragma: no cover
+                    res, center_x, center_y, radius = void_circle.primitive_object.GetParameters()
+                else:
+                    res, center_x, center_y, radius = void_circle.primitive_object.GetParameters(0.0, 0.0, 0.0)
+                cloned_circle = self.edb.Cell.Primitive.Circle.Create(
+                    layout,
+                    void_circle.layer_name,
+                    void_circle.net,
+                    self.edb_value(center_x),
+                    self.edb_value(center_y),
+                    self.edb_value(radius),
+                )
+                cloned_circle.SetIsNegative(True)
+            elif void_circle.type == "Polygon":
+                cloned_polygon = self.edb.Cell.Primitive.Polygon.Create(
+                    layout, void_circle.layer_name, void_circle.net, void_circle.primitive_object.GetPolygonData()
+                )
+                cloned_polygon.SetIsNegative(True)
+        layers = [i for i in list(self.stackup.signal_layers.keys())]
+        for layer in layers:
+            layer_primitves = self.modeler.get_primitives(layer_name=layer)
+            if len(layer_primitves) == 0:
+                self.modeler.create_polygon(plane, layer, net_name="DUMMY")
+        self.logger.info("Cutout %s created correctly", _cutout.GetName())
+        id = 1
+        for _setup in self.active_cell.SimulationSetups:
+            # Empty string '' if coming from setup copy and don't set explicitly.
+            _setup_name = _setup.GetName()
+            if "GetSimSetupInfo" in dir(_setup):
+                # setup is an Ansys.Ansoft.Edb.Utility.HFSSSimulationSetup object
+                _hfssSimSetupInfo = _setup.GetSimSetupInfo()
+                _hfssSimSetupInfo.Name = "HFSS Setup " + str(id)  # Set name of analysis setup
+                # Write the simulation setup info into the cell/design setup
+                _setup.SetSimSetupInfo(_hfssSimSetupInfo)
+                _cutout.AddSimulationSetup(_setup)  # Add simulation setup to the cutout design
+                id += 1
+            else:
+                _cutout.AddSimulationSetup(_setup)  # Add simulation setup to the cutout design
+
+        _dbCells = [_cutout]
+        if output_aedb_path:
+            db2 = self.edb.Database.Create(output_aedb_path)
+            if not db2.Save():
+                self.logger.error("Failed to create new Edb. Check if the path already exists and remove it.")
+                return False
+            _dbCells = convert_py_list_to_net_list(_dbCells)
+            cell_copied = db2.CopyCells(_dbCells)  # Copies cutout cell/design to db2 project
+            cell = list(cell_copied)[0]
+            cell.SetName(os.path.basename(output_aedb_path[:-5]))
+            db2.Save()
+            for c in list(self.db.TopCircuitCells):
+                if c.GetName() == _cutout.GetName():
+                    c.Delete()
+            if open_cutout_at_end:  # pragma: no cover
+                _success = db2.Save()
+                self._db = db2
+                self.edbpath = output_aedb_path
+                self._active_cell = cell
+                self.builder = EdbBuilder(self.edbutils, self._db, self._active_cell)
+                self.edbpath = self._db.GetDirectory()
+                self._init_objects()
+            else:
+                db2.Close()
+                source = os.path.join(output_aedb_path, "edb.def.tmp")
+                target = os.path.join(output_aedb_path, "edb.def")
+                self._wait_for_file_release(file_to_release=output_aedb_path)
+                if os.path.exists(source) and not os.path.exists(target):
+                    try:
+                        shutil.copy(source, target)
+                        self.logger.warning("aedb def file manually created.")
+                    except:
+                        pass
+        return True
 
     @pyaedt_function_handler()
-    def polar_plot_3d_pyvista(
+    def create_cutout_on_point_list(
         self,
-        qty_str="RealizedGain",
-        convert_to_db=True,
-        position=None,
-        rotation=None,
-        export_image_path=None,
-        show=True,
-        show_as_standalone=False,
+        point_list,
+        units="mm",
+        output_aedb_path=None,
+        open_cutout_at_end=True,
+        nets_to_include=None,
+        include_partial_instances=False,
+        keep_voids=True,
     ):
-        """Create a 3d Polar Plot of Geometry with Radiation Pattern in Pyvista.
+        """Create a cutout on a specified shape and save it to a new AEDB file.
+
+        .. deprecated:: 0.6.58
+           Use new method :func:`cutout` instead.
 
         Parameters
         ----------
-        qty_str : str, optional
-            Quantity to plot. Default `"RealizedGain"`.
-        convert_to_db : bool, optional
-            Either if the quantity has to be converted in db or not. Default is `True`.
-        export_image_path : str, optional
-            Full path to image file. Default is None to not export.
-        position : list, optional
-            It can be a list of numpy list of origin of plot. Default is [0,0,0].
-        rotation : list, optional
-            It can be a list of numpy list of origin of plot.
-            Default is [[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]].
-        show : bool, optional
-            Either if the plot has to be shown or not. Default is `True`.
-        show_as_standalone : bool, optional
-            Either if the plot has to be shown as standalone or not. Default is `True`.
-
-        Returns
-        -------
-        bool or :class:`Pyvista.Plotter`
-            Return :class:`Pyvista.Plotter` in case show and export_image_path is `False`.
-            In other cases return ``True`` when successful.
-
-        """
-        if not position:
-            position = np.zeros(3)
-        elif isinstance(position, (list, tuple)):
-            position = np.array(position)
-        if not rotation:
-            rotation = np.eye(3)
-        elif isinstance(rotation, (list, tuple)):
-            rotation = np.array(rotation)
-        self.beamform(phi_scan=0, theta_scan=0)
-        plot_min = -40
-        self._get_far_field_mesh(qty_str=qty_str, convert_to_db=convert_to_db)
-
-        # plot everything together
-        rotation_euler = self._rotation_to_euler_angles(rotation) * 180 / np.pi
-
-        if not export_image_path and not show:
-            off_screen = False
-        else:
-            off_screen = not show
-
-        if show_as_standalone:
-            p = pv.Plotter(notebook=False, off_screen=off_screen)
-        else:
-            p = pv.Plotter(notebook=is_notebook(), off_screen=off_screen)
-
-        uf = UpdateBeamForm(self)
-
-        p.add_slider_widget(
-            uf.update_phi,
-            rng=[0, 360],
-            value=0,
-            title="Phi",
-            pointa=(0.55, 0.1),
-            pointb=(0.74, 0.1),
-            style="modern",
-            event_type="always",
-            title_height=0.02,
-        )
-        p.add_slider_widget(
-            uf.update_theta,
-            rng=[-180, 180],
-            value=0,
-            title="Theta",
-            pointa=(0.77, 0.1),
-            pointb=(0.98, 0.1),
-            style="modern",
-            event_type="always",
-            title_height=0.02,
-        )
+        point_list : list
+            Points list defining the cutout shape.
+        units : str
+            Units of the point list. The default is ``"mm"``.
+        output_aedb_path : str, optional
+            Full path and name for the new AEDB file.
+            The aedb folder shall not exist otherwise the method will return ``False``.
+        open_cutout_at_end : bool, optional
+            Whether to open the cutout at the end. The default is ``True``.
+        nets_to_include : list, optional
+            List of nets to include in the cutout. The default is ``None``, in
+            which case all nets are included.
+        include_partial_instances : bool, optional
+            Whether to include padstack instances that have bounding boxes intersecting with point list polygons.
+            This operation may slow down the cutout export.
+        keep_voids : bool
+            Boolean used for keep or not the voids intersecting the polygon used for clipping the layout.
+            Default value is ``True``, ``False`` will remove the voids.
 
-        # sargs = dict(height=0.4, vertical=True, position_x=0.05, position_y=0.5)
-        sargs = dict(
-            title_font_size=12,
-            label_font_size=10,
-            shadow=True,
-            n_labels=7,
-            italic=True,
-            fmt="%.1f",
-            font_family="arial",
-            vertical=True,
-            position_x=0.05,
-            position_y=0.65,
-            height=0.3,
-            width=0.06,
-            outline=True,
+        Returns
+        -------
+        bool
+            ``True`` when successful, ``False`` when failed.
+
+        """
+        warnings.warn("Use new method `cutout` instead.", DeprecationWarning)
+        return self._create_cutout_on_point_list(
+            point_list=point_list,
+            units=units,
+            output_aedb_path=output_aedb_path,
+            open_cutout_at_end=open_cutout_at_end,
+            nets_to_include=nets_to_include,
+            include_partial_instances=include_partial_instances,
+            keep_voids=keep_voids,
         )
-        # ff_mesh_inst = p.add_mesh(uf.output,smooth_shading=True,cmap="jet",scalar_bar_args=sargs,opacity=0.5)
-        # not sure why, but smooth_shading causes this to not update
 
-        ff_mesh_inst = p.add_mesh(uf.output, cmap="jet", clim=[plot_min, self.max_gain], scalar_bar_args=sargs)
-        cad_mesh = self._get_geometry()
-        if cad_mesh:
-
-            def toggle_vis_ff(flag):
-                ff_mesh_inst.SetVisibility(flag)
-
-            def toggle_vis_cad(flag):
-                for i in cad:
-                    i.SetVisibility(flag)
-
-            def scale(value=1):
-                ff_mesh_inst.SetScale(value, value, value)
-                ff_mesh_inst.SetPosition(position)
-                ff_mesh_inst.SetOrientation(rotation_euler)
-                # p.add_mesh(ff_mesh, smooth_shading=True,cmap="jet")
-                return
+    @pyaedt_function_handler()
+    def write_export3d_option_config_file(self, path_to_output, config_dictionaries=None):
+        """Write the options for a 3D export to a configuration file.
 
-            p.add_checkbox_button_widget(toggle_vis_ff, value=True, size=30)
-            p.add_text("Show Far Fields", position=(70, 25), color="white", font_size=10)
-            slider_max = int(np.ceil(self.all_max / 2 / self.max_gain))
-            if slider_max > 0:
-                slider_min = 0
-                value = slider_max / 3
-            else:
-                slider_min = slider_max
-                slider_max = 0
-                value = slider_min / 3
-
-            p.add_slider_widget(
-                scale,
-                [slider_min, slider_max],
-                title="Scale Plot",
-                value=value,
-                pointa=(0.7, 0.93),
-                pointb=(0.99, 0.93),
-                style="modern",
-                title_height=0.02,
-            )
+        Parameters
+        ----------
+        path_to_output : str
+            Full path to the configuration file to save 3D export options to.
 
-            cad = []
-            for cm in cad_mesh:
-                cad.append(p.add_mesh(cm[0], color=cm[1], show_scalar_bar=False, opacity=cm[2]))
-            p.add_checkbox_button_widget(toggle_vis_cad, value=True, position=(10, 70), size=30)
-            p.add_text("Show Geometry", position=(70, 75), color="white", font_size=10)
+        config_dictionaries : dict, optional
+            Configuration dictionaries. The default is ``None``.
+
+        """
+        option_config = {
+            "UNITE_NETS": 1,
+            "ASSIGN_SOLDER_BALLS_AS_SOURCES": 0,
+            "Q3D_MERGE_SOURCES": 0,
+            "Q3D_MERGE_SINKS": 0,
+            "CREATE_PORTS_FOR_PWR_GND_NETS": 0,
+            "PORTS_FOR_PWR_GND_NETS": 0,
+            "GENERATE_TERMINALS": 0,
+            "SOLVE_CAPACITANCE": 0,
+            "SOLVE_DC_RESISTANCE": 0,
+            "SOLVE_DC_INDUCTANCE_RESISTANCE": 1,
+            "SOLVE_AC_INDUCTANCE_RESISTANCE": 0,
+            "CreateSources": 0,
+            "CreateSinks": 0,
+            "LAUNCH_Q3D": 0,
+            "LAUNCH_HFSS": 0,
+        }
+        if config_dictionaries:
+            for el, val in config_dictionaries.items():
+                option_config[el] = val
+        with open(os.path.join(path_to_output, "options.config"), "w") as f:
+            for el, val in option_config.items():
+                f.write(el + " " + str(val) + "\n")
+        return os.path.join(path_to_output, "options.config")
+
+    @pyaedt_function_handler()
+    def export_hfss(self, path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False):
+        """Export EDB to HFSS.
 
-        if export_image_path:
-            p.show(screenshot=export_image_path)
-            return True
-        elif show:  # pragma: no cover
-            p.show()
-            return True
-        return p
+        Parameters
+        ----------
+        path_to_output : str
+            Full path and name for saving the AEDT file.
+        net_list : list, optional
+            List of nets to export if only certain ones are to be exported.
+            The default is ``None``, in which case all nets are eported.
+        num_cores : int, optional
+            Number of cores to use for the export. The default is ``None``.
+        aedt_file_name : str, optional
+            Name of the AEDT output file without the ``.aedt`` extension. The default is ``None``,
+            in which case the default name is used.
+        hidden : bool, optional
+            Open Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.
+
+        Returns
+        -------
+        str
+            Full path to the AEDT file.
+
+        Examples
+        --------
+
+        >>> from pyaedt import Edb
+
+        >>> edb = Edb(edbpath=r"C:\temp\myproject.aedb", edbversion="2021.2")
+
+        >>> options_config = {'UNITE_NETS' : 1, 'LAUNCH_Q3D' : 0}
+        >>> edb.write_export3d_option_config_file(r"C:\temp", options_config)
+        >>> edb.export_hfss(r"C:\temp")
+        "C:\\temp\\hfss_siwave.aedt"
+
+        """
+        siwave_s = SiwaveSolve(self.edbpath, aedt_installer_path=self.base_path)
+        return siwave_s.export_3d_cad("HFSS", path_to_output, net_list, num_cores, aedt_file_name, hidden=hidden)
 
     @pyaedt_function_handler()
-    def polar_plot_3d_pyvista_2beams(
-        self,
-        qty_str="RealizedGain",
-        convert_to_db=True,
-        position=None,
-        rotation=None,
-        export_image_path=None,
-        show=True,
-    ):  # pragma: no cover
-        """Create a 3d Polar Plot with 2 beams of Geometry with Radiation Pattern in Pyvista.
+    def export_q3d(self, path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False):
+        """Export EDB to Q3D.
 
         Parameters
         ----------
-        qty_str : str, optional
-            Quantity to plot. Default `"RealizedGain"`.
-        convert_to_db : bool, optional
-            Either if the quantity has to be converted in db or not. Default is `True`.
-        export_image_path : str, optional
-            Full path to image file. Default is None to not export.
-        position : list, optional
-            It can be a list of numpy list of origin of plot. Default is [0,0,0].
-        rotation : list, optional
-            It can be a list of numpy list of origin of plot.
-            Default is [[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]].
-        show : bool, optional
-            Either if the plot has to be shown or not. Default is `True`.
+        path_to_output : str
+            Full path and name for saving the AEDT file.
+        net_list : list, optional
+            List of nets to export only if certain ones are to be exported.
+            The default is ``None``, in which case all nets are eported.
+        num_cores : int, optional
+            Number of cores to use for the export. The default is ``None``.
+        aedt_file_name : str, optional
+            Name of the AEDT output file without the ``.aedt`` extension. The default is ``None``,
+            in which case the default name is used.
+        hidden : bool, optional
+            Open Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.
 
         Returns
         -------
-        bool or :class:`Pyvista.Plotter`
-            Return :class:`Pyvista.Plotter` in case show and export_image_path is `False`.
-            In other cases return ``True`` when successful.
-        """
-        if not position:
-            position = np.zeros(3)
-        elif isinstance(position, (list, tuple)):
-            position = np.array(position)
-        if not rotation:
-            rotation = np.eye(3)
-        elif isinstance(rotation, (list, tuple)):
-            rotation = np.array(rotation)
-        self.beamform_2beams(phi_scan1=0, theta_scan1=0, phi_scan2=0, theta_scan2=0)
-        self._get_far_field_mesh(qty_str=qty_str, convert_to_db=convert_to_db)
-
-        uf = Update2BeamForms(self, max_value=self.max_gain)
-        rotation_euler = self._rotation_to_euler_angles(rotation) * 180 / np.pi
-
-        if not export_image_path and not show:
-            off_screen = False
-        else:
-            off_screen = not show
-
-        p = pv.Plotter(notebook=is_notebook(), off_screen=off_screen, window_size=[1024, 768])
-
-        p.add_slider_widget(
-            uf.update_phi1,
-            rng=[0, 360],
-            value=0,
-            title="Phi1",
-            pointa=(0.35, 0.1),
-            pointb=(0.64, 0.1),
-            style="modern",
-            event_type="always",
-        )
-        p.add_slider_widget(
-            uf.update_theta1,
-            rng=[-180, 180],
-            value=0,
-            title="Theta1",
-            pointa=(0.67, 0.1),
-            pointb=(0.98, 0.1),
-            style="modern",
-            event_type="always",
-        )
+        str
+            Full path to the AEDT file.
 
-        p.add_slider_widget(
-            uf.update_phi2,
-            rng=[0, 360],
-            value=0,
-            title="Phi2",
-            pointa=(0.35, 0.25),
-            pointb=(0.64, 0.25),
-            style="modern",
-            event_type="always",
-        )
-        p.add_slider_widget(
-            uf.update_theta2,
-            rng=[-180, 180],
-            value=0,
-            title="Theta2",
-            pointa=(0.67, 0.25),
-            pointb=(0.98, 0.25),
-            style="modern",
-            event_type="always",
-        )
-        sargs = dict(height=0.4, vertical=True, position_x=0.05, position_y=0.5)
-        # ff_mesh_inst = p.add_mesh(uf.output,smooth_shading=True,cmap="jet",scalar_bar_args=sargs,opacity=0.5)
-        # not sure why, but smooth_shading causes this to not update
-        plot_min = self.min_gain
-        ff_mesh_inst = p.add_mesh(uf.output, cmap="jet", clim=[plot_min, self.max_gain], scalar_bar_args=sargs)
-        cad_mesh = self._get_geometry()
-        if cad_mesh:
-
-            def toggle_vis_ff(flag):
-                ff_mesh_inst.SetVisibility(flag)
-
-            def toggle_vis_cad(flag):
-                for i in cad:
-                    i.SetVisibility(flag)
-
-            def scale(value=1):
-                ff_mesh_inst.SetScale(value, value, value)
-                ff_mesh_inst.SetPosition(position)
-                ff_mesh_inst.SetOrientation(rotation_euler)
-                # p.add_mesh(ff_mesh, smooth_shading=True,cmap="jet")
-                return
+        Examples
+        --------
 
-            p.add_checkbox_button_widget(toggle_vis_ff, value=True)
-            p.add_text("Show Far Fields", position=(70, 25), color="black", font_size=12)
-            slider_max = int(np.ceil(self.all_max / 2 / self.max_gain))
-            if slider_max > 0:
-                slider_min = 0
-                value = slider_max / 3
-            else:
-                slider_min = slider_max
-                slider_max = 0
-                value = slider_min / 3
-            p.add_slider_widget(scale, [0, slider_max], title="Scale Plot", value=value)
-
-            if "MaterialIds" in cad_mesh.array_names:
-                color_display_type = cad_mesh["MaterialIds"]
-            else:
-                color_display_type = None
-            cad = []
-            for cm in cad_mesh:
-                cad.append(p.add_mesh(cm[0], color=cm[1], show_scalar_bar=False, opacity=cm[2]))
-            size = int(p.window_size[1] / 40)
-            p.add_checkbox_button_widget(toggle_vis_cad, size=size, value=True, position=(10, 70))
-            p.add_text("Show Geometry", position=(70, 75), color="black", font_size=12)
+        >>> from pyaedt import Edb
 
-        if export_image_path:
-            p.show(screenshot=export_image_path)
-            return True
-        elif show:
-            p.show()
-            return True
-        return p
+        >>> edb = Edb(edbpath=r"C:\temp\myproject.aedb", edbversion="2021.2")
+
+        >>> options_config = {'UNITE_NETS' : 1, 'LAUNCH_Q3D' : 0}
+        >>> edb.write_export3d_option_config_file(r"C:\temp", options_config)
+        >>> edb.export_q3d(r"C:\temp")
+        "C:\\temp\\q3d_siwave.aedt"
+
+        """
+
+        siwave_s = SiwaveSolve(self.edbpath, aedt_installer_path=self.base_path)
+        return siwave_s.export_3d_cad(
+            "Q3D", path_to_output, net_list, num_cores=num_cores, aedt_file_name=aedt_file_name, hidden=hidden
+        )
 
-    @staticmethod
     @pyaedt_function_handler()
-    def _find_nearest(array, value):
-        idx = np.searchsorted(array, value, side="left")
-        if idx > 0 and (idx == len(array) or math.fabs(value - array[idx - 1]) < math.fabs(value - array[idx])):
-            return idx - 1
-        else:
-            return idx
-
-    @staticmethod
-    @pyaedt_function_handler()
-    def _rotation_to_euler_angles(R):
-        sy = math.sqrt(R[0, 0] * R[0, 0] + R[1, 0] * R[1, 0])
-        singular = sy < 1e-6
-        if not singular:
-            x = math.atan2(R[2, 1], R[2, 2])
-            y = math.atan2(-R[2, 0], sy)
-            z = math.atan2(R[1, 0], R[0, 0])
-        else:
-            x = math.atan2(-R[1, 2], R[1, 1])
-            y = math.atan2(-R[2, 0], sy)
-            z = 0
-        return np.array([x, y, z])
-
-
-class UpdateBeamForm:
-    def __init__(self, ff):
-        self.output = ff.mesh
-        self._phi = 0
-        self._theta = 0
-        # default parameters
-        self.ff = ff
-        self.qty_str = "RealizedGain"
-        self.convert_to_db = True
-
-    def _update_both(self):
-        self.ff.beamform(phi_scan=self._phi, theta_scan=self._theta)
-        # perc_of_maxgain= self.ff.max_gain/self.max_value
+    def export_maxwell(self, path_to_output, net_list=None, num_cores=None, aedt_file_name=None, hidden=False):
+        """Export EDB to Maxwell 3D.
 
-        self.ff._get_far_field_mesh(self.qty_str, self.convert_to_db)
+        Parameters
+        ----------
+        path_to_output : str
+            Full path and name for saving the AEDT file.
+        net_list : list, optional
+            List of nets to export only if certain ones are to be
+            exported. The default is ``None``, in which case all nets are exported.
+        num_cores : int, optional
+            Number of cores to use for the export. The default is ``None.``
+        aedt_file_name : str, optional
+            Name of the AEDT output file without the ``.aedt`` extension. The default is ``None``,
+            in which case the default name is used.
+        hidden : bool, optional
+            Open Siwave in embedding mode. User will only see Siwave Icon but UI will be hidden.
 
-        self.output.overwrite(self.ff.mesh)
-        return
+        Returns
+        -------
+        str
+            Full path to the AEDT file.
 
-    def update_phi(self, phi):
-        """Updates the Pyvista Plot with new phi value."""
-        self._phi = phi
-        self._update_both()
-
-    def update_theta(self, theta):
-        """Updates the Pyvista Plot with new theta value."""
-        self._theta = theta
-        self._update_both()
-
-
-class Update2BeamForms:
-    def __init__(self, ff, max_value=1):
-        self.max_value = max_value
-        self.output = ff.mesh
-        self._phi1 = 0
-        self._theta1 = 0
-        self._phi2 = 0
-        self._theta2 = 0
-        # default parameters
-        self.ff = ff
-        self.qty_str = "RealizedGain"
-        self.convert_to_db = True
-
-    def _update_both(self):
-        self.ff.beamform_2beams(
-            phi_scan1=self._phi1, theta_scan1=self._theta1, phi_scan2=self._phi2, theta_scan2=self._theta2
-        )
-        self.ff._get_far_field_mesh(self.qty_str, self.convert_to_db)
-        current_max = np.max(self.ff.mesh["FarFieldData"])
-        delta = self.max_value - current_max
-        self.ff.mesh["FarFieldData"] = self.ff.mesh["FarFieldData"] - delta
-        self.output.overwrite(self.ff.mesh)
-        return
+        Examples
+        --------
 
-    def update_phi1(self, phi1):
-        """Updates the Pyvista Plot with new phi1 value."""
-        self._phi1 = phi1
-        self._update_both()
-
-    def update_theta1(self, theta1):
-        """Updates the Pyvista Plot with new theta1 value."""
-        self._theta1 = theta1
-        self._update_both()
-
-    def update_phi2(self, phi2):
-        """Updates the Pyvista Plot with new phi2 value."""
-        self._phi2 = phi2
-        self._update_both()
-
-    def update_theta2(self, theta2):
-        """Updates the Pyvista Plot with new theta2 value."""
-        self._theta2 = theta2
-        self._update_both()
+        >>> from pyaedt import Edb
 
+        >>> edb = Edb(edbpath=r"C:\temp\myproject.aedb", edbversion="2021.2")
 
-class FieldPlot:
-    """Creates and edits field plots.
+        >>> options_config = {'UNITE_NETS' : 1, 'LAUNCH_Q3D' : 0}
+        >>> edb.write_export3d_option_config_file(r"C:\temp", options_config)
+        >>> edb.export_maxwell(r"C:\temp")
+        "C:\\temp\\maxwell_siwave.aedt"
 
-    Parameters
-    ----------
-    postprocessor : :class:`pyaedt.modules.PostProcessor.PostProcessor`
+        """
+        siwave_s = SiwaveSolve(self.edbpath, aedt_installer_path=self.base_path)
+        return siwave_s.export_3d_cad(
+            "Maxwell",
+            path_to_output,
+            net_list,
+            num_cores=num_cores,
+            aedt_file_name=aedt_file_name,
+            hidden=hidden,
+        )
 
-    objlist : list
-        List of objects.
-    solutionName : str
-        Name of the solution.
-    quantityName : str
-        Name of the plot or the name of the object.
-    intrinsincList : dict, optional
-        Name of the intrinsic dictionary. The default is ``{}``.
+    @pyaedt_function_handler()
+    def solve_siwave(self):
+        """Close EDB and solve it with Siwave.
 
-    """
+        Returns
+        -------
+        str
+            Siwave project path.
+        """
+        process = SiwaveSolve(self.edbpath, aedt_version=self.edbversion)
+        try:
+            self._db.Close()
+        except:
+            pass
+        process.solve()
+        return self.edbpath[:-5] + ".siw"
 
-    def __init__(
+    @pyaedt_function_handler()
+    def export_siwave_dc_results(
         self,
-        postprocessor,
-        objlist=[],
-        surfacelist=[],
-        linelist=[],
-        cutplanelist=[],
-        solutionName="",
-        quantityName="",
-        intrinsincList={},
-        seedingFaces=[],
+        siwave_project,
+        solution_name,
+        output_folder=None,
+        html_report=True,
+        vias=True,
+        voltage_probes=True,
+        current_sources=True,
+        voltage_sources=True,
+        power_tree=True,
+        loop_res=True,
     ):
-        self._postprocessor = postprocessor
-        self.oField = postprocessor.ofieldsreporter
-        self.volume_indexes = objlist
-        self.surfaces_indexes = surfacelist
-        self.line_indexes = linelist
-        self.cutplane_indexes = cutplanelist
-        self.seeding_faces = seedingFaces
-        self.solutionName = solutionName
-        self.quantityName = quantityName
-        self.intrinsincList = intrinsincList
-        self.name = "Field_Plot"
-        self.plotFolder = "Field_Plot"
-        self.Filled = False
-        self.IsoVal = "Fringe"
-        self.SmoothShade = True
-        self.AddGrid = False
-        self.MapTransparency = True
-        self.Refinement = 0
-        self.Transparency = 0
-        self.SmoothingLevel = 0
-        self.ArrowUniform = True
-        self.ArrowSpacing = 0
-        self.MinArrowSpacing = 0
-        self.MaxArrowSpacing = 0
-        self.GridColor = [255, 255, 255]
-        self.PlotIsoSurface = True
-        self.PointSize = 1
-        self.CloudSpacing = 0.5
-        self.CloudMinSpacing = -1
-        self.CloudMaxSpacing = -1
-        self.LineWidth = 4
-        self.LineStyle = "Cylinder"
-        self.IsoValType = "Tone"
-        self.NumofPoints = 100
-        self.TraceStepLength = "0.001mm"
-        self.UseAdaptiveStep = True
-        self.SeedingSamplingOption = True
-        self.SeedingPointsNumber = 15
-        self.FractionOfMaximum = 0.8
-
-    @property
-    def plotGeomInfo(self):
-        """Plot geometry information."""
-        idx = 0
-        if self.volume_indexes:
-            idx += 1
-        if self.surfaces_indexes:
-            idx += 1
-        if self.cutplane_indexes:
-            idx += 1
-        if self.line_indexes:
-            idx += 1
-        info = [idx]
-        if self.volume_indexes:
-            info.append("Volume")
-            info.append("ObjList")
-            info.append(len(self.volume_indexes))
-            for index in self.volume_indexes:
-                info.append(str(index))
-        if self.surfaces_indexes:
-            model_faces = []
-            nonmodel_faces = []
-            models = self._postprocessor.modeler.model_objects
-            for index in self.surfaces_indexes:
-                try:
-                    if isinstance(index, FacePrimitive):
-                        index = index.id
-                    oname = self._postprocessor.modeler.oeditor.GetObjectNameByFaceID(index)
-                    if oname in models:
-                        model_faces.append(str(index))
-                    else:
-                        nonmodel_faces.append(str(index))
-                except:
-                    pass
-            info.append("Surface")
-            if model_faces:
-                info.append("FacesList")
-                info.append(len(model_faces))
-                for index in model_faces:
-                    info.append(index)
-            if nonmodel_faces:
-                info.append("NonModelFaceList")
-                info.append(len(nonmodel_faces))
-                for index in nonmodel_faces:
-                    info.append(index)
-        if self.cutplane_indexes:
-            info.append("Surface")
-            info.append("CutPlane")
-            info.append(len(self.cutplane_indexes))
-            for index in self.cutplane_indexes:
-                info.append(str(index))
-        if self.line_indexes:
-            info.append("Line")
-            info.append(len(self.line_indexes))
-            for index in self.line_indexes:
-                info.append(str(index))
-        return info
-
-    @property
-    def intrinsicVar(self):
-        """Intrinsic variable.
+        """Close EDB and solve it with Siwave.
 
+        Parameters
+        ----------
+        siwave_project : str
+            Siwave full project name.
+        solution_name : str
+            Siwave DC Analysis name.
+        output_folder : str, optional
+            Ouptu folder where files will be downloaded.
+        html_report : bool, optional
+            Either if generate or not html report. Default is `True`.
+        vias : bool, optional
+            Either if generate or not vias report. Default is `True`.
+        voltage_probes : bool, optional
+            Either if generate or not voltage probe report. Default is `True`.
+        current_sources : bool, optional
+            Either if generate or not current source report. Default is `True`.
+        voltage_sources : bool, optional
+            Either if generate or not voltage source report. Default is `True`.
+        power_tree : bool, optional
+            Either if generate or not power tree image. Default is `True`.
+        loop_res : bool, optional
+            Either if generate or not loop resistance report. Default is `True`.
         Returns
         -------
-        list or dict
-            List or dictionary of the variables for the field plot.
-        """
-        var = ""
-        if type(self.intrinsincList) is list:
-            l = 0
-            while l < len(self.intrinsincList):
-                val = self.intrinsincList[l + 1]
-                if ":=" in self.intrinsincList[l] and isinstance(self.intrinsincList[l + 1], list):
-                    val = self.intrinsincList[l + 1][0]
-                ll = self.intrinsincList[l].split(":=")
-                var += ll[0] + "='" + str(val) + "' "
-                l += 2
-        else:
-            for a in self.intrinsincList:
-                var += a + "='" + str(self.intrinsincList[a]) + "' "
-        return var
+        list
+            list of files generated.
+        """
+        process = SiwaveSolve(self.edbpath, aedt_version=self.edbversion)
+        try:
+            self._db.Close()
+        except:
+            pass
+        return process.export_dc_report(
+            siwave_project,
+            solution_name,
+            output_folder,
+            html_report,
+            vias,
+            voltage_probes,
+            current_sources,
+            voltage_sources,
+            power_tree,
+            loop_res,
+            hidden=True,
+        )
 
-    @property
-    def plotsettings(self):
-        """Plot settings.
+    @pyaedt_function_handler()
+    def variable_exists(self, variable_name):
+        """Check if a variable exists or not.
 
         Returns
         -------
-        list
-            List of plot settings.
+        tuple of bool and VaribleServer
+            It returns a booleand to check if the variable exists and the variable
+            server that should contain the variable.
         """
-        if self.surfaces_indexes or self.cutplane_indexes:
-            arg = [
-                "NAME:PlotOnSurfaceSettings",
-                "Filled:=",
-                self.Filled,
-                "IsoValType:=",
-                self.IsoVal,
-                "SmoothShade:=",
-                self.SmoothShade,
-                "AddGrid:=",
-                self.AddGrid,
-                "MapTransparency:=",
-                self.MapTransparency,
-                "Refinement:=",
-                self.Refinement,
-                "Transparency:=",
-                self.Transparency,
-                "SmoothingLevel:=",
-                self.SmoothingLevel,
-                [
-                    "NAME:Arrow3DSpacingSettings",
-                    "ArrowUniform:=",
-                    self.ArrowUniform,
-                    "ArrowSpacing:=",
-                    self.ArrowSpacing,
-                    "MinArrowSpacing:=",
-                    self.MinArrowSpacing,
-                    "MaxArrowSpacing:=",
-                    self.MaxArrowSpacing,
-                ],
-                "GridColor:=",
-                self.GridColor,
-            ]
-        elif self.line_indexes:
-            arg = [
-                "NAME:PlotOnLineSettings",
-                ["NAME:LineSettingsID", "Width:=", self.LineWidth, "Style:=", self.LineStyle],
-                "IsoValType:=",
-                self.IsoValType,
-                "ArrowUniform:=",
-                self.ArrowUniform,
-                "NumofArrow:=",
-                self.NumofPoints,
-                "Refinement:=",
-                self.Refinement,
-            ]
+        if "$" in variable_name:
+            if variable_name.index("$") == 0:
+                var_server = self.db.GetVariableServer()
+
+            else:
+                var_server = self.active_cell.GetVariableServer()
+
         else:
-            arg = [
-                "NAME:PlotOnVolumeSettings",
-                "PlotIsoSurface:=",
-                self.PlotIsoSurface,
-                "PointSize:=",
-                self.PointSize,
-                "Refinement:=",
-                self.Refinement,
-                "CloudSpacing:=",
-                self.CloudSpacing,
-                "CloudMinSpacing:=",
-                self.CloudMinSpacing,
-                "CloudMaxSpacing:=",
-                self.CloudMaxSpacing,
-                [
-                    "NAME:Arrow3DSpacingSettings",
-                    "ArrowUniform:=",
-                    self.ArrowUniform,
-                    "ArrowSpacing:=",
-                    self.ArrowSpacing,
-                    "MinArrowSpacing:=",
-                    self.MinArrowSpacing,
-                    "MaxArrowSpacing:=",
-                    self.MaxArrowSpacing,
-                ],
-            ]
-        return arg
+            var_server = self.active_cell.GetVariableServer()
 
-    @property
-    def surfacePlotInstruction(self):
-        """Surface plot settings.
+        variables = var_server.GetAllVariableNames()
+        if variable_name in list(variables):
+            return True, var_server
+        return False, var_server
+
+    @pyaedt_function_handler()
+    def get_variable(self, variable_name):
+        """Return Variable Value if variable exists.
+
+        Parameters
+        ----------
+        variable_name
 
         Returns
         -------
-        list
-            List of surface plot settings.
-
+        :class:`pyaedt.edb_core.edb_data.edbvalue.EdbValue`
         """
-        return [
-            "NAME:" + self.name,
-            "SolutionName:=",
-            self.solutionName,
-            "QuantityName:=",
-            self.quantityName,
-            "PlotFolder:=",
-            self.plotFolder,
-            "UserSpecifyName:=",
-            1,
-            "UserSpecifyFolder:=",
-            1,
-            "StreamlinePlot:=",
-            False,
-            "AdjacentSidePlot:=",
-            False,
-            "FullModelPlot:=",
-            False,
-            "IntrinsicVar:=",
-            self.intrinsicVar,
-            "PlotGeomInfo:=",
-            self.plotGeomInfo,
-            "FilterBoxes:=",
-            [0],
-            self.plotsettings,
-            "EnableGaussianSmoothing:=",
-            False,
-        ]
+        var_server = self.variable_exists(variable_name)
+        if var_server[0]:
+            tuple_value = var_server[1].GetVariableValue(variable_name)
+            return EdbValue(tuple_value[1])
+        self.logger.info("Variable %s doesn't exists.", variable_name)
+        return None
 
-    @property
-    def surfacePlotInstructionLineTraces(self):
-        """Surface plot settings for field line traces.
+    @pyaedt_function_handler()
+    def add_project_variable(self, variable_name, variable_value):
+        """Add a variable to edb database (project). The variable will have the prefix `$`.
 
         ..note::
-            ``Specify seeding points on selections`` is by default set to ''by sampling''.
+            User can use also the setitem to create or assign a variable. See example below.
+
+        Parameters
+        ----------
+        variable_name : str
+            Name of the variable. Name can be provided without ``$`` prefix.
+        variable_value : str, float
+            Value of the variable with units.
 
         Returns
         -------
-        list
-            List of plot settings for line traces.
+        tuple
+            Tuple containing the ``AddVariable`` result and variable server.
+
+        Examples
+        --------
+
+        >>> from pyaedt import Edb
+        >>> edb_app = Edb()
+        >>> boolean_1, ant_length = edb_app.add_project_variable("my_local_variable", "1cm")
+        >>> print(edb_app["$my_local_variable"])    #using getitem
+        >>> edb_app["$my_local_variable"] = "1cm"   #using setitem
 
         """
-        return [
-            "NAME:" + self.name,
-            "SolutionName:=",
-            self.solutionName,
-            "UserSpecifyName:=",
-            0,
-            "UserSpecifyFolder:=",
-            0,
-            "QuantityName:=",
-            "QuantityName_FieldLineTrace",
-            "PlotFolder:=",
-            self.plotFolder,
-            "IntrinsicVar:=",
-            self.intrinsicVar,
-            "Trace Step Length:=",
-            self.TraceStepLength,
-            "Use Adaptive Step:=",
-            self.UseAdaptiveStep,
-            "Seeding Faces:=",
-            self.seeding_faces,
-            "Seeding Markers:=",
-            [0],
-            "Surface Tracing Objects:=",
-            self.surfaces_indexes,
-            "Volume Tracing Objects:=",
-            self.volume_indexes,
-            "Seeding Sampling Option:=",
-            self.SeedingSamplingOption,
-            "Seeding Points Number:=",
-            self.SeedingPointsNumber,
-            "Fractional of Maximal:=",
-            self.FractionOfMaximum,
-            "Discrete Seeds Option:=",
-            "Marker Point",
-            [
-                "NAME:InceptionEvaluationSettings",
-                "Gas Type:=",
-                0,
-                "Gas Pressure:=",
-                1,
-                "Use Inception:=",
-                True,
-                "Potential U0:=",
-                0,
-                "Potential K:=",
-                0,
-                "Potential A:=",
-                1,
-            ],
-            self.field_line_trace_plot_settings,
-        ]
+        if not variable_name.startswith("$"):
+            variable_name = "${}".format(variable_name)
+        return self.add_design_variable(variable_name=variable_name, variable_value=variable_value)
 
-    @property
-    def field_plot_settings(self):
-        """Field Plot Settings.
+    @pyaedt_function_handler()
+    def add_design_variable(self, variable_name, variable_value, is_parameter=False):
+        """Add a variable to edb. The variable can be a design one or a project variable (using ``$`` prefix).
+
+        ..note::
+            User can use also the setitem to create or assign a variable. See example below.
+
+        Parameters
+        ----------
+        variable_name : str
+            Name of the variable. To added the variable as a project variable, the name
+            must begin with ``$``.
+        variable_value : str, float
+            Value of the variable with units.
+        is_parameter : bool, optional
+            Whether to add the variable as a local variable. The default is ``False``.
+            When ``True``, the variable is added as a parameter default.
 
         Returns
         -------
-        list
-            Field Plot Settings.
+        tuple
+            Tuple containing the ``AddVariable`` result and variable server.
+
+        Examples
+        --------
+
+        >>> from pyaedt import Edb
+        >>> edb_app = Edb()
+        >>> boolean_1, ant_length = edb_app.add_design_variable("my_local_variable", "1cm")
+        >>> print(edb_app["my_local_variable"])    #using getitem
+        >>> edb_app["my_local_variable"] = "1cm"   #using setitem
+        >>> boolean_2, para_length = edb_app.change_design_variable_value("my_parameter", "1m", is_parameter=True
+        >>> boolean_3, project_length = edb_app.change_design_variable_value("$my_project_variable", "1m")
+
+
         """
-        return [
-            "NAME:FieldsPlotItemSettings",
-            [
-                "NAME:PlotOnSurfaceSettings",
-                "Filled:=",
-                self.Filled,
-                "IsoValType:=",
-                self.IsoVal,
-                "AddGrid:=",
-                self.AddGrid,
-                "MapTransparency:=",
-                self.MapTransparency,
-                "Refinement:=",
-                self.Refinement,
-                "Transparency:=",
-                self.Transparency,
-                "SmoothingLevel:=",
-                self.SmoothingLevel,
-                "ShadingType:=",
-                self.SmoothShade,
-                [
-                    "NAME:Arrow3DSpacingSettings",
-                    "ArrowUniform:=",
-                    self.ArrowUniform,
-                    "ArrowSpacing:=",
-                    self.ArrowSpacing,
-                    "MinArrowSpacing:=",
-                    self.MinArrowSpacing,
-                    "MaxArrowSpacing:=",
-                    self.MaxArrowSpacing,
-                ],
-                "GridColor:=",
-                self.GridColor,
-            ],
-        ]
+        var_server = self.variable_exists(variable_name)
+        if not var_server[0]:
+            var_server[1].AddVariable(variable_name, self.edb_value(variable_value), is_parameter)
+            return True, var_server[1]
+        self.logger.error("Variable %s already exists.", variable_name)
+        return False, var_server[1]
 
-    @property
-    def field_line_trace_plot_settings(self):
-        """Settings for the field line traces in the plot.
+    @pyaedt_function_handler()
+    def change_design_variable_value(self, variable_name, variable_value):
+        """Change a variable value.
+
+        ..note::
+            User can use also the getitem to read the variable value. See example below.
+
+        Parameters
+        ----------
+        variable_name : str
+            Name of the variable.
+        variable_value : str, float
+            Value of the variable with units.
 
         Returns
         -------
-        list
-            List of settings for the field line traces in the plot.
+        tuple
+            Tuple containing the ``SetVariableValue`` result and variable server.
+
+        Examples
+        --------
+
+        >>> from pyaedt import Edb
+        >>> edb_app = Edb()
+        >>> boolean, ant_length = edb_app.add_design_variable("ant_length", "1cm")
+        >>> boolean, ant_length = edb_app.change_design_variable_value("ant_length", "1m")
+        >>> print(edb_app["ant_length"])    #using getitem
         """
-        return [
-            "NAME:FieldLineTracePlotSettings",
-            ["NAME:LineSettingsID", "Width:=", self.LineWidth, "Style:=", self.LineStyle],
-            "IsoValType:=",
-            self.IsoValType,
-        ]
+        var_server = self.variable_exists(variable_name)
+        if var_server[0]:
+            var_server[1].SetVariableValue(variable_name, self.edb_value(variable_value))
+            return True, var_server[1]
+        self.logger.error("Variable %s does not exists.", variable_name)
+        return False, var_server[1]
 
     @pyaedt_function_handler()
-    def create(self):
-        """Create a field plot.
+    def get_bounding_box(self):
+        """Get the layout bounding box.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-
+        list of list of double
+            Bounding box as a [lower-left X, lower-left Y], [upper-right X, upper-right Y]) pair in meters.
         """
-        try:
-            if self.seeding_faces:
-                self.oField.CreateFieldPlot(self.surfacePlotInstructionLineTraces, "FieldLineTrace")
-            else:
-                self.oField.CreateFieldPlot(self.surfacePlotInstruction, "Field")
-            return True
-        except:
-            return False
+        bbox = self.edbutils.HfssUtilities.GetBBox(self.active_layout)
+        return [[bbox.Item1.X.ToDouble(), bbox.Item1.Y.ToDouble()], [bbox.Item2.X.ToDouble(), bbox.Item2.Y.ToDouble()]]
 
     @pyaedt_function_handler()
-    def update(self):
-        """Update the field plot.
+    def build_simulation_project(self, simulation_setup):
+        """Build a ready-to-solve simulation project.
 
-        .. note::
-           This method works on any plot created inside PyAEDT.
-           For Plot already existing in AEDT Design it may produce incorrect results.
+        Parameters
+        ----------
+        simulation_setup : edb_data.SimulationConfiguratiom object.
+            SimulationConfiguration object that can be instantiated or directly loaded with a
+            configuration file.
 
         Returns
         -------
         bool
-            ``True`` when successful, ``False`` when failed.
-        """
+            ``True`` when successful, False when ``Failed``.
+
+        Examples
+        --------
+
+        >>> from pyaedt import Edb
+        >>> from pyaedt.edb_core.edb_data.simulation_configuration import SimulationConfiguration
+        >>> config_file = path_configuration_file
+        >>> source_file = path_to_edb_folder
+        >>> edb = Edb(source_file)
+        >>> sim_setup = SimulationConfiguration(config_file)
+        >>> edb.build_simulation_project(sim_setup)
+        >>> edb.save_edb()
+        >>> edb.close_edb()
+        """
+        self.logger.info("Building simulation project.")
+        legacy_name = self.edbpath
+        if simulation_setup.output_aedb:
+            self.save_edb_as(simulation_setup.output_aedb)
         try:
-            if self.seeding_faces:
-                if self.seeding_faces[0] != len(self.seeding_faces) - 1:
-                    for face in self.seeding_faces[1:]:
-                        if not isinstance(face, int):
-                            self._postprocessor.logger.error("Provide valid object id for seeding faces.")
-                            return False
-                        else:
-                            if face not in list(self._postprocessor._app.modeler.objects.keys()):
-                                self._postprocessor.logger.error("Invalid object id.")
-                                self.seeding_faces.remove(face)
-                                return False
-                    self.seeding_faces[0] = len(self.seeding_faces) - 1
-                if self.volume_indexes[0] != len(self.volume_indexes) - 1:
-                    for obj in self.volume_indexes[1:]:
-                        if not isinstance(obj, int):
-                            self._postprocessor.logger.error("Provide valid object id for in-volume object.")
-                            return False
-                        else:
-                            if obj not in list(self._postprocessor._app.modeler.objects.keys()):
-                                self._postprocessor.logger.error("Invalid object id.")
-                                self.volume_indexes.remove(obj)
-                                return False
-                    self.volume_indexes[0] = len(self.volume_indexes) - 1
-                if self.surfaces_indexes[0] != len(self.surfaces_indexes) - 1:
-                    for obj in self.surfaces_indexes[1:]:
-                        if not isinstance(obj, int):
-                            self._postprocessor.logger.error("Provide valid object id for surface object.")
-                            return False
-                        else:
-                            if obj not in list(self._postprocessor._app.modeler.objects.keys()):
-                                self._postprocessor.logger.error("Invalid object id.")
-                                self.surfaces_indexes.remove(obj)
-                                return False
-                    self.surfaces_indexes[0] = len(self.surfaces_indexes) - 1
-                self.oField.ModifyFieldPlot(self.name, self.surfacePlotInstructionLineTraces)
-            else:
-                self.oField.ModifyFieldPlot(self.name, self.surfacePlotInstruction)
+            if simulation_setup.signal_layer_etching_instances:
+                for layer in simulation_setup.signal_layer_etching_instances:
+                    if layer in self.stackup.layers:
+                        idx = simulation_setup.signal_layer_etching_instances.index(layer)
+                        if len(simulation_setup.etching_factor_instances) > idx:
+                            self.stackup[layer].etch_factor = float(simulation_setup.etching_factor_instances[idx])
+
+            self.nets.classify_nets(simulation_setup.power_nets, simulation_setup.signal_nets)
+            if simulation_setup.do_cutout_subdesign:
+                self.logger.info("Cutting out using method: {0}".format(simulation_setup.cutout_subdesign_type))
+                if simulation_setup.use_default_cutout:
+                    old_cell_name = self.active_cell.GetName()
+                    if self.cutout(
+                        signal_list=simulation_setup.signal_nets,
+                        reference_list=simulation_setup.power_nets,
+                        expansion_size=simulation_setup.cutout_subdesign_expansion,
+                        use_round_corner=simulation_setup.cutout_subdesign_round_corner,
+                        extent_type=simulation_setup.cutout_subdesign_type,
+                        use_pyaedt_cutout=False,
+                        use_pyaedt_extent_computing=False,
+                    ):
+                        self.logger.info("Cutout processed.")
+                        old_cell = self.active_cell.FindByName(
+                            self._db, self.edb.Cell.CellType.CircuitCell, old_cell_name
+                        )
+                        if old_cell:
+                            old_cell.Delete()
+                    else:  # pragma: no cover
+                        self.logger.error("Cutout failed.")
+                else:
+                    self.logger.info("Cutting out using method: {0}".format(simulation_setup.cutout_subdesign_type))
+                    self.cutout(
+                        signal_list=simulation_setup.signal_nets,
+                        reference_list=simulation_setup.power_nets,
+                        expansion_size=simulation_setup.cutout_subdesign_expansion,
+                        use_round_corner=simulation_setup.cutout_subdesign_round_corner,
+                        extent_type=simulation_setup.cutout_subdesign_type,
+                        use_pyaedt_cutout=True,
+                        use_pyaedt_extent_computing=True,
+                        remove_single_pin_components=True,
+                    )
+                    self.logger.info("Cutout processed.")
+            self.logger.info("Deleting existing ports.")
+            map(lambda port: port.Delete(), list(self.active_layout.Terminals))
+            map(lambda pg: pg.Delete(), list(self.active_layout.PinGroups))
+            if simulation_setup.solver_type == SolverType.Hfss3dLayout:
+                self.logger.info("Creating HFSS ports for signal nets.")
+                for cmp in simulation_setup.components:
+                    self.components.create_port_on_component(
+                        cmp,
+                        net_list=simulation_setup.signal_nets,
+                        do_pingroup=False,
+                        reference_net=simulation_setup.power_nets,
+                        port_type=SourceType.CoaxPort,
+                    )
+                if not self.hfss.set_coax_port_attributes(simulation_setup):  # pragma: no cover
+                    self.logger.error("Failed to configure coaxial port attributes.")
+                self.logger.info("Number of ports: {}".format(self.hfss.get_ports_number()))
+                self.logger.info("Configure HFSS extents.")
+                if simulation_setup.trim_reference_size:  # pragma: no cover
+                    self.logger.info(
+                        "Trimming the reference plane for coaxial ports: {0}".format(
+                            bool(simulation_setup.trim_reference_size)
+                        )
+                    )
+                    self.hfss.trim_component_reference_size(simulation_setup)  # pragma: no cover
+                self.hfss.configure_hfss_extents(simulation_setup)
+                if not self.hfss.configure_hfss_analysis_setup(simulation_setup):
+                    self.logger.error("Failed to configure HFSS simulation setup.")
+            if simulation_setup.solver_type == SolverType.SiwaveSYZ:
+                for cmp in simulation_setup.components:
+                    self.components.create_port_on_component(
+                        cmp,
+                        net_list=simulation_setup.signal_nets,
+                        do_pingroup=simulation_setup.do_pingroup,
+                        reference_net=simulation_setup.power_nets,
+                        port_type=SourceType.CircPort,
+                    )
+                self.logger.info("Configuring analysis setup.")
+                if not self.siwave.configure_siw_analysis_setup(simulation_setup):  # pragma: no cover
+                    self.logger.error("Failed to configure Siwave simulation setup.")
+
+            if simulation_setup.solver_type == SolverType.SiwaveDC:
+                self.components.create_source_on_component(simulation_setup.sources)
+                if not self.siwave.configure_siw_analysis_setup(simulation_setup):  # pragma: no cover
+                    self.logger.error("Failed to configure Siwave simulation setup.")
+            self.padstacks.check_and_fix_via_plating()
+            self.save_edb()
+            if not simulation_setup.open_edb_after_build and simulation_setup.output_aedb:
+                self.close_edb()
+                self.edbpath = legacy_name
+                self.open_edb(True)
             return True
-        except:
+        except:  # pragma: no cover
             return False
 
     @pyaedt_function_handler()
-    def update_field_plot_settings(self):
-        """Modify the field plot settings.
-
-        .. note::
-            This method is not available for field plot line traces.
+    def get_statistics(self, compute_area=False):
+        """Get the EDBStatistics object.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
+        EDBStatistics object from the loaded layout.
         """
-        self.oField.SetFieldPlotSettings(self.name, ["NAME:FieldsPlotItemSettings", self.plotsettings])
-        return True
+        return self.modeler.get_layout_statistics(evaluate_area=compute_area, net_list=None)
 
     @pyaedt_function_handler()
-    def delete(self):
-        """Delete the field plot."""
-        self.oField.DeleteFieldPlot([self.name])
-        self._postprocessor.field_plots.pop(self.name, None)
-
-    @pyaedt_function_handler()
-    def change_plot_scale(self, minimum_value, maximum_value, is_log=False, is_db=False):
-        """Change Field Plot Scale.
+    def are_port_reference_terminals_connected(self, common_reference=None):
+        """Check if all terminal references in design are connected.
+        If the reference nets are different, there is no hope for the terminal references to be connected.
+        After we have identified a common reference net we need to loop the terminals again to get
+        the correct reference terminals that uses that net.
 
         Parameters
         ----------
-        minimum_value : str, float
-            Minimum value of the scale.
-        maximum_value : str, float
-            Maximum value of the scale.
-        is_log : bool, optional
-            Set to ``True`` if Log Scale is setup.
-        is_db : bool, optional
-            Set to ``True`` if dB Scale is setup.
+        common_reference : str, optional
+            Common Reference name. If ``None`` it will be searched in ports terminal.
+            If a string is passed then all excitations must have such reference assigned.
 
         Returns
         -------
         bool
-            ``True`` if successful.
+            Either if the ports are connected to reference_name or not.
 
-        References
-        ----------
+        Examples
+        --------
+        >>>edb = Edb()
+        >>> edb.hfss.create_edge_port_vertical(prim_1_id, ["-66mm", "-4mm"], "port_ver")
+        >>> edb.hfss.create_edge_port_horizontal(
+        >>> ... prim_1_id, ["-60mm", "-4mm"], prim_2_id, ["-59mm", "-4mm"], "port_hori", 30, "Lower"
+        >>> ... )
+        >>> edb.hfss.create_wave_port(traces[0].id, trace_paths[0][0], "wave_port")
+        >>> edb.cutout(["Net1"])
+        >>> assert edb.are_port_reference_terminals_connected()
+        """
+        all_sources = [i for i in self.excitations.values() if not isinstance(i, ExcitationPorts)]
+        all_sources.extend([i for i in self.sources.values()])
+        if not all_sources:
+            return True
+        self.logger.reset_timer()
+        if not common_reference:
+            common_reference = list(set([i.reference_net_name for i in all_sources if i.reference_net_name]))
+            if len(common_reference) > 1:
+                self.logger.error("More than 1 reference found.")
+                return False
+            if not common_reference:
+                self.logger.error("No Reference found.")
+                return False
 
-        >>> oModule.SetPlotFolderSettings
-        """
-        args = ["NAME:FieldsPlotSettings", "Real Time mode:=", True]
-        args += [
-            [
-                "NAME:ColorMaPSettings",
-                "ColorMapType:=",
-                "Spectrum",
-                "SpectrumType:=",
-                "Rainbow",
-                "UniformColor:=",
-                [127, 255, 255],
-                "RampColor:=",
-                [255, 127, 127],
-            ]
+            common_reference = common_reference[0]
+        all_sources = [i for i in all_sources if i.net_name != common_reference]
+
+        setList = [
+            set(i.reference_object.get_connected_object_id_set())
+            for i in all_sources
+            if i.reference_object and i.reference_net_name == common_reference
         ]
-        args += [
-            [
-                "NAME:Scale3DSettings",
-                "minvalue:=",
-                minimum_value,
-                "maxvalue:=",
-                maximum_value,
-                "log:=",
-                not is_log,
-                "dB:=",
-                is_db,
-                "ScaleType:=",
-                1,
-            ]
+        if len(setList) != len(all_sources):
+            self.logger.error("No Reference found.")
+            return False
+        cmps = [
+            i
+            for i in list(self.components.resistors.values())
+            if i.numpins == 2 and common_reference in i.nets and self._decompose_variable_value(i.res_value) <= 1
         ]
-        self.oField.SetPlotFolderSettings(self.plotFolder, args)
-        return True
+        cmps.extend(
+            [i for i in list(self.components.inductors.values()) if i.numpins == 2 and common_reference in i.nets]
+        )
 
-    @pyaedt_function_handler()
-    def export_image(self, full_path=None, width=1920, height=1080, orientation="isometric", display_wireframe=True):
-        """Export the active plot to an image file.
+        for cmp in cmps:
+            found = False
+            ids = [i.GetId() for i in cmp.pinlist]
+            for list_obj in setList:
+                if len(set(ids).intersection(list_obj)) == 1:
+                    for list_obj2 in setList:
+                        if list_obj2 != list_obj and len(set(ids).intersection(list_obj)) == 1:
+                            if (ids[0] in list_obj and ids[1] in list_obj2) or (
+                                ids[1] in list_obj and ids[0] in list_obj2
+                            ):
+                                setList[setList.index(list_obj)] = list_obj.union(list_obj2)
+                                setList[setList.index(list_obj2)] = list_obj.union(list_obj2)
+                                found = True
+                                break
+                    if found:
+                        break
+
+        # Get the set intersections for all the ID sets.
+        iDintersection = set.intersection(*setList)
+        self.logger.info_timer(
+            "Terminal reference primitive IDs total intersections = {}\n\n".format(len(iDintersection))
+        )
 
-        .. note::
-           There are some limitations on HFSS 3D Layout plots.
+        # If the intersections are non-zero, the terminal references are connected.
+        return True if len(iDintersection) > 0 else False
 
-        full_path : str, optional
-            Path for saving the image file. PNG and GIF formats are supported.
-            The default is ``None`` which export file in working_directory.
-        width : int, optional
-            Plot Width.
-        height : int, optional
-            Plot height.
-        orientation : str, optional
-            View of the exported plot. Options are ``isometric``,
-            ``top``, ``bottom``, ``right``, ``left``, ``front``,
-            ``back``, and any custom orientation.
-        display_wireframe : bool, optional
-            Set to ``True`` if the objects has to be put in wireframe mode.
+    @pyaedt_function_handler()
+    def new_simulation_configuration(self, filename=None):
+        """New SimulationConfiguration Object.
+
+        Parameters
+        ----------
+        filename : str, optional
+            Input config file.
 
         Returns
         -------
-        str
-            Full path to exported file if successful.
-
-        References
-        ----------
+        :class:`pyaedt.edb_core.edb_data.simulation_configuration.SimulationConfiguration`
+        """
+        return SimulationConfiguration(filename, self)
 
-        >>> oModule.ExportPlotImageToFile
-        >>> oModule.ExportModelImageToFile
-        >>> oModule.ExportPlotImageWithViewToFile
-        """
-        self.oField.UpdateQuantityFieldsPlots(self.plotFolder)
-        if not full_path:
-            full_path = os.path.join(self._postprocessor._app.working_directory, self.name + ".png")
-        status = self._postprocessor.export_field_jpg(
-            full_path,
-            self.name,
-            self.plotFolder,
-            orientation=orientation,
-            width=width,
-            height=height,
-            display_wireframe=display_wireframe,
-        )
-        if status:
-            return full_path
-        else:
-            return False
+    @property
+    def setups(self):
+        """Get the dictionary of all EDB HFSS and SIwave setups.
 
-    @pyaedt_function_handler()
-    def export_image_from_aedtplt(
-        self, export_path=None, view="isometric", plot_mesh=False, scale_min=None, scale_max=None
-    ):
-        """Save an image of the active plot using PyVista.
+        Returns
+        -------
+        Dict[str, :class:`pyaedt.edb_core.edb_data.hfss_simulation_setup_data.HfssSimulationSetup`] or
+        Dict[str, :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveDCSimulationSetup`] or
+        Dict[str, :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup`]
 
-        .. note::
-            This method only works if the CPython with PyVista module is installed.
+        """
+        for i in list(self.active_cell.SimulationSetups):
+            if i.GetName() not in self._setups:
+                if i.GetType() == self.edb.Utility.SimulationSetupType.kHFSS:
+                    self._setups[i.GetName()] = HfssSimulationSetup(self, i.GetName(), i)
+                elif i.GetType() == self.edb.Utility.SimulationSetupType.kSIWave:
+                    self._setups[i.GetName()] = SiwaveSYZSimulationSetup(self, i.GetName(), i)
+                elif i.GetType() == self.edb.Utility.SimulationSetupType.kSIWaveDCIR:
+                    self._setups[i.GetName()] = SiwaveDCSimulationSetup(self, i.GetName(), i)
+        return self._setups
 
-        Parameters
-        ----------
-        export_path : str, optional
-            Path where image will be saved.
-            The default is ``None`` which export file in working_directory.
-        view : str, optional
-           View to export. Options are ``"isometric"``, ``"xy"``, ``"xz"``, ``"yz"``.
-        plot_mesh : bool, optional
-            Plot mesh.
-        scale_min : float, optional
-            Scale output min.
-        scale_max : float, optional
-            Scale output max.
+    @property
+    def hfss_setups(self):
+        """Active HFSS setup in EDB.
 
         Returns
         -------
-        str
-            Full path to exported file if successful.
-
-        References
-        ----------
-
-        >>> oModule.UpdateAllFieldsPlots
-        >>> oModule.UpdateQuantityFieldsPlots
-        >>> oModule.ExportFieldPlot
-        """
-        if not export_path:
-            export_path = self._postprocessor._app.working_directory
-        if sys.version_info.major > 2:
-            return self._postprocessor.plot_field_from_fieldplot(
-                self.name,
-                project_path=export_path,
-                meshplot=plot_mesh,
-                imageformat="jpg",
-                view=view,
-                plot_label=self.quantityName,
-                show=False,
-                scale_min=scale_min,
-                scale_max=scale_max,
-            )
-        else:
-            self._postprocessor.logger.info("This method works only on CPython with PyVista")
-            return False
+        Dict[str, :class:`pyaedt.edb_core.edb_data.hfss_simulation_setup_data.HfssSimulationSetup`]
 
+        """
+        return {name: i for name, i in self.setups.items() if i.setup_type == "kHFSS"}
 
-class VRTFieldPlot:
-    """Creates and edits VRT field plots for SBR+ and Creeping Waves.
+    @property
+    def siwave_dc_setups(self):
+        """Active Siwave DC IR Setups.
 
-    Parameters
-    ----------
-    postprocessor : :class:`pyaedt.modules.PostProcessor.PostProcessor`
+        Returns
+        -------
+        Dict[str, :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveDCSimulationSetup`]
+        """
+        return {name: i for name, i in self.setups.items() if i.setup_type == "kSIWaveDCIR"}
 
-    objlist : list
-        List of objects.
-    solutionName : str
-        Name of the solution.
-    quantity_name : str
-        Name of the plot or the name of the object.
-    intrinsincList : dict, optional
-        Name of the intrinsic dictionary. The default is ``{}``.
+    @property
+    def siwave_ac_setups(self):
+        """Active Siwave SYZ setups.
 
-    """
+        Returns
+        -------
+        Dict[str, :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup`]
+        """
+        return {name: i for name, i in self.setups.items() if i.setup_type == "kSIWave"}
 
-    def __init__(
-        self,
-        postprocessor,
-        is_creeping_wave=False,
-        quantity_name="QuantityName_SBR",
-        max_frequency="1GHz",
-        ray_density=2,
-        bounces=5,
-        intrinsincList={},
-    ):
-        self.is_creeping_wave = is_creeping_wave
-        self._postprocessor = postprocessor
-        self._ofield = postprocessor.ofieldsreporter
-        self.quantity_name = quantity_name
-        self.intrinsics = intrinsincList
-        self.name = "Field_Plot"
-        self.plot_folder = "Field_Plot"
-        self.max_frequency = max_frequency
-        self.ray_density = ray_density
-        self.number_of_bounces = bounces
-        self.multi_bounce_ray_density_control = False
-        self.mbrd_max_subdivision = 2
-        self.shoot_utd_rays = False
-        self.shoot_type = "All Rays"
-        self.start_index = 0
-        self.stop_index = 1
-        self.step_index = 1
-        self.is_plane_wave = True
-        self.incident_theta = "0deg"
-        self.incident_phi = "0deg"
-        self.vertical_polarization = False
-        self.custom_location = [0, 0, 0]
-        self.ray_box = None
-        self.ray_elevation = "0deg"
-        self.ray_azimuth = "0deg"
-        self.custom_coordinatesystem = 1
-        self.ray_cutoff = 40
-        self.sample_density = 10
-        self.irregular_surface_tolerance = 50
-
-    @property
-    def intrinsicVar(self):
-        """Intrinsic variable.
-
-        Returns
-        -------
-        list or dict
-            List or dictionary of the variables for the field plot.
-        """
-        var = ""
-        if isinstance(self.intrinsics, list):
-            l = 0
-            while l < len(self.intrinsics):
-                val = self.intrinsics[l + 1]
-                if ":=" in self.intrinsics[l] and isinstance(self.intrinsics[l + 1], list):
-                    val = self.intrinsics[l + 1][0]
-                ll = self.intrinsics[l].split(":=")
-                var += ll[0] + "='" + str(val) + "' "
-                l += 2
-        else:
-            for a in self.intrinsics:
-                var += a + "='" + str(self.intrinsics[a]) + "' "
-        return var
-
-    @pyaedt_function_handler()
-    def _create_args(self):
-        args = [
-            "NAME:" + self.name,
-            "UserSpecifyName:=",
-            0,
-            "UserSpecifyFolder:=",
-            0,
-            "QuantityName:=",
-            self.quantity_name,
-            "PlotFolder:=",
-            "Visual Ray Trace SBR",
-            "IntrinsicVar:=",
-            self.intrinsicVar,
-            "MaxFrequency:=",
-            self.max_frequency,
-            "RayDensity:=",
-            self.ray_density,
-            "NumberBounces:=",
-            self.number_of_bounces,
-            "Multi-Bounce Ray Density Control:=",
-            self.multi_bounce_ray_density_control,
-            "MBRD Max sub divisions:=",
-            self.mbrd_max_subdivision,
-            "Shoot UTD Rays:=",
-            self.shoot_utd_rays,
-            "ShootFilterType:=",
-            self.shoot_type,
-        ]
-        if self.shoot_type == "Rays by index":
-            args.extend(
-                [
-                    "start index:=",
-                    self.start_index,
-                    "stop index:=",
-                    self.stop_index,
-                    "index step:=",
-                    self.step_index,
-                ]
-            )
-        elif self.shoot_type == "Rays in box":
-            box_id = None
-            if isinstance(self.ray_box, int):
-                box_id = self.ray_box
-            elif isinstance(self.ray_box, str):
-                box_id = self._postprocessor._primitives.object_id_dict[self.ray_box]
-            else:
-                box_id = self.ray_box.id
-            args.extend("FilterBoxID:=", box_id)
-        elif self.shoot_type == "Single ray":
-            args.extend("Ray elevation:=", self.ray_elevation, "Ray azimuth:=", self.ray_azimuth)
-        args.append("LaunchFrom:=")
-        if self.is_plane_wave:
-            args.append("Launch from Plane-Wave")
-            args.append("Incident direction theta:=")
-            args.append(self.incident_theta)
-            args.append("Incident direction phi:=")
-            args.append(self.incident_phi)
-            args.append("Vertical Incident Polarization:=")
-            args.append(self.vertical_polarization)
-        else:
-            args.append("Launch from Custom")
-            args.append("LaunchFromPointID:=")
-            args.append(-1)
-            args.append("CustomLocationCoordSystem:=")
-            args.append(self.custom_coordinatesystem)
-            args.append("CustomLocation:=")
-            args.append(self.custom_location)
-        return args
-
-    @pyaedt_function_handler()
-    def _create_args_creeping(self):
-        args = [
-            "NAME:" + self.name,
-            "UserSpecifyName:=",
-            0,
-            "UserSpecifyFolder:=",
-            0,
-            "QuantityName:=",
-            self.quantity_name,
-            "PlotFolder:=",
-            "Visual Ray Trace CW",
-            "IntrinsicVar:=",
-            "",
-            "MaxFrequency:=",
-            self.max_frequency,
-            "SampleDensity:=",
-            self.sample_density,
-            "RayCutOff:=",
-            self.ray_cutoff,
-            "Irregular Surface Tolerance:=",
-            self.irregular_surface_tolerance,
-            "LaunchFrom:=",
-        ]
-        if self.is_plane_wave:
-            args.append("Launch from Plane-Wave")
-            args.append("Incident direction theta:=")
-            args.append(self.incident_theta)
-            args.append("Incident direction phi:=")
-            args.append(self.incident_phi)
-            args.append("Vertical Incident Polarization:=")
-            args.append(self.vertical_polarization)
-        else:
-            args.append("Launch from Custom")
-            args.append("LaunchFromPointID:=")
-            args.append(-1)
-            args.append("CustomLocationCoordSystem:=")
-            args.append(self.custom_coordinatesystem)
-            args.append("CustomLocation:=")
-            args.append(self.custom_location)
-        args.append("SBRRayDensity:=")
-        args.append(self.ray_density)
-        return args
+    def create_hfss_setup(self, name=None):
+        """Create a setup from a template.
 
-    @pyaedt_function_handler()
-    def create(self):
-        """Create a field plot.
+        Parameters
+        ----------
+        name : str, optional
+            Setup name.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
+        :class:`pyaedt.edb_core.edb_data.hfss_simulation_setup_data.HfssSimulationSetup`
 
+        Examples
+        --------
+        >>> setup1 = edbapp.create_hfss_setup("setup1")
+        >>> setup1.hfss_port_settings.max_delta_z0 = 0.5
         """
-        try:
-            if self.is_creeping_wave:
-                self._ofield.CreateFieldPlot(self._create_args_creeping(), "CreepingWave_VRT")
-            else:
-                self._ofield.CreateFieldPlot(self._create_args(), "VRT")
-            return True
-        except:
+        if name in self.setups:
             return False
+        setup = HfssSimulationSetup(self, name)
+        self._setups[name] = setup
+        return setup
 
     @pyaedt_function_handler()
-    def update(self):
-        """Update the field plot.
+    def create_siwave_syz_setup(self, name=None):
+        """Create a setup from a template.
 
+        Parameters
+        ----------
+        name : str, optional
+            Setup name.
 
         Returns
         -------
-        bool
-            ``True`` when successful, ``False`` when failed.
-        """
-        try:
-            if self.is_creeping_wave:
-                self._ofield.ModifyFieldPlot(self.name, self._create_args_creeping())
+        :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup`
 
-            else:
-                self._ofield.ModifyFieldPlot(self.name, self._create_args())
-            return True
-        except:
+        Examples
+        --------
+        >>> setup1 = edbapp.create_siwave_syz_setup("setup1")
+        >>> setup1.add_frequency_sweep(frequency_sweep=[
+        ...                           ["linear count", "0", "1kHz", 1],
+        ...                           ["log scale", "1kHz", "0.1GHz", 10],
+        ...                           ["linear scale", "0.1GHz", "10GHz", "0.1GHz"],
+        ...                           ])
+        """
+        if not name:
+            name = generate_unique_name("Siwave_SYZ")
+        if name in self.setups:
             return False
+        setup = SiwaveSYZSimulationSetup(self, name)
+        self._setups[name] = setup
+        return setup
 
     @pyaedt_function_handler()
-    def delete(self):
-        """Delete the field plot."""
-        self._ofield.DeleteFieldPlot([self.name])
-        return True
-
-    @pyaedt_function_handler()
-    def export(self, path_to_hdm_file=None):
-        """Export the Visual Ray Tracing to ``hdm`` file.
+    def create_siwave_dc_setup(self, name=None):
+        """Create a setup from a template.
 
         Parameters
         ----------
-        path_to_hdm_file : str, optional
-            Full path to output file. If ``None``, the file will be exported in working directory.
+        name : str, optional
+            Setup name.
 
         Returns
         -------
-        str
-            Path to the file.
+        :class:`pyaedt.edb_core.edb_data.siwave_simulation_setup_data.SiwaveSYZSimulationSetup`
+
+        Examples
+        --------
+        >>> setup1 = edbapp.create_siwave_dc_setup("setup1")
+        >>> setup1.mesh_bondwires = True
+
         """
-        if not path_to_hdm_file:
-            path_to_hdm_file = os.path.join(self._postprocessor._app.working_directory, self.name + ".hdm")
-        self._ofield.ExportFieldPlot(self.name, False, path_to_hdm_file)
-        return path_to_hdm_file
+        if not name:
+            name = generate_unique_name("Siwave_DC")
+        if name in self.setups:
+            return False
+        setup = SiwaveDCSimulationSetup(self, name)
+        self._setups[name] = setup
+        return setup
+
+    @pyaedt_function_handler()
+    def calculate_initial_extent(self, expansion_factor):
+        """Compute a float representing the larger number between the dielectric thickness or trace width
+        multiplied by the nW factor. The trace width search is limited to nets with ports attached.
+
+        Parameters
+        ----------
+        expansion_factor : float
+            Value for the width multiplier (nW factor).
+        """
+        nets = []
+        for port in self.excitations.values():
+            nets.append(port.net_name)
+        for port in self.sources.values():
+            nets.append(port.net_name)
+        nets = list(set(nets))
+        max_width = 0
+        for net in nets:
+            for primitive in self.nets[net].primitives:
+                if primitive.type == "Path":
+                    max_width = max(max_width, primitive.width)
+
+        for layer in list(self.stackup.dielectric_layers.values()):
+            max_width = max(max_width, layer.thickness)
+
+        max_width = max_width * expansion_factor
+        self.logger.info("The W factor is {}, The initial extent = {:e}".format(expansion_factor, max_width))
+        return max_width
```

### Comparing `pyaedt-0.6.61/pyaedt/q3d.py` & `pyaedt-0.6.70/pyaedt/q3d.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/rmxprt.py` & `pyaedt-0.6.70/pyaedt/rmxprt.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/rpc/rpyc_services.py` & `pyaedt-0.6.70/pyaedt/rpc/rpyc_services.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/hdm_parser.py` & `pyaedt-0.6.70/pyaedt/sbrplus/hdm_parser.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/hdm_utils.py` & `pyaedt-0.6.70/pyaedt/sbrplus/hdm_utils.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/HdmObject.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/HdmObject.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/SbrBounceType.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/SbrBounceType.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/StopWatch.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/StopWatch.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/add_3dlight.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/add_3dlight.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/draw_rays1.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/draw_rays1.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/draw_wfobj.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/draw_wfobj.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/filter_rays1.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/filter_rays1.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/filtered_tracks.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/filtered_tracks.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/ld_sbrplushdm.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/ld_sbrplushdm.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/ld_wfobj.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/ld_wfobj.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/matlab/validate_sfields.m` & `pyaedt-0.6.70/pyaedt/sbrplus/matlab/validate_sfields.m`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/sbrplus/plot.py` & `pyaedt-0.6.70/pyaedt/sbrplus/plot.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/siwave.py` & `pyaedt-0.6.70/pyaedt/siwave.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyaedt/twinbuilder.py` & `pyaedt-0.6.70/pyaedt/twinbuilder.py`

 * *Files identical despite different names*

### Comparing `pyaedt-0.6.61/pyproject.toml` & `pyaedt-0.6.70/pyproject.toml`

 * *Files 1% similar despite different names*

```diff
@@ -6,15 +6,15 @@
 [project]
 name = "pyaedt"
 dynamic = ["version"]
 description = "Higher-Level Pythonic Ansys Electronics Desktop Framework"
 readme = "README.rst"
 requires-python = ">=3.7,<4"
 license = {file = "LICENSE"}
-authors = [{name = "ANSYS, Inc.", email = "pyansys.support@ansys.com"}]
+authors = [{name = "ANSYS, Inc.", email = "pyansys.core@ansys.com"}]
 maintainers = [{name = "PyAEDT developers", email = "massimo.capodiferro@ansys.com"}]
 classifiers = [
     "Development Status :: 4 - Beta",
     "Intended Audience :: Science/Research",
     "Topic :: Scientific/Engineering :: Information Analysis",
     "License :: OSI Approved :: MIT License",
     "Operating System :: OS Independent",
```

### Comparing `pyaedt-0.6.61/PKG-INFO` & `pyaedt-0.6.70/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,12 +1,12 @@
 Metadata-Version: 2.1
 Name: pyaedt
-Version: 0.6.61
+Version: 0.6.70
 Summary: Higher-Level Pythonic Ansys Electronics Desktop Framework
-Author-email: "ANSYS, Inc." <pyansys.support@ansys.com>
+Author-email: "ANSYS, Inc." <pyansys.core@ansys.com>
 Maintainer-email: PyAEDT developers <massimo.capodiferro@ansys.com>
 Requires-Python: >=3.7,<4
 Description-Content-Type: text/x-rst
 Classifier: Development Status :: 4 - Beta
 Classifier: Intended Audience :: Science/Research
 Classifier: Topic :: Scientific/Engineering :: Information Analysis
 Classifier: License :: OSI Approved :: MIT License
@@ -281,18 +281,18 @@
 PyAEDT also provides advanced error management. Usage examples follow.
 
 Explicit AEDT declaration and error management
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 .. code:: python
 
-    # Launch AEDT 2022 R2 in non-graphical mode
+    # Launch AEDT 2023 R1 in non-graphical mode
 
     from pyaedt import Desktop, Circuit
-    with Desktop(specified_version="2022.2",
+    with Desktop(specified_version="2023.1",
                  non_graphical=False, new_desktop_session=True,
                  close_on_exit=True, student_version=False):
         circuit = Circuit()
         ...
         # Any error here will be caught by Desktop.
         ...
 
@@ -303,15 +303,15 @@
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
 .. code:: python
 
     # Launch the latest installed version of AEDT in graphical mode
 
     from pyaedt import Circuit
-    with Circuit(specified_version="2022.2",
+    with Circuit(specified_version="2023.1",
                  non_graphical=False) as circuit:
         ...
         # Any error here will be caught by Desktop.
         ...
 
     # Desktop is automatically released here.
```

