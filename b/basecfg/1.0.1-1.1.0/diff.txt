--- tmp/basecfg-1.0.1.tar.gz
+++ tmp/basecfg-1.1.0.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "basecfg-1.0.1.tar", last modified: Fri Apr  7 04:19:16 2023, max compression
│ +gzip compressed data, was "basecfg-1.1.0.tar", last modified: Fri Apr  7 16:59:26 2023, max compression
│   --- basecfg-1.0.1.tar
├── +++ basecfg-1.1.0.tar
│ ├── file list
│ │ @@ -1,15 +1,15 @@
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 04:19:16.093213 basecfg-1.0.1/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)    26526 2023-04-07 04:18:47.000000 basecfg-1.0.1/LICENSE
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      887 2023-04-07 04:19:16.093213 basecfg-1.0.1/PKG-INFO
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      322 2023-04-07 04:18:47.000000 basecfg-1.0.1/README.md
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     1289 2023-04-07 04:18:47.000000 basecfg-1.0.1/pyproject.toml
│ │ --rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-07 04:19:16.093213 basecfg-1.0.1/setup.cfg
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 04:19:16.089213 basecfg-1.0.1/src/
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 04:19:16.093213 basecfg-1.0.1/src/basecfg/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      110 2023-04-07 04:18:47.000000 basecfg-1.0.1/src/basecfg/__init__.py
│ │ --rw-r--r--   0 runner    (1001) docker     (123)     8614 2023-04-07 04:18:47.000000 basecfg-1.0.1/src/basecfg/basecfg.py
│ │ -drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 04:19:16.093213 basecfg-1.0.1/src/basecfg.egg-info/
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      887 2023-04-07 04:19:16.000000 basecfg-1.0.1/src/basecfg.egg-info/PKG-INFO
│ │ --rw-r--r--   0 runner    (1001) docker     (123)      219 2023-04-07 04:19:16.000000 basecfg-1.0.1/src/basecfg.egg-info/SOURCES.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-07 04:19:16.000000 basecfg-1.0.1/src/basecfg.egg-info/dependency_links.txt
│ │ --rw-r--r--   0 runner    (1001) docker     (123)        8 2023-04-07 04:19:16.000000 basecfg-1.0.1/src/basecfg.egg-info/top_level.txt
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 16:59:26.946476 basecfg-1.1.0/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    26526 2023-04-07 16:58:56.000000 basecfg-1.1.0/LICENSE
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      887 2023-04-07 16:59:26.942476 basecfg-1.1.0/PKG-INFO
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      322 2023-04-07 16:58:56.000000 basecfg-1.1.0/README.md
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)     1289 2023-04-07 16:58:56.000000 basecfg-1.1.0/pyproject.toml
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)       38 2023-04-07 16:59:26.946476 basecfg-1.1.0/setup.cfg
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 16:59:26.938476 basecfg-1.1.0/src/
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 16:59:26.942476 basecfg-1.1.0/src/basecfg/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      110 2023-04-07 16:58:56.000000 basecfg-1.1.0/src/basecfg/__init__.py
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)    12058 2023-04-07 16:58:56.000000 basecfg-1.1.0/src/basecfg/basecfg.py
│ │ +drwxr-xr-x   0 runner    (1001) docker     (123)        0 2023-04-07 16:59:26.942476 basecfg-1.1.0/src/basecfg.egg-info/
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      887 2023-04-07 16:59:26.000000 basecfg-1.1.0/src/basecfg.egg-info/PKG-INFO
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)      219 2023-04-07 16:59:26.000000 basecfg-1.1.0/src/basecfg.egg-info/SOURCES.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        1 2023-04-07 16:59:26.000000 basecfg-1.1.0/src/basecfg.egg-info/dependency_links.txt
│ │ +-rw-r--r--   0 runner    (1001) docker     (123)        8 2023-04-07 16:59:26.000000 basecfg-1.1.0/src/basecfg.egg-info/top_level.txt
│ │   --- basecfg-1.0.1/LICENSE
│ ├── +++ basecfg-1.1.0/LICENSE
│ │┄ Files identical despite different names
│ │   --- basecfg-1.0.1/PKG-INFO
│ ├── +++ basecfg-1.1.0/PKG-INFO
│ │┄ Files 12% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: basecfg
│ │ -Version: 1.0.1
│ │ +Version: 1.1.0
│ │  Summary: typed 12-factor app configuration helper
│ │  Author-email: Ben Burke <actualben@users.noreply.github.com>
│ │  Project-URL: Homepage, https://github.com/edencehealth/basecfg
│ │  Project-URL: Bug Tracker, https://github.com/edencehealth/basecfg/issues
│ │  Classifier: Programming Language :: Python :: 3
│ │  Classifier: License :: OSI Approved :: GNU Lesser General Public License v2 (LGPLv2)
│ │  Classifier: Operating System :: OS Independent
│ │   --- basecfg-1.0.1/pyproject.toml
│ ├── +++ basecfg-1.1.0/pyproject.toml
│ │┄ Files 1% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  [project]
│ │  name = "basecfg"
│ │ -version = "1.0.1"
│ │ +version = "1.1.0"
│ │  authors = [
│ │    { name="Ben Burke", email="actualben@users.noreply.github.com" },
│ │  ]
│ │  description = "typed 12-factor app configuration helper"
│ │  readme = "README.md"
│ │  requires-python = ">=3.10"
│ │  classifiers = [
│ │   --- basecfg-1.0.1/src/basecfg/basecfg.py
│ ├── +++ basecfg-1.1.0/src/basecfg/basecfg.py
│ │┄ Files 20% similar despite different names
│ │ @@ -92,57 +92,125 @@
│ │      """
│ │  
│ │      OptFunc = _OptFunc  # this is an alias to enable users to call BaseCfg.OptFunc()
│ │      optfunc: _OptFunc  # this is an attribute set by OptFunc.link
│ │      _options: Dict[str, OptionMetadata]
│ │  
│ │      def __init__(
│ │ -        self, json_config_path: Optional[str] = None, json_required=False
│ │ +        self,
│ │ +        json_config_path: Optional[str] = None,
│ │ +        json_required=False,
│ │ +        cli_args: Optional[Sequence[str]] = None,
│ │      ) -> None:
│ │          """parse data from various sources according to options"""
│ │          # step 1 is to enrich our metadata about the configuration options, at
│ │          # this point we finally have the names of the fields and are aware of
│ │          # their resolved type annotations
│ │          self._options = {}
│ │  
│ │          option_metadata = iter(self.optfunc.namespace)
│ │          for key, val in self.__class__.__annotations__.items():
│ │              self._options[key] = next(option_metadata)._replace(
│ │                  name=key, option_type=val
│ │              )
│ │  
│ │          if json_config_path:
│ │ -            for key, val in self.parse_json_config(
│ │ +            for key, val in self._parse_json_config(
│ │                  json_config_path, json_required
│ │              ).items():
│ │                  setattr(self, key, val)
│ │ -        for key, val in self.parse_envvars().items():
│ │ -            setattr(self, key, val)
│ │ -        for key, val in self.parse_args().items():
│ │ +        for key, val in self._parse_envvars().items():
│ │              setattr(self, key, val)
│ │ +        for key, val in self._parse_args(cli_args).items():
│ │ +            if val is not None:
│ │ +                setattr(self, key, val)
│ │  
│ │ -    def parse_json_config(self, path: str, required: bool = False) -> Dict[str, Any]:
│ │ +    def _parse_json_config(self, path: str, required: bool = False) -> Dict[str, Any]:
│ │          """parses the configuration from the json file at the given path"""
│ │          result: Dict[str, Any] = {}
│ │          if not os.path.isfile(path):
│ │              if required:
│ │                  raise RuntimeError(f"required json config file {path} was not found")
│ │              # no file, not required
│ │              return result
│ │          with open(path, "rt", encoding="utf8") as json_fp:
│ │              for key, val in json.load(json_fp).items():
│ │ -                result[key] = val
│ │ +                if key not in self._options:
│ │ +                    # in the future we may want to optionally raise an
│ │ +                    # exception here
│ │ +                    continue
│ │ +                option = self._options[key]
│ │ +                option_type = self._base_type(option.option_type)
│ │ +
│ │ +                # check json value types against the supported types
│ │ +                val_type = type(val).__name__
│ │ +
│ │ +                coercions: Dict[str, Callable[[Any], Any]] = {
│ │ +                    "bool": bool,
│ │ +                    "float": float,
│ │ +                    "int": int,
│ │ +                    "str": str,
│ │ +                    "List[bool]": self._bool_list,
│ │ +                    "List[float]": self._float_list,
│ │ +                    "List[int]": self._int_list,
│ │ +                    "List[str]": self._str_list,
│ │ +                }
│ │ +
│ │ +                coerced_value = val
│ │ +                if val_type != option_type:
│ │ +                    if val_type == "list":
│ │ +                        if option_type not in coercions:
│ │ +                            raise TypeError(
│ │ +                                f"{key}: unsupported list type {option_type}"
│ │ +                            )
│ │ +                    if option_type not in coercions:
│ │ +                        raise TypeError(f"{key}: unsupported value type {option_type}")
│ │ +                    try:
│ │ +                        coerced_value = coercions[option_type](val)
│ │ +                    except ValueError:
│ │ +                        raise TypeError(
│ │ +                            f"{key}: unsupported value type {val_type}"
│ │ +                        ) from None
│ │ +
│ │ +                if option.choices:
│ │ +                    if coerced_value not in option.choices:
│ │ +                        raise ValueError(
│ │ +                            f'{key}: value "{coerced_value}" not in specified '
│ │ +                            f"option choices ({str(option.choices)})"
│ │ +                        )
│ │ +                result[key] = coerced_value
│ │ +
│ │          return result
│ │  
│ │ -    def parse_args(self) -> Dict[str, Any]:
│ │ +    def _bool_list(self, input_list: List[Any]) -> List[bool]:
│ │ +        """converts a list of unknown type into a list of bool values"""
│ │ +        return [bool(x) for x in input_list]
│ │ +
│ │ +    def _float_list(self, input_list: List[Any]) -> List[float]:
│ │ +        """converts a list of unknown type into a list of float values"""
│ │ +        return [float(x) for x in input_list]
│ │ +
│ │ +    def _int_list(self, input_list: List[Any]) -> List[int]:
│ │ +        """converts a list of unknown type into a list of int values"""
│ │ +        return [int(x) for x in input_list]
│ │ +
│ │ +    def _str_list(self, input_list: List[Any]) -> List[str]:
│ │ +        """converts a list of unknown type into a list of str values"""
│ │ +        return [str(x) for x in input_list]
│ │ +
│ │ +    def _keys(self) -> Sequence[str]:
│ │ +        """return a list of keys in this configuration"""
│ │ +        return [key for key in self._options if not key.startswith("_")]
│ │ +
│ │ +    def _parse_args(self, cli_args: Optional[Sequence[str]] = None) -> Dict[str, Any]:
│ │          """generate an args parser and call it"""
│ │          argp = argparse.ArgumentParser()
│ │          for optname, option in self._options.items():
│ │              arg_name = "--" + optname.replace("_", "-")
│ │ -            option_type = self.base_type(option.option_type)
│ │ +            option_type = self._base_type(option.option_type)
│ │  
│ │              # use this for as little as possible (because it doesn't get type checked)
│ │              # it could be good to switch to TypedDict for this
│ │              arg_config: Dict[str, Any] = {
│ │                  "action": "store",
│ │              }
│ │              if option_type == "bool":
│ │ @@ -157,28 +225,28 @@
│ │                  arg_config["action"] = "append"
│ │                  arg_config["type"] = int
│ │              elif option_type == "List[float]":
│ │                  arg_config["action"] = "append"
│ │                  arg_config["type"] = float
│ │              elif option_type == "List[bool]":
│ │                  arg_config["action"] = "append"
│ │ -                arg_config["type"] = self.parse_bool
│ │ +                arg_config["type"] = self._parse_bool
│ │  
│ │              argp.add_argument(
│ │                  arg_name,
│ │                  dest=optname,
│ │ -                default=option.default,
│ │ -                help=option.doc,
│ │ +                help=option.doc + f" (default {str(option.default)})",
│ │ +                required=False,
│ │                  choices=option.choices,
│ │                  **arg_config,
│ │              )
│ │  
│ │ -        return vars(argp.parse_args())
│ │ +        return vars(argp.parse_args(args=cli_args))
│ │  
│ │ -    def parse_envvars(self) -> Dict[str, Any]:
│ │ +    def _parse_envvars(self) -> Dict[str, Any]:
│ │          """parse environment variables for configuration values"""
│ │          # pylint: disable=too-many-branches
│ │          result: Dict[str, Any] = {}
│ │  
│ │          for optname, option in self._options.items():
│ │              envvar_name: str = optname.upper()
│ │              envvar_value: str
│ │ @@ -186,60 +254,69 @@
│ │                  envvar_value = os.environ[envvar_name]
│ │              elif optname in os.environ:
│ │                  envvar_name = optname
│ │                  envvar_value = os.environ[envvar_name]
│ │              else:
│ │                  continue
│ │  
│ │ -            option_type = self.base_type(option.option_type)
│ │ +            coerced_value: Any = envvar_value
│ │ +            option_type = self._base_type(option.option_type)
│ │              if option_type == "str":
│ │ -                result[optname] = envvar_value
│ │ -            if option_type == "bool":
│ │ -                result[optname] = self.parse_bool(envvar_value)
│ │ +                coerced_value = envvar_value
│ │ +            elif option_type == "bool":
│ │ +                coerced_value = self._parse_bool(envvar_value)
│ │              elif option_type == "int":
│ │ -                result[optname] = int(envvar_value)
│ │ +                coerced_value = int(envvar_value)
│ │              elif option_type == "float":
│ │ -                result[optname] = float(envvar_value)
│ │ +                coerced_value = float(envvar_value)
│ │              elif option_type == "List[str]":
│ │ -                result[optname] = option.sep.split(envvar_value)
│ │ +                coerced_value = envvar_value.split(option.sep)
│ │              elif option_type == "List[int]":
│ │ -                result[optname] = [int(n) for n in option.sep.split(envvar_value)]
│ │ +                coerced_value = [int(n) for n in envvar_value.split(option.sep)]
│ │              elif option_type == "List[float]":
│ │ -                result[optname] = [float(f) for f in option.sep.split(envvar_value)]
│ │ +                coerced_value = [float(f) for f in envvar_value.split(option.sep)]
│ │              elif option_type == "List[bool]":
│ │ -                result[optname] = [
│ │ -                    self.parse_bool(s) for s in option.sep.split(envvar_value)
│ │ +                coerced_value = [
│ │ +                    self._parse_bool(s) for s in envvar_value.split(option.sep)
│ │                  ]
│ │              else:
│ │                  raise ValueError(
│ │                      f"Don't know how to parse type {option.option_type} "
│ │                      f"({option_type})"
│ │                  )
│ │ +            if option.choices:
│ │ +                if coerced_value not in option.choices:
│ │ +                    raise ValueError(
│ │ +                        f"{optname} (envvar: {envvar_name}): "
│ │ +                        f'value "{coerced_value}" not in specified '
│ │ +                        f"choices list ({str(option.choices)})"
│ │ +                    )
│ │ +            result[optname] = coerced_value
│ │          return result
│ │  
│ │ -    def base_type(self, type_spec: Any) -> str:
│ │ +    def _base_type(self, type_spec: Any) -> str:
│ │          """returns a string representing the type of object"""
│ │ -        print(
│ │ -            f"spec: {type_spec}; "
│ │ -            f"name: {type_spec.__name__}; "
│ │ -            f"origin: {get_origin(type_spec)}; "
│ │ -            f"args: {get_args(type_spec)}"
│ │ -        )
│ │ +        # print(
│ │ +        #     f"spec: {type_spec}; "
│ │ +        #     f"name: {type_spec.__name__}; "
│ │ +        #     f"origin: {get_origin(type_spec)}; "
│ │ +        #     f"args: {get_args(type_spec)}"
│ │ +        # )
│ │          result = (
│ │              type_spec.__name__ if hasattr(type_spec, "__name__") else repr(type_spec)
│ │          )
│ │          origin = get_origin(type_spec)
│ │          args = get_args(type_spec)
│ │          if origin == Union and len(args) == 2 and args[1] == type(None):  # noqa
│ │              # Optional[thing] where thing is in args[0]
│ │ -            return self.base_type(args[0])
│ │ +            return self._base_type(args[0])
│ │          if origin == list and len(args) == 1:
│ │              if args[0] in (str, int, float, bool):
│ │                  result = f"List[{args[0].__name__}]"
│ │  
│ │ -        print(f"result is: {result}")
│ │ +        # print(f"result is: {result}")
│ │          return result
│ │  
│ │      @staticmethod
│ │ -    def parse_bool(value: str) -> bool:
│ │ +    def _parse_bool(value: str) -> bool:
│ │          """evaluates the string value in a boolean context and returns the result"""
│ │          return value.lower().strip() in ("1", "enable", "on", "true", "t", "y", "yes")
│ │   --- basecfg-1.0.1/src/basecfg.egg-info/PKG-INFO
│ ├── +++ basecfg-1.1.0/src/basecfg.egg-info/PKG-INFO
│ │┄ Files 12% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: basecfg
│ │ -Version: 1.0.1
│ │ +Version: 1.1.0
│ │  Summary: typed 12-factor app configuration helper
│ │  Author-email: Ben Burke <actualben@users.noreply.github.com>
│ │  Project-URL: Homepage, https://github.com/edencehealth/basecfg
│ │  Project-URL: Bug Tracker, https://github.com/edencehealth/basecfg/issues
│ │  Classifier: Programming Language :: Python :: 3
│ │  Classifier: License :: OSI Approved :: GNU Lesser General Public License v2 (LGPLv2)
│ │  Classifier: Operating System :: OS Independent
