--- tmp/idun_guardian_client-1.1b1.tar.gz
+++ tmp/idun_guardian_client-1.1b2.tar.gz
├── filetype from file(1)
│ @@ -1 +1 @@
│ -gzip compressed data, was "idun_guardian_client-1.1b1.tar", last modified: Fri Apr  7 12:31:33 2023, max compression
│ +gzip compressed data, was "idun_guardian_client-1.1b2.tar", last modified: Fri Apr  7 15:59:20 2023, max compression
│   --- idun_guardian_client-1.1b1.tar
├── +++ idun_guardian_client-1.1b2.tar
│ ├── file list
│ │ @@ -1,28 +1,28 @@
│ │ -drwxr-xr-x   0 waddaben   (501) staff       (20)        0 2023-04-07 12:31:33.241931 idun_guardian_client-1.1b1/
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)     8728 2023-04-07 12:31:33.241670 idun_guardian_client-1.1b1/PKG-INFO
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)     8163 2023-04-07 09:22:23.000000 idun_guardian_client-1.1b1/README.md
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)      869 2023-04-07 12:30:57.000000 idun_guardian_client-1.1b1/pyproject.toml
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)       38 2023-04-07 12:31:33.241987 idun_guardian_client-1.1b1/setup.cfg
│ │ -drwxr-xr-x   0 waddaben   (501) staff       (20)        0 2023-04-07 12:31:33.234346 idun_guardian_client-1.1b1/src/
│ │ -drwxr-xr-x   0 waddaben   (501) staff       (20)        0 2023-04-07 12:31:33.239248 idun_guardian_client-1.1b1/src/idun_guardian_client/
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)      339 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/__init__.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)        0 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/__main__.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)     7083 2023-04-07 11:46:40.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/client.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)     1797 2023-04-07 12:29:46.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/config.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)    11341 2023-04-07 11:46:38.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/debug_logs.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)    19332 2023-04-07 12:28:00.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/igeb_api.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)    30743 2023-04-07 12:30:04.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/igeb_bluetooth.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)     2846 2023-04-07 11:46:38.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/igeb_utils.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)      191 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/mock_utils.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)      164 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/setup.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)     1214 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b1/src/idun_guardian_client/test_producer_consumer.py
│ │ -drwxr-xr-x   0 waddaben   (501) staff       (20)        0 2023-04-07 12:31:33.240500 idun_guardian_client-1.1b1/src/idun_guardian_client.egg-info/
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)     8728 2023-04-07 12:31:33.000000 idun_guardian_client-1.1b1/src/idun_guardian_client.egg-info/PKG-INFO
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)      752 2023-04-07 12:31:33.000000 idun_guardian_client-1.1b1/src/idun_guardian_client.egg-info/SOURCES.txt
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)        1 2023-04-07 12:31:33.000000 idun_guardian_client-1.1b1/src/idun_guardian_client.egg-info/dependency_links.txt
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)      137 2023-04-07 12:31:33.000000 idun_guardian_client-1.1b1/src/idun_guardian_client.egg-info/requires.txt
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)       21 2023-04-07 12:31:33.000000 idun_guardian_client-1.1b1/src/idun_guardian_client.egg-info/top_level.txt
│ │ -drwxr-xr-x   0 waddaben   (501) staff       (20)        0 2023-04-07 12:31:33.241330 idun_guardian_client-1.1b1/tests/
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)     1940 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b1/tests/test_ble.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)     1672 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b1/tests/test_ble_record.py
│ │ --rw-r--r--   0 waddaben   (501) staff       (20)     1106 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b1/tests/test_utils.py
│ │ +drwxr-xr-x   0 waddaben   (501) staff       (20)        0 2023-04-07 15:59:20.694010 idun_guardian_client-1.1b2/
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)     8728 2023-04-07 15:59:20.693788 idun_guardian_client-1.1b2/PKG-INFO
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)     8163 2023-04-07 09:22:23.000000 idun_guardian_client-1.1b2/README.md
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)      869 2023-04-07 15:57:28.000000 idun_guardian_client-1.1b2/pyproject.toml
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)       38 2023-04-07 15:59:20.694062 idun_guardian_client-1.1b2/setup.cfg
│ │ +drwxr-xr-x   0 waddaben   (501) staff       (20)        0 2023-04-07 15:59:20.687763 idun_guardian_client-1.1b2/src/
│ │ +drwxr-xr-x   0 waddaben   (501) staff       (20)        0 2023-04-07 15:59:20.692133 idun_guardian_client-1.1b2/src/idun_guardian_client/
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)      339 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/__init__.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)        0 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/__main__.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)     7083 2023-04-07 11:46:40.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/client.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)     1797 2023-04-07 12:29:46.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/config.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)    11623 2023-04-07 15:53:12.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/debug_logs.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)    20707 2023-04-07 15:53:12.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/igeb_api.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)    30620 2023-04-07 15:53:12.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/igeb_bluetooth.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)     2846 2023-04-07 11:46:38.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/igeb_utils.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)      191 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/mock_utils.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)      164 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/setup.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)     1214 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b2/src/idun_guardian_client/test_producer_consumer.py
│ │ +drwxr-xr-x   0 waddaben   (501) staff       (20)        0 2023-04-07 15:59:20.693021 idun_guardian_client-1.1b2/src/idun_guardian_client.egg-info/
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)     8728 2023-04-07 15:59:20.000000 idun_guardian_client-1.1b2/src/idun_guardian_client.egg-info/PKG-INFO
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)      752 2023-04-07 15:59:20.000000 idun_guardian_client-1.1b2/src/idun_guardian_client.egg-info/SOURCES.txt
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)        1 2023-04-07 15:59:20.000000 idun_guardian_client-1.1b2/src/idun_guardian_client.egg-info/dependency_links.txt
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)      137 2023-04-07 15:59:20.000000 idun_guardian_client-1.1b2/src/idun_guardian_client.egg-info/requires.txt
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)       21 2023-04-07 15:59:20.000000 idun_guardian_client-1.1b2/src/idun_guardian_client.egg-info/top_level.txt
│ │ +drwxr-xr-x   0 waddaben   (501) staff       (20)        0 2023-04-07 15:59:20.693538 idun_guardian_client-1.1b2/tests/
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)     1940 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b2/tests/test_ble.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)     1672 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b2/tests/test_ble_record.py
│ │ +-rw-r--r--   0 waddaben   (501) staff       (20)     1106 2023-04-06 15:19:16.000000 idun_guardian_client-1.1b2/tests/test_utils.py
│ │   --- idun_guardian_client-1.1b1/PKG-INFO
│ ├── +++ idun_guardian_client-1.1b2/PKG-INFO
│ │┄ Files 1% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: idun_guardian_client
│ │ -Version: 1.1b1
│ │ +Version: 1.1b2
│ │  Summary: Python SDK for communication with the IDUN Guardian earbuds and IDUN cloud
│ │  Author-email: IDUN Technologies <contact@iduntechnologies.com>
│ │  Classifier: Development Status :: 1 - Planning
│ │  Classifier: License :: Other/Proprietary License
│ │  Classifier: Topic :: Software Development :: Libraries
│ │  Classifier: Operating System :: OS Independent
│ │  Classifier: Programming Language :: Python :: 3.10
│ │   --- idun_guardian_client-1.1b1/README.md
│ ├── +++ idun_guardian_client-1.1b2/README.md
│ │┄ Files identical despite different names
│ │   --- idun_guardian_client-1.1b1/pyproject.toml
│ ├── +++ idun_guardian_client-1.1b2/pyproject.toml
│ │┄ Files 1% similar despite different names
│ │ @@ -1,14 +1,14 @@
│ │  [build-system]
│ │  requires = ["setuptools>=61.0"]
│ │  build-backend = "setuptools.build_meta"
│ │  
│ │  [project]
│ │  name = "idun_guardian_client"
│ │ -version = "1.1.beta.1"
│ │ +version = "1.1.beta.2"
│ │  authors = [
│ │    { name="IDUN Technologies", email="contact@iduntechnologies.com" },
│ │  ]
│ │  description = "Python SDK for communication with the IDUN Guardian earbuds and IDUN cloud"
│ │  readme = "README.md"
│ │  requires-python = ">=3.10"
│ │   --- idun_guardian_client-1.1b1/src/idun_guardian_client/client.py
│ ├── +++ idun_guardian_client-1.1b2/src/idun_guardian_client/client.py
│ │┄ Files identical despite different names
│ │   --- idun_guardian_client-1.1b1/src/idun_guardian_client/config.py
│ ├── +++ idun_guardian_client-1.1b2/src/idun_guardian_client/config.py
│ │┄ Files identical despite different names
│ │   --- idun_guardian_client-1.1b1/src/idun_guardian_client/debug_logs.py
│ ├── +++ idun_guardian_client-1.1b2/src/idun_guardian_client/debug_logs.py
│ │┄ Files 0% similar despite different names
│ │ @@ -150,14 +150,19 @@
│ │  
│ │  
│ │  def logging_connecting_to_cloud(debug):
│ │      if debug:
│ │          logging.info("[API]: Connecting to cloud...")
│ │  
│ │  
│ │ +def logging_waiting_for_stop_receipt(debug):
│ │ +    if debug:
│ │ +        logging.info("[API]: Waiting for stop receipt")
│ │ +
│ │ +
│ │  def logging_api_completed(debug):
│ │      if debug:
│ │          logging.info("[API]: -----------  API client is COMPLETED ----------- ")
│ │  
│ │  
│ │  def logging_succesfull_stop(debug):
│ │      if debug:
│ │ @@ -269,14 +274,21 @@
│ │      if debug:
│ │          logging.info("[BLE]: KeyboardInterrupt applied, terminating...")
│ │          logging.info(
│ │              "[BLE]: Sending stop signal to device and cloud, please wait a moment ..."
│ │          )
│ │  
│ │  
│ │ +def logging_stop_send(debug):
│ │ +    if debug:
│ │ +        logging.info(
│ │ +            "[API]: Sending stop signal to device and cloud, please wait a moment ..."
│ │ +        )
│ │ +
│ │ +
│ │  def logging_device_lost_give_up(debug):
│ │      if debug:
│ │          logging.info("[BLE]: Device lost, terminating...")
│ │  
│ │  
│ │  def logging_trying_to_connect_again(debug, try_to_connect_timeout):
│ │      if debug:
│ │   --- idun_guardian_client-1.1b1/src/idun_guardian_client/igeb_api.py
│ ├── +++ idun_guardian_client-1.1b2/src/idun_guardian_client/igeb_api.py
│ │┄ Files 3% similar despite different names
│ │ @@ -36,15 +36,15 @@
│ │              debug (bool, optional): Enable debug logging. Defaults to True.
│ │          """
│ │          self.debug: bool = debug
│ │          self.ping_timeout: int = 2
│ │          self.retry_time: int = 2
│ │          self.base64string_len: int = 236
│ │          self.first_message_check = True
│ │ -        self.final_message_check = False
│ │ +        self.final_message_sent = False
│ │          self.payload_valid = True
│ │          self.sample_rate = 250
│ │          self.sentinal = object()
│ │          self.encrypted_buffer_size = 3750  # 5 minutes => (5 * 60 * 250) / 20 = 3750
│ │          self.decrypted_buffer_size = 75000  # 5 minutes => (5 * 60 * 250) = 75000
│ │          self.encrypted_data_queue: asyncio.Queue = asyncio.Queue(
│ │              maxsize=self.encrypted_buffer_size
│ │ @@ -59,14 +59,15 @@
│ │          self.runtime_bi_directional_timeout = 4
│ │          self.sending_time_limit = 0.01
│ │          self.bi_directional_timeout = self.initial_bi_directional_timeout
│ │          self.last_saved_time = time.time()
│ │          self.connected = False
│ │          self.data_model = GuardianDataModel(None, None, None, None, None, False)
│ │          self.websocket: Optional[websockets.WebSocketClientProtocol] = None  # type: ignore
│ │ +        self.final_receipt_got = False
│ │  
│ │      async def connect_ws_api(
│ │          self,
│ │          data_queue: asyncio.Queue,
│ │          device_id: str = "deviceMockID",
│ │          recording_id: str = "dummy_recID",
│ │          impedance_measurement: bool = False,
│ │ @@ -156,27 +157,38 @@
│ │              self.data_model.stop = True
│ │              device_timestamp = await create_timestamp(self.debug)
│ │              if device_timestamp is not None:
│ │                  self.data_model.deviceTimestamp = device_timestamp
│ │  
│ │          async def send_messages():
│ │              while True:
│ │ +
│ │                  if not self.connected:
│ │                      break
│ │ +
│ │                  if await unpack_and_load_data():
│ │                      await asyncio.shield(
│ │                          asyncio.sleep(self.sending_time_limit)
│ │                      )  # Wait as to not overload the cloud
│ │                      await asyncio.shield(
│ │                          self.websocket.send(json.dumps(asdict(self.data_model)))
│ │                      )
│ │                      await asyncio.shield(pack_encrypted_queue())
│ │  
│ │                  if self.data_model.stop:
│ │ -                    self.current_timeout = self.initial_receipt_timeout
│ │ +                    logging_stop_send(self.debug)
│ │ +                    self.current_timeout = (
│ │ +                        1000  # Wait until necessary for the stop to be sent
│ │ +                    )
│ │ +                    self.final_message_sent = True
│ │ +                    while not self.final_receipt_got:
│ │ +                        # It will loop in here and not update the
│ │ +                        # data until the stop is sent
│ │ +                        logging_waiting_for_stop_receipt(self.debug)
│ │ +                        await asyncio.sleep(1)
│ │                      break
│ │  
│ │          async def receive_messages():
│ │              self.last_saved_time = time.time()
│ │              while True:
│ │  
│ │                  if not self.connected:
│ │ @@ -199,21 +211,21 @@
│ │                      if self.first_message_check:
│ │                          self.first_message_check = False
│ │                          log_first_message(
│ │                              self.data_model,
│ │                              message_str,
│ │                              self.debug,
│ │                          )
│ │ -                    if self.data_model.stop:
│ │ +                    if self.final_message_sent:
│ │                          log_final_message(
│ │                              self.data_model,
│ │                              message_str,
│ │                              self.debug,
│ │                          )
│ │ -                        self.final_message_check = True
│ │ +                        self.final_receipt_got = True
│ │                          break
│ │  
│ │                  bi_directional_timeout(impedance_measurement)
│ │  
│ │          def bi_directional_timeout(impedance_measurement):
│ │              time_without_data = time.time() - self.last_saved_time
│ │              if (
│ │ @@ -221,15 +233,15 @@
│ │                  and not impedance_measurement
│ │              ):
│ │                  raise asyncio.TimeoutError
│ │  
│ │          def once_initialise_variables():
│ │              # initiate flags
│ │              self.first_message_check = True
│ │ -            self.final_message_check = False
│ │ +            self.final_message_sent = False
│ │              self.data_model = GuardianDataModel(
│ │                  None, device_id, recording_id, None, None, False
│ │              )
│ │  
│ │          def on_connection_initialise_variables():
│ │              self.first_message_check = True
│ │              self.connected = True
│ │ @@ -247,15 +259,15 @@
│ │                          await self.websocket.send(json.dumps(asdict(self.data_model)))
│ │                          package_receipt = await self.websocket.recv()
│ │                          log_final_message(
│ │                              self.data_model,
│ │                              package_receipt,
│ │                              self.debug,
│ │                          )
│ │ -                        self.final_message_check = True
│ │ +                        self.final_message_sent = True
│ │                          break
│ │                  except Exception as error:
│ │                      await asyncio.sleep(self.ping_timeout)
│ │                      log_error_in_sending_stop(error, self.debug)
│ │                      continue
│ │  
│ │          once_initialise_variables()
│ │ @@ -299,28 +311,48 @@
│ │                              continue
│ │                          except asyncio.CancelledError as error:
│ │                              await handle_cancelled_error(error)
│ │  
│ │                      except asyncio.CancelledError as error:
│ │                          await handle_cancelled_error(error)
│ │  
│ │ +                    finally:
│ │ +                        # Otherwise new tasks will be created which is a problem
│ │ +                        try:
│ │ +                            if not send_task.done():
│ │ +                                send_task.cancel()
│ │ +                            if not receive_task.done():
│ │ +                                receive_task.cancel()
│ │ +                        except Exception as error:
│ │ +                            print("These tasks does not exist yet")
│ │ +
│ │              except socket.gaierror as error:
│ │                  logging_gaieerror(error, self.retry_time, self.debug)
│ │                  await asyncio.sleep(self.retry_time)
│ │                  continue
│ │  
│ │              except ConnectionRefusedError as error:
│ │                  logging_connection_refused(error, self.retry_time, self.debug)
│ │                  await asyncio.sleep(self.retry_time)
│ │                  continue
│ │  
│ │              except Exception as error:
│ │                  log_interrupt_error(error, self.debug)
│ │  
│ │ -            if self.final_message_check:
│ │ +            finally:
│ │ +                # Otherwise new tasks will be created which is a problem
│ │ +                try:
│ │ +                    if not send_task.done():
│ │ +                        send_task.cancel()
│ │ +                    if not receive_task.done():
│ │ +                        receive_task.cancel()
│ │ +                except Exception as error:
│ │ +                    print("These tasks does not exist yet")
│ │ +
│ │ +            if self.final_message_sent:
│ │                  logging_break(self.debug)
│ │                  break
│ │  
│ │          logging_api_completed(self.debug)
│ │  
│ │      def get_recordings_info_all(
│ │          self, device_id: str = "mock-device-0", first_to_last=False, password: str = ""
│ │   --- idun_guardian_client-1.1b1/src/idun_guardian_client/igeb_bluetooth.py
│ ├── +++ idun_guardian_client-1.1b2/src/idun_guardian_client/igeb_bluetooth.py
│ │┄ Files 2% similar despite different names
│ │ @@ -54,14 +54,16 @@
│ │          # The timing constants
│ │          self.sample_rate = 250
│ │          self.amount_samples_packet = 20
│ │          self.max_index = 256
│ │          self.prev_index = 0
│ │          self.prev_timestamp = 0
│ │  
│ │ +        self.remaining_time = 0
│ │ +
│ │          self.get_ble_characteristic()
│ │  
│ │          loggig_ble_init(self.debug)
│ │  
│ │      def get_ble_characteristic(self) -> None:
│ │          """Get the environment variables."""
│ │          # General information
│ │ @@ -281,15 +283,15 @@
│ │              package = {
│ │                  "timestamp": new_time_stamp,
│ │                  "deviceID": mac_id,
│ │                  "data": data_base_64,
│ │                  "stop": False,
│ │              }
│ │              # print the size of the queue
│ │ -            # print(f"                        [BLE]: Queue size: {data_queue.qsize()}")
│ │ +            # print(f"[BLE]: Queue size: {data_queue.qsize()}")
│ │              if not data_queue.full():
│ │                  await asyncio.shield(data_queue.put(package))
│ │              else:
│ │                  await asyncio.shield(data_queue.get())
│ │  
│ │          async def battery_handler(_, data):
│ │              """Battery handler for the BLE client.
│ │ @@ -375,17 +377,14 @@
│ │              await asyncio.sleep(self.ble_delay)
│ │              await self.client.write_gatt_char(
│ │                  self.command_id, utf_8_encode(self.start_imp_cmd)[0]
│ │              )
│ │  
│ │          async def stop_impedance_timeout():
│ │              """Stop recording gracefully."""
│ │ -
│ │ -            # ------------------------- TEST
│ │ -            await asyncio.sleep(self.ble_delay)
│ │              # make sure the last data is now a stop command
│ │              package = {
│ │                  "timestamp": datetime.datetime.now().astimezone().isoformat(),
│ │                  "deviceID": mac_id,
│ │                  "stop": True,
│ │              }
│ │              # ------------------ Load final stop package ------------------
│ │ @@ -416,16 +415,14 @@
│ │              if self.write_to_file:
│ │                  self.data_recording_logfile.close()
│ │              logging_recording_successfully_stopped(self.debug)
│ │  
│ │          async def stop_recording_timeout():
│ │              """Stop recording gracefully."""
│ │  
│ │ -            # ------------------------- TEST
│ │ -            await asyncio.sleep(self.ble_delay)
│ │              # make sure the last data is now a stop command
│ │              package = {
│ │                  "timestamp": datetime.datetime.now().astimezone().isoformat(),
│ │                  "deviceID": mac_id,
│ │                  "data": "STOP_TIMEOUT",
│ │                  "stop": True,
│ │              }
│ │ @@ -595,23 +592,35 @@
│ │  
│ │          def initialise_timestamps():
│ │              if self.initial_time:
│ │                  self.initial_time = False  # record that this is the initial time
│ │                  self.original_time = time.time()
│ │  
│ │          async def main_loop():
│ │ -            while self.connection_established is True and self.time_left is True:
│ │ -                await asyncio.shield(
│ │ -                    asyncio.sleep(self.ble_delay)
│ │ -                )  # sleep so that everything can happen
│ │ -                remaining_time = record_time - (time.time() - self.original_time)
│ │ -                print(f"Time left: {round(remaining_time)}s")
│ │ -                if remaining_time <= 0:
│ │ -                    self.time_left = False
│ │ -                    logging_time_reached(self.debug, self.original_time)
│ │ +            while True:
│ │ +                if self.connection_established:
│ │ +
│ │ +                    await asyncio.shield(
│ │ +                        asyncio.sleep(self.ble_delay)
│ │ +                    )  # sleep so that everything can happen
│ │ +                    self.remaining_time = record_time - (
│ │ +                        time.time() - self.original_time
│ │ +                    )
│ │ +                    print(f"Time left: {round(self.remaining_time)}s")
│ │ +
│ │ +                    if self.remaining_time <= 0:
│ │ +                        logging_time_reached(self.debug, self.original_time)
│ │ +                        if not impedance_measurement:
│ │ +                            await stop_recording_timeout()
│ │ +                        else:
│ │ +                            await stop_impedance_timeout()
│ │ +                        break
│ │ +
│ │ +                else:
│ │ +                    break
│ │  
│ │          # >>>>>>>>>>>>>>>>>>>>> Start of recording process <<<<<<<<<<<<<<<<<<<<<<<<
│ │          # ------------------ Initialise values for timestamps ------------------
│ │          self.prev_timestamp = 0
│ │          self.prev_index = -1
│ │          # ------------------ Initialise time values for recording timeout ------------------
│ │          # This has been decoupled from the device timing for robustness
│ │ @@ -643,22 +652,17 @@
│ │                      self.try_to_connect_timeout = (
│ │                          self.reconnect_try_amount
│ │                      )  # reset counter
│ │                      # >>>>>>>>>>>>>>>>>>>>> Main loop <<<<<<<<<<<<<<<<<<<<<<<<
│ │                      initialise_timestamps()
│ │                      await asyncio.shield(main_loop())
│ │                      # >>>>>>>>>>>>>>>>>>>>> Main loop <<<<<<<<<<<<<<<<<<<<<<<<
│ │ -                    if not self.time_left:
│ │ -                        logging_timeout_reached(self.debug)
│ │  
│ │ -                        if not impedance_measurement:
│ │ -                            await stop_recording_timeout()
│ │ -                        else:
│ │ -                            await stop_impedance_timeout()
│ │ -                        break
│ │ +                if self.remaining_time <= 0:
│ │ +                    break
│ │  
│ │                  if not self.connection_established:
│ │                      logging_disconnected_recognised(self.debug)
│ │                      await bluetooth_reconnect()
│ │                      if self.device_lost:
│ │                          break
│ │   --- idun_guardian_client-1.1b1/src/idun_guardian_client/igeb_utils.py
│ ├── +++ idun_guardian_client-1.1b2/src/idun_guardian_client/igeb_utils.py
│ │┄ Files identical despite different names
│ │   --- idun_guardian_client-1.1b1/src/idun_guardian_client/test_producer_consumer.py
│ ├── +++ idun_guardian_client-1.1b2/src/idun_guardian_client/test_producer_consumer.py
│ │┄ Files identical despite different names
│ │   --- idun_guardian_client-1.1b1/src/idun_guardian_client.egg-info/PKG-INFO
│ ├── +++ idun_guardian_client-1.1b2/src/idun_guardian_client.egg-info/PKG-INFO
│ │┄ Files 0% similar despite different names
│ │ @@ -1,10 +1,10 @@
│ │  Metadata-Version: 2.1
│ │  Name: idun-guardian-client
│ │ -Version: 1.1b1
│ │ +Version: 1.1b2
│ │  Summary: Python SDK for communication with the IDUN Guardian earbuds and IDUN cloud
│ │  Author-email: IDUN Technologies <contact@iduntechnologies.com>
│ │  Classifier: Development Status :: 1 - Planning
│ │  Classifier: License :: Other/Proprietary License
│ │  Classifier: Topic :: Software Development :: Libraries
│ │  Classifier: Operating System :: OS Independent
│ │  Classifier: Programming Language :: Python :: 3.10
│ │   --- idun_guardian_client-1.1b1/src/idun_guardian_client.egg-info/SOURCES.txt
│ ├── +++ idun_guardian_client-1.1b2/src/idun_guardian_client.egg-info/SOURCES.txt
│ │┄ Files identical despite different names
│ │   --- idun_guardian_client-1.1b1/tests/test_ble.py
│ ├── +++ idun_guardian_client-1.1b2/tests/test_ble.py
│ │┄ Files identical despite different names
│ │   --- idun_guardian_client-1.1b1/tests/test_ble_record.py
│ ├── +++ idun_guardian_client-1.1b2/tests/test_ble_record.py
│ │┄ Files identical despite different names
│ │   --- idun_guardian_client-1.1b1/tests/test_utils.py
│ ├── +++ idun_guardian_client-1.1b2/tests/test_utils.py
│ │┄ Files identical despite different names
