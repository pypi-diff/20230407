# Comparing `tmp/casambi_bt-0.0.9b2-py3-none-any.whl.zip` & `tmp/casambi_bt-0.1.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,19 +1,19 @@
-Zip file size: 25977 bytes, number of entries: 17
--rw-r--r--  2.0 unx      171 b- defN 23-Feb-13 11:50 CasambiBt/__init__.py
--rw-r--r--  2.0 unx      589 b- defN 23-Feb-13 19:05 CasambiBt/_cache.py
--rw-r--r--  2.0 unx    15105 b- defN 23-Feb-13 19:03 CasambiBt/_casambi.py
--rw-r--r--  2.0 unx    17213 b- defN 23-Feb-13 11:50 CasambiBt/_client.py
--rw-r--r--  2.0 unx      288 b- defN 23-Feb-13 19:03 CasambiBt/_constants.py
--rw-r--r--  2.0 unx     1144 b- defN 23-Feb-13 11:50 CasambiBt/_discover.py
--rw-r--r--  2.0 unx     3858 b- defN 23-Feb-13 19:03 CasambiBt/_encryption.py
--rw-r--r--  2.0 unx     2459 b- defN 23-Feb-13 11:50 CasambiBt/_keystore.py
--rw-r--r--  2.0 unx     9197 b- defN 23-Feb-13 19:03 CasambiBt/_network.py
--rw-r--r--  2.0 unx      633 b- defN 23-Feb-13 19:03 CasambiBt/_operation.py
--rw-r--r--  2.0 unx    13361 b- defN 23-Feb-13 19:03 CasambiBt/_unit.py
--rw-r--r--  2.0 unx      776 b- defN 23-Feb-13 11:50 CasambiBt/errors.py
--rw-r--r--  2.0 unx    11341 b- defN 23-Feb-13 19:06 casambi_bt-0.0.9b2.dist-info/LICENSE
--rw-r--r--  2.0 unx     2079 b- defN 23-Feb-13 19:06 casambi_bt-0.0.9b2.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 23-Feb-13 19:06 casambi_bt-0.0.9b2.dist-info/WHEEL
--rw-r--r--  2.0 unx       10 b- defN 23-Feb-13 19:06 casambi_bt-0.0.9b2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1347 b- defN 23-Feb-13 19:06 casambi_bt-0.0.9b2.dist-info/RECORD
-17 files, 79663 bytes uncompressed, 23789 bytes compressed:  70.1%
+Zip file size: 26963 bytes, number of entries: 17
+-rw-r--r--  2.0 unx      229 b- defN 23-Apr-07 15:31 CasambiBt/__init__.py
+-rw-r--r--  2.0 unx      828 b- defN 23-Feb-21 11:39 CasambiBt/_cache.py
+-rw-r--r--  2.0 unx    15729 b- defN 23-Apr-07 15:24 CasambiBt/_casambi.py
+-rw-r--r--  2.0 unx    17483 b- defN 23-Apr-07 16:35 CasambiBt/_client.py
+-rw-r--r--  2.0 unx      194 b- defN 23-Feb-21 11:37 CasambiBt/_constants.py
+-rw-r--r--  2.0 unx     1144 b- defN 23-Feb-21 11:54 CasambiBt/_discover.py
+-rw-r--r--  2.0 unx     3831 b- defN 23-Apr-07 15:24 CasambiBt/_encryption.py
+-rw-r--r--  2.0 unx     2389 b- defN 23-Apr-07 15:30 CasambiBt/_keystore.py
+-rw-r--r--  2.0 unx    11573 b- defN 23-Apr-07 15:24 CasambiBt/_network.py
+-rw-r--r--  2.0 unx      683 b- defN 23-Apr-07 12:56 CasambiBt/_operation.py
+-rw-r--r--  2.0 unx    13496 b- defN 23-Apr-07 15:31 CasambiBt/_unit.py
+-rw-r--r--  2.0 unx     1551 b- defN 23-Apr-07 15:46 CasambiBt/errors.py
+-rw-r--r--  2.0 unx    11341 b- defN 23-Apr-07 16:43 casambi_bt-0.1.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx     2076 b- defN 23-Apr-07 16:43 casambi_bt-0.1.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 23-Apr-07 16:43 casambi_bt-0.1.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       10 b- defN 23-Apr-07 16:43 casambi_bt-0.1.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1339 b- defN 23-Apr-07 16:43 casambi_bt-0.1.0.dist-info/RECORD
+17 files, 83988 bytes uncompressed, 24795 bytes compressed:  70.5%
```

## zipnote {}

```diff
@@ -30,23 +30,23 @@
 
 Filename: CasambiBt/_unit.py
 Comment: 
 
 Filename: CasambiBt/errors.py
 Comment: 
 
-Filename: casambi_bt-0.0.9b2.dist-info/LICENSE
+Filename: casambi_bt-0.1.0.dist-info/LICENSE
 Comment: 
 
-Filename: casambi_bt-0.0.9b2.dist-info/METADATA
+Filename: casambi_bt-0.1.0.dist-info/METADATA
 Comment: 
 
-Filename: casambi_bt-0.0.9b2.dist-info/WHEEL
+Filename: casambi_bt-0.1.0.dist-info/WHEEL
 Comment: 
 
-Filename: casambi_bt-0.0.9b2.dist-info/top_level.txt
+Filename: casambi_bt-0.1.0.dist-info/top_level.txt
 Comment: 
 
-Filename: casambi_bt-0.0.9b2.dist-info/RECORD
+Filename: casambi_bt-0.1.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## CasambiBt/__init__.py

```diff
@@ -1,5 +1,8 @@
+"""Top-level module for CasambiBt."""
+
 # Import everything that should be public
+# ruff: noqa: F401
 
 from ._casambi import Casambi
 from ._discover import discover
 from ._unit import Group, Scene, Unit, UnitControlType, UnitState
```

## CasambiBt/_cache.py

```diff
@@ -1,22 +1,32 @@
-from typing import Final
-from ._constants import BASE_PATH
-
+import os
 import shutil
+from pathlib import Path
+from typing import Final
 
+CACHE_PATH: Final = Path(os.getcwd()) / "casambi-bt-store"
 CACHE_VERSION: Final = 1
-
-CACHE_VER_FILE = BASE_PATH / ".cachever"
+CACHE_VER_FILE: Final = CACHE_PATH / ".cachever"
 
 
-def ensureCacheValid() -> None:
-    if BASE_PATH.exists():
+def _ensureCacheValid() -> None:
+    if CACHE_PATH.exists():
         cacheVer = None
         if CACHE_VER_FILE.exists():
             cacheVer = int(CACHE_VER_FILE.read_text())
         if not cacheVer or cacheVer < 1:
-            shutil.rmtree(BASE_PATH)
+            shutil.rmtree(CACHE_PATH)
 
     # This is not a redunant condition. We may have deleted the cache.
-    if not BASE_PATH.exists():
-        BASE_PATH.mkdir(mode=0o700)
+    if not CACHE_PATH.exists():
+        CACHE_PATH.mkdir(mode=0o700)
         CACHE_VER_FILE.write_text(str(CACHE_VERSION))
+
+
+def getCacheDir(id: str) -> Path:
+    _ensureCacheValid()
+
+    cacheDir = CACHE_PATH / id
+    if not cacheDir.exists():
+        cacheDir.mkdir()
+
+    return cacheDir
```

## CasambiBt/_casambi.py

```diff
@@ -1,42 +1,35 @@
 import logging
 from binascii import b2a_hex as b2a
-from typing import Any, Callable, Optional, Union
+from itertools import pairwise  # type: ignore[attr-defined]
+from typing import Any, Callable, Optional, Union, cast
 
 from bleak.backends.device import BLEDevice
-from httpx import AsyncClient
+from httpx import AsyncClient, NetworkError
 
 from ._client import CasambiClient, ConnectionState, IncommingPacketType
-from ._network import Network, getNetworkIdFromUuid
+from ._network import Network
 from ._operation import OpCode, OperationsContext
 from ._unit import Group, Scene, Unit, UnitState
-from .errors import (
-    AuthenticationError,
-    ConnectionStateError,
-    NetworkNotFoundError,
-    ProtocolError,
-)
+from .errors import ConnectionStateError, ProtocolError
 
 
 class Casambi:
     """Class to manage one Casambi network.
 
     This is the central point of interaction and should be preferred to dealing with the internal components,
     e.g. ``Network`` or ``CasambiClient``, directly.
     """
 
-    _casaClient: CasambiClient
-    _casaNetwork: Optional[Network]
-    _opContext: OperationsContext
-    _httpClient: AsyncClient
-    _ownHttpClient: bool
+    def __init__(self, httpClient: Optional[AsyncClient] = None) -> None:
+        self._casaClient: Optional[CasambiClient] = None
+        self._casaNetwork: Optional[Network] = None
 
-    _unitChangedCallbacks: list[Callable[[Unit], None]] = []
+        self._unitChangedCallbacks: list[Callable[[Unit], None]] = []
 
-    def __init__(self, httpClient: Optional[AsyncClient] = None) -> None:
         self._logger = logging.getLogger(__name__)
         self._opContext = OperationsContext()
         if not httpClient:
             httpClient = AsyncClient()
             self._ownHttpClient = True
         else:
             self._ownHttpClient = False
@@ -88,55 +81,69 @@
         """
         self._checkNetwork()
         return self._casaNetwork.scenes  # type: ignore
 
     @property
     def connected(self) -> bool:
         """Check whether there is an active connection to the network."""
-        return self._casaClient._connectionState == ConnectionState.AUTHENTICATED
+        return (
+            self._casaClient is not None
+            and self._casaClient._connectionState == ConnectionState.AUTHENTICATED
+        )
 
     async def connect(
-        self, addr_or_device: Union[str, BLEDevice], password: str
+        self,
+        addr_or_device: Union[str, BLEDevice],
+        password: str,
+        forceOffline: bool = False,
     ) -> None:
         """Connect and authenticate to a network.
 
         :param addr: The MAC address of the network or a BLEDevice. Use `discover` to find the address of a network.
         :param password: The password for the network.
+        :param forceOffline: Whether to avoid contacting the casambi servers.
         :raises AuthenticationError: The supplied password is invalid.
         :raises ProtocolError: The network did not follow the expected protocol.
         :raises NetworkNotFoundError: No network was found under the supplied address.
+        :raises NetworkOnlineUpdateNeededError: An offline update isn't possible in the current state.
         :raises BluetoothError: An error occurred in the bluetooth stack.
         """
 
         if isinstance(addr_or_device, BLEDevice):
             addr = addr_or_device.address
         else:
+            # Add colons if necessary.
+            if ":" not in addr_or_device:
+                addr_or_device = ":".join(["".join(p) for p in pairwise(addr)][::2])
             addr = addr_or_device
 
         self._logger.info(f"Trying to connect to casambi network {addr}...")
 
         self._casaClient = CasambiClient(
             addr_or_device, self._dataCallback, self._disconnect_callback
         )
 
         # Retrieve network information
-        networkId = await getNetworkIdFromUuid(addr, self._httpClient)
-        if not networkId:
-            raise NetworkNotFoundError
-        self._casaNetwork = Network(networkId, self._httpClient)
-        if not self._casaNetwork.authenticated():
-            loggedIn = await self._casaNetwork.logIn(password)
-            if not loggedIn:
-                raise AuthenticationError("Login failed")
-        await self._casaNetwork.update()
+        uuid = addr.replace(":", "").lower()
+        self._casaNetwork = Network(uuid, self._httpClient)
+        try:
+            await self._casaNetwork.logIn(password, forceOffline)
+        except NetworkError:
+            self._logger.warning(
+                "Network error while logging in. Trying to continue offline.",
+                exc_info=True,
+            )
+            forceOffline = True
 
+        await self._casaNetwork.update(forceOffline)
         await self._connectClient()
 
     async def _connectClient(self) -> None:
         """Initiate the bluetooth connection."""
+        self._casaClient = cast(CasambiClient, self._casaClient)
         await self._casaClient.connect()
         try:
             await self._casaClient.exchangeKey(self._casaNetwork.getKeyStore())  # type: ignore[union-attr]
             await self._casaClient.authenticate(self._casaNetwork.getKeyStore())  # type: ignore[union-attr]
         except ProtocolError as e:
             await self._casaClient.disconnect()
             raise e
@@ -165,15 +172,17 @@
         """
         if level < 0 or level > 255:
             raise ValueError()
 
         payload = level.to_bytes(1, byteorder="big", signed=False)
         await self._send(target, payload, OpCode.SetLevel)
 
-    async def setVertical(self, target: Union[Unit, Group, None], vertical: int) -> None:
+    async def setVertical(
+        self, target: Union[Unit, Group, None], vertical: int
+    ) -> None:
         """Set the vertical (balance between top and bottom LED) for one or multiple units.
 
         If ``target`` is of type ``Unit`` only this unit is affected.
         If ``target`` is of type ``Group`` the whole group is affected.
         if ``target`` is of type ``None`` all units in the network are affected.
 
         :param target: One or multiple targeted units.
@@ -258,14 +267,20 @@
         :return: Nothing is returned by this function. To get the new state register a change handler.
         """
         await self.setLevel(target, level)  # type: ignore[arg-type]
 
     async def _send(
         self, target: Union[Unit, Group, Scene, None], state: bytes, opcode: OpCode
     ) -> None:
+        if self._casaClient is None:
+            raise ConnectionStateError(
+                ConnectionState.AUTHENTICATED,
+                ConnectionState.NONE,
+            )
+
         targetCode = 0
         if isinstance(target, Unit):
             assert target.deviceId <= 0xFF
             targetCode = (target.deviceId << 8) | 0x01
         elif isinstance(target, Group):
             assert target.groudId <= 0xFF
             targetCode = (target.groudId << 8) | 0x02
@@ -281,15 +296,15 @@
 
         opPkt = self._opContext.prepareOperation(opcode, targetCode, state)
 
         try:
             await self._casaClient.send(opPkt)
         except ConnectionStateError as exc:
             if exc.got == ConnectionState.NONE:
-                self._logger.info(f"Trying to reconnect broken connection once.")
+                self._logger.info("Trying to reconnect broken connection once.")
                 await self._connectClient()
                 await self._casaClient.send(opPkt)
             else:
                 raise exc
 
     def _dataCallback(
         self, packetType: IncommingPacketType, data: dict[str, Any]
@@ -364,10 +379,7 @@
         if self._casaClient:
             await self._casaClient.disconnect()
         if self._casaNetwork:
             await self._casaNetwork.disconnect()
             self._casaNetwork = None
         if self._ownHttpClient:
             await self._httpClient.aclose()
-
-    async def __aexit__(self) -> None:
-        await self.disconnect()
```

## CasambiBt/_client.py

```diff
@@ -6,15 +6,20 @@
 from hashlib import sha256
 from typing import Any, Callable, Optional, Union
 
 from bleak import BleakClient
 from bleak.backends.characteristic import BleakGATTCharacteristic
 from bleak.backends.client import BLEDevice
 from bleak.exc import BleakError
-from bleak_retry_connector import BleakNotFoundError, establish_connection, get_device
+from bleak_retry_connector import (
+    BleakNotFoundError,
+    close_stale_connections,
+    establish_connection,
+    get_device,
+)
 from cryptography.exceptions import InvalidSignature
 from cryptography.hazmat.primitives.asymmetric import ec
 
 from ._constants import CASA_AUTH_CHAR_UUID
 from ._encryption import Encryptor
 from ._keystore import KeyStore
 
@@ -24,52 +29,53 @@
     NONE = 0
     CONNECTED = 1
     KEY_EXCHANGED = 2
     AUTHENTICATED = 3
     ERROR = 99
 
 
-from .errors import (
+# We need to move these imports here to prevent a cycle.
+from .errors import (  # noqa: E402
     BluetoothError,
     ConnectionStateError,
     NetworkNotFoundError,
     ProtocolError,
 )
 
 
 @unique
 class IncommingPacketType(IntEnum):
     UnitState = 6
     NetworkConfig = 9
 
 
 class CasambiClient:
-    _gattClient: BleakClient
-    _notifySignal: asyncio.Event
-
-    _mtu: int
-    _unitId: int
-    _flags: int
-    _nonce: bytes
-    _key: bytearray
-
-    _encryptor: Encryptor
-
-    _outPacketCount: int
-    _inPacketCount: int
-
-    _callbackQueue: asyncio.Queue[tuple[BleakGATTCharacteristic, bytes]]
-    _callbackTask: Optional[asyncio.Task[None]]
-
     def __init__(
         self,
         address_or_device: Union[str, BLEDevice],
         dataCallback: Callable[[IncommingPacketType, dict[str, Any]], None],
         disonnectedCallback: Callable[[], None],
     ) -> None:
+        self._gattClient: BleakClient
+        self._notifySignal = asyncio.Event()
+
+        self._mtu: int
+        self._unitId: int
+        self._flags: int
+        self._nonce: bytes
+        self._key: bytearray
+
+        self._encryptor: Encryptor
+
+        self._outPacketCount = 0
+        self._inPacketCount = 0
+
+        self._callbackQueue: asyncio.Queue[tuple[BleakGATTCharacteristic, bytes]]
+        self._callbackTask: Optional[asyncio.Task[None]] = None
+
         self._address_or_devive = address_or_device
         self.address = (
             address_or_device.address
             if isinstance(address_or_device, BLEDevice)
             else address_or_device
         )
         self._logger = logging.getLogger(__name__)
@@ -103,14 +109,16 @@
         )
 
         if not device:
             self._logger.error("Failed to discover client.")
             raise NetworkNotFoundError
 
         try:
+            # If we are already connected to the device the key exchange will fail.
+            await close_stale_connections(device)
             # TODO: Should we try to get access to the network name here?
             self._gattClient = await establish_connection(
                 BleakClient, device, "Casambi Network", self._on_disconnect
             )
         except BleakNotFoundError as e:
             # Guess that this is the error reason since ther are no better error types
             self._logger.error("Failed to find client.", exc_info=True)
@@ -152,16 +160,15 @@
                 ">BHH16s", firstResp, 2
             )
             self._logger.debug(
                 f"Parsed mtu {self._mtu}, unit {self._unit}, flags {self._flags}, nonce {b2a(self._nonce)}"
             )
 
             # Device will initiate key exchange, so listen for that
-            self._notifySignal = asyncio.Event()
-            self._logger.debug(f"Starting notify")
+            self._logger.debug("Starting notify")
             await self._gattClient.start_notify(
                 CASA_AUTH_CHAR_UUID, self._queueCallback
             )
         finally:
             self._activityLock.release()
 
         # Wait for key exchange, will get notified by _exchNotifyCallback
@@ -278,15 +285,15 @@
             self._logger.error(f"Unexcpedted package type in {b2a(data)}.")
             self._connectionState = ConnectionState.ERROR
             self._notifySignal.set()
 
     async def authenticate(self, keystore: KeyStore) -> None:
         self._checkState(ConnectionState.KEY_EXCHANGED)
 
-        self._logger.info(f"Authenicating channel...")
+        self._logger.info("Authenicating channel...")
         key = keystore.getKey()  # Session key
 
         if not key:
             self._logger.info("No key in keystore. Skipping auth.")
             # The channel already has to be set to authenticated by exchangeKey.
             # This needs to be done there a non-handshake packet could be sent right after acking the key exch
             # and we don't want that packet to end up in _authNofityCallback.
@@ -328,17 +335,15 @@
     def _authNofityCallback(self, handle: BleakGATTCharacteristic, data: bytes) -> None:
         self._logger.info("Processing authentication response...")
 
         # TODO: Verify counter
         self._inPacketCount += 1
 
         try:
-            response = self._encryptor.decryptAndVerify(
-                data, data[:4] + self._nonce[4:]
-            )
+            self._encryptor.decryptAndVerify(data, data[:4] + self._nonce[4:])
         except InvalidSignature:
             self._logger.fatal("Invalid signature for auth response!")
             self._connectionState = ConnectionState.ERROR
             return
 
         # TODO: Verify Digest 2 (to compare with response from device); SHA256(key.key||self pubKey point||self._transportKey)
 
@@ -403,15 +408,15 @@
         elif packetType == IncommingPacketType.NetworkConfig:
             # We don't care about the config the network thinks it has.
             # We assume that cloud config and local config match.
             # If there is a mismatch the user can solve it using the app.
             # In the future we might want to parse the revision and issue a warning if there is a mismatch.
             pass
         else:
-            self._logger.warning(f"Packet type {packetType} not implemented. Ignoring!")
+            self._logger.info(f"Packet type {packetType} not implemented. Ignoring!")
 
     def _parseUnitStates(self, data: bytes) -> None:
         self._logger.info("Parsing incoming unit states...")
         self._logger.debug(f"Incoming unit state: {b2a(data)}")
 
         pos = 0
         oldPos = 0
@@ -450,18 +455,18 @@
                 oldPos = pos
         except IndexError:
             self._logger.error(
                 f"Ran out of data while parsing unit state! Remaining data {b2a(data[oldPos:])} in {b2a(data)}."
             )
 
     async def disconnect(self) -> None:
-        self._logger.info(f"Disconnecting...")
+        self._logger.info("Disconnecting...")
 
         if self._callbackTask:
             self._callbackTask.cancel()
             self._callbackTask = None
 
         if self._gattClient.is_connected:
             await self._gattClient.disconnect()
 
         self._connectionState = ConnectionState.NONE
-        self._logger.info(f"Disconnected.")
+        self._logger.info("Disconnected.")
```

## CasambiBt/_constants.py

```diff
@@ -1,10 +1,6 @@
-import os
-from pathlib import Path
 from typing import Final
 
-BASE_PATH: Final = Path(os.getcwd()) / "casambi-bt-store"
-
 DEVICE_NAME: Final = "Casambi BT Python"
 
 CASA_UUID: Final = "0000fe4d-0000-1000-8000-00805f9b34fb"
 CASA_AUTH_CHAR_UUID: Final = "c9ffde48-ca5a-0001-ab83-8f519b482f77"
```

## CasambiBt/_encryption.py

```diff
@@ -1,10 +1,8 @@
-import binascii
 import logging
-import sys
 from binascii import b2a_hex as b2a
 
 from cryptography.hazmat.primitives.ciphers import Cipher
 from cryptography.hazmat.primitives.ciphers.algorithms import AES
 from cryptography.hazmat.primitives.ciphers.modes import CBC, ECB
 from cryptography.hazmat.primitives.cmac import CMAC
```

## CasambiBt/_keystore.py

```diff
@@ -1,46 +1,43 @@
 import binascii
 import logging
 import pickle
 from dataclasses import dataclass
 from pathlib import Path
-from typing import Dict, List, Optional
-
-from ._constants import BASE_PATH
+from typing import Optional
 
 
 @dataclass()
 class Key:
     id: int
     type: int
     role: int
     name: str
     key: bytes
 
 
 class KeyStore:
-    _keys: List[Key] = []
-    _logger = logging.getLogger(__name__)
+    def __init__(self, cacheDir: Path) -> None:
+        self._keys: list[Key] = []
+        self._logger = logging.getLogger(__name__)
 
-    def __init__(self, networkId: str) -> None:
-        self._networkId = networkId
-        self._storePath = Path(BASE_PATH / networkId / "keys.pck")
+        self._storePath = cacheDir / "keys.pck"
         if self._storePath.exists():
             self._load()
 
     def _load(self) -> None:
         self._logger.info("Loading keys...")
         self._keys = pickle.load(self._storePath.open("rb"))
         self._logger.info(f"Loaded {len(self._keys)} keys.")
 
     def _save(self) -> None:
         self._logger.info("Saving keys...")
         pickle.dump(self._keys, (self._storePath.open("wb")))
 
-    def addKey(self, dict: Dict) -> None:
+    def addKey(self, dict: dict) -> None:
         if "id" not in dict:
             raise KeyError("id")
         id = int(dict["id"])
         if id < 0:
             raise ValueError("id")
 
         if any(filter(lambda k: k.id == id, self._keys)):  # type: ignore
@@ -63,25 +60,25 @@
             raise KeyError("name")
         name = dict["name"]
 
         if "key" not in dict:
             raise KeyError("key")
         try:
             key = binascii.a2b_hex(dict["key"])
-        except:
+        except binascii.Error:
             raise ValueError("key")
 
         keyObj = Key(id, type, role, name, key)
         self._keys.append(keyObj)
         self._logger.info(f"Added key {name} with role {role} to store.")
         self._save()
 
     def clear(self, save: bool = False) -> None:
         self._keys.clear()
-        self._logger.info(f"Keystore cleared.")
+        self._logger.info("Keystore cleared.")
         if save:
             self._save()
 
     def getKey(self) -> Optional[Key]:
         key: Optional[Key] = None
         for k in self._keys:
             if not key:
```

## CasambiBt/_network.py

```diff
@@ -1,23 +1,27 @@
+import json
 import logging
 import pickle
 from dataclasses import dataclass
 from datetime import datetime
-from pathlib import Path
-from re import sub
 from typing import Optional, cast
 
 import httpx
-from httpx import AsyncClient
+from httpx import AsyncClient, NetworkError
 
-from ._constants import BASE_PATH, DEVICE_NAME
+from ._cache import getCacheDir
+from ._constants import DEVICE_NAME
 from ._keystore import KeyStore
 from ._unit import Group, Scene, Unit, UnitControl, UnitControlType, UnitType
-from .errors import AuthenticationError, NetworkNotFoundError, NetworkUpdateError
-from ._cache import ensureCacheValid
+from .errors import (
+    AuthenticationError,
+    NetworkNotFoundError,
+    NetworkOnlineUpdateNeededError,
+    NetworkUpdateError,
+)
 
 
 @dataclass()
 class _NetworkSession:
     session: str
     network: str
     manager: bool
@@ -27,42 +31,40 @@
     role: int = 3  # TODO: Support other role types?
 
     def expired(self) -> bool:
         return datetime.utcnow() > self.expires
 
 
 class Network:
-    _session: Optional[_NetworkSession] = None
+    def __init__(self, uuid: str, httpClient: AsyncClient) -> None:
+        self._session: Optional[_NetworkSession] = None
 
-    _networkName: Optional[str] = None
-    _networkRevision: Optional[int] = None
+        self._networkName: Optional[str] = None
+        self._networkRevision: Optional[int] = None
 
-    _unitTypes: dict[int, UnitType] = {}
-    units: list[Unit] = []
-    groups: list[Group] = []
-    scenes: list[Scene] = []
+        self._unitTypes: dict[int, UnitType] = {}
+        self.units: list[Unit] = []
+        self.groups: list[Group] = []
+        self.scenes: list[Scene] = []
 
-    def __init__(self, id: str, httpClient: AsyncClient) -> None:
         self._logger = logging.getLogger(__name__)
-        self._keystore = KeyStore(id)
-        self._id = id
-        basePath = Path(BASE_PATH / id)
-
-        if not basePath.exists():
-            basePath.mkdir(parents=True)
+        # TODO: Create LoggingAdapter to prepend uuid.
 
+        self._id: Optional[str] = None
+        self._uuid = uuid
         self._httpClient = httpClient
 
-        ensureCacheValid()
+        self._cachePath = getCacheDir(uuid)
+        self._keystore = KeyStore(self._cachePath)
 
-        self._sessionPath = basePath / "session.pck"
+        self._sessionPath = self._cachePath / "session.pck"
         if self._sessionPath.exists():
             self._loadSession()
 
-        self._typeCachePath = basePath / "types.pck"
+        self._typeCachePath = self._cachePath / "types.pck"
         if self._typeCachePath.exists():
             self._loadTypeCache()
 
     def _loadSession(self) -> None:
         self._logger.info("Loading session...")
         self._session = pickle.load(self._sessionPath.open("rb"))
 
@@ -74,80 +76,154 @@
         self._logger.info("Loading unit type cache...")
         self._unitTypes = pickle.load(self._typeCachePath.open("rb"))
 
     def _saveTypeCache(self) -> None:
         self._logger.info("Saving type cache...")
         pickle.dump(self._unitTypes, self._typeCachePath.open("wb"))
 
+    async def getNetworkId(self, forceOffline: bool = False) -> None:
+        self._logger.info("Getting network id...")
+
+        networkCacheFile = self._cachePath / "networkid"
+
+        if networkCacheFile.exists():
+            self._id = networkCacheFile.read_text()
+
+        if forceOffline:
+            if not self._id:
+                raise NetworkOnlineUpdateNeededError("Network isn't cached.")
+            else:
+                return
+
+        getNetworkIdUrl = f"https://api.casambi.com/network/uuid/{self._uuid}"
+        try:
+            res = await self._httpClient.get(getNetworkIdUrl)
+        except NetworkError as err:
+            if not self._id:
+                raise NetworkOnlineUpdateNeededError from err
+            else:
+                self._logger.warning(
+                    "Network error while fetching network id. Continuing with cache.",
+                    exc_info=True,
+                )
+                return
+
+        if res.status_code == httpx.codes.NOT_FOUND:
+            raise NetworkNotFoundError(
+                "API failed to find network. Is your network configured correctly?"
+            )
+        if res.status_code != httpx.codes.OK:
+            raise NetworkNotFoundError(
+                f"Getting network id returned unexpected status {res.status_code}"
+            )
+
+        new_id = cast(str, res.json()["id"])
+        if self._id != new_id:
+            self._logger.info(f"Network id changed from {self._id} to {new_id}.")
+            networkCacheFile.write_text(new_id)
+            self._id = new_id
+        self._logger.info(f"Got network id {self._id}.")
+
     def authenticated(self) -> bool:
         if not self._session:
             return False
         return not self._session.expired()
 
     def getKeyStore(self) -> KeyStore:
         return self._keystore
 
-    async def logIn(self, password: str) -> bool:
-        self._logger.info(f"Logging in to network...")
+    async def logIn(self, password: str, forceOffline: bool = False) -> None:
+        await self.getNetworkId(forceOffline)
+
+        # No need to be authenticated if we try to be offline anyway.
+        if self.authenticated() or forceOffline:
+            return
+
+        self._logger.info("Logging in to network...")
         getSessionUrl = f"https://api.casambi.com/network/{self._id}/session"
 
         res = await self._httpClient.post(
             getSessionUrl, json={"password": password, "deviceName": DEVICE_NAME}
         )
         if res.status_code == httpx.codes.OK:
             # Parse session
             sessionJson = res.json()
             sessionJson["expires"] = datetime.utcfromtimestamp(
                 sessionJson["expires"] / 1000
             )
             self._session = _NetworkSession(**sessionJson)
             self._logger.info("Login sucessful.")
             self._saveSesion()
-            return True
         else:
-            self._logger.error(f"Login failed: {res.status_code}\n{res.text}")
-            return False
+            raise AuthenticationError(f"Login failed: {res.status_code}\n{res.text}")
 
-    async def update(self) -> None:
-        self._logger.info(f"Updating network...")
-        if not self.authenticated():
+    async def update(self, forceOffline: bool = False) -> None:
+        self._logger.info("Updating network...")
+        if not self.authenticated() and not forceOffline:
             raise AuthenticationError("Not authenticated!")
 
-        # TODO: Save and send revision to receive actual updates?
+        assert self._id is not None, "Network id must be set."
 
-        getNetworkUrl = f"https://api.casambi.com/network/{self._id}/"
-
-        # **SECURITY**: Do not set session header for client! This could leak the session with external clients.
-        res = await self._httpClient.put(
-            getNetworkUrl,
-            json={"formatVersion": 1, "deviceName": DEVICE_NAME},
-            headers={"X-Casambi-Session": self._session.session},  # type: ignore[union-attr]
-        )
-
-        if res.status_code != httpx.codes.OK:
-            self._logger.error(f"Update failed: {res.status_code}\n{res.text}")
-            raise NetworkUpdateError("Could not update network!")
+        # TODO: Save and send revision to receive actual updates?
 
-        self._logger.debug(f"Network: {res.text}")
+        cachedNetworkPah = self._cachePath / f"{self._id}.json"
+        if cachedNetworkPah.exists():
+            network = json.loads(cachedNetworkPah.read_bytes())
+            self._networkRevision = network["network"]["revision"]
+            self._logger.info(
+                f"Loaded cached network. Revision: {self._networkRevision}"
+            )
+        else:
+            if forceOffline:
+                raise NetworkOnlineUpdateNeededError("Network isn't cached.")
+            self._networkRevision = 0
+
+        if not forceOffline:
+            getNetworkUrl = f"https://api.casambi.com/network/{self._id}/"
+
+            # **SECURITY**: Do not set session header for client! This could leak the session with external clients.
+            res = await self._httpClient.put(
+                getNetworkUrl,
+                json={
+                    "formatVersion": 1,
+                    "deviceName": DEVICE_NAME,
+                    "revision": self._networkRevision,
+                },
+                headers={"X-Casambi-Session": self._session.session},  # type: ignore[union-attr]
+            )
 
-        resJson = res.json()
+            if res.status_code != httpx.codes.OK:
+                self._logger.error(f"Update failed: {res.status_code}\n{res.text}")
+                raise NetworkUpdateError("Could not update network!")
+
+            self._logger.debug(f"Network: {res.text}")
+
+            updateResult = res.json()
+            if updateResult["status"] != "UPTODATE":
+                self._networkRevision = updateResult["network"]["revision"]
+                cachedNetworkPah.write_bytes(res.content)
+                network = updateResult
+                self._logger.info(
+                    f"Fetched updated network with revision {self._networkRevision}"
+                )
 
         # Prase general information
-        self._networkName = resJson["network"]["name"]
-        self._networkRevision = resJson["network"]["revision"]
+        self._networkName = network["network"]["name"]
 
-        # Parse keys if there are any. Otherwise the network is probably set up for keyless auth.
-        if "keyStore" in resJson["network"]:
-            keys = resJson["network"]["keyStore"]["keys"]
+        # Parse keys if there are any. Otherwise the network is probably a classic network.
+        if "keyStore" in network["network"]:
+            keys = network["network"]["keyStore"]["keys"]
             for k in keys:
                 self._keystore.addKey(k)
 
+        # TODO: Parse managerKey and visitorKey for classic networks.
+
         # Parse units
         self.units = []
-        units = resJson["network"]["units"]
+        units = network["network"]["units"]
         for u in units:
             uType = await self._fetchUnitInfo(u["type"])
             uObj = Unit(
                 u["type"],
                 u["deviceID"],
                 u["uuid"],
                 u["address"],
@@ -155,15 +231,15 @@
                 str(u["firmware"]),
                 uType,
             )
             self.units.append(uObj)
 
         # Parse cells
         self.groups = []
-        cells = resJson["network"]["grid"]["cells"]
+        cells = network["network"]["grid"]["cells"]
         for c in cells:
             # Only one type at top level is currently supported
             if c["type"] != 2:
                 continue
 
             # Parse group members
             group_units = []
@@ -184,15 +260,15 @@
                 group_units.append(unitMatch[0])
 
             gObj = Group(c["groupID"], c["name"], group_units)
             self.groups.append(gObj)
 
         # Parse scenes
         self.scenes = []
-        scenes = resJson["network"]["scenes"]
+        scenes = network["network"]["scenes"]
         for s in scenes:
             sObj = Scene(s["sceneID"], s["name"])
             self.scenes.append(sObj)
 
         # TODO: Parse more stuff
 
         self._saveTypeCache()
@@ -255,26 +331,7 @@
         self._unitTypes[unitTypeObj.id] = unitTypeObj
 
         self._logger.info("Sucessfully fetched unit type.")
         return unitTypeObj
 
     async def disconnect(self) -> None:
         return None
-
-
-async def getNetworkIdFromUuid(mac: str, httpClient: AsyncClient) -> Optional[str]:
-    _logger = logging.getLogger(__name__)
-    _logger.info(f"Getting network id...")
-    getNetworkIdUrl = f"https://api.casambi.com/network/uuid/{mac.replace(':', '')}"
-    res = await httpClient.get(getNetworkIdUrl)
-
-    if res.status_code == httpx.codes.NOT_FOUND:
-        raise NetworkNotFoundError(
-            "API failed to find network. Is your network configured correctly?"
-        )
-    if res.status_code != httpx.codes.OK:
-        _logger.error(f"Getting network id returned {res.status_code}")
-        return None
-
-    id = cast(str, res.json()["id"])
-    _logger.info(f"Got network id {id}.")
-    return id
```

## CasambiBt/_operation.py

```diff
@@ -10,16 +10,17 @@
     SetWhite = 5
     SetColor = 7
     SetTemperature = 10
     SetState = 48
 
 
 class OperationsContext:
-    origin: int = 1
-    lifetime: int = 5
+    def __init__(self) -> None:
+        self.origin: int = 1
+        self.lifetime: int = 5
 
     def prepareOperation(self, op: OpCode, target: int, payload: bytes) -> bytes:
         if len(payload) > 63:
             raise ValueError("Payload too long")
 
         flags = (self.lifetime & 15) << 11 | len(payload)
```

## CasambiBt/_unit.py

```diff
@@ -1,16 +1,17 @@
 import logging
 from binascii import b2a_hex as b2a
 from colorsys import hsv_to_rgb, rgb_to_hsv
 from dataclasses import dataclass
 from enum import Enum, unique
-from typing import Final, List, Optional, Tuple
+from typing import Final, Optional
 
 _LOGGER = logging.getLogger(__name__)
 
+
 # Numbers are totally arbitrary so far.
 @unique
 class UnitControlType(Enum):
     """All implemented control types."""
 
     DIMMER = 0
     """The brightness of the light can be adjusted."""
@@ -56,15 +57,15 @@
     """
 
     id: int
     model: str
     manufacturer: str
     mode: str
     stateLength: int
-    controls: List[UnitControl]
+    controls: list[UnitControl]
 
     def get_control(self, controlType: UnitControlType) -> Optional[UnitControl]:
         """Return the control description if the unit type supports the given type of control.
 
         :param controlType: The desired control type.
         :return: A control description for the given control type if available, otherwise `None`
         """
@@ -76,19 +77,20 @@
 
 
 # TODO: Support for different resolutions?
 # TODO: Work with HS instead of RGB internally
 class UnitState:
     """Parsed representation of the state of a unit."""
 
-    _dimmer: Optional[int] = None
-    _rgb: Optional[Tuple[int, int, int]] = None
-    _white: Optional[int] = None
-    _temperature: Optional[int] = None
-    _vertical: Optional[int] = None
+    def __init__(self) -> None:
+        self._dimmer: Optional[int] = None
+        self._rgb: Optional[tuple[int, int, int]] = None
+        self._white: Optional[int] = None
+        self._temperature: Optional[int] = None
+        self._vertical: Optional[int] = None
 
     def _check_range(self, value: int, min: int, max: int) -> None:
         if value < min or value > max:
             raise ValueError(f"{value} is not between {min} and {max}")
 
     DIMMER_RESOLUTION: Final = 8
     DIMMER_MIN: Final = 0
@@ -105,15 +107,15 @@
 
     @dimmer.deleter
     def dimmer(self) -> None:
         self._dimmer = None
 
     VERTICAL_RESOLUTION: Final = 8
     VERTICAL_MIN: Final = 0
-    VERTICAL_MAX: Final = 2**VERTICAL_RESOLUTION- 1
+    VERTICAL_MAX: Final = 2**VERTICAL_RESOLUTION - 1
 
     @property
     def vertical(self) -> Optional[int]:
         return self._vertical
 
     @vertical.setter
     def vertical(self, value: int) -> None:
@@ -125,48 +127,48 @@
         self._vertical = None
 
     RGB_RESOLUTION: Final = 8
     RGB_MIN: Final = 0
     RGB_MAX: Final = 2**RGB_RESOLUTION - 1
 
     @property
-    def rgb(self) -> Optional[Tuple[int, int, int]]:
+    def rgb(self) -> Optional[tuple[int, int, int]]:
         return self._rgb
 
     @rgb.setter
-    def rgb(self, value: Tuple[int, int, int]) -> None:
+    def rgb(self, value: tuple[int, int, int]) -> None:
         r, g, b = value
         self._check_range(r, self.RGB_MIN, self.RGB_MAX)
         self._check_range(g, self.RGB_MIN, self.RGB_MAX)
         self._check_range(b, self.RGB_MIN, self.RGB_MAX)
 
         self._rgb = (r, g, b)
 
     @rgb.deleter
     def rgb(self) -> None:
         self._rgb = None
 
     @property
-    def hs(self) -> Optional[Tuple[float, float]]:
-        """Convert RGB into HS where H is a float in [0..1[ and S a float in [0..1]"""
+    def hs(self) -> Optional[tuple[float, float]]:
+        """Convert RGB into HS where H is a float in [0..1[ and S a float in [0..1]."""
         if self._rgb is None:
             return None
 
         rgb_float = [c / (2**self.RGB_RESOLUTION - 1) for c in self._rgb]
         h, s, _ = rgb_to_hsv(*rgb_float)
 
         h %= 1
         if h == 0 and s == 0:
             h = 0.5
 
         return (h, s)
 
     @hs.setter
-    def hs(self, value: Tuple[float, float]) -> None:
-        """Convert HS color to interal RBG representation where H is a float in [0..1[ and S a float in [0..1]"""
+    def hs(self, value: tuple[float, float]) -> None:
+        """Convert HS color to interal RBG representation where H is a float in [0..1[ and S a float in [0..1]."""
         h, s = value
 
         rgb = hsv_to_rgb(h, s, 1)
         self.rgb = tuple([round(c * (2**self.RGB_RESOLUTION - 1)) for c in rgb])  # type: ignore[assignment]
 
     WHITE_RESOLUTION = 8
     WHITE_MIN = 0
@@ -232,20 +234,18 @@
     def state(self) -> Optional[UnitState]:
         """Get the state of the unit if it has been set."""
         return self._state
 
     @property
     def is_on(self) -> bool:
         """Determine whether the unit is turned on."""
-        if (
-            self.unitType.get_control(UnitControlType.DIMMER)
-            and self._state
-            and self._state.dimmer
-        ):
-            return self._on and self._state.dimmer > 0
+        if self.unitType.get_control(UnitControlType.DIMMER) and self._state:
+            return (
+                self._on and self._state.dimmer is not None and self._state.dimmer > 0
+            )
         else:
             return self._on
 
     @property
     def online(self) -> bool:
         return self._online
 
@@ -253,15 +253,15 @@
     def getStateAsBytes(self, state: UnitState) -> bytes:
         """Given a generic UnitState convert it into the internal state representation.
 
         Unsupported state information will be ignored.
         """
 
         # offset, lenth, value
-        values: List[Tuple[int, int, int]] = []
+        values: list[tuple[int, int, int]] = []
 
         # TODO: Support for resolutions >8 byte?
         # Parse and convert state
         for c in self.unitType.controls:
             if c.type == UnitControlType.DIMMER and state.dimmer is not None:
                 scale = UnitState.DIMMER_RESOLUTION - c.length
                 scaledValue = state.dimmer >> scale
@@ -374,23 +374,25 @@
                 self._state.rgb = tuple(rgb)
                 """
             elif c.type == UnitControlType.WHITE:
                 scale = UnitState.WHITE_RESOLUTION - c.length
                 self._state.white = cInt << scale
             elif c.type == UnitControlType.TEMPERATURE:
                 if not c.max or not c.min:
-                    _LOGGER.warning(f"Can't set temperature when min or max unknown.")
+                    _LOGGER.warning("Can't set temperature when min or max unknown.")
                     continue
                 tempRange = c.max - c.min
                 tempMask = 2**c.length - 1
                 # TODO: We should probalby try to make this number a bit more round
                 self._state.temperature = int(((cInt / tempMask) * tempRange) + c.min)
             elif c.type == UnitControlType.UNKOWN:
                 # Might be useful for implementing more state types
-                _LOGGER.debug(f"Value for unkown control type at {c.offset}: {cInt}")
+                _LOGGER.debug(
+                    f"Value for unkown control type at {c.offset}: {cInt}. Unit type is {self.unitType.id}."
+                )
 
         _LOGGER.debug(f"Parsed {b2a(value)} to {self.state.__repr__()}")
 
 
 @dataclass
 class Scene:
     """A scene in a network.
@@ -411,8 +413,8 @@
     :ivar name: The name of the group.
     :ivar units: A list of units in this group.
     """
 
     groudId: int
     name: str
 
-    units: List[Unit]
+    units: list[Unit]
```

## CasambiBt/errors.py

```diff
@@ -1,44 +1,67 @@
+"""Error types for CasambiBt."""
+
 from typing import Optional
 
 from ._client import ConnectionState
 
 
 class CasambiBtError(RuntimeError):
+    """Base class for all CasambiBt errors."""
+
     pass
 
 
 class NetworkNotFoundError(CasambiBtError):
+    """Exception that is raised when the network can't be found."""
+
     pass
 
 
 class NetworkUpdateError(CasambiBtError):
+    """Exception that is raised when the network can't be updated."""
+
+    pass
+
+
+class NetworkOnlineUpdateNeededError(NetworkUpdateError):
+    """Exception that is raised when an online update is needed for the network."""
+
+    pass
+
+
+class AuthenticationError(CasambiBtError):
+    """Excpetion that is raised when authentication to the network fails."""
+
     pass
 
 
 class ConnectionStateError(CasambiBtError):
+    """Exception that is raised when the connection isn't in the required state."""
+
     def __init__(
         self,
         expected: ConnectionState,
         got: ConnectionState,
         expl: Optional[str] = None,
     ) -> None:
+        """Create a new `ConnectionStateError`."""
         self.expected = expected
         self.got = got
 
         msg = f"Expected state {expected.name}. Current state {got.name}."
         if expl:
             msg += " " + expl
 
         super().__init__(msg)
 
 
 class BluetoothError(CasambiBtError):
+    """Exception that is raised when a bluetooth-related error happens."""
+
     pass
 
 
 class ProtocolError(CasambiBtError):
-    pass
+    """Exception that is raised when communication with the device doesn't follow the expected protocol."""
 
-
-class AuthenticationError(CasambiBtError):
     pass
```

## Comparing `casambi_bt-0.0.9b2.dist-info/LICENSE` & `casambi_bt-0.1.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `casambi_bt-0.0.9b2.dist-info/METADATA` & `casambi_bt-0.1.0.dist-info/METADATA`

 * *Files 2% similar despite different names*

```diff
@@ -1,18 +1,18 @@
 Metadata-Version: 2.1
 Name: casambi-bt
-Version: 0.0.9b2
+Version: 0.1.0
 Summary: A minimal, unofficial implementation of a bluetooth client for casambi devices
 Home-page: https://github.com/lkempf/casambi-bt
 Author: lkempf
 Author-email: pypi@lukas-kempf.de
 Classifier: Programming Language :: Python :: 3.9
 Classifier: License :: OSI Approved :: Apache Software License
 Classifier: Operating System :: OS Independent
-Classifier: Development Status :: 3 - Alpha
+Classifier: Development Status :: 4 - Beta
 Requires-Python: >=3.9
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Requires-Dist: bleak (>=0.19)
 Requires-Dist: cryptography (>=3)
 Requires-Dist: httpx (>=0.17)
 Requires-Dist: bleak-retry-connector (>=2.8.5)
```

