--- tmp/copier-7.1.0.tar.gz
+++ tmp/copier-7.1.0a0.tar.gz
â”œâ”€â”€ filetype from file(1)
â”‚ @@ -1 +1 @@
â”‚ -gzip compressed data, was "copier-7.1.0.tar", max compression
â”‚ +gzip compressed data, was "copier-7.1.0a0.tar", max compression
â”‚   --- copier-7.1.0.tar
â”œâ”€â”€ +++ copier-7.1.0a0.tar
â”‚ â”œâ”€â”€ file list
â”‚ â”‚ @@ -1,15 +1,16 @@
â”‚ â”‚ --rw-r--r--   0        0        0     1076 2023-04-07 16:59:22.654278 copier-7.1.0/LICENSE
â”‚ â”‚ --rw-r--r--   0        0        0     6143 2023-04-07 16:59:22.654278 copier-7.1.0/README.md
â”‚ â”‚ --rw-r--r--   0        0        0      263 2023-04-07 16:59:43.911203 copier-7.1.0/copier/__init__.py
â”‚ â”‚ --rw-r--r--   0        0        0      198 2023-04-07 16:59:22.654278 copier-7.1.0/copier/__main__.py
â”‚ â”‚ --rw-r--r--   0        0        0    11236 2023-04-07 16:59:22.654278 copier-7.1.0/copier/cli.py
â”‚ â”‚ --rw-r--r--   0        0        0     3413 2023-04-07 16:59:22.654278 copier-7.1.0/copier/errors.py
â”‚ â”‚ --rw-r--r--   0        0        0    36147 2023-04-07 16:59:22.654278 copier-7.1.0/copier/main.py
â”‚ â”‚ --rw-r--r--   0        0        0     2476 2023-04-07 16:59:22.654278 copier-7.1.0/copier/subproject.py
â”‚ â”‚ --rw-r--r--   0        0        0    16594 2023-04-07 16:59:22.654278 copier-7.1.0/copier/template.py
â”‚ â”‚ --rw-r--r--   0        0        0     6234 2023-04-07 16:59:22.654278 copier-7.1.0/copier/tools.py
â”‚ â”‚ --rw-r--r--   0        0        0     2243 2023-04-07 16:59:22.654278 copier-7.1.0/copier/types.py
â”‚ â”‚ --rw-r--r--   0        0        0    15733 2023-04-07 16:59:22.654278 copier-7.1.0/copier/user_data.py
â”‚ â”‚ --rw-r--r--   0        0        0     6731 2023-04-07 16:59:22.654278 copier-7.1.0/copier/vcs.py
â”‚ â”‚ --rw-r--r--   0        0        0     3459 2023-04-07 16:59:43.907203 copier-7.1.0/pyproject.toml
â”‚ â”‚ --rw-r--r--   0        0        0     7983 1970-01-01 00:00:00.000000 copier-7.1.0/PKG-INFO
â”‚ â”‚ +-rw-r--r--   0        0        0     1076 2022-12-29 11:22:56.467372 copier-7.1.0a0/LICENSE
â”‚ â”‚ +-rw-r--r--   0        0        0     5675 2022-12-29 11:22:56.467372 copier-7.1.0a0/README.md
â”‚ â”‚ +-rw-r--r--   0        0        0      265 2022-12-29 11:23:14.811279 copier-7.1.0a0/copier/__init__.py
â”‚ â”‚ +-rw-r--r--   0        0        0       81 2022-12-29 11:22:56.467372 copier-7.1.0a0/copier/__main__.py
â”‚ â”‚ +-rw-r--r--   0        0        0    11237 2022-12-29 11:22:56.467372 copier-7.1.0a0/copier/cli.py
â”‚ â”‚ +-rw-r--r--   0        0        0     3302 2022-12-29 11:22:56.467372 copier-7.1.0a0/copier/errors.py
â”‚ â”‚ +-rw-r--r--   0        0        0    35683 2022-12-29 11:22:56.467372 copier-7.1.0a0/copier/main.py
â”‚ â”‚ +-rw-r--r--   0        0        0     2477 2022-12-29 11:22:56.467372 copier-7.1.0a0/copier/subproject.py
â”‚ â”‚ +-rw-r--r--   0        0        0    16175 2022-12-29 11:22:56.467372 copier-7.1.0a0/copier/template.py
â”‚ â”‚ +-rw-r--r--   0        0        0     5483 2022-12-29 11:22:56.467372 copier-7.1.0a0/copier/tools.py
â”‚ â”‚ +-rw-r--r--   0        0        0     1868 2022-12-29 11:22:56.467372 copier-7.1.0a0/copier/types.py
â”‚ â”‚ +-rw-r--r--   0        0        0    15445 2022-12-29 11:22:56.467372 copier-7.1.0a0/copier/user_data.py
â”‚ â”‚ +-rw-r--r--   0        0        0     5577 2022-12-29 11:22:56.467372 copier-7.1.0a0/copier/vcs.py
â”‚ â”‚ +-rw-r--r--   0        0        0     3460 2022-12-29 11:23:14.807279 copier-7.1.0a0/pyproject.toml
â”‚ â”‚ +-rw-r--r--   0        0        0     7084 1970-01-01 00:00:00.000000 copier-7.1.0a0/setup.py
â”‚ â”‚ +-rw-r--r--   0        0        0     7466 1970-01-01 00:00:00.000000 copier-7.1.0a0/PKG-INFO
â”‚ â”‚   --- copier-7.1.0/LICENSE
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/LICENSE
â”‚ â”‚â”„ Files identical despite different names
â”‚ â”‚   --- copier-7.1.0/README.md
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/README.md
â”‚ â”‚â”„ Files 8% similar despite different names
â”‚ â”‚ @@ -21,27 +21,26 @@
â”‚ â”‚  
â”‚ â”‚  ## Installation
â”‚ â”‚  
â”‚ â”‚  1. Install Python 3.7 or newer (3.8 or newer if you're on Windows).
â”‚ â”‚  1. Install Git 2.27 or newer.
â”‚ â”‚  1. To use as a CLI app: `pipx install copier`
â”‚ â”‚  1. To use as a library: `pip install copier` or `conda install -c conda-forge copier`
â”‚ â”‚ -1. To use with 100% reproducibility: `nix profile install github:copier-org/copier`
â”‚ â”‚  
â”‚ â”‚  ## Quick start
â”‚ â”‚  
â”‚ â”‚  To create a template:
â”‚ â”‚  
â”‚ â”‚  ```shell
â”‚ â”‚ -ðŸ“ my_copier_template                        # your template project
â”‚ â”‚ -â”œâ”€â”€ ðŸ“„ copier.yml                            # your template configuration
â”‚ â”‚ -â”œâ”€â”€ ðŸ“ .git/                                 # your template is a Git repository
â”‚ â”‚ -â”œâ”€â”€ ðŸ“ {{project_name}}                      # a folder with a templated name
â”‚ â”‚ -â”‚   â””â”€â”€ ðŸ“„ {{module_name}}.py.jinja          # a file with a templated name
â”‚ â”‚ -â””â”€â”€ ðŸ“„ {{_copier_conf.answers_file}}.jinja   # answers are recorded here
â”‚ â”‚ +ðŸ“ my_copier_template ------------------------ # your template project
â”‚ â”‚ +â”œâ”€â”€ ðŸ“„ copier.yml ---------------------------- # your template configuration
â”‚ â”‚ +â”œâ”€â”€ ðŸ“ .git ---------------------------------- # your template is a Git repository
â”‚ â”‚ +â”œâ”€â”€ ðŸ“ {{project_name}} ---------------------- # a folder with a templated name
â”‚ â”‚ +â”‚   â””â”€â”€ ðŸ“„ {{module_name}}.py.jinja ---------- # a file with a templated name
â”‚ â”‚ +â””â”€â”€ ðŸ“„ {{_copier_conf.answers_file}}.jinja --- # answers are recorded here
â”‚ â”‚  ```
â”‚ â”‚  
â”‚ â”‚  ```yaml title="copier.yml"
â”‚ â”‚  # questions
â”‚ â”‚  project_name:
â”‚ â”‚      type: str
â”‚ â”‚      help: What is your project name?
â”‚ â”‚ @@ -135,20 +134,12 @@
â”‚ â”‚  
â”‚ â”‚  Special thanks go to [jpsca](https://github.com/jpsca) for originally creating `Copier`.
â”‚ â”‚  This project would not be a thing without him.
â”‚ â”‚  
â”‚ â”‚  Many thanks to [pykong](https://github.com/pykong) who took over maintainership on the
â”‚ â”‚  project, promoted it, and laid out the bases of what the project is today.
â”‚ â”‚  
â”‚ â”‚ -Big thanks also go to [yajo](https://github.com/yajo) for his relentless zest for
â”‚ â”‚ +Big thanks also go to [Yajo](https://github.com/Yajo) for his relentless zest for
â”‚ â”‚  improving `Copier` even further.
â”‚ â”‚  
â”‚ â”‚  Thanks a lot, [pawamoy](https://github.com/pawamoy) for polishing very important rough
â”‚ â”‚  edges and improving the documentation and UX a lot.
â”‚ â”‚ -
â”‚ â”‚ -Also special thanks to [sisp](https://github.com/sisp) for being very helpful in
â”‚ â”‚ -polishing documentation, fixing bugs, helping the community and cleaning up the
â”‚ â”‚ -codebase.
â”‚ â”‚ -
â”‚ â”‚ -And thanks to all financial supporters and folks that give us a shiny star! â­
â”‚ â”‚ -
â”‚ â”‚ -[![Star History Chart](https://api.star-history.com/svg?repos=copier-org/copier&type=Date)](https://star-history.com/#copier-org/copier&Date)
â”‚ â”‚   --- copier-7.1.0/copier/cli.py
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/copier/cli.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -1,7 +1,8 @@
â”‚ â”‚ +#!/usr/bin/env python
â”‚ â”‚  """
â”‚ â”‚  Command line entrypoint. This module declares the Copier CLI applications.
â”‚ â”‚  
â”‚ â”‚  Basically, there are 3 different commands you can run:
â”‚ â”‚  
â”‚ â”‚  -   [`copier`][copier.cli.CopierApp], the main app, which is a shortcut for the
â”‚ â”‚      `copy` and `update` subapps.
â”‚ â”‚ @@ -46,19 +47,21 @@
â”‚ â”‚  import sys
â”‚ â”‚  from functools import wraps
â”‚ â”‚  from io import StringIO
â”‚ â”‚  from pathlib import Path
â”‚ â”‚  from textwrap import dedent
â”‚ â”‚  from unittest.mock import patch
â”‚ â”‚  
â”‚ â”‚ +import yaml
â”‚ â”‚  from plumbum import cli, colors
â”‚ â”‚  
â”‚ â”‚ +from copier.tools import copier_version
â”‚ â”‚ +
â”‚ â”‚  from .errors import UserMessageError
â”‚ â”‚  from .main import Worker
â”‚ â”‚ -from .tools import copier_version
â”‚ â”‚  from .types import AnyByStrDict, OptStr, StrSeq
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def handle_exceptions(method):
â”‚ â”‚      """Handle keyboard interruption while running a method."""
â”‚ â”‚  
â”‚ â”‚      @wraps(method)
â”‚ â”‚ @@ -123,14 +126,23 @@
â”‚ â”‚          ["-a", "--answers-file"],
â”‚ â”‚          default=None,
â”‚ â”‚          help=(
â”‚ â”‚              "Update using this path (relative to `destination_path`) "
â”‚ â”‚              "to find the answers file"
â”‚ â”‚          ),
â”‚ â”‚      )
â”‚ â”‚ +    conflict: cli.SwitchAttr = cli.SwitchAttr(
â”‚ â”‚ +        ["-o", "--conflict"],
â”‚ â”‚ +        cli.Set("rej", "inline"),
â”‚ â”‚ +        default="rej",
â”‚ â”‚ +        help=(
â”‚ â”‚ +            "Behavior on conflict: rej=Create .rej file, inline=inline conflict "
â”‚ â”‚ +            "markers"
â”‚ â”‚ +        ),
â”‚ â”‚ +    )
â”‚ â”‚      exclude: cli.SwitchAttr = cli.SwitchAttr(
â”‚ â”‚          ["-x", "--exclude"],
â”‚ â”‚          str,
â”‚ â”‚          list=True,
â”‚ â”‚          help=(
â”‚ â”‚              "A name or shell-style pattern matching files or folders "
â”‚ â”‚              "that must not be copied"
â”‚ â”‚ @@ -185,14 +197,15 @@
â”‚ â”‚  
â”‚ â”‚          Arguments:
â”‚ â”‚              values: The list of values to apply.
â”‚ â”‚                  Each value in the list is of the following form: `NAME=VALUE`.
â”‚ â”‚          """
â”‚ â”‚          for arg in values:
â”‚ â”‚              key, value = arg.split("=", 1)
â”‚ â”‚ +            value = yaml.safe_load(value)
â”‚ â”‚              self.data[key] = value
â”‚ â”‚  
â”‚ â”‚      def _worker(self, src_path: OptStr = None, dst_path: str = ".", **kwargs) -> Worker:
â”‚ â”‚          """
â”‚ â”‚          Run Copier's internal API using CLI switches.
â”‚ â”‚  
â”‚ â”‚          Arguments:
â”‚ â”‚ @@ -204,19 +217,19 @@
â”‚ â”‚              data=self.data,
â”‚ â”‚              dst_path=Path(dst_path),
â”‚ â”‚              answers_file=self.answers_file,
â”‚ â”‚              exclude=self.exclude,
â”‚ â”‚              defaults=self.force or self.defaults,
â”‚ â”‚              overwrite=self.force or self.overwrite,
â”‚ â”‚              pretend=self.pretend,
â”‚ â”‚ -            skip_if_exists=self.skip,
â”‚ â”‚              quiet=self.quiet,
â”‚ â”‚              src_path=src_path,
â”‚ â”‚              vcs_ref=self.vcs_ref,
â”‚ â”‚              use_prereleases=self.prereleases,
â”‚ â”‚ +            conflict=self.conflict,
â”‚ â”‚              **kwargs,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚      @handle_exceptions
â”‚ â”‚      def main(self, *args: str) -> int:
â”‚ â”‚          """Copier CLI app shortcuts.
â”‚ â”‚  
â”‚ â”‚ @@ -298,17 +311,14 @@
â”‚ â”‚  
â”‚ â”‚  @CopierApp.subcommand("update")
â”‚ â”‚  class CopierUpdateSubApp(cli.Application):
â”‚ â”‚      """The `copier update` subcommand.
â”‚ â”‚  
â”‚ â”‚      Use this subcommand to update an existing subproject from a template
â”‚ â”‚      that supports updates.
â”‚ â”‚ -
â”‚ â”‚ -    Attributes:
â”‚ â”‚ -        conflict: Set [conflict][] option.
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      DESCRIPTION = "Update a copy from its original template"
â”‚ â”‚      DESCRIPTION_MORE = dedent(
â”‚ â”‚          """\
â”‚ â”‚          The copy must have a valid answers file which contains info
â”‚ â”‚          from the last Copier execution, including the source template
â”‚ â”‚ @@ -317,43 +327,35 @@
â”‚ â”‚          If that file contains also `_commit` and `destination_path` is a git
â”‚ â”‚          repository, this command will do its best to respect the diff that you have
â”‚ â”‚          generated since the last `copier` execution. To avoid that, use `copier copy`
â”‚ â”‚          instead.
â”‚ â”‚          """
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚ -    conflict: cli.SwitchAttr = cli.SwitchAttr(
â”‚ â”‚ -        ["-o", "--conflict"],
â”‚ â”‚ -        cli.Set("rej", "inline"),
â”‚ â”‚ -        default="rej",
â”‚ â”‚ -        help=(
â”‚ â”‚ -            "Behavior on conflict: rej=Create .rej file, inline=inline conflict "
â”‚ â”‚ -            "markers (inline is still experimental)"
â”‚ â”‚ -        ),
â”‚ â”‚ -    )
â”‚ â”‚ -
â”‚ â”‚      @handle_exceptions
â”‚ â”‚      def main(self, destination_path: cli.ExistingDirectory = ".") -> int:
â”‚ â”‚          """Call [run_update][copier.main.Worker.run_update].
â”‚ â”‚  
â”‚ â”‚          Parameters:
â”‚ â”‚              destination_path:
â”‚ â”‚                  Only the destination path is needed to update, because the
â”‚ â”‚                  `src_path` comes from [the answers file][the-copier-answersyml-file].
â”‚ â”‚  
â”‚ â”‚                  The subproject must exist. If not specified, the currently
â”‚ â”‚                  working directory is used.
â”‚ â”‚          """
â”‚ â”‚          self.parent._worker(
â”‚ â”‚              dst_path=destination_path,
â”‚ â”‚ -            conflict=self.conflict,
â”‚ â”‚          ).run_update()
â”‚ â”‚          return 0
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # Add --help-all results to docs
â”‚ â”‚  if __doc__:
â”‚ â”‚      help_io = StringIO()
â”‚ â”‚      with patch("sys.stdout", help_io):
â”‚ â”‚          CopierApp.run(["copier", "--help-all"], exit=False)
â”‚ â”‚      help_io.seek(0)
â”‚ â”‚      __doc__ += f"\n\nCLI help generated from `copier --help-all`:\n\n```\n{help_io.read()}\n```"
â”‚ â”‚ +
â”‚ â”‚ +if __name__ == "__main__":
â”‚ â”‚ +    CopierApp.run()
â”‚ â”‚   --- copier-7.1.0/copier/errors.py
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/copier/errors.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -109,11 +109,7 @@
â”‚ â”‚  
â”‚ â”‚  class OldTemplateWarning(UserWarning, CopierWarning):
â”‚ â”‚      """Template was designed for an older Copier version."""
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class DirtyLocalWarning(UserWarning, CopierWarning):
â”‚ â”‚      """Changes and untracked files present in template."""
â”‚ â”‚ -
â”‚ â”‚ -
â”‚ â”‚ -class ShallowCloneWarning(UserWarning, CopierWarning):
â”‚ â”‚ -    """The template repository is a shallow clone."""
â”‚ â”‚   --- copier-7.1.0/copier/main.py
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/copier/main.py
â”‚ â”‚â”„ Files 3% similar despite different names
â”‚ â”‚ @@ -1,21 +1,22 @@
â”‚ â”‚  """Main functions and classes, used to generate or update projects."""
â”‚ â”‚  
â”‚ â”‚ +import contextlib
â”‚ â”‚  import os
â”‚ â”‚  import platform
â”‚ â”‚  import subprocess
â”‚ â”‚  import sys
â”‚ â”‚  from contextlib import suppress
â”‚ â”‚  from dataclasses import asdict, field, replace
â”‚ â”‚  from filecmp import dircmp
â”‚ â”‚  from functools import partial
â”‚ â”‚  from itertools import chain
â”‚ â”‚  from pathlib import Path
â”‚ â”‚ -from shutil import rmtree
â”‚ â”‚ -from typing import Callable, Iterable, Mapping, Optional, Sequence, Union
â”‚ â”‚ +from shutil import copyfile, rmtree
â”‚ â”‚ +from typing import Callable, Iterable, List, Mapping, Optional, Sequence, Set
â”‚ â”‚  from unicodedata import normalize
â”‚ â”‚  
â”‚ â”‚  from jinja2.loaders import FileSystemLoader
â”‚ â”‚  from jinja2.sandbox import SandboxedEnvironment
â”‚ â”‚  from pathspec import PathSpec
â”‚ â”‚  from plumbum import ProcessExecutionError, colors
â”‚ â”‚  from plumbum.cli.terminal import ask
â”‚ â”‚ @@ -25,20 +26,18 @@
â”‚ â”‚  from pydantic.dataclasses import dataclass
â”‚ â”‚  from pydantic.json import pydantic_encoder
â”‚ â”‚  from questionary import unsafe_prompt
â”‚ â”‚  
â”‚ â”‚  from .errors import CopierAnswersInterrupt, ExtensionNotFoundError, UserMessageError
â”‚ â”‚  from .subproject import Subproject
â”‚ â”‚  from .template import Task, Template
â”‚ â”‚ -from .tools import Style, TemporaryDirectory, printf, readlink
â”‚ â”‚ +from .tools import Style, TemporaryDirectory, printf
â”‚ â”‚  from .types import (
â”‚ â”‚ -    MISSING,
â”‚ â”‚      AnyByStrDict,
â”‚ â”‚      JSONSerializable,
â”‚ â”‚ -    Literal,
â”‚ â”‚      OptStr,
â”‚ â”‚      RelativePath,
â”‚ â”‚      StrOrPath,
â”‚ â”‚      StrSeq,
â”‚ â”‚  )
â”‚ â”‚  from .user_data import DEFAULT_DATA, AnswersMap, Question
â”‚ â”‚  
â”‚ â”‚ @@ -76,17 +75,15 @@
â”‚ â”‚      -   [run_copy][copier.main.Worker.run_copy] to copy a subproject.
â”‚ â”‚      -   [run_update][copier.main.Worker.run_update] to update a subproject.
â”‚ â”‚      -   [run_auto][copier.main.Worker.run_auto] to let it choose whether you
â”‚ â”‚          want to copy or update the subproject.
â”‚ â”‚  
â”‚ â”‚      Example:
â”‚ â”‚          ```python
â”‚ â”‚ -        with Worker(
â”‚ â”‚ -            src_path="https://github.com/copier-org/autopretty.git", "output"
â”‚ â”‚ -        ) as worker:
â”‚ â”‚ +        with Worker(src_path="https://github.com/copier-org/autopretty.git", "output") as worker:
â”‚ â”‚              worker.run_copy()
â”‚ â”‚          ```
â”‚ â”‚  
â”‚ â”‚      Attributes:
â”‚ â”‚          src_path:
â”‚ â”‚              String that can be resolved to a template path, be it local or remote.
â”‚ â”‚  
â”‚ â”‚ @@ -172,19 +169,17 @@
â”‚ â”‚      user_defaults: AnyByStrDict = field(default_factory=dict)
â”‚ â”‚      overwrite: bool = False
â”‚ â”‚      pretend: bool = False
â”‚ â”‚      quiet: bool = False
â”‚ â”‚      conflict: str = "rej"
â”‚ â”‚  
â”‚ â”‚      def __enter__(self):
â”‚ â”‚ -        """Allow using worker as a context manager."""
â”‚ â”‚          return self
â”‚ â”‚  
â”‚ â”‚      def __exit__(self, type, value, traceback):
â”‚ â”‚ -        """Clean up garbage files after worker usage ends."""
â”‚ â”‚          if value is not None:
â”‚ â”‚              # exception was raised from code inside context manager:
â”‚ â”‚              # try to clean up, ignoring any exception, then re-raise
â”‚ â”‚              with suppress(Exception):
â”‚ â”‚                  self._cleanup()
â”‚ â”‚              raise value
â”‚ â”‚          # otherwise clean up and let any exception bubble up
â”‚ â”‚ @@ -230,30 +225,27 @@
â”‚ â”‚                  use_shell = False
â”‚ â”‚              if not self.quiet:
â”‚ â”‚                  print(
â”‚ â”‚                      colors.info
â”‚ â”‚                      | f" > Running task {i + 1} of {len(tasks)}: {task_cmd}",
â”‚ â”‚                      file=sys.stderr,
â”‚ â”‚                  )
â”‚ â”‚ -            if self.pretend:
â”‚ â”‚ -                continue
â”‚ â”‚              with local.cwd(self.subproject.local_abspath), local.env(**task.extra_env):
â”‚ â”‚                  subprocess.run(task_cmd, shell=use_shell, check=True, env=local.env)
â”‚ â”‚  
â”‚ â”‚      def _render_context(self) -> Mapping:
â”‚ â”‚          """Produce render context for Jinja."""
â”‚ â”‚          # Backwards compatibility
â”‚ â”‚          # FIXME Remove it?
â”‚ â”‚          conf = asdict(self)
â”‚ â”‚          conf.update(
â”‚ â”‚              {
â”‚ â”‚                  "answers_file": self.answers_relpath,
â”‚ â”‚                  "src_path": self.template.local_abspath,
â”‚ â”‚                  "vcs_ref_hash": self.template.commit_hash,
â”‚ â”‚ -                "sep": os.sep,
â”‚ â”‚              }
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚          return dict(
â”‚ â”‚              DEFAULT_DATA,
â”‚ â”‚              **self.answers.combined,
â”‚ â”‚              _copier_answers=self._answers_to_remember(),
â”‚ â”‚ @@ -302,136 +294,134 @@
â”‚ â”‚              return True
â”‚ â”‚          return bool(ask(f" Overwrite {dst_relpath}?", default=True))
â”‚ â”‚  
â”‚ â”‚      def _render_allowed(
â”‚ â”‚          self,
â”‚ â”‚          dst_relpath: Path,
â”‚ â”‚          is_dir: bool = False,
â”‚ â”‚ -        is_symlink: bool = False,
â”‚ â”‚ -        expected_contents: Union[bytes, Path] = b"",
â”‚ â”‚ +        expected_contents: bytes = b"",
â”‚ â”‚ +        expected_permissions=None,
â”‚ â”‚      ) -> bool:
â”‚ â”‚          """Determine if a file or directory can be rendered.
â”‚ â”‚  
â”‚ â”‚          Args:
â”‚ â”‚ +
â”‚ â”‚              dst_relpath:
â”‚ â”‚                  Relative path to destination.
â”‚ â”‚              is_dir:
â”‚ â”‚                  Indicate if the path must be treated as a directory or not.
â”‚ â”‚ -            is_symlink:
â”‚ â”‚ -                Indicate if the path must be treated as a symlink or not.
â”‚ â”‚              expected_contents:
â”‚ â”‚                  Used to compare existing file contents with them. Allows to know if
â”‚ â”‚                  rendering is needed.
â”‚ â”‚          """
â”‚ â”‚          assert not dst_relpath.is_absolute()
â”‚ â”‚          assert not expected_contents or not is_dir, "Dirs cannot have expected content"
â”‚ â”‚          dst_abspath = Path(self.subproject.local_abspath, dst_relpath)
â”‚ â”‚          if dst_relpath != Path(".") and self.match_exclude(dst_relpath):
â”‚ â”‚              return False
â”‚ â”‚          try:
â”‚ â”‚ -            previous_content: Union[bytes, Path]
â”‚ â”‚ -            if is_symlink:
â”‚ â”‚ -                previous_content = readlink(dst_abspath)
â”‚ â”‚ -            else:
â”‚ â”‚ -                previous_content = dst_abspath.read_bytes()
â”‚ â”‚ +            previous_content = dst_abspath.read_bytes()
â”‚ â”‚          except FileNotFoundError:
â”‚ â”‚              printf(
â”‚ â”‚                  "create",
â”‚ â”‚                  dst_relpath,
â”‚ â”‚                  style=Style.OK,
â”‚ â”‚                  quiet=self.quiet,
â”‚ â”‚                  file_=sys.stderr,
â”‚ â”‚              )
â”‚ â”‚              return True
â”‚ â”‚ -        except PermissionError as error:
â”‚ â”‚ +        except (IsADirectoryError, PermissionError) as error:
â”‚ â”‚              # HACK https://bugs.python.org/issue43095
â”‚ â”‚ -            if not (error.errno == 13 and platform.system() == "Windows"):
â”‚ â”‚ +            if isinstance(error, PermissionError) and not (
â”‚ â”‚ +                error.errno == 13 and platform.system() == "Windows"
â”‚ â”‚ +            ):
â”‚ â”‚                  raise
â”‚ â”‚ -        except IsADirectoryError:
â”‚ â”‚ -            assert is_dir
â”‚ â”‚ -        if is_dir or previous_content == expected_contents:
â”‚ â”‚ -            printf(
â”‚ â”‚ -                "identical",
â”‚ â”‚ -                dst_relpath,
â”‚ â”‚ -                style=Style.IGNORE,
â”‚ â”‚ -                quiet=self.quiet,
â”‚ â”‚ -                file_=sys.stderr,
â”‚ â”‚ -            )
â”‚ â”‚ -            return True
â”‚ â”‚ -        return self._solve_render_conflict(dst_relpath)
â”‚ â”‚ +            if is_dir:
â”‚ â”‚ +                printf(
â”‚ â”‚ +                    "identical",
â”‚ â”‚ +                    dst_relpath,
â”‚ â”‚ +                    style=Style.IGNORE,
â”‚ â”‚ +                    quiet=self.quiet,
â”‚ â”‚ +                    file_=sys.stderr,
â”‚ â”‚ +                )
â”‚ â”‚ +                return True
â”‚ â”‚ +            return self._solve_render_conflict(dst_relpath)
â”‚ â”‚ +        else:
â”‚ â”‚ +            if previous_content == expected_contents:
â”‚ â”‚ +                printf(
â”‚ â”‚ +                    "identical",
â”‚ â”‚ +                    dst_relpath,
â”‚ â”‚ +                    style=Style.IGNORE,
â”‚ â”‚ +                    quiet=self.quiet,
â”‚ â”‚ +                    file_=sys.stderr,
â”‚ â”‚ +                )
â”‚ â”‚ +                return True
â”‚ â”‚ +            return self._solve_render_conflict(dst_relpath)
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚      def answers(self) -> AnswersMap:
â”‚ â”‚          """Container of all answers to the questionary.
â”‚ â”‚  
â”‚ â”‚          It asks the user the 1st time it is called, if running interactively.
â”‚ â”‚          """
â”‚ â”‚          result = AnswersMap(
â”‚ â”‚              default=self.template.default_answers,
â”‚ â”‚              user_defaults=self.user_defaults,
â”‚ â”‚              init=self.data,
â”‚ â”‚              last=self.subproject.last_answers,
â”‚ â”‚              metadata=self.template.metadata,
â”‚ â”‚          )
â”‚ â”‚ -
â”‚ â”‚ +        questions: List[Question] = []
â”‚ â”‚          for var_name, details in self.template.questions_data.items():
â”‚ â”‚ -            question = Question(
â”‚ â”‚ -                answers=result,
â”‚ â”‚ -                jinja_env=self.jinja_env,
â”‚ â”‚ -                var_name=var_name,
â”‚ â”‚ -                **details,
â”‚ â”‚ -            )
â”‚ â”‚              if var_name in result.init:
â”‚ â”‚ -                # Try to parse the answer value.
â”‚ â”‚ -                answer = question.parse_answer(result.init[var_name])
â”‚ â”‚ -                # Try to validate the answer value if the question has a
â”‚ â”‚ -                # validator.
â”‚ â”‚ -                question.validate_answer(answer)
â”‚ â”‚ -                # At this point, the answer value is valid. Do not ask the
â”‚ â”‚ -                # question again, but set answer as the user's answer instead.
â”‚ â”‚ -                result.user[var_name] = answer
â”‚ â”‚ +                # Do not ask again
â”‚ â”‚                  continue
â”‚ â”‚ -
â”‚ â”‚ +            questions.append(
â”‚ â”‚ +                Question(
â”‚ â”‚ +                    answers=result,
â”‚ â”‚ +                    ask_user=not self.defaults,
â”‚ â”‚ +                    jinja_env=self.jinja_env,
â”‚ â”‚ +                    var_name=var_name,
â”‚ â”‚ +                    **details,
â”‚ â”‚ +                )
â”‚ â”‚ +            )
â”‚ â”‚ +        for question in questions:
â”‚ â”‚              # Display TUI and ask user interactively only without --defaults
â”‚ â”‚              try:
â”‚ â”‚ -                if self.defaults:
â”‚ â”‚ -                    new_answer = question.get_default()
â”‚ â”‚ -                    if new_answer is MISSING:
â”‚ â”‚ -                        raise ValueError(f'Question "{var_name}" is required')
â”‚ â”‚ -                else:
â”‚ â”‚ -                    new_answer = unsafe_prompt(
â”‚ â”‚ +                new_answer = (
â”‚ â”‚ +                    question.get_default()
â”‚ â”‚ +                    if self.defaults
â”‚ â”‚ +                    else unsafe_prompt(
â”‚ â”‚                          [question.get_questionary_structure()], answers=result.combined
â”‚ â”‚                      )[question.var_name]
â”‚ â”‚ +                )
â”‚ â”‚              except KeyboardInterrupt as err:
â”‚ â”‚                  raise CopierAnswersInterrupt(result, question, self.template) from err
â”‚ â”‚              previous_answer = result.combined.get(question.var_name)
â”‚ â”‚              # If question was skipped and it's the 1st
â”‚ â”‚              # run, you could be getting a raw templated value
â”‚ â”‚              default_answer = result.default.get(question.var_name)
â”‚ â”‚              if new_answer == default_answer:
â”‚ â”‚                  new_answer = question.render_value(default_answer)
â”‚ â”‚                  new_answer = question.filter_answer(new_answer)
â”‚ â”‚              if new_answer != previous_answer:
â”‚ â”‚                  result.user[question.var_name] = new_answer
â”‚ â”‚ -
â”‚ â”‚          return result
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚      def answers_relpath(self) -> Path:
â”‚ â”‚          """Obtain the proper relative path for the answers file.
â”‚ â”‚  
â”‚ â”‚          It comes from:
â”‚ â”‚  
â”‚ â”‚          1. User choice.
â”‚ â”‚          2. Template default.
â”‚ â”‚          3. Copier default.
â”‚ â”‚          """
â”‚ â”‚ -        path = self.answers_file or self.template.answers_relpath
â”‚ â”‚ -        template = self.jinja_env.from_string(str(path))
â”‚ â”‚ -        return Path(template.render(**self.answers.combined))
â”‚ â”‚ +        return self.answers_file or self.template.answers_relpath
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚      def all_exclusions(self) -> StrSeq:
â”‚ â”‚          """Combine default, template and user-chosen exclusions."""
â”‚ â”‚          return self.template.exclude + tuple(self.exclude)
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚ @@ -460,28 +450,14 @@
â”‚ â”‚                  "Make sure to install these extensions alongside Copier itself.\n"
â”‚ â”‚                  "See the docs at https://copier.readthedocs.io/en/latest/configuring/#jinja_extensions"
â”‚ â”‚              )
â”‚ â”‚          # patch the `to_json` filter to support Pydantic dataclasses
â”‚ â”‚          env.filters["to_json"] = partial(
â”‚ â”‚              env.filters["to_json"], default=pydantic_encoder
â”‚ â”‚          )
â”‚ â”‚ -
â”‚ â”‚ -        # Add a global function to join filesystem paths.
â”‚ â”‚ -        separators = {
â”‚ â”‚ -            "posix": "/",
â”‚ â”‚ -            "windows": "\\",
â”‚ â”‚ -            "native": os.path.sep,
â”‚ â”‚ -        }
â”‚ â”‚ -
â”‚ â”‚ -        def _pathjoin(
â”‚ â”‚ -            *path: str, mode: Literal["posix", "windows", "native"] = "posix"
â”‚ â”‚ -        ) -> str:
â”‚ â”‚ -            return separators[mode].join(path)
â”‚ â”‚ -
â”‚ â”‚ -        env.globals["pathjoin"] = _pathjoin
â”‚ â”‚          return env
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚      def match_exclude(self) -> Callable[[Path], bool]:
â”‚ â”‚          """Get a callable to match paths against all exclusions."""
â”‚ â”‚          return self._path_matcher(self.all_exclusions)
â”‚ â”‚  
â”‚ â”‚ @@ -495,14 +471,15 @@
â”‚ â”‚              )
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚      def _render_file(self, src_abspath: Path) -> None:
â”‚ â”‚          """Render one file.
â”‚ â”‚  
â”‚ â”‚          Args:
â”‚ â”‚ +
â”‚ â”‚              src_abspath:
â”‚ â”‚                  The absolute path to the file that will be rendered.
â”‚ â”‚          """
â”‚ â”‚          # TODO Get from main.render_file()
â”‚ â”‚          assert src_abspath.is_absolute()
â”‚ â”‚          src_relpath = src_abspath.relative_to(self.template.local_abspath).as_posix()
â”‚ â”‚          src_renderpath = src_abspath.relative_to(self.template_copy_root)
â”‚ â”‚ @@ -519,60 +496,26 @@
â”‚ â”‚                  # suffix is empty, fallback to copy
â”‚ â”‚                  new_content = src_abspath.read_bytes()
â”‚ â”‚              else:
â”‚ â”‚                  new_content = tpl.render(**self._render_context()).encode()
â”‚ â”‚          else:
â”‚ â”‚              new_content = src_abspath.read_bytes()
â”‚ â”‚          dst_abspath = Path(self.subproject.local_abspath, dst_relpath)
â”‚ â”‚ -        src_mode = src_abspath.stat().st_mode
â”‚ â”‚ -        if not self._render_allowed(dst_relpath, expected_contents=new_content):
â”‚ â”‚ +        if dst_abspath.is_dir():
â”‚ â”‚              return
â”‚ â”‚ -        if not self.pretend:
â”‚ â”‚ -            dst_abspath.parent.mkdir(parents=True, exist_ok=True)
â”‚ â”‚ -            dst_abspath.write_bytes(new_content)
â”‚ â”‚ -            dst_abspath.chmod(src_mode)
â”‚ â”‚ -
â”‚ â”‚ -    def _render_symlink(self, src_abspath: Path) -> None:
â”‚ â”‚ -        """Render one symlink.
â”‚ â”‚ -
â”‚ â”‚ -        Args:
â”‚ â”‚ -            src_abspath:
â”‚ â”‚ -                Symlink to be rendered. It must be an absolute path within
â”‚ â”‚ -                the template.
â”‚ â”‚ -        """
â”‚ â”‚ -        assert src_abspath.is_absolute()
â”‚ â”‚ -        src_relpath = src_abspath.relative_to(self.template_copy_root)
â”‚ â”‚ -        dst_relpath = self._render_path(src_relpath)
â”‚ â”‚ -        if dst_relpath is None:
â”‚ â”‚ -            return
â”‚ â”‚ -        dst_abspath = Path(self.subproject.local_abspath, dst_relpath)
â”‚ â”‚ -
â”‚ â”‚ -        src_target = readlink(src_abspath)
â”‚ â”‚ -        if src_abspath.name.endswith(self.template.templates_suffix):
â”‚ â”‚ -            dst_target = Path(self._render_string(str(src_target)))
â”‚ â”‚ -        else:
â”‚ â”‚ -            dst_target = src_target
â”‚ â”‚ -
â”‚ â”‚ +        src_mode = src_abspath.stat().st_mode
â”‚ â”‚          if not self._render_allowed(
â”‚ â”‚              dst_relpath,
â”‚ â”‚ -            expected_contents=dst_target,
â”‚ â”‚ -            is_symlink=True,
â”‚ â”‚ +            expected_contents=new_content,
â”‚ â”‚ +            expected_permissions=src_mode,
â”‚ â”‚          ):
â”‚ â”‚              return
â”‚ â”‚ -
â”‚ â”‚          if not self.pretend:
â”‚ â”‚ -            # symlink_to doesn't overwrite existing files, so delete it first
â”‚ â”‚ -            if dst_abspath.is_symlink() or dst_abspath.exists():
â”‚ â”‚ -                dst_abspath.unlink()
â”‚ â”‚ -            dst_abspath.symlink_to(dst_target)
â”‚ â”‚ -            if sys.platform == "darwin":
â”‚ â”‚ -                # Only macOS supports permissions on symlinks.
â”‚ â”‚ -                # Other platforms just copy the permission of the target
â”‚ â”‚ -                src_mode = src_abspath.lstat().st_mode
â”‚ â”‚ -                dst_abspath.lchmod(src_mode)
â”‚ â”‚ +            dst_abspath.write_bytes(new_content)
â”‚ â”‚ +            dst_abspath.chmod(src_mode)
â”‚ â”‚  
â”‚ â”‚      def _render_folder(self, src_abspath: Path) -> None:
â”‚ â”‚          """Recursively render a folder.
â”‚ â”‚  
â”‚ â”‚          Args:
â”‚ â”‚              src_path:
â”‚ â”‚                  Folder to be rendered. It must be an absolute path within
â”‚ â”‚ @@ -587,16 +530,14 @@
â”‚ â”‚              return
â”‚ â”‚          dst_abspath = Path(self.subproject.local_abspath, dst_relpath)
â”‚ â”‚          if not self.pretend:
â”‚ â”‚              dst_abspath.mkdir(parents=True, exist_ok=True)
â”‚ â”‚          for file in src_abspath.iterdir():
â”‚ â”‚              if file.is_dir():
â”‚ â”‚                  self._render_folder(file)
â”‚ â”‚ -            elif file.is_symlink() and self.template.preserve_symlinks:
â”‚ â”‚ -                self._render_symlink(file)
â”‚ â”‚              else:
â”‚ â”‚                  self._render_file(file)
â”‚ â”‚  
â”‚ â”‚      def _render_path(self, relpath: Path) -> Optional[Path]:
â”‚ â”‚          """Render one relative path.
â”‚ â”‚  
â”‚ â”‚          Args:
â”‚ â”‚ @@ -606,27 +547,28 @@
â”‚ â”‚          is_template = relpath.name.endswith(self.template.templates_suffix)
â”‚ â”‚          templated_sibling = (
â”‚ â”‚              self.template.local_abspath / f"{relpath}{self.template.templates_suffix}"
â”‚ â”‚          )
â”‚ â”‚          # With an empty suffix, the templated sibling always exists.
â”‚ â”‚          if templated_sibling.exists() and self.template.templates_suffix:
â”‚ â”‚              return None
â”‚ â”‚ -        if self.template.templates_suffix and is_template:
â”‚ â”‚ -            relpath = relpath.with_suffix("")
â”‚ â”‚          rendered_parts = []
â”‚ â”‚          for part in relpath.parts:
â”‚ â”‚              # Skip folder if any part is rendered as an empty string
â”‚ â”‚              part = self._render_string(part)
â”‚ â”‚              if not part:
â”‚ â”‚                  return None
â”‚ â”‚ -            # {{ _copier_conf.answers_file }} becomes the full path; in that case,
â”‚ â”‚ -            # restore part to be just the end leaf
â”‚ â”‚ -            if str(self.answers_relpath) == part:
â”‚ â”‚ -                part = Path(part).name
â”‚ â”‚              rendered_parts.append(part)
â”‚ â”‚ +        with suppress(IndexError):
â”‚ â”‚ +            # With an empty suffix, the next instruction
â”‚ â”‚ +            # would erroneously empty the last rendered part
â”‚ â”‚ +            if is_template and self.template.templates_suffix:
â”‚ â”‚ +                rendered_parts[-1] = rendered_parts[-1][
â”‚ â”‚ +                    : -len(self.template.templates_suffix)
â”‚ â”‚ +                ]
â”‚ â”‚          result = Path(*rendered_parts)
â”‚ â”‚          if not is_template:
â”‚ â”‚              templated_sibling = (
â”‚ â”‚                  self.template.local_abspath
â”‚ â”‚                  / f"{result}{self.template.templates_suffix}"
â”‚ â”‚              )
â”‚ â”‚              if templated_sibling.exists():
â”‚ â”‚ @@ -754,42 +696,48 @@
â”‚ â”‚              # TODO Unify printing tools
â”‚ â”‚              print(
â”‚ â”‚                  f"Updating to template version {self.template.version}", file=sys.stderr
â”‚ â”‚              )
â”‚ â”‚          self._apply_update()
â”‚ â”‚  
â”‚ â”‚      def _apply_update(self):
â”‚ â”‚ -        subproject_top = Path(
â”‚ â”‚ -            git(
â”‚ â”‚ -                "-C",
â”‚ â”‚ -                self.subproject.local_abspath,
â”‚ â”‚ -                "rev-parse",
â”‚ â”‚ -                "--show-toplevel",
â”‚ â”‚ -            ).strip()
â”‚ â”‚ -        )
â”‚ â”‚ -        subproject_subdir = self.subproject.local_abspath.relative_to(subproject_top)
â”‚ â”‚ +        if self.conflict == "inline":
â”‚ â”‚ +            # New implementation.
â”‚ â”‚ +            self._apply_update_inline_conflict_markers()
â”‚ â”‚ +            return
â”‚ â”‚  
â”‚ â”‚ +        # Old implementation.
â”‚ â”‚ +        # Copy old template into a temporary destination
â”‚ â”‚          with TemporaryDirectory(
â”‚ â”‚ -            prefix=f"{__name__}.old_copy."
â”‚ â”‚ -        ) as old_copy, TemporaryDirectory(prefix=f"{__name__}.new_copy.") as new_copy:
â”‚ â”‚ -            # Copy old template into a temporary destination
â”‚ â”‚ -            old_worker = replace(
â”‚ â”‚ +            prefix=f"{__name__}.update_diff."
â”‚ â”‚ +        ) as old_copy, TemporaryDirectory(
â”‚ â”‚ +            prefix=f"{__name__}.recopy_diff."
â”‚ â”‚ +        ) as new_copy:
â”‚ â”‚ +            old_worker = self._make_old_worker(old_copy)
â”‚ â”‚ +            old_worker.run_copy()
â”‚ â”‚ +            recopy_worker = replace(
â”‚ â”‚                  self,
â”‚ â”‚ -                dst_path=old_copy / subproject_subdir,
â”‚ â”‚ +                dst_path=new_copy,
â”‚ â”‚                  data=self.subproject.last_answers,
â”‚ â”‚                  defaults=True,
â”‚ â”‚                  quiet=True,
â”‚ â”‚                  src_path=self.subproject.template.url,
â”‚ â”‚ -                vcs_ref=self.subproject.template.commit,
â”‚ â”‚              )
â”‚ â”‚ -            old_worker.run_copy()
â”‚ â”‚ +            recopy_worker.run_copy()
â”‚ â”‚ +            compared = dircmp(old_copy, new_copy)
â”‚ â”‚              # Extract diff between temporary destination and real destination
â”‚ â”‚              with local.cwd(old_copy):
â”‚ â”‚ +                subproject_top = git(
â”‚ â”‚ +                    "-C",
â”‚ â”‚ +                    self.subproject.local_abspath.absolute(),
â”‚ â”‚ +                    "rev-parse",
â”‚ â”‚ +                    "--show-toplevel",
â”‚ â”‚ +                ).strip()
â”‚ â”‚                  self._git_initialize_repo()
â”‚ â”‚ -                git("remote", "add", "real_dst", "file://" + str(subproject_top))
â”‚ â”‚ +                git("remote", "add", "real_dst", "file://" + subproject_top)
â”‚ â”‚                  git("fetch", "--depth=1", "real_dst", "HEAD")
â”‚ â”‚                  diff_cmd = git["diff-tree", "--unified=1", "HEAD...FETCH_HEAD"]
â”‚ â”‚                  try:
â”‚ â”‚                      diff = diff_cmd("--inter-hunk-context=-1")
â”‚ â”‚                  except ProcessExecutionError:
â”‚ â”‚                      print(
â”‚ â”‚                          colors.warn
â”‚ â”‚ @@ -797,93 +745,141 @@
â”‚ â”‚                          file=sys.stderr,
â”‚ â”‚                      )
â”‚ â”‚                      diff = diff_cmd("--inter-hunk-context=0")
â”‚ â”‚              # Run pre-migration tasks
â”‚ â”‚              self._execute_tasks(
â”‚ â”‚                  self.template.migration_tasks("before", self.subproject.template)
â”‚ â”‚              )
â”‚ â”‚ -            # Clear last answers cache to load possible answers migration
â”‚ â”‚ -            with suppress(AttributeError):
â”‚ â”‚ -                del self.answers
â”‚ â”‚ -            with suppress(AttributeError):
â”‚ â”‚ -                del self.subproject.last_answers
â”‚ â”‚ -            # Do a normal update in final destination
â”‚ â”‚ -            self.run_copy()
â”‚ â”‚ -            # Render with the same answers in an empty dir to avoid pollution
â”‚ â”‚ -            new_worker = replace(
â”‚ â”‚ -                self,
â”‚ â”‚ -                dst_path=new_copy / subproject_subdir,
â”‚ â”‚ -                data=self.answers.combined,
â”‚ â”‚ -                defaults=True,
â”‚ â”‚ -                quiet=True,
â”‚ â”‚ -                src_path=self.subproject.template.url,
â”‚ â”‚ -            )
â”‚ â”‚ -            new_worker.run_copy()
â”‚ â”‚ -            compared = dircmp(old_copy, new_copy)
â”‚ â”‚ +            self._uncached_copy()
â”‚ â”‚              # Try to apply cached diff into final destination
â”‚ â”‚ -            with local.cwd(subproject_top):
â”‚ â”‚ +            with local.cwd(self.subproject.local_abspath):
â”‚ â”‚                  apply_cmd = git["apply", "--reject", "--exclude", self.answers_relpath]
â”‚ â”‚                  for skip_pattern in chain(
â”‚ â”‚                      self.skip_if_exists, self.template.skip_if_exists
â”‚ â”‚                  ):
â”‚ â”‚                      apply_cmd = apply_cmd["--exclude", skip_pattern]
â”‚ â”‚                  (apply_cmd << diff)(retcode=None)
â”‚ â”‚ -                # TODO Test more, remove from experimental, make default
â”‚ â”‚ -                if self.conflict == "inline":
â”‚ â”‚ -                    status = git("status", "--porcelain").strip().splitlines()
â”‚ â”‚ -                    for line in status:
â”‚ â”‚ -                        # Find merge rejections
â”‚ â”‚ -                        if not (line.startswith("?? ") and line.endswith(".rej")):
â”‚ â”‚ -                            continue
â”‚ â”‚ -                        # FIXME Test with a file named '`Ã¢ Ã±"', see it fail, fix it
â”‚ â”‚ -                        fname = line[3:-4]
â”‚ â”‚ -                        # Undo possible non-rejected chunks
â”‚ â”‚ -                        git("checkout", "--", fname)
â”‚ â”‚ -                        # 3-way-merge the file directly
â”‚ â”‚ -                        git(
â”‚ â”‚ -                            "merge-file",
â”‚ â”‚ -                            "-L",
â”‚ â”‚ -                            "before updating",
â”‚ â”‚ -                            "-L",
â”‚ â”‚ -                            "last update",
â”‚ â”‚ -                            "-L",
â”‚ â”‚ -                            "after updating",
â”‚ â”‚ -                            fname,
â”‚ â”‚ -                            Path(old_copy) / fname,
â”‚ â”‚ -                            Path(new_copy) / fname,
â”‚ â”‚ -                            retcode=None,
â”‚ â”‚ -                        )
â”‚ â”‚ -                        # Remove rejection witness
â”‚ â”‚ -                        Path(f"{fname}.rej").unlink()
â”‚ â”‚ +
â”‚ â”‚              # Trigger recursive removal of deleted files in last template version
â”‚ â”‚ -            _remove_old_files(subproject_top, compared)
â”‚ â”‚ +            _remove_old_files(self.subproject.local_abspath, compared)
â”‚ â”‚  
â”‚ â”‚          # Run post-migration tasks
â”‚ â”‚          self._execute_tasks(
â”‚ â”‚              self.template.migration_tasks("after", self.subproject.template)
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚ +    def _apply_update_inline_conflict_markers(self):
â”‚ â”‚ +        """Implements the apply_update() method using inline conflict markers."""
â”‚ â”‚ +        # Copy old template into a temporary destination
â”‚ â”‚ +        with TemporaryDirectory(
â”‚ â”‚ +            prefix=f"{__name__}.update_diff.reference."
â”‚ â”‚ +        ) as reference_dst_temp, TemporaryDirectory(
â”‚ â”‚ +            prefix=f"{__name__}.update_diff.original."
â”‚ â”‚ +        ) as old_copy, TemporaryDirectory(
â”‚ â”‚ +            prefix=f"{__name__}.update_diff.merge."
â”‚ â”‚ +        ) as merge_dst_temp:
â”‚ â”‚ +            # Copy reference to be used as base by merge-file
â”‚ â”‚ +            copytree(self.dst_path, reference_dst_temp, dirs_exist_ok=True)
â”‚ â”‚ +
â”‚ â”‚ +            # Compute modification from the original template to be used as other by merge-file
â”‚ â”‚ +            assert self.subproject
â”‚ â”‚ +            assert self.subproject.template
â”‚ â”‚ +            old_worker = self._make_old_worker(old_copy)
â”‚ â”‚ +            old_worker.run_copy()
â”‚ â”‚ +            with local.cwd(old_copy):
â”‚ â”‚ +                self._git_initialize_repo()
â”‚ â”‚ +
â”‚ â”‚ +            # Run pre-migration tasks
â”‚ â”‚ +            self._execute_tasks(
â”‚ â”‚ +                self.template.migration_tasks("before", self.subproject.template)
â”‚ â”‚ +            )
â”‚ â”‚ +            self._uncached_copy()
â”‚ â”‚ +
â”‚ â”‚ +            # Extract the list of files to merge
â”‚ â”‚ +            participating_files: Set[Path] = set()
â”‚ â”‚ +            for src_dir in (old_copy, reference_dst_temp):
â”‚ â”‚ +                for root, dirs, files in os.walk(src_dir, topdown=True):
â”‚ â”‚ +                    if root == src_dir and ".git" in dirs:
â”‚ â”‚ +                        dirs.remove(".git")
â”‚ â”‚ +                    root = Path(root).relative_to(src_dir)
â”‚ â”‚ +                    participating_files.update(Path(root, f) for f in files)
â”‚ â”‚ +
â”‚ â”‚ +            # Merging files
â”‚ â”‚ +            for basename in sorted(participating_files):
â”‚ â”‚ +                subfile_names = []
â”‚ â”‚ +                for subfile_kind, src_dir in [
â”‚ â”‚ +                    ("modified", reference_dst_temp),
â”‚ â”‚ +                    ("old upstream", old_copy),
â”‚ â”‚ +                    ("new upstream", self.dst_path),
â”‚ â”‚ +                ]:
â”‚ â”‚ +                    path = Path(src_dir, basename)
â”‚ â”‚ +                    if path.is_file():
â”‚ â”‚ +                        copyfile(path, Path(merge_dst_temp, subfile_kind))
â”‚ â”‚ +                    else:
â”‚ â”‚ +                        subfile_kind = os.devnull
â”‚ â”‚ +                    subfile_names.append(subfile_kind)
â”‚ â”‚ +
â”‚ â”‚ +                with local.cwd(merge_dst_temp):
â”‚ â”‚ +                    # https://git-scm.com/docs/git-merge-file
â”‚ â”‚ +                    output = git("merge-file", "-p", *subfile_names, retcode=None)
â”‚ â”‚ +
â”‚ â”‚ +                dest_path = Path(self.dst_path, basename)
â”‚ â”‚ +                # Remove the file if it was already removed in the project
â”‚ â”‚ +                if not output and "modified" not in subfile_names:
â”‚ â”‚ +                    with contextlib.suppress(FileNotFoundError):
â”‚ â”‚ +                        dest_path.unlink()
â”‚ â”‚ +                else:
â”‚ â”‚ +                    dest_path.parent.mkdir(parents=True, exist_ok=True)
â”‚ â”‚ +                    dest_path.write_text(output)
â”‚ â”‚ +
â”‚ â”‚ +        # Run post-migration tasks
â”‚ â”‚ +        self._execute_tasks(
â”‚ â”‚ +            self.template.migration_tasks("after", self.subproject.template)
â”‚ â”‚ +        )
â”‚ â”‚ +
â”‚ â”‚ +    def _uncached_copy(self):
â”‚ â”‚ +        """Copy template to destination without using answer cache."""
â”‚ â”‚ +        # Clear last answers cache to load possible answers migration
â”‚ â”‚ +        with suppress(AttributeError):
â”‚ â”‚ +            del self.answers
â”‚ â”‚ +        with suppress(AttributeError):
â”‚ â”‚ +            del self.subproject.last_answers
â”‚ â”‚ +        # Do a normal update in final destination
â”‚ â”‚ +        self.run_copy()
â”‚ â”‚ +
â”‚ â”‚ +    def _make_old_worker(self, old_copy):
â”‚ â”‚ +        """Create a worker to copy the old template into a temporary destination."""
â”‚ â”‚ +        old_worker = replace(
â”‚ â”‚ +            self,
â”‚ â”‚ +            dst_path=old_copy,
â”‚ â”‚ +            data=self.subproject.last_answers,
â”‚ â”‚ +            defaults=True,
â”‚ â”‚ +            quiet=True,
â”‚ â”‚ +            src_path=self.subproject.template.url,
â”‚ â”‚ +            vcs_ref=self.subproject.template.commit,
â”‚ â”‚ +        )
â”‚ â”‚ +        return old_worker
â”‚ â”‚ +
â”‚ â”‚      def _git_initialize_repo(self):
â”‚ â”‚          """Initialize a git repository in the current directory."""
â”‚ â”‚          git("init", retcode=None)
â”‚ â”‚          git("add", ".")
â”‚ â”‚          git("config", "user.name", "Copier")
â”‚ â”‚          git("config", "user.email", "copier@copier")
â”‚ â”‚          # 1st commit could fail if any pre-commit hook reformats code
â”‚ â”‚ -        # 2nd commit uses --no-verify to disable pre-commit-like checks
â”‚ â”‚          git("commit", "--allow-empty", "-am", "dumb commit 1", retcode=None)
â”‚ â”‚ -        git("commit", "--allow-empty", "-am", "dumb commit 2", "--no-verify")
â”‚ â”‚ +        git("commit", "--allow-empty", "-am", "dumb commit 2")
â”‚ â”‚          git("config", "--unset", "user.name")
â”‚ â”‚          git("config", "--unset", "user.email")
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def run_copy(
â”‚ â”‚      src_path: str,
â”‚ â”‚      dst_path: StrOrPath = ".",
â”‚ â”‚ -    data: Optional[AnyByStrDict] = None,
â”‚ â”‚ +    data: AnyByStrDict = None,
â”‚ â”‚      **kwargs,
â”‚ â”‚  ) -> Worker:
â”‚ â”‚      """Copy a template to a destination, from zero.
â”‚ â”‚  
â”‚ â”‚      This is a shortcut for [run_copy][copier.main.Worker.run_copy].
â”‚ â”‚  
â”‚ â”‚      See [Worker][copier.main.Worker] fields to understand this function's args.
â”‚ â”‚ @@ -893,15 +889,15 @@
â”‚ â”‚      with Worker(src_path=src_path, dst_path=Path(dst_path), **kwargs) as worker:
â”‚ â”‚          worker.run_copy()
â”‚ â”‚      return worker
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def run_update(
â”‚ â”‚      dst_path: StrOrPath = ".",
â”‚ â”‚ -    data: Optional[AnyByStrDict] = None,
â”‚ â”‚ +    data: AnyByStrDict = None,
â”‚ â”‚      **kwargs,
â”‚ â”‚  ) -> Worker:
â”‚ â”‚      """Update a subproject, from its template.
â”‚ â”‚  
â”‚ â”‚      This is a shortcut for [run_update][copier.main.Worker.run_update].
â”‚ â”‚  
â”‚ â”‚      See [Worker][copier.main.Worker] fields to understand this function's args.
â”‚ â”‚ @@ -912,15 +908,15 @@
â”‚ â”‚          worker.run_update()
â”‚ â”‚      return worker
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def run_auto(
â”‚ â”‚      src_path: OptStr = None,
â”‚ â”‚      dst_path: StrOrPath = ".",
â”‚ â”‚ -    data: Optional[AnyByStrDict] = None,
â”‚ â”‚ +    data: AnyByStrDict = None,
â”‚ â”‚      **kwargs,
â”‚ â”‚  ) -> Worker:
â”‚ â”‚      """Generate or update a subproject.
â”‚ â”‚  
â”‚ â”‚      This is a shortcut for [run_auto][copier.main.Worker.run_auto].
â”‚ â”‚  
â”‚ â”‚      See [Worker][copier.main.Worker] fields to understand this function's args.
â”‚ â”‚ â”œâ”€â”€ encoding
â”‚ â”‚ â”‚ @@ -1 +1 @@
â”‚ â”‚ â”‚ -utf-8
â”‚ â”‚ â”‚ +us-ascii
â”‚ â”‚   --- copier-7.1.0/copier/subproject.py
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/copier/subproject.py
â”‚ â”‚â”„ Files 1% similar despite different names
â”‚ â”‚ @@ -35,26 +35,26 @@
â”‚ â”‚              Relative path to [the answers file][the-copier-answersyml-file].
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      local_abspath: AbsolutePath
â”‚ â”‚      answers_relpath: Path = Path(".copier-answers.yml")
â”‚ â”‚  
â”‚ â”‚      def is_dirty(self) -> bool:
â”‚ â”‚ -        """Indicate if the local template root is dirty.
â”‚ â”‚ +        """Indicates if the local template root is dirty.
â”‚ â”‚  
â”‚ â”‚          Only applicable for VCS-tracked templates.
â”‚ â”‚          """
â”‚ â”‚          if self.vcs == "git":
â”‚ â”‚              with local.cwd(self.local_abspath):
â”‚ â”‚                  return bool(git("status", "--porcelain").strip())
â”‚ â”‚          return False
â”‚ â”‚  
â”‚ â”‚      @property
â”‚ â”‚      def _raw_answers(self) -> AnyByStrDict:
â”‚ â”‚ -        """Get last answers, loaded raw as yaml."""
â”‚ â”‚ +        """The last answers, loaded raw as yaml."""
â”‚ â”‚          try:
â”‚ â”‚              return yaml.safe_load(
â”‚ â”‚                  (self.local_abspath / self.answers_relpath).read_text()
â”‚ â”‚              )
â”‚ â”‚          except OSError:
â”‚ â”‚              return {}
â”‚ â”‚   --- copier-7.1.0/copier/template.py
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/copier/template.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -84,44 +84,38 @@
â”‚ â”‚      Params:
â”‚ â”‚          conf_path: The path to the `copier.yml` file.
â”‚ â”‚          quiet: Used to configure the exception.
â”‚ â”‚  
â”‚ â”‚      Raises:
â”‚ â”‚          InvalidConfigFileError: When the file is formatted badly.
â”‚ â”‚      """
â”‚ â”‚ -
â”‚ â”‚ -    class _Loader(yaml.FullLoader):
â”‚ â”‚ -        """Intermediate class to avoid monkey-patching main loader."""
â”‚ â”‚ -
â”‚ â”‚      YamlIncludeConstructor.add_to_loader_class(
â”‚ â”‚ -        loader_class=_Loader, base_dir=conf_path.parent
â”‚ â”‚ +        loader_class=yaml.FullLoader, base_dir=conf_path.parent
â”‚ â”‚      )
â”‚ â”‚  
â”‚ â”‚ -    with open(conf_path) as f:
â”‚ â”‚ -        try:
â”‚ â”‚ -            flattened_result = lflatten(yaml.load_all(f, Loader=_Loader))
â”‚ â”‚ -        except yaml.parser.ParserError as e:
â”‚ â”‚ -            raise InvalidConfigFileError(conf_path, quiet) from e
â”‚ â”‚ -
â”‚ â”‚ -    merged_options = defaultdict(list)
â”‚ â”‚ -    for option in (
â”‚ â”‚ -        "_exclude",
â”‚ â”‚ -        "_jinja_extensions",
â”‚ â”‚ -        "_secret_questions",
â”‚ â”‚ -        "_skip_if_exists",
â”‚ â”‚ -    ):
â”‚ â”‚ -        for result in flattened_result:
â”‚ â”‚ -            try:
â”‚ â”‚ -                values = result[option]
â”‚ â”‚ -            except KeyError:
â”‚ â”‚ -                pass
â”‚ â”‚ -            else:
â”‚ â”‚ -                merged_options[option].extend(values)
â”‚ â”‚ -
â”‚ â”‚ -    return dict(ChainMap(dict(merged_options), *reversed(flattened_result)))
â”‚ â”‚ +    try:
â”‚ â”‚ +        with open(conf_path) as f:
â”‚ â”‚ +            flattened_result = lflatten(yaml.load_all(f, Loader=yaml.FullLoader))
â”‚ â”‚ +            merged_options = defaultdict(list)
â”‚ â”‚ +            for option in (
â”‚ â”‚ +                "_exclude",
â”‚ â”‚ +                "_jinja_extensions",
â”‚ â”‚ +                "_secret_questions",
â”‚ â”‚ +                "_skip_if_exists",
â”‚ â”‚ +            ):
â”‚ â”‚ +                for result in flattened_result:
â”‚ â”‚ +                    try:
â”‚ â”‚ +                        values = result[option]
â”‚ â”‚ +                    except KeyError:
â”‚ â”‚ +                        pass
â”‚ â”‚ +                    else:
â”‚ â”‚ +                        merged_options[option].extend(values)
â”‚ â”‚ +            return dict(ChainMap(dict(merged_options), *reversed(flattened_result)))
â”‚ â”‚ +    except yaml.parser.ParserError as e:
â”‚ â”‚ +        raise InvalidConfigFileError(conf_path, quiet) from e
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def verify_copier_version(version_str: str) -> None:
â”‚ â”‚      """Raise an error if the current Copier version is less than the given version.
â”‚ â”‚  
â”‚ â”‚      Args:
â”‚ â”‚          version_str:
â”‚ â”‚ @@ -302,20 +296,15 @@
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚      def exclude(self) -> Tuple[str, ...]:
â”‚ â”‚          """Get exclusions specified in the template, or default ones.
â”‚ â”‚  
â”‚ â”‚          See [exclude][].
â”‚ â”‚          """
â”‚ â”‚ -        return tuple(
â”‚ â”‚ -            self.config_data.get(
â”‚ â”‚ -                "exclude",
â”‚ â”‚ -                DEFAULT_EXCLUDE if Path(self.subdirectory) == Path(".") else [],
â”‚ â”‚ -            )
â”‚ â”‚ -        )
â”‚ â”‚ +        return tuple(self.config_data.get("exclude", DEFAULT_EXCLUDE))
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚      def jinja_extensions(self) -> Tuple[str, ...]:
â”‚ â”‚          """Get Jinja2 extensions specified in the template, or `()`.
â”‚ â”‚  
â”‚ â”‚          See [jinja_extensions][].
â”‚ â”‚          """
â”‚ â”‚ @@ -367,15 +356,15 @@
â”‚ â”‚                  }
â”‚ â”‚                  for cmd in migration.get(stage, []):
â”‚ â”‚                      result.append(Task(cmd=cmd, extra_env=extra_env))
â”‚ â”‚          return result
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚      def min_copier_version(self) -> Optional[Version]:
â”‚ â”‚ -        """Get minimal copier version for the template and validates it.
â”‚ â”‚ +        """Gets minimal copier version for the template and validates it.
â”‚ â”‚  
â”‚ â”‚          See [min_copier_version][].
â”‚ â”‚          """
â”‚ â”‚          try:
â”‚ â”‚              return Version(self.config_data["min_copier_version"])
â”‚ â”‚          except KeyError:
â”‚ â”‚              return None
â”‚ â”‚ @@ -443,38 +432,28 @@
â”‚ â”‚          """
â”‚ â”‚          result = self.config_data.get("templates_suffix")
â”‚ â”‚          if result is None:
â”‚ â”‚              return DEFAULT_TEMPLATES_SUFFIX
â”‚ â”‚          return result
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚ -    def preserve_symlinks(self) -> bool:
â”‚ â”‚ -        """Know if Copier should preserve symlinks when rendering the template.
â”‚ â”‚ -
â”‚ â”‚ -        See [preserve_symlinks][].
â”‚ â”‚ -        """
â”‚ â”‚ -        return bool(self.config_data.get("preserve_symlinks", False))
â”‚ â”‚ -
â”‚ â”‚ -    @cached_property
â”‚ â”‚      def local_abspath(self) -> Path:
â”‚ â”‚          """Get the absolute path to the template on disk.
â”‚ â”‚  
â”‚ â”‚          This may clone it if `url` points to a VCS-tracked template.
â”‚ â”‚          Dirty changes for local VCS-tracked templates will be copied.
â”‚ â”‚          """
â”‚ â”‚          result = Path(self.url)
â”‚ â”‚          if self.vcs == "git":
â”‚ â”‚              result = Path(clone(self.url_expanded, self.ref))
â”‚ â”‚              if self.ref is None:
â”‚ â”‚                  checkout_latest_tag(result, self.use_prereleases)
â”‚ â”‚          if not result.is_dir():
â”‚ â”‚              raise ValueError("Local template must be a directory.")
â”‚ â”‚ -        with suppress(OSError):
â”‚ â”‚ -            result = result.resolve()
â”‚ â”‚ -        return result
â”‚ â”‚ +        return result.absolute()
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚      def url_expanded(self) -> str:
â”‚ â”‚          """Get usable URL.
â”‚ â”‚  
â”‚ â”‚          `url` can be specified in shortcut
â”‚ â”‚          format, which wouldn't be understood by the underlying VCS system. This
â”‚ â”‚   --- copier-7.1.0/copier/tools.py
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/copier/tools.py
â”‚ â”‚â”„ Files 14% similar despite different names
â”‚ â”‚ @@ -14,26 +14,24 @@
â”‚ â”‚  
â”‚ â”‚  import colorama
â”‚ â”‚  from packaging.version import Version
â”‚ â”‚  from pydantic import StrictBool
â”‚ â”‚  
â”‚ â”‚  from .types import IntSeq
â”‚ â”‚  
â”‚ â”‚ -# TODO Remove condition when dropping python 3.8 support
â”‚ â”‚ -if sys.version_info < (3, 8):
â”‚ â”‚ -    from importlib_metadata import version
â”‚ â”‚ -else:
â”‚ â”‚ +try:
â”‚ â”‚      from importlib.metadata import version
â”‚ â”‚ +except ImportError:
â”‚ â”‚ +    # Python < 3.8
â”‚ â”‚ +    from importlib_metadata import version
â”‚ â”‚  
â”‚ â”‚  colorama.init()
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class Style:
â”‚ â”‚ -    """Common color styles."""
â”‚ â”‚ -
â”‚ â”‚      OK: IntSeq = [colorama.Fore.GREEN, colorama.Style.BRIGHT]
â”‚ â”‚      WARNING: IntSeq = [colorama.Fore.YELLOW, colorama.Style.BRIGHT]
â”‚ â”‚      IGNORE: IntSeq = [colorama.Fore.CYAN]
â”‚ â”‚      DANGER: IntSeq = [colorama.Fore.RED, colorama.Style.BRIGHT]
â”‚ â”‚      RESET: IntSeq = [colorama.Fore.RESET, colorama.Style.RESET_ALL]
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ @@ -61,15 +59,14 @@
â”‚ â”‚      action: str,
â”‚ â”‚      msg: Any = "",
â”‚ â”‚      style: Optional[IntSeq] = None,
â”‚ â”‚      indent: int = 10,
â”‚ â”‚      quiet: Union[bool, StrictBool] = False,
â”‚ â”‚      file_: TextIO = sys.stdout,
â”‚ â”‚  ) -> Optional[str]:
â”‚ â”‚ -    """Print string with common format."""
â”‚ â”‚      if quiet:
â”‚ â”‚          return None  # HACK: Satisfy MyPy
â”‚ â”‚      _msg = str(msg)
â”‚ â”‚      action = action.rjust(indent, " ")
â”‚ â”‚      if not style:
â”‚ â”‚          return action + _msg
â”‚ â”‚  
â”‚ â”‚ @@ -77,15 +74,14 @@
â”‚ â”‚      print(*out, sep="", file=file_)
â”‚ â”‚      return None  # HACK: Satisfy MyPy
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def printf_exception(
â”‚ â”‚      e: Exception, action: str, msg: str = "", indent: int = 0, quiet: bool = False
â”‚ â”‚  ) -> None:
â”‚ â”‚ -    """Print exception with common format."""
â”‚ â”‚      if not quiet:
â”‚ â”‚          print("", file=sys.stderr)
â”‚ â”‚          printf(action, msg=msg, style=Style.DANGER, indent=indent, file_=sys.stderr)
â”‚ â”‚          print(HLINE, file=sys.stderr)
â”‚ â”‚          print(e, file=sys.stderr)
â”‚ â”‚          print(HLINE, file=sys.stderr)
â”‚ â”‚  
â”‚ â”‚ @@ -114,15 +110,14 @@
â”‚ â”‚          elif lower in {"n", "no", "f", "false", "off", "~", "null", "none"}:
â”‚ â”‚              return False
â”‚ â”‚      # Assume nothing
â”‚ â”‚      return bool(value)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def copy_file(src_path: Path, dst_path: Path, follow_symlinks: bool = True) -> None:
â”‚ â”‚ -    """Copy one file to another place."""
â”‚ â”‚      shutil.copy2(src_path, dst_path, follow_symlinks=follow_symlinks)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def force_str_end(original_str: str, end: str = "\n") -> str:
â”‚ â”‚      """Make sure a `original_str` ends with `end`.
â”‚ â”‚  
â”‚ â”‚      Params:
â”‚ â”‚ @@ -167,28 +162,13 @@
â”‚ â”‚  
â”‚ â”‚      @classmethod
â”‚ â”‚      def _cleanup(cls, name, warn_message):
â”‚ â”‚          cls._robust_cleanup(name)
â”‚ â”‚          warnings.warn(warn_message, ResourceWarning)
â”‚ â”‚  
â”‚ â”‚      def cleanup(self):
â”‚ â”‚ -        """Remove directory safely."""
â”‚ â”‚          if self._finalizer.detach():
â”‚ â”‚              self._robust_cleanup(self.name)
â”‚ â”‚  
â”‚ â”‚      @staticmethod
â”‚ â”‚      def _robust_cleanup(name):
â”‚ â”‚          shutil.rmtree(name, ignore_errors=False, onerror=handle_remove_readonly)
â”‚ â”‚ -
â”‚ â”‚ -
â”‚ â”‚ -def readlink(link: Path) -> Path:
â”‚ â”‚ -    """A custom version of os.readlink/pathlib.Path.readlink.
â”‚ â”‚ -
â”‚ â”‚ -    pathlib.Path.readlink is what we ideally would want to use, but it is only available on python>=3.9.
â”‚ â”‚ -    os.readlink doesn't support Path and bytes on Windows for python<3.8
â”‚ â”‚ -    """
â”‚ â”‚ -    if sys.version_info >= (3, 9):
â”‚ â”‚ -        return link.readlink()
â”‚ â”‚ -    elif sys.version_info >= (3, 8) or os.name != "nt":
â”‚ â”‚ -        return Path(os.readlink(link))
â”‚ â”‚ -    else:
â”‚ â”‚ -        return Path(os.readlink(str(link)))
â”‚ â”‚   --- copier-7.1.0/copier/types.py
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/copier/types.py
â”‚ â”‚â”„ Files 26% similar despite different names
â”‚ â”‚ @@ -1,22 +1,12 @@
â”‚ â”‚  """Complex types, annotations, validators."""
â”‚ â”‚  
â”‚ â”‚  import sys
â”‚ â”‚  from pathlib import Path
â”‚ â”‚ -from typing import (
â”‚ â”‚ -    TYPE_CHECKING,
â”‚ â”‚ -    Any,
â”‚ â”‚ -    Dict,
â”‚ â”‚ -    Mapping,
â”‚ â”‚ -    NewType,
â”‚ â”‚ -    Optional,
â”‚ â”‚ -    Sequence,
â”‚ â”‚ -    TypeVar,
â”‚ â”‚ -    Union,
â”‚ â”‚ -)
â”‚ â”‚ +from typing import TYPE_CHECKING, Any, Dict, Mapping, Optional, Sequence, TypeVar, Union
â”‚ â”‚  
â”‚ â”‚  from pydantic.validators import path_validator
â”‚ â”‚  
â”‚ â”‚  # HACK https://github.com/python/mypy/issues/8520#issuecomment-772081075
â”‚ â”‚  if sys.version_info >= (3, 8):
â”‚ â”‚      from typing import Literal
â”‚ â”‚  else:
â”‚ â”‚ @@ -43,57 +33,47 @@
â”‚ â”‚  OptStr = Optional[str]
â”‚ â”‚  
â”‚ â”‚  # miscellaneous
â”‚ â”‚  T = TypeVar("T")
â”‚ â”‚  JSONSerializable = (dict, list, str, int, float, bool, type(None))
â”‚ â”‚  VCSTypes = Literal["git"]
â”‚ â”‚  Env = Mapping[str, str]
â”‚ â”‚ -MissingType = NewType("MissingType", object)
â”‚ â”‚ -MISSING = MissingType(object())
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  class AllowArbitraryTypes:
â”‚ â”‚ -    """Allow any type for this class."""
â”‚ â”‚ -
â”‚ â”‚      arbitrary_types_allowed = True
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # Validators
â”‚ â”‚  def path_is_absolute(value: Path) -> Path:
â”‚ â”‚ -    """Require absolute paths in an argument."""
â”‚ â”‚      if not value.is_absolute():
â”‚ â”‚          from .errors import PathNotAbsoluteError
â”‚ â”‚  
â”‚ â”‚          raise PathNotAbsoluteError(path=value)
â”‚ â”‚      return value
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def path_is_relative(value: Path) -> Path:
â”‚ â”‚ -    """Require relative paths in an argument."""
â”‚ â”‚      if value.is_absolute():
â”‚ â”‚          from .errors import PathNotRelativeError
â”‚ â”‚  
â”‚ â”‚          raise PathNotRelativeError(path=value)
â”‚ â”‚      return value
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  # Validated types
â”‚ â”‚  if TYPE_CHECKING:
â”‚ â”‚      AbsolutePath = Path
â”‚ â”‚      RelativePath = Path
â”‚ â”‚  else:
â”‚ â”‚  
â”‚ â”‚      class AbsolutePath(Path):
â”‚ â”‚ -        """Require absolute paths in an argument."""
â”‚ â”‚ -
â”‚ â”‚          @classmethod
â”‚ â”‚          def __get_validators__(cls) -> "CallableGenerator":
â”‚ â”‚              yield path_validator
â”‚ â”‚              yield path_is_absolute
â”‚ â”‚  
â”‚ â”‚      class RelativePath(Path):
â”‚ â”‚ -        """Require relative paths in an argument."""
â”‚ â”‚ -
â”‚ â”‚          @classmethod
â”‚ â”‚          def __get_validators__(cls) -> "CallableGenerator":
â”‚ â”‚              yield path_validator
â”‚ â”‚              yield path_is_relative
â”‚ â”‚   --- copier-7.1.0/copier/user_data.py
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/copier/user_data.py
â”‚ â”‚â”„ Files 2% similar despite different names
â”‚ â”‚ @@ -8,14 +8,15 @@
â”‚ â”‚  from hashlib import sha512
â”‚ â”‚  from os import urandom
â”‚ â”‚  from pathlib import Path
â”‚ â”‚  from typing import (
â”‚ â”‚      TYPE_CHECKING,
â”‚ â”‚      Any,
â”‚ â”‚      Callable,
â”‚ â”‚ +    ChainMap as t_ChainMap,
â”‚ â”‚      Dict,
â”‚ â”‚      Mapping,
â”‚ â”‚      Optional,
â”‚ â”‚      Sequence,
â”‚ â”‚      Union,
â”‚ â”‚  )
â”‚ â”‚  
â”‚ â”‚ @@ -27,23 +28,15 @@
â”‚ â”‚  from pydantic import validator as pydantic_validator
â”‚ â”‚  from pydantic.dataclasses import dataclass
â”‚ â”‚  from pygments.lexers.data import JsonLexer, YamlLexer
â”‚ â”‚  from questionary.prompts.common import Choice
â”‚ â”‚  
â”‚ â”‚  from .errors import InvalidTypeError, UserMessageError
â”‚ â”‚  from .tools import cast_str_to_bool, force_str_end
â”‚ â”‚ -from .types import (
â”‚ â”‚ -    MISSING,
â”‚ â”‚ -    AllowArbitraryTypes,
â”‚ â”‚ -    AnyByStrDict,
â”‚ â”‚ -    MissingType,
â”‚ â”‚ -    OptStr,
â”‚ â”‚ -    OptStrOrPath,
â”‚ â”‚ -    StrOrPath,
â”‚ â”‚ -)
â”‚ â”‚ +from .types import AllowArbitraryTypes, AnyByStrDict, OptStr, OptStrOrPath, StrOrPath
â”‚ â”‚  
â”‚ â”‚  # HACK https://github.com/python/mypy/issues/8520#issuecomment-772081075
â”‚ â”‚  if sys.version_info >= (3, 8):
â”‚ â”‚      from functools import cached_property
â”‚ â”‚  else:
â”‚ â”‚      from backports.cached_property import cached_property
â”‚ â”‚  
â”‚ â”‚ @@ -124,29 +117,28 @@
â”‚ â”‚      init: AnyByStrDict = field(default_factory=dict)
â”‚ â”‚      metadata: AnyByStrDict = field(default_factory=dict)
â”‚ â”‚      last: AnyByStrDict = field(default_factory=dict)
â”‚ â”‚      user_defaults: AnyByStrDict = field(default_factory=dict)
â”‚ â”‚      default: AnyByStrDict = field(default_factory=dict)
â”‚ â”‚  
â”‚ â”‚      @cached_property
â”‚ â”‚ -    def combined(self) -> Mapping[str, Any]:
â”‚ â”‚ +    def combined(self) -> t_ChainMap[str, Any]:
â”‚ â”‚          """Answers combined from different sources, sorted by priority."""
â”‚ â”‚          return ChainMap(
â”‚ â”‚              self.local,
â”‚ â”‚              self.user,
â”‚ â”‚              self.init,
â”‚ â”‚              self.metadata,
â”‚ â”‚              self.last,
â”‚ â”‚              self.user_defaults,
â”‚ â”‚              self.default,
â”‚ â”‚              DEFAULT_DATA,
â”‚ â”‚          )
â”‚ â”‚  
â”‚ â”‚      def old_commit(self) -> OptStr:
â”‚ â”‚ -        """Commit when the project was updated from this template the last time."""
â”‚ â”‚          return self.last.get("_commit")
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  @dataclass(config=AllowArbitraryTypes)
â”‚ â”‚  class Question:
â”‚ â”‚      """One question asked to the user.
â”‚ â”‚  
â”‚ â”‚ @@ -199,16 +191,17 @@
â”‚ â”‚              boolean values.
â”‚ â”‚      """
â”‚ â”‚  
â”‚ â”‚      var_name: str
â”‚ â”‚      answers: AnswersMap
â”‚ â”‚      jinja_env: SandboxedEnvironment
â”‚ â”‚      choices: Union[Dict[Any, Any], Sequence[Any]] = field(default_factory=list)
â”‚ â”‚ -    default: Any = MISSING
â”‚ â”‚ +    default: Any = None
â”‚ â”‚      help: str = ""
â”‚ â”‚ +    ask_user: bool = False
â”‚ â”‚      multiline: Union[str, bool] = False
â”‚ â”‚      placeholder: str = ""
â”‚ â”‚      secret: bool = False
â”‚ â”‚      type: str = ""
â”‚ â”‚      validator: str = ""
â”‚ â”‚      when: Union[str, bool] = True
â”‚ â”‚  
â”‚ â”‚ @@ -233,32 +226,28 @@
â”‚ â”‚          except KeyError:
â”‚ â”‚              try:
â”‚ â”‚                  result = self.answers.last[self.var_name]
â”‚ â”‚              except KeyError:
â”‚ â”‚                  try:
â”‚ â”‚                      result = self.answers.user_defaults[self.var_name]
â”‚ â”‚                  except KeyError:
â”‚ â”‚ -                    if self.default is MISSING:
â”‚ â”‚ -                        return MISSING
â”‚ â”‚                      result = self.render_value(self.default)
â”‚ â”‚          result = cast_answer_type(result, cast_fn)
â”‚ â”‚          return result
â”‚ â”‚  
â”‚ â”‚ -    def get_default_rendered(self) -> Union[bool, str, Choice, None, MissingType]:
â”‚ â”‚ +    def get_default_rendered(self) -> Union[bool, str, Choice, None]:
â”‚ â”‚          """Get default answer rendered for the questionary lib.
â”‚ â”‚  
â”‚ â”‚          The questionary lib expects some specific data types, and returns
â”‚ â”‚          it when the user answers. Sometimes you need to compare the response
â”‚ â”‚          to the rendered one, or viceversa.
â”‚ â”‚  
â”‚ â”‚          This helper allows such usages.
â”‚ â”‚          """
â”‚ â”‚          default = self.get_default()
â”‚ â”‚ -        if default is MISSING:
â”‚ â”‚ -            return MISSING
â”‚ â”‚          # If there are choices, return the one that matches the expressed default
â”‚ â”‚          if self.choices:
â”‚ â”‚              for choice in self._formatted_choices:
â”‚ â”‚                  if choice.value == default:
â”‚ â”‚                      return choice
â”‚ â”‚              return None
â”‚ â”‚          # Yes/No questions expect and return bools
â”‚ â”‚ @@ -296,14 +285,16 @@
â”‚ â”‚              # The value can be templated
â”‚ â”‚              value = self.render_value(value)
â”‚ â”‚              result.append(Choice(name, value))
â”‚ â”‚          return result
â”‚ â”‚  
â”‚ â”‚      def filter_answer(self, answer) -> Any:
â”‚ â”‚          """Cast the answer to the desired type."""
â”‚ â”‚ +        if answer == self.get_default_rendered():
â”‚ â”‚ +            return self.get_default()
â”‚ â”‚          return cast_answer_type(answer, self.get_cast_fn())
â”‚ â”‚  
â”‚ â”‚      def get_message(self) -> str:
â”‚ â”‚          """Get the message that will be printed to the user."""
â”‚ â”‚          if self.help:
â”‚ â”‚              rendered_help = self.render_value(self.help)
â”‚ â”‚              if rendered_help:
â”‚ â”‚ @@ -319,31 +310,26 @@
â”‚ â”‚          """Render and obtain the placeholder."""
â”‚ â”‚          return self.render_value(self.placeholder)
â”‚ â”‚  
â”‚ â”‚      def get_questionary_structure(self) -> AnyByStrDict:
â”‚ â”‚          """Get the question in a format that the questionary lib understands."""
â”‚ â”‚          lexer = None
â”‚ â”‚          result: AnyByStrDict = {
â”‚ â”‚ +            "default": self.get_default_rendered(),
â”‚ â”‚              "filter": self.filter_answer,
â”‚ â”‚              "message": self.get_message(),
â”‚ â”‚              "mouse_support": True,
â”‚ â”‚              "name": self.var_name,
â”‚ â”‚              "qmark": "ðŸ•µï¸" if self.secret else "ðŸŽ¤",
â”‚ â”‚              "when": self.get_when,
â”‚ â”‚          }
â”‚ â”‚ -        default = self.get_default_rendered()
â”‚ â”‚ -        if default is not MISSING:
â”‚ â”‚ -            result["default"] = default
â”‚ â”‚          questionary_type = "input"
â”‚ â”‚          type_name = self.get_type_name()
â”‚ â”‚          if type_name == "bool":
â”‚ â”‚              questionary_type = "confirm"
â”‚ â”‚ -            # For backwards compatibility
â”‚ â”‚ -            if default is MISSING:
â”‚ â”‚ -                result["default"] = False
â”‚ â”‚          if self.choices:
â”‚ â”‚              questionary_type = "select"
â”‚ â”‚              result["choices"] = self._formatted_choices
â”‚ â”‚          if questionary_type == "input":
â”‚ â”‚              if self.secret:
â”‚ â”‚                  questionary_type = "password"
â”‚ â”‚              elif type_name == "yaml":
â”‚ â”‚ @@ -369,34 +355,47 @@
â”‚ â”‚  
â”‚ â”‚      def get_type_name(self) -> str:
â”‚ â”‚          """Render the type name and return it."""
â”‚ â”‚          return self.render_value(self.type)
â”‚ â”‚  
â”‚ â”‚      def get_multiline(self) -> bool:
â”‚ â”‚          """Get the value for multiline."""
â”‚ â”‚ -        return cast_str_to_bool(self.render_value(self.multiline))
â”‚ â”‚ +        multiline = self.render_value(self.multiline)
â”‚ â”‚ +        multiline = cast_answer_type(multiline, cast_str_to_bool)
â”‚ â”‚ +        return bool(multiline)
â”‚ â”‚  
â”‚ â”‚      def validate_answer(self, answer) -> bool:
â”‚ â”‚          """Validate user answer."""
â”‚ â”‚ +        cast_fn = self.get_cast_fn()
â”‚ â”‚          try:
â”‚ â”‚ -            ans = self.parse_answer(answer)
â”‚ â”‚ +            ans = cast_fn(answer)
â”‚ â”‚          except Exception:
â”‚ â”‚              return False
â”‚ â”‚  
â”‚ â”‚          try:
â”‚ â”‚              err_msg = self.render_value(self.validator, {self.var_name: ans}).strip()
â”‚ â”‚          except Exception as error:
â”‚ â”‚              raise ValidationError(message=str(error)) from error
â”‚ â”‚          if err_msg:
â”‚ â”‚              raise ValidationError(message=err_msg)
â”‚ â”‚          return True
â”‚ â”‚  
â”‚ â”‚      def get_when(self, answers) -> bool:
â”‚ â”‚          """Get skip condition for question."""
â”‚ â”‚ -        return cast_str_to_bool(self.render_value(self.when))
â”‚ â”‚ +        if (
â”‚ â”‚ +            # Skip on --defaults
â”‚ â”‚ +            not self.ask_user
â”‚ â”‚ +            # Skip on --data=this_question=some_answer
â”‚ â”‚ +            or self.var_name in self.answers.init
â”‚ â”‚ +        ):
â”‚ â”‚ +            return False
â”‚ â”‚ +        when = self.when
â”‚ â”‚ +        when = self.render_value(when)
â”‚ â”‚ +        when = cast_answer_type(when, cast_str_to_bool)
â”‚ â”‚ +        return bool(when)
â”‚ â”‚  
â”‚ â”‚      def render_value(
â”‚ â”‚          self, value: Any, extra_answers: Optional[AnyByStrDict] = None
â”‚ â”‚      ) -> str:
â”‚ â”‚          """Render a single templated value using Jinja.
â”‚ â”‚  
â”‚ â”‚          If the value cannot be used as a template, it will be returned as is.
â”‚ â”‚ @@ -409,26 +408,14 @@
â”‚ â”‚              # value was not a string
â”‚ â”‚              return value
â”‚ â”‚          try:
â”‚ â”‚              return template.render({**self.answers.combined, **(extra_answers or {})})
â”‚ â”‚          except UndefinedError as error:
â”‚ â”‚              raise UserMessageError(str(error)) from error
â”‚ â”‚  
â”‚ â”‚ -    def parse_answer(self, answer: Any) -> Any:
â”‚ â”‚ -        """Parse the answer according to the question's type."""
â”‚ â”‚ -        cast_fn = self.get_cast_fn()
â”‚ â”‚ -        ans = cast_answer_type(answer, cast_fn)
â”‚ â”‚ -        choice_values = {
â”‚ â”‚ -            cast_answer_type(choice.value, cast_fn)
â”‚ â”‚ -            for choice in self._formatted_choices
â”‚ â”‚ -        }
â”‚ â”‚ -        if choice_values and ans not in choice_values:
â”‚ â”‚ -            raise ValueError("Invalid choice")
â”‚ â”‚ -        return ans
â”‚ â”‚ -
â”‚ â”‚  
â”‚ â”‚  def parse_yaml_string(string: str) -> Any:
â”‚ â”‚      """Parse a YAML string and raise a ValueError if parsing failed.
â”‚ â”‚  
â”‚ â”‚      This method is needed because :meth:`prompt` requires a ``ValueError``
â”‚ â”‚      to repeat failed questions.
â”‚ â”‚      """
â”‚ â”‚ @@ -448,14 +435,17 @@
â”‚ â”‚              return yaml.safe_load(fd)
â”‚ â”‚      except FileNotFoundError:
â”‚ â”‚          return {}
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def cast_answer_type(answer: Any, type_fn: Callable) -> Any:
â”‚ â”‚      """Cast answer to expected type."""
â”‚ â”‚ +    # Skip casting None into "None"
â”‚ â”‚ +    if type_fn is str and answer is None:
â”‚ â”‚ +        return answer
â”‚ â”‚      try:
â”‚ â”‚          return type_fn(answer)
â”‚ â”‚      except (TypeError, AttributeError):
â”‚ â”‚          # JSON or YAML failed because it wasn't a string; no need to convert
â”‚ â”‚          return answer
â”‚ â”‚   --- copier-7.1.0/copier/vcs.py
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/copier/vcs.py
â”‚ â”‚â”„ Files 11% similar despite different names
â”‚ â”‚ @@ -4,19 +4,19 @@
â”‚ â”‚  import sys
â”‚ â”‚  from contextlib import suppress
â”‚ â”‚  from pathlib import Path
â”‚ â”‚  from tempfile import mkdtemp
â”‚ â”‚  from warnings import warn
â”‚ â”‚  
â”‚ â”‚  from packaging import version
â”‚ â”‚ -from packaging.version import InvalidVersion, Version
â”‚ â”‚ +from packaging.version import Version
â”‚ â”‚  from plumbum import TF, ProcessExecutionError, colors, local
â”‚ â”‚  from plumbum.cmd import git
â”‚ â”‚  
â”‚ â”‚ -from .errors import DirtyLocalWarning, ShallowCloneWarning
â”‚ â”‚ +from .errors import DirtyLocalWarning
â”‚ â”‚  from .tools import TemporaryDirectory
â”‚ â”‚  from .types import OptBool, OptStr, StrOrPath
â”‚ â”‚  
â”‚ â”‚  GIT_PREFIX = ("git@", "git://", "git+", "https://github.com/", "https://gitlab.com/")
â”‚ â”‚  GIT_POSTFIX = ".git"
â”‚ â”‚  GIT_VERSION = Version(re.findall(r"\d+\.\d+\.\d+", git("version"))[0])
â”‚ â”‚  REPLACEMENTS = (
â”‚ â”‚ @@ -41,34 +41,26 @@
â”‚ â”‚      try:
â”‚ â”‚          git("-C", path, "rev-parse", "--show-toplevel")
â”‚ â”‚          return True
â”‚ â”‚      except (OSError, ProcessExecutionError):
â”‚ â”‚          return False
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚ -def is_git_shallow_repo(path: StrOrPath) -> bool:
â”‚ â”‚ -    """Indicate if a given path is a git shallow repo directory."""
â”‚ â”‚ -    try:
â”‚ â”‚ -        return git("-C", path, "rev-parse", "--is-shallow-repository").strip() == "true"
â”‚ â”‚ -    except (OSError, ProcessExecutionError):
â”‚ â”‚ -        return False
â”‚ â”‚ -
â”‚ â”‚ -
â”‚ â”‚  def is_git_bundle(path: Path) -> bool:
â”‚ â”‚      """Indicate if a path is a valid git bundle."""
â”‚ â”‚      with suppress(OSError):
â”‚ â”‚          path = path.resolve()
â”‚ â”‚      with TemporaryDirectory(prefix=f"{__name__}.is_git_bundle.") as dirname:
â”‚ â”‚          with local.cwd(dirname):
â”‚ â”‚              git("init")
â”‚ â”‚              return bool(git["bundle", "verify", path] & TF)
â”‚ â”‚  
â”‚ â”‚  
â”‚ â”‚  def get_repo(url: str) -> OptStr:
â”‚ â”‚ -    """Transform `url` into a git-parseable origin URL.
â”‚ â”‚ +    """Transforms `url` into a git-parseable origin URL.
â”‚ â”‚  
â”‚ â”‚      Args:
â”‚ â”‚          url:
â”‚ â”‚              Valid examples:
â”‚ â”‚  
â”‚ â”‚              - gh:copier-org/copier
â”‚ â”‚              - gl:copier-org/copier
â”‚ â”‚ @@ -105,15 +97,15 @@
â”‚ â”‚      Parameters:
â”‚ â”‚          local_repo:
â”‚ â”‚              A git repository in the local filesystem.
â”‚ â”‚          use_prereleases:
â”‚ â”‚              If `False`, skip prerelease git tags.
â”‚ â”‚      """
â”‚ â”‚      with local.cwd(local_repo):
â”‚ â”‚ -        all_tags = filter(valid_version, git("tag").split())
â”‚ â”‚ +        all_tags = git("tag").split()
â”‚ â”‚          if not use_prereleases:
â”‚ â”‚              all_tags = filter(
â”‚ â”‚                  lambda tag: not version.parse(tag).is_prerelease, all_tags
â”‚ â”‚              )
â”‚ â”‚          sorted_tags = sorted(all_tags, key=version.parse, reverse=True)
â”‚ â”‚          try:
â”‚ â”‚              latest_tag = str(sorted_tags[0])
â”‚ â”‚ @@ -137,34 +129,23 @@
â”‚ â”‚      Args:
â”‚ â”‚          url:
â”‚ â”‚              Git-parseable URL of the repo. As returned by
â”‚ â”‚              [get_repo][copier.vcs.get_repo].
â”‚ â”‚          ref:
â”‚ â”‚              Reference to checkout. For Git repos, defaults to `HEAD`.
â”‚ â”‚      """
â”‚ â”‚ +
â”‚ â”‚      location = mkdtemp(prefix=f"{__name__}.clone.")
â”‚ â”‚      _clone = git["clone", "--no-checkout", url, location]
â”‚ â”‚      # Faster clones if possible
â”‚ â”‚      if GIT_VERSION >= Version("2.27"):
â”‚ â”‚ -        url_match = re.match("(file://)?(.*)", url)
â”‚ â”‚ -        if url_match is not None:
â”‚ â”‚ -            file_url = url_match.groups()[-1]
â”‚ â”‚ -        else:
â”‚ â”‚ -            file_url = url
â”‚ â”‚ -        if is_git_shallow_repo(file_url):
â”‚ â”‚ -            warn(
â”‚ â”‚ -                f"The repository '{url}' is a shallow clone, this might lead to unexpected "
â”‚ â”‚ -                "failure or unusually high resource consumption.",
â”‚ â”‚ -                ShallowCloneWarning,
â”‚ â”‚ -            )
â”‚ â”‚ -        else:
â”‚ â”‚ -            _clone = _clone["--filter=blob:none"]
â”‚ â”‚ +        _clone = _clone["--filter=blob:none"]
â”‚ â”‚      _clone()
â”‚ â”‚ -    # Include dirty changes if checking out a local HEAD
â”‚ â”‚ -    if ref in {None, "HEAD"} and os.path.exists(url) and Path(url).is_dir():
â”‚ â”‚ +
â”‚ â”‚ +    if not ref and os.path.exists(url) and Path(url).is_dir():
â”‚ â”‚          is_dirty = False
â”‚ â”‚          with local.cwd(url):
â”‚ â”‚              is_dirty = bool(git("status", "--porcelain").strip())
â”‚ â”‚          if is_dirty:
â”‚ â”‚              url_abspath = Path(url).absolute()
â”‚ â”‚              with local.cwd(location):
â”‚ â”‚                  git("--git-dir=.git", f"--work-tree={url_abspath}", "add", "-A")
â”‚ â”‚ @@ -178,23 +159,11 @@
â”‚ â”‚                  )
â”‚ â”‚                  warn(
â”‚ â”‚                      "Dirty template changes included automatically.",
â”‚ â”‚                      DirtyLocalWarning,
â”‚ â”‚                  )
â”‚ â”‚  
â”‚ â”‚      with local.cwd(location):
â”‚ â”‚ -        git("reset", "--hard", ref or "HEAD")
â”‚ â”‚ +        git("checkout", ref or "HEAD")
â”‚ â”‚          git("submodule", "update", "--checkout", "--init", "--recursive", "--force")
â”‚ â”‚  
â”‚ â”‚      return location
â”‚ â”‚ -
â”‚ â”‚ -
â”‚ â”‚ -def valid_version(version_: str) -> bool:
â”‚ â”‚ -    """Tell if a string is a valid [PEP 440][] version specifier.
â”‚ â”‚ -
â”‚ â”‚ -    [PEP 440]: https://peps.python.org/pep-0440/
â”‚ â”‚ -    """
â”‚ â”‚ -    try:
â”‚ â”‚ -        version.parse(version_)
â”‚ â”‚ -    except InvalidVersion:
â”‚ â”‚ -        return False
â”‚ â”‚ -    return True
â”‚ â”‚   --- copier-7.1.0/pyproject.toml
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/pyproject.toml
â”‚ â”‚â”„ Files 14% similar despite different names
â”‚ â”‚ @@ -1,75 +1,78 @@
â”‚ â”‚  [tool.poetry]
â”‚ â”‚  name = "copier"
â”‚ â”‚  # This version is a placeholder autoupdated by poetry-dynamic-versioning
â”‚ â”‚ -version = "7.1.0"
â”‚ â”‚ +version = "7.1.0a0"
â”‚ â”‚  description = "A library for rendering project templates."
â”‚ â”‚  license = "MIT"
â”‚ â”‚  classifiers = [
â”‚ â”‚      "Development Status :: 5 - Production/Stable",
â”‚ â”‚      "Intended Audience :: Developers",
â”‚ â”‚      "License :: OSI Approved :: MIT License",
â”‚ â”‚      "Programming Language :: Python :: 3",
â”‚ â”‚      "Programming Language :: Python :: 3.7",
â”‚ â”‚      "Programming Language :: Python :: 3.8",
â”‚ â”‚      "Programming Language :: Python :: 3.9",
â”‚ â”‚      "Programming Language :: Python :: 3.10",
â”‚ â”‚ -    "Programming Language :: Python :: 3.11",
â”‚ â”‚  ]
â”‚ â”‚  authors = ["Ben Felder <ben@felder.io>"]
â”‚ â”‚  homepage = "https://github.com/copier-org/copier"
â”‚ â”‚  repository = "https://github.com/copier-org/copier"
â”‚ â”‚  readme = "README.md"
â”‚ â”‚  
â”‚ â”‚  [tool.poetry.scripts]
â”‚ â”‚ -copier = "copier.__main__:copier_app_run"
â”‚ â”‚ +copier = "copier.cli:CopierApp.run"
â”‚ â”‚  
â”‚ â”‚  [tool.poetry.urls]
â”‚ â”‚  "Bug Tracker" = "https://github.com/copier-org/copier/issues"
â”‚ â”‚  
â”‚ â”‚  [tool.poetry.dependencies]
â”‚ â”‚  python = ">=3.7,<4.0" # HACK https://github.com/PyCQA/isort/issues/1945
â”‚ â”‚  "backports.cached-property" = { version = ">=1.0.0", python = "<3.8" }
â”‚ â”‚  colorama = ">=0.4.3"
â”‚ â”‚  dunamai = ">=1.7.0"
â”‚ â”‚  funcy = ">=1.17"
â”‚ â”‚ -importlib-metadata = { version = ">=3.4,<7.0", python = "<3.8" }
â”‚ â”‚ +importlib-metadata = { version = ">=3.4,<5.0", python = "<3.8" }
â”‚ â”‚  jinja2 = ">=3.1.1"
â”‚ â”‚  jinja2-ansible-filters = ">=1.3.1"
â”‚ â”‚ -packaging = ">=23.0"
â”‚ â”‚ +packaging = ">=21.0" # packaging is needed when installing from PyPI
â”‚ â”‚  pathspec = ">=0.9.0"
â”‚ â”‚  plumbum = ">=1.6.9"
â”‚ â”‚  pydantic = ">=1.10.2"
â”‚ â”‚  pygments = ">=2.7.1"
â”‚ â”‚  pyyaml = ">=5.3.1"
â”‚ â”‚  pyyaml-include = ">=1.2"
â”‚ â”‚  questionary = ">=1.8.1"
â”‚ â”‚  typing-extensions = { version = ">=3.7.4,<5.0.0", python = "<3.8" }
â”‚ â”‚  
â”‚ â”‚ -[tool.poetry.group.dev]
â”‚ â”‚ -optional = true
â”‚ â”‚ -
â”‚ â”‚  [tool.poetry.group.dev.dependencies]
â”‚ â”‚ +autoflake = ">=1.4"
â”‚ â”‚ +black = ">=22.1"
â”‚ â”‚ +commitizen = ">=2.32.2"
â”‚ â”‚ +flake8 = ">=4.0.1"
â”‚ â”‚ +flake8-bugbear = ">=22.1.11"
â”‚ â”‚ +flake8-comprehensions = ">=3.8.0"
â”‚ â”‚ +flake8-debugger = ">=4.0.0"
â”‚ â”‚ +flake8-simplify = ">=0.19.3"
â”‚ â”‚ +isort = ">=5.10.1"
â”‚ â”‚  mypy = ">=0.931"
â”‚ â”‚  pexpect = ">=4.8.0"
â”‚ â”‚  poethepoet = ">=0.12.3"
â”‚ â”‚  pre-commit = ">=2.17.0"
â”‚ â”‚ -pytest = ">=7.2.0"
â”‚ â”‚ +pytest = ">=7.0.1"
â”‚ â”‚  pytest-cov = ">=3.0.0"
â”‚ â”‚  pytest-xdist = ">=2.5.0"
â”‚ â”‚  types-backports = ">=0.1.3"
â”‚ â”‚  types-pyyaml = ">=6.0.4"
â”‚ â”‚ -types-psutil = "*"
â”‚ â”‚  
â”‚ â”‚  [tool.poetry.group.docs]
â”‚ â”‚  optional = true
â”‚ â”‚  
â”‚ â”‚  [tool.poetry.group.docs.dependencies]
â”‚ â”‚ -markdown-exec = ">=1.3.0"
â”‚ â”‚ -mkdocs-material = ">=8.2,<10.0.0"
â”‚ â”‚ +mkdocs-material = ">=8.2,<9.0.0"
â”‚ â”‚  mkdocstrings = { version = ">=0.19.0", extras = ["python"] }
â”‚ â”‚  
â”‚ â”‚  [tool.poe.tasks.clean]
â”‚ â”‚  script = "devtasks:clean"
â”‚ â”‚  help = "remove build/python artifacts"
â”‚ â”‚  
â”‚ â”‚  [tool.poe.tasks.coverage]
â”‚ â”‚ @@ -81,15 +84,15 @@
â”‚ â”‚  help = "set up local development environment"
â”‚ â”‚  
â”‚ â”‚  [tool.poe.tasks.docs]
â”‚ â”‚  cmd = "mkdocs serve"
â”‚ â”‚  help = "start local docs server"
â”‚ â”‚  
â”‚ â”‚  [tool.poe.tasks.lint]
â”‚ â”‚ -script = "devtasks:lint"
â”‚ â”‚ +cmd = "pre-commit run --all-files"
â”‚ â”‚  help = "check (and auto-fix) style with pre-commit"
â”‚ â”‚  
â”‚ â”‚  [tool.poe.tasks.test]
â”‚ â”‚  cmd = "pytest --color=yes"
â”‚ â”‚  help = "run tests"
â”‚ â”‚  
â”‚ â”‚  [tool.poe.tasks.types]
â”‚ â”‚ @@ -110,27 +113,20 @@
â”‚ â”‚  known_first_party = ["copier"]
â”‚ â”‚  
â”‚ â”‚  [tool.mypy]
â”‚ â”‚  ignore_missing_imports = true
â”‚ â”‚  plugins = ["pydantic.mypy"]
â”‚ â”‚  warn_no_return = false
â”‚ â”‚  
â”‚ â”‚ -[tool.pydocstyle]
â”‚ â”‚ -match_dir = "^copier"
â”‚ â”‚ -add_ignore = ["D105", "D107"]
â”‚ â”‚ -
â”‚ â”‚  [tool.pytest.ini_options]
â”‚ â”‚  addopts = "-n auto -ra"
â”‚ â”‚ -markers = [
â”‚ â”‚ -    "impure: needs network or is not 100% reproducible"
â”‚ â”‚ -]
â”‚ â”‚  
â”‚ â”‚  [tool.commitizen]
â”‚ â”‚  annotated_tag = true
â”‚ â”‚  changelog_incremental = true
â”‚ â”‚  tag_format = "v$version"
â”‚ â”‚  update_changelog_on_bump = true
â”‚ â”‚ -version = "7.1.0"
â”‚ â”‚ +version = "7.1.0a0"
â”‚ â”‚  
â”‚ â”‚  [build-system]
â”‚ â”‚ -requires = ["poetry-core>=1.0.0", "poetry-dynamic-versioning"]
â”‚ â”‚ +requires = ["poetry_core>=1.0.0", "poetry-dynamic-versioning"]
â”‚ â”‚  build-backend = "poetry_dynamic_versioning.backend"
â”‚ â”‚   --- copier-7.1.0/PKG-INFO
â”‚ â”œâ”€â”€ +++ copier-7.1.0a0/PKG-INFO
â”‚ â”‚â”„ Files 5% similar despite different names
â”‚ â”‚ @@ -1,10 +1,10 @@
â”‚ â”‚  Metadata-Version: 2.1
â”‚ â”‚  Name: copier
â”‚ â”‚ -Version: 7.1.0
â”‚ â”‚ +Version: 7.1.0a0
â”‚ â”‚  Summary: A library for rendering project templates.
â”‚ â”‚  Home-page: https://github.com/copier-org/copier
â”‚ â”‚  License: MIT
â”‚ â”‚  Author: Ben Felder
â”‚ â”‚  Author-email: ben@felder.io
â”‚ â”‚  Requires-Python: >=3.7,<4.0
â”‚ â”‚  Classifier: Development Status :: 5 - Production/Stable
â”‚ â”‚ @@ -14,26 +14,25 @@
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.7
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.8
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.9
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.10
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.11
â”‚ â”‚  Classifier: Programming Language :: Python :: 3
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.10
â”‚ â”‚ -Classifier: Programming Language :: Python :: 3.11
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.7
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.8
â”‚ â”‚  Classifier: Programming Language :: Python :: 3.9
â”‚ â”‚  Requires-Dist: backports.cached-property (>=1.0.0) ; python_version < "3.8"
â”‚ â”‚  Requires-Dist: colorama (>=0.4.3)
â”‚ â”‚  Requires-Dist: dunamai (>=1.7.0)
â”‚ â”‚  Requires-Dist: funcy (>=1.17)
â”‚ â”‚ -Requires-Dist: importlib-metadata (>=3.4,<7.0) ; python_version < "3.8"
â”‚ â”‚ +Requires-Dist: importlib-metadata (>=3.4,<5.0) ; python_version < "3.8"
â”‚ â”‚  Requires-Dist: jinja2 (>=3.1.1)
â”‚ â”‚  Requires-Dist: jinja2-ansible-filters (>=1.3.1)
â”‚ â”‚ -Requires-Dist: packaging (>=23.0)
â”‚ â”‚ +Requires-Dist: packaging (>=21.0)
â”‚ â”‚  Requires-Dist: pathspec (>=0.9.0)
â”‚ â”‚  Requires-Dist: plumbum (>=1.6.9)
â”‚ â”‚  Requires-Dist: pydantic (>=1.10.2)
â”‚ â”‚  Requires-Dist: pygments (>=2.7.1)
â”‚ â”‚  Requires-Dist: pyyaml (>=5.3.1)
â”‚ â”‚  Requires-Dist: pyyaml-include (>=1.2)
â”‚ â”‚  Requires-Dist: questionary (>=1.8.1)
â”‚ â”‚ @@ -65,27 +64,26 @@
â”‚ â”‚  
â”‚ â”‚  ## Installation
â”‚ â”‚  
â”‚ â”‚  1. Install Python 3.7 or newer (3.8 or newer if you're on Windows).
â”‚ â”‚  1. Install Git 2.27 or newer.
â”‚ â”‚  1. To use as a CLI app: `pipx install copier`
â”‚ â”‚  1. To use as a library: `pip install copier` or `conda install -c conda-forge copier`
â”‚ â”‚ -1. To use with 100% reproducibility: `nix profile install github:copier-org/copier`
â”‚ â”‚  
â”‚ â”‚  ## Quick start
â”‚ â”‚  
â”‚ â”‚  To create a template:
â”‚ â”‚  
â”‚ â”‚  ```shell
â”‚ â”‚ -ðŸ“ my_copier_template                        # your template project
â”‚ â”‚ -â”œâ”€â”€ ðŸ“„ copier.yml                            # your template configuration
â”‚ â”‚ -â”œâ”€â”€ ðŸ“ .git/                                 # your template is a Git repository
â”‚ â”‚ -â”œâ”€â”€ ðŸ“ {{project_name}}                      # a folder with a templated name
â”‚ â”‚ -â”‚   â””â”€â”€ ðŸ“„ {{module_name}}.py.jinja          # a file with a templated name
â”‚ â”‚ -â””â”€â”€ ðŸ“„ {{_copier_conf.answers_file}}.jinja   # answers are recorded here
â”‚ â”‚ +ðŸ“ my_copier_template ------------------------ # your template project
â”‚ â”‚ +â”œâ”€â”€ ðŸ“„ copier.yml ---------------------------- # your template configuration
â”‚ â”‚ +â”œâ”€â”€ ðŸ“ .git ---------------------------------- # your template is a Git repository
â”‚ â”‚ +â”œâ”€â”€ ðŸ“ {{project_name}} ---------------------- # a folder with a templated name
â”‚ â”‚ +â”‚   â””â”€â”€ ðŸ“„ {{module_name}}.py.jinja ---------- # a file with a templated name
â”‚ â”‚ +â””â”€â”€ ðŸ“„ {{_copier_conf.answers_file}}.jinja --- # answers are recorded here
â”‚ â”‚  ```
â”‚ â”‚  
â”‚ â”‚  ```yaml title="copier.yml"
â”‚ â”‚  # questions
â”‚ â”‚  project_name:
â”‚ â”‚      type: str
â”‚ â”‚      help: What is your project name?
â”‚ â”‚ @@ -179,21 +177,13 @@
â”‚ â”‚  
â”‚ â”‚  Special thanks go to [jpsca](https://github.com/jpsca) for originally creating `Copier`.
â”‚ â”‚  This project would not be a thing without him.
â”‚ â”‚  
â”‚ â”‚  Many thanks to [pykong](https://github.com/pykong) who took over maintainership on the
â”‚ â”‚  project, promoted it, and laid out the bases of what the project is today.
â”‚ â”‚  
â”‚ â”‚ -Big thanks also go to [yajo](https://github.com/yajo) for his relentless zest for
â”‚ â”‚ +Big thanks also go to [Yajo](https://github.com/Yajo) for his relentless zest for
â”‚ â”‚  improving `Copier` even further.
â”‚ â”‚  
â”‚ â”‚  Thanks a lot, [pawamoy](https://github.com/pawamoy) for polishing very important rough
â”‚ â”‚  edges and improving the documentation and UX a lot.
â”‚ â”‚  
â”‚ â”‚ -Also special thanks to [sisp](https://github.com/sisp) for being very helpful in
â”‚ â”‚ -polishing documentation, fixing bugs, helping the community and cleaning up the
â”‚ â”‚ -codebase.
â”‚ â”‚ -
â”‚ â”‚ -And thanks to all financial supporters and folks that give us a shiny star! â­
â”‚ â”‚ -
â”‚ â”‚ -[![Star History Chart](https://api.star-history.com/svg?repos=copier-org/copier&type=Date)](https://star-history.com/#copier-org/copier&Date)
â”‚ â”‚ -
